ScreenCaptureCommand.prototype = new Command();
ScreenCaptureCommand.prototype.constructor = Command;

ScreenCaptureCommand.prototype.ScreenCaptureCommand = function()
{
    this.filename = null;
    this.typeString = "ScreenCapture";
    AddPrototype(this);
}

ScreenCaptureCommand.prototype.ScreenCaptureCommand = function(id)
{
    CCommand = id;
    this.filename = null;
    this.typeString = "ScreenCapture";

    if (!(this.filename = New<CStringAttr>())) return;

    RegisterAttribute(this.filename, "filename");
}


ScreenCaptureCommand.prototype.clonePrototype()
{
    var c = ++s_count;
    return c;
}

ScreenCaptureCommand.prototype.execute = function()
{
    console.log("Error in Screen Capture");
}

 ScreenCaptureCommand.prototype.undo = function()
{
    return console.log("Error: Not Implemented");
}

ScreenCaptureCommand.prototype.matchesType = function()
{
   var matches = 0;
   matches = !(_stricmp(type, "ScreenCapture"));
   return matches;
}

 ScreenCaptureCommand.prototype.screenCapture = function()
{
    // get render context
    var resource = null;
    var renderAgent = null;
    var renderContext = null;
    var registry = this.registry;
    if (registry)
    {
        if (registry.find("RenderAgent", resource))
        {
            var renderAgent = resource;
            if (renderAgent)
            {
                renderContext = renderAgent.getRenderContext();
            }
        }
    }
    if (!renderContext)
    {
        console.log("Error: Render fail");
    }

    // get render engine
    var renderEngine = renderContext.getRenderEngine();
    if (!renderEngine)
    {
        console.log("Error: Failure");
    }

    // get window handle
    var windowHandle = renderContext.getWindowHandle();
    if (!windowHandle)
    {
        console.log("Error: Failure");
    }

    var clientWidth, clientHeight;
    windowHandle.getClientDimensions(clientWidth, clientHeight);

    // allocate buffer
     var pixels = [clientWidth * clientHeight * 3];
    if (!pixels)
    {
        console.log("Error: Out of Memory");
    }

    // read frame buffer
    renderEngine.readFrameBuffer(0, 0, clientWidth, clientHeight, PixelFormat_B8G8R8, 1, pixels);

    // get frame buffer origin
    var bufferOrigin = renderEngine.getFrameBufferOrigin();

    // if frame buffer origin is upper-left, invert image
    switch (bufferOrigin)
    {
        case ReBufferOrigin_UpperLeft:
        {
            // invert image
           var invertedPixels = [clientWidth * clientHeight * 3];
            if (!invertedPixels)
            {
                pixels = [];
                console.log("Error: Out of memory");
            }

            var pixelPos = 0;
            var invPixelPos = 0;
            for (var i=clientHeight-1; i >= 0; i--)
            {
                for (var j=0, k=0; j < clientWidth; j++, k+=3)
                {
                    pixelPos = i*clientWidth*3;

                    invertedPixels[invPixelPos++] = pixels[pixelPos+k  ];
                    invertedPixels[invPixelPos++] = pixels[pixelPos+k+1];
                    invertedPixels[invPixelPos++] = pixels[pixelPos+k+2];
                }
            }

           pixels = [];

            pixels = invertedPixels;
        }
            break;
    }

    // get filename
    var filename = [256];
    this.filename.getValueDirect(filename, sizeof(filename));

    // capture
    var result;
    if (this.filename.getLength() == 0 || !strcmp(filename, "")) // capture to clipboard
    {
        result = copyToClipboard(clientWidth, clientHeight, clientWidth * 3, PixelFormat_B8G8R8, pixels);
    }
    else // capture to file
    {
        result = CMediaDepot.prototype.Instance().Save(filename, clientWidth, clientHeight, clientWidth * 3, PixelFormat_B8G8R8, pixels);
    }

    // deallocate buffer
    pixels = [];

    return result ? console.log("All good") : console.log("Error");
}