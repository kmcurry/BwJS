function Base() 
{
    this.userData = "";
    this.className = "";
}

Base.prototype.destroy = function()
{
    delete this;
}

function Allocator()
{
}
//These are created in global scope that way 3Scape can access them
var message = "";
var imgeData = "";
var cimageData = "";
var serializedScene = "";

Allocator.prototype.allocate = function()
{
    return null;
}
function loadBinaryResource(url)
{
    var req = new XMLHttpRequest();
    
    req.open('GET', url, false);
    req.overrideMimeType('text/plain; charset=x-user-defined');
    req.send();
    
    if (req.status != 200)
    {
        return null;
    }
    
    return req.responseText;
}

function loadXMLResource(url)
{
    var req = new XMLHttpRequest();
 
    req.open('GET', url, false);
    req.overrideMimeType('text/plain; charset=x-user-defined');    
    req.send();
    
    if (req.status != 200)
    {
        return null;
    }
    
    return req.responseText;
}

function loadTextResource(url)
{
    var req = new XMLHttpRequest();
 
    req.open('GET', url, false);
    req.overrideMimeType('text/plain; charset=x-user-defined');    
    req.send();
    
    if (req.status != 200)
    {
        return null;
    }
    
    return req.responseText;
}

function isLower(c)
{
    var ascii = c.charCodeAt(0);
    return (ascii > 96 && ascii < 123);
}

function isUpper(c)
{
    var ascii = c.charCodeAt(0);
    return (ascii > 64 && ascii < 91);
}

function isSpace(c)
{
    if (c == ' '  || 
        c == '\f' ||
        c == '\n' ||
        c == '\r' ||
        c == '\t' ||
        c == '\v')
        return true;
        
    return false;
}

// From: http://blog.magnetiq.com/post/514962277/finding-out-class-names-of-javascript-objects
/* Returns the class name of the argument or undefined if
   it's not a valid JavaScript object.
*/
function getObjectClassName(obj) {
    if (obj && obj.constructor && obj.constructor.toString) {
        var arr = obj.constructor.toString().match(
            /function\s*(\w+)/);

        if (arr && arr.length == 2) {
            return arr[1];
        }
    }

    return undefined;
}

/*  takes string to an absolute or relative URL 
    returns an array containing a valid Bw path
    and the expected content directory.
    DOES NOT ENSURE CONTENT EXISTS
    Treat is like our best guess
*/
function formatPath(url)
{
    var result = [];
    
    var validPath = "";
    var validDir  = "";
    
    try {
        $.ajax({
            url: url,
            type:'HEAD',
            async: false,
            error: function()
            {
                console.debug(url + " does not exist.");
                // could be a relative path
                var href = document.location.href;
                
                validPath = href.substring(0, href.lastIndexOf("/")) + "/" + bridgeworks.contentDir + "/" + url;
                
                console.debug("Trying: " + validPath);
                
                var ndx = validPath.lastIndexOf("objects/");
                if (ndx == -1) ndx = validPath.lastIndexOf("motions/");
                if (ndx == -1) ndx = validPath.lastIndexOf("envelopes/");
                if (ndx == -1) ndx = validPath.lastIndexOf("scenes/");
                
                validDir = validPath.substring(0, ndx);
                
                console.debug("With contentDir: " + validDir);  
            },
            success: function()
            {
                validPath = url;
                
                var ndx = validPath.lastIndexOf("objects/");
                if (ndx == -1) ndx = validPath.lastIndexOf("motions/");
                if (ndx == -1) ndx = validPath.lastIndexOf("envelopes/");
                if (ndx == -1) ndx = validPath.lastIndexOf("scenes/");
                
                validDir = validPath.substring(0, ndx);
                
                console.debug("File found: " + validPath);
            }
        });
        
        result[0] = validPath;
        result[1] = validDir;
    } catch (e) {
        
    }
    
    return result;
}

/**
 * Determine if the filename represents a full path.
 * @params filePath     - the filename [path] string.
 * @return bool         - boolean indicating if the filename represents a full path.
 */
function isFullPath(filePath)
{
    // check for // or \\ in beginning of pathname (UNC filename)
    var unc = false;
    var filePathLen = filePath.length;
    if (filePathLen >= 2)
    {
        if ((filePath[0] == '\\' || filePath[0] == '/') &&
            (filePath[1] == '\\' || filePath[1] == '/'))
        {
            unc = true;
        }
    }       

    // check if file path is a full path
    if (unc || filePath.indexOf(':') >= 0)
    {
        return true;
    }

    return false;
}

/**
 * Form a full path string by appending a filename [path] to a directory path.
 * @params filePath     - the filename [path] string.
 * @params dirPath      - the directory path string.
 * @return string       - the output string.
 */
function formFullPath(filePath, dirPath)
{
    var fullPath = new String();

    if (!filePath || !dirPath)
    {
        return null;
    }      

    // check if file path is already a full path
    if (isFullPath(filePath))
    {
        fullPath = filePath;
    }
    else // file path is relative, formulate full path
    {
        fullPath = dirPath;
        if (fullPath.length > 0)
        {
            var last = fullPath.charAt(fullPath.length - 1);
            if (last != '/' && last != '\\')
            {
                fullPath += '/';
            }
        }
        
        // don't allow "//" in the filepath (Minefield doesn't like that)
        if (filePath[0] == '/' || filePath[0] == "\\")
        {
            fullPath += filePath.slice(1);
        }
        else
        {
            fullPath += filePath;
        }
    }

    return fullPath;
}

function getFileExtension(filename)
{
    var ext = null;
    var lastDot = filename.lastIndexOf(".");
    if (lastDot != -1)
    {
        var ext = "";
        ext = filename.substr(lastDot+1)
        return ext;
    }

    return ext;    
}

function getBrowserName()
{
    var browser = new String(navigator.userAgent);
    
    // chrome
    if (browser.indexOf("Chrome") >= 0) return "Chrome";

    // firefox
    if (browser.indexOf("Firefox") >= 0) return "Firefox";

    return undefined;
}

function OutputDebugMsg(msg)
{
    var innerHTML = document.getElementById("DebugOutput").innerHTML;
    innerHTML += "&gt; " + msg + "<br>";
    document.getElementById("DebugOutput").innerHTML = innerHTML;
}
function Color()
{
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
}

Color.prototype.v = function()
{
    var values = [ this.r, this.g, this.b, this.a ];
    return values; 
}

Color.prototype.load = function(r, g, b, a)
{
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
}

Color.prototype.copy = function(color)
{
    if (color)
    {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        this.a = color.a;
    }
}

function Pair(first, second)
{
    this.first = first;
    this.second = second;
}

function Rect(left, top, right, bottom)
{
    this.left = left || 0;
    this.top = top || 0;
    this.right = right || 0;
    this.bottom = bottom || 0;
}

Rect.prototype.load = function(left, top, right, bottom)
{
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
}

Rect.prototype.loadRect = function(rect)
{
    this.left = rect.left;
    this.top = rect.top;
    this.right = rect.right;
    this.bottom = rect.bottom;
}

function Viewport()
{
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    
    this.equals = function(rhs)
    {
        return (this.x == rhs.x &&
                this.y == rhs.y &&
                this.width == rhs.width &&
                this.height == rhs.height); 
    }
}

Viewport.prototype.load = function(x, y, width, height)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
}

Viewport.prototype.loadViewport = function(vp)
{
    this.x = vp.x;
    this.y = vp.y;
    this.width = vp.width;
    this.height = vp.height;
}

Viewport.prototype.containsPoint = function(x, y)
{
    if (x >= this.x &&
        y >= this.y &&
        x <= (this.x + this.width) &&
        y <= (this.y + this.height))
        return true;

    return false;
}
function Stack(element)
{
    this.stack = new Array();
    this.maxLength = 0;
    
    if (element)
    {
        this.stack.push(element);
    }
}

Stack.prototype.push = function(element)
{
	if (this.maxLength > 0 && this.stack.length >= this.maxLength)
	{
		this.pop();
	}
	
    this.stack.push(element);
}

Stack.prototype.pop = function()
{
    if (this.stack.length > 0)
    {
        this.stack.pop();
    }
}

Stack.prototype.load = function(element)
{
    this.pop(); // does nothing if empty
    this.push(element);
}

Stack.prototype.top = function()
{
    if (this.stack.length > 0)
    {
        return this.stack[this.stack.length-1];
    }
    
    return null;
}

Stack.prototype.getAt = function(index)
{
    if (this.stack.length > index)
    {
        return this.stack[index];
    }
    
    return null;
}

Stack.prototype.length = function()
{
    return this.stack.length;
}

Stack.prototype.empty = function()
{
    return this.stack.length == 0;
}

Stack.prototype.clear = function()
{
    this.stack.length = 0;
}

Stack.prototype.copy = function()
{
    return this.stack.slice();
}
function Queue(element)
{
	this.queue = new Array();
    this.maxLength = 0;
    
    if (element)
    {
        this.queue.push(element);
    }
}

Queue.prototype.push = function(element)
{
	if (this.maxLength > 0 && this.queue.length >= this.maxLength)
	{
		this.pop();
	}
	
    this.queue.push(element);
}

Queue.prototype.pop = function()
{
    if (this.queue.length > 0)
    {
        this.queue.shift();
    }
}

Queue.prototype.load = function(element)
{
    this.pop(); // does nothing if empty
    this.push(element);
}

Queue.prototype.front = function()
{
    if (this.queue.length > 0)
    {
        return this.queue[0];
    }
    
    return null;
}

Queue.prototype.getAt = function(index)
{
    if (this.queue.length > index)
    {
        return this.queue[index];
    }
    
    return null;
}

Queue.prototype.length = function()
{
    return this.queue.length;
}

Queue.prototype.empty = function()
{
    return this.queue.length == 0;
}

Queue.prototype.clear = function()
{
    this.queue.length = 0;
}

Queue.prototype.copy = function()
{
    return this.queue.slice();
}

var gAttributeBin = null;
var gAttributePairs = null;

function setAttributeBin(bin)
{
    gAttributeBin = bin;
}

function setAttributePairs(pairs)
{
    gAttributePairs = pairs;
}

function deserializeAttributeContainer(container, atts)
{
    for (var i=0; i < atts.length; i++)
    {
        var attribute = container.getAttribute(atts[i][0]);
        if (attribute)
        {
            deserializeAttribute(attribute, atts[i][1]);
        }
    }
    
    container.flagDeserializedFromXML();
}

function deserializeComplexAttribute(attribute, atts)
{
    var values = [];
    for (var i=0; i < atts.length; i++)
    {
        values.push(atts[i][1]);
    }
    if (values.length > 0) 
    {
        if (!gAttributeBin)
        {
            setAttributeValue(attribute, values);
        }
        else // gAttributeBin != null
        {
            gAttributeBin.push(new Pair(attribute, values));
        }
    }
    
    attribute.flagDeserializedFromXML();
}

function deserializeAttribute(attribute, value)
{
    // TODO: search value for operators
    
    if (!gAttributeBin)
    {
        setAttributeValue(attribute, value);
    }
    else // gAttributeBin != null
    {
        gAttributeBin.push(new Pair(attribute, value));
    }
    
    attribute.flagDeserializedFromXML();
}

function resolveAttributeContainerReference(container, atts, registry)
{
    if (atts.length > 0)
    {
        if (atts[0][0] == "ref")
        {
            var resource = registry.find(atts[0][1]);
            if (resource)
            {
                container.synchronize(resource, true);
                return true;
            } 
        }
    }
    
    return false;
}

function resolveComplexAttributeReference(attribute, atts)
{
    if (atts.length > 0)
    {
        if (atts[0][0] == "ref")
        {
            return resolvePrimitiveAttributeReference(attribute, atts[0][1]);
        }
    }

    return false;
}

function resolvePrimitiveAttributeReference(attribute, value)
{
    // TODO
    return false;
}

function resolveAttributeReference(source, target)
{
    if (!gAttributePairs)
    {
        target.copyValue(source);
    }
    else // gAttributePairs != null
    {
        gAttributePairs.push(new Pair(source, target));
    }
}
// =========================================================================
//
// xmlsax.js - an XML SAX parser in JavaScript.
//
// version 3.1
//
// =========================================================================
//
// Copyright (C) 2001 - 2002 David Joham (djoham@yahoo.com) and Scott Severtson
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.

// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//
// Visit the XML for <SCRIPT> home page at http://xmljs.sourceforge.net
//

// CONSTANTS

// =========================================================================
// =========================================================================
// =========================================================================
var whitespace = "\n\r\t ";


/***************************************************************************************************************
XMLP is a pull-based parser. The calling application passes in a XML string
to the constructor, then repeatedly calls .next() to parse the next segment.
.next() returns a flag indicating what type of segment was found, and stores
data temporarily in couple member variables (name, content, array of
attributes), which can be accessed by several .get____() methods.

Basically, XMLP is the lowest common denominator parser - an very simple
API which other wrappers can be built against.
*****************************************************************************************************************/


XMLP = function(strXML) {
    /*******************************************************************************************************************
    function:   this is the constructor to the XMLP Object

    Author:   Scott Severtson

    Description:
        Instantiates and initializes the object
    *********************************************************************************************************************/
    // Normalize line breaks
    strXML = SAXStrings.replace(strXML, null, null, "\r\n", "\n");
    strXML = SAXStrings.replace(strXML, null, null, "\r", "\n");

    this.m_xml = strXML;
    this.m_iP = 0;
    this.m_iState = XMLP._STATE_PROLOG;
    this.m_stack = new saxStack();
    this._clearAttributes();

}  // end XMLP constructor


// CONSTANTS    (these must be below the constructor)

// =========================================================================
// =========================================================================
// =========================================================================

XMLP._NONE    = 0;
XMLP._ELM_B   = 1;
XMLP._ELM_E   = 2;
XMLP._ELM_EMP = 3;
XMLP._ATT     = 4;
XMLP._TEXT    = 5;
XMLP._ENTITY  = 6;
XMLP._PI      = 7;
XMLP._CDATA   = 8;
XMLP._COMMENT = 9;
XMLP._DTD     = 10;
XMLP._ERROR   = 11;

XMLP._CONT_XML = 0;
XMLP._CONT_ALT = 1;

XMLP._ATT_NAME = 0;
XMLP._ATT_VAL  = 1;

XMLP._STATE_PROLOG = 1;
XMLP._STATE_DOCUMENT = 2;
XMLP._STATE_MISC = 3;

XMLP._errs = new Array();
XMLP._errs[XMLP.ERR_CLOSE_PI       = 0 ] = "PI: missing closing sequence";
XMLP._errs[XMLP.ERR_CLOSE_DTD      = 1 ] = "DTD: missing closing sequence";
XMLP._errs[XMLP.ERR_CLOSE_COMMENT  = 2 ] = "Comment: missing closing sequence";
XMLP._errs[XMLP.ERR_CLOSE_CDATA    = 3 ] = "CDATA: missing closing sequence";
XMLP._errs[XMLP.ERR_CLOSE_ELM      = 4 ] = "Element: missing closing sequence";
XMLP._errs[XMLP.ERR_CLOSE_ENTITY   = 5 ] = "Entity: missing closing sequence";
XMLP._errs[XMLP.ERR_PI_TARGET      = 6 ] = "PI: target is required";
XMLP._errs[XMLP.ERR_ELM_EMPTY      = 7 ] = "Element: cannot be both empty and closing";
XMLP._errs[XMLP.ERR_ELM_NAME       = 8 ] = "Element: name must immediatly follow \"<\"";
XMLP._errs[XMLP.ERR_ELM_LT_NAME    = 9 ] = "Element: \"<\" not allowed in element names";
XMLP._errs[XMLP.ERR_ATT_VALUES     = 10] = "Attribute: values are required and must be in quotes";
XMLP._errs[XMLP.ERR_ATT_LT_NAME    = 11] = "Element: \"<\" not allowed in attribute names";
XMLP._errs[XMLP.ERR_ATT_LT_VALUE   = 12] = "Attribute: \"<\" not allowed in attribute values";
XMLP._errs[XMLP.ERR_ATT_DUP        = 13] = "Attribute: duplicate attributes not allowed";
XMLP._errs[XMLP.ERR_ENTITY_UNKNOWN = 14] = "Entity: unknown entity";
XMLP._errs[XMLP.ERR_INFINITELOOP   = 15] = "Infininte loop";
XMLP._errs[XMLP.ERR_DOC_STRUCTURE  = 16] = "Document: only comments, processing instructions, or whitespace allowed outside of document element";
XMLP._errs[XMLP.ERR_ELM_NESTING    = 17] = "Element: must be nested correctly";

// =========================================================================
// =========================================================================
// =========================================================================


XMLP.prototype._addAttribute = function(name, value) {
    /*******************************************************************************************************************
    function:   _addAttribute

    Author:   Scott Severtson
    *********************************************************************************************************************/
    this.m_atts[this.m_atts.length] = new Array(name, value);
}  // end function _addAttribute


XMLP.prototype._checkStructure = function(iEvent) {
    /*******************************************************************************************************************
    function:   _checkStructure

    Author:   Scott Severtson
    *********************************************************************************************************************/
  
	if(XMLP._STATE_PROLOG == this.m_iState) {
		if((XMLP._TEXT == iEvent) || (XMLP._ENTITY == iEvent)) {
            if(SAXStrings.indexOfNonWhitespace(this.getContent(), this.getContentBegin(), this.getContentEnd()) != -1) {
				return this._setErr(XMLP.ERR_DOC_STRUCTURE);
            }
        }

        if((XMLP._ELM_B == iEvent) || (XMLP._ELM_EMP == iEvent)) {
            this.m_iState = XMLP._STATE_DOCUMENT;
            // Don't return - fall through to next state
        }
    }
    if(XMLP._STATE_DOCUMENT == this.m_iState) {
        if((XMLP._ELM_B == iEvent) || (XMLP._ELM_EMP == iEvent)) {
            this.m_stack.push(this.getName());
        }

        if((XMLP._ELM_E == iEvent) || (XMLP._ELM_EMP == iEvent)) {
            var strTop = this.m_stack.pop();
            if((strTop == null) || (strTop != this.getName())) {
                return this._setErr(XMLP.ERR_ELM_NESTING);
            }
        }

        if(this.m_stack.count() == 0) {
            this.m_iState = XMLP._STATE_MISC;
            return iEvent;
        }
    }
    if(XMLP._STATE_MISC == this.m_iState) {
		if((XMLP._ELM_B == iEvent) || (XMLP._ELM_E == iEvent) || (XMLP._ELM_EMP == iEvent) || (XMLP.EVT_DTD == iEvent)) {
			return this._setErr(XMLP.ERR_DOC_STRUCTURE);
        }

        if((XMLP._TEXT == iEvent) || (XMLP._ENTITY == iEvent)) {
			if(SAXStrings.indexOfNonWhitespace(this.getContent(), this.getContentBegin(), this.getContentEnd()) != -1) {
				return this._setErr(XMLP.ERR_DOC_STRUCTURE);
            }
        }
    }

    return iEvent;

}  // end function _checkStructure


XMLP.prototype._clearAttributes = function() {
    /*******************************************************************************************************************
    function:   _clearAttributes

    Author:   Scott Severtson
    *********************************************************************************************************************/
    this.m_atts = new Array();
}  // end function _clearAttributes


XMLP.prototype._findAttributeIndex = function(name) {
    /*******************************************************************************************************************
    function:   findAttributeIndex

    Author:   Scott Severtson
    *********************************************************************************************************************/
    for(var i = 0; i < this.m_atts.length; i++) {
        if(this.m_atts[i][XMLP._ATT_NAME] == name) {
            return i;
        }
    }
    return -1;

}  // end function _findAttributeIndex


XMLP.prototype.getAttributeCount = function() {
    /*******************************************************************************************************************
    function:   getAttributeCount

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_atts ? this.m_atts.length : 0;

}  // end function getAttributeCount()


XMLP.prototype.getAttributeName = function(index) {
    /*******************************************************************************************************************
    function:   getAttributeName

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return ((index < 0) || (index >= this.m_atts.length)) ? null : this.m_atts[index][XMLP._ATT_NAME];

}  //end function getAttributeName


XMLP.prototype.getAttributeValue = function(index) {
    /*******************************************************************************************************************
    function:   getAttributeValue

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return ((index < 0) || (index >= this.m_atts.length)) ? null : __unescapeString(this.m_atts[index][XMLP._ATT_VAL]);

} // end function getAttributeValue


XMLP.prototype.getAttributeValueByName = function(name) {
    /*******************************************************************************************************************
    function:   getAttributeValueByName

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.getAttributeValue(this._findAttributeIndex(name));

}  // end function getAttributeValueByName


XMLP.prototype.getColumnNumber = function() {
    /*******************************************************************************************************************
    function:   getColumnNumber

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return SAXStrings.getColumnNumber(this.m_xml, this.m_iP);

}  // end function getColumnNumber


XMLP.prototype.getContent = function() {
    /*******************************************************************************************************************
    function:   getContent

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return (this.m_cSrc == XMLP._CONT_XML) ? this.m_xml : this.m_cAlt;

}  //end function getContent


XMLP.prototype.getContentBegin = function() {
    /*******************************************************************************************************************
    function:   getContentBegin

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_cB;

}  //end function getContentBegin


XMLP.prototype.getContentEnd = function() {
    /*******************************************************************************************************************
    function:   getContentEnd

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_cE;

}  // end function getContentEnd


XMLP.prototype.getLineNumber = function() {
    /*******************************************************************************************************************
    function:   getLineNumber

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return SAXStrings.getLineNumber(this.m_xml, this.m_iP);

}  // end function getLineNumber


XMLP.prototype.getName = function() {
    /*******************************************************************************************************************
    function:   getName

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_name;

}  // end function getName()


XMLP.prototype.next = function() {
    /*******************************************************************************************************************
    function:   next

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this._checkStructure(this._parse());

}  // end function next()


XMLP.prototype._parse = function() {
    /*******************************************************************************************************************
    function:   _parse

    Author:   Scott Severtson
    *********************************************************************************************************************/

	if(this.m_iP == this.m_xml.length) {
        return XMLP._NONE;
    }

    if(this.m_iP == this.m_xml.indexOf("<?",        this.m_iP)) {
        return this._parsePI     (this.m_iP + 2);
    }
    else if(this.m_iP == this.m_xml.indexOf("<!DOCTYPE", this.m_iP)) {
        return this._parseDTD    (this.m_iP + 9);
    }
    else if(this.m_iP == this.m_xml.indexOf("<!--",      this.m_iP)) {
        return this._parseComment(this.m_iP + 4);
    }
    else if(this.m_iP == this.m_xml.indexOf("<![CDATA[", this.m_iP)) {
        return this._parseCDATA  (this.m_iP + 9);
    }
    else if(this.m_iP == this.m_xml.indexOf("<",         this.m_iP)) {
        return this._parseElement(this.m_iP + 1);
    }
    else if(this.m_iP == this.m_xml.indexOf("&",         this.m_iP)) {
        return this._parseEntity (this.m_iP + 1);
    }
    else{
        return this._parseText   (this.m_iP);
    }
	

}  // end function _parse


XMLP.prototype._parseAttribute = function(iB, iE) {
    /*******************************************************************************************************************
    function:   _parseAttribute

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var iNB, iNE, iEq, iVB, iVE;
    var cQuote, strN, strV;

	this.m_cAlt = ""; //resets the value so we don't use an old one by accident (see testAttribute7 in the test suite)
    
	iNB = SAXStrings.indexOfNonWhitespace(this.m_xml, iB, iE);
    if((iNB == -1) ||(iNB >= iE)) {
        return iNB;
    }

    iEq = this.m_xml.indexOf("=", iNB);
    if((iEq == -1) || (iEq > iE)) {
        return this._setErr(XMLP.ERR_ATT_VALUES);
    }

    iNE = SAXStrings.lastIndexOfNonWhitespace(this.m_xml, iNB, iEq);

    iVB = SAXStrings.indexOfNonWhitespace(this.m_xml, iEq + 1, iE);
    if((iVB == -1) ||(iVB > iE)) {
        return this._setErr(XMLP.ERR_ATT_VALUES);
    }

    cQuote = this.m_xml.charAt(iVB);
    if(SAXStrings.QUOTES.indexOf(cQuote) == -1) {
        return this._setErr(XMLP.ERR_ATT_VALUES);
    }

    iVE = this.m_xml.indexOf(cQuote, iVB + 1);
    if((iVE == -1) ||(iVE > iE)) {
        return this._setErr(XMLP.ERR_ATT_VALUES);
    }

    strN = this.m_xml.substring(iNB, iNE + 1);
    strV = this.m_xml.substring(iVB + 1, iVE);

    if(strN.indexOf("<") != -1) {
        return this._setErr(XMLP.ERR_ATT_LT_NAME);
    }

    if(strV.indexOf("<") != -1) {
        return this._setErr(XMLP.ERR_ATT_LT_VALUE);
    }

    strV = SAXStrings.replace(strV, null, null, "\n", " ");
    strV = SAXStrings.replace(strV, null, null, "\t", " ");
	iRet = this._replaceEntities(strV);
    if(iRet == XMLP._ERROR) {
        return iRet;
    }

    strV = this.m_cAlt;

    if(this._findAttributeIndex(strN) == -1) {
        this._addAttribute(strN, strV);
    }
    else {
        return this._setErr(XMLP.ERR_ATT_DUP);
    }

    this.m_iP = iVE + 2;

    return XMLP._ATT;

}  // end function _parseAttribute


XMLP.prototype._parseCDATA = function(iB) {
    /*******************************************************************************************************************
    function:   _parseCDATA

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var iE = this.m_xml.indexOf("]]>", iB);
    if (iE == -1) {
        return this._setErr(XMLP.ERR_CLOSE_CDATA);
    }

    this._setContent(XMLP._CONT_XML, iB, iE);

    this.m_iP = iE + 3;

    return XMLP._CDATA;

}  // end function _parseCDATA


XMLP.prototype._parseComment = function(iB) {
    /*******************************************************************************************************************
    function:   _parseComment

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var iE = this.m_xml.indexOf("-" + "->", iB);
    if (iE == -1) {
        return this._setErr(XMLP.ERR_CLOSE_COMMENT);
    }

    this._setContent(XMLP._CONT_XML, iB, iE);

    this.m_iP = iE + 3;

    return XMLP._COMMENT;

}  // end function _parseComment


XMLP.prototype._parseDTD = function(iB) {
    /*******************************************************************************************************************
    function:  _parseDTD

    Author:   Scott Severtson
    *********************************************************************************************************************/

    // Eat DTD

    var iE, strClose, iInt, iLast;

    iE = this.m_xml.indexOf(">", iB);
    if(iE == -1) {
        return this._setErr(XMLP.ERR_CLOSE_DTD);
    }

    iInt = this.m_xml.indexOf("[", iB);
    strClose = ((iInt != -1) && (iInt < iE)) ? "]>" : ">";

    while(true) {
        // DEBUG: Remove
        if(iE == iLast) {
            return this._setErr(XMLP.ERR_INFINITELOOP);
        }

        iLast = iE;
        // DEBUG: Remove End

        iE = this.m_xml.indexOf(strClose, iB);
        if(iE == -1) {
            return this._setErr(XMLP.ERR_CLOSE_DTD);
        }

        // Make sure it is not the end of a CDATA section
        if (this.m_xml.substring(iE - 1, iE + 2) != "]]>") {
            break;
        }
    }

    this.m_iP = iE + strClose.length;

    return XMLP._DTD;

}  // end function _parseDTD


XMLP.prototype._parseElement = function(iB) {
    /*******************************************************************************************************************
    function:   _parseElement

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var iE, iDE, iNE, iRet;
    var iType, strN, iLast;

    iDE = iE = this.m_xml.indexOf(">", iB);
    if(iE == -1) {
        return this._setErr(XMLP.ERR_CLOSE_ELM);
    }

    if(this.m_xml.charAt(iB) == "/") {
        iType = XMLP._ELM_E;
        iB++;
    } else {
        iType = XMLP._ELM_B;
    }

    if(this.m_xml.charAt(iE - 1) == "/") {
        if(iType == XMLP._ELM_E) {
            return this._setErr(XMLP.ERR_ELM_EMPTY);
        }
        iType = XMLP._ELM_EMP;
        iDE--;
    }

    iDE = SAXStrings.lastIndexOfNonWhitespace(this.m_xml, iB, iDE);

    //djohack
    //hack to allow for elements with single character names to be recognized

    if (iE - iB != 1 ) {
        if(SAXStrings.indexOfNonWhitespace(this.m_xml, iB, iDE) != iB) {
            return this._setErr(XMLP.ERR_ELM_NAME);
        }
    }
    // end hack -- original code below

    /*
    if(SAXStrings.indexOfNonWhitespace(this.m_xml, iB, iDE) != iB)
        return this._setErr(XMLP.ERR_ELM_NAME);
    */
    this._clearAttributes();

    iNE = SAXStrings.indexOfWhitespace(this.m_xml, iB, iDE);
    if(iNE == -1) {
        iNE = iDE + 1;
    }
    else {
        this.m_iP = iNE;
        while(this.m_iP < iDE) {
            // DEBUG: Remove
            if(this.m_iP == iLast) return this._setErr(XMLP.ERR_INFINITELOOP);
            iLast = this.m_iP;
            // DEBUG: Remove End


            iRet = this._parseAttribute(this.m_iP, iDE);
            if(iRet == XMLP._ERROR) return iRet;
        }
    }

    strN = this.m_xml.substring(iB, iNE);

    if(strN.indexOf("<") != -1) {
        return this._setErr(XMLP.ERR_ELM_LT_NAME);
    }

    this.m_name = strN;
    this.m_iP = iE + 1;

    return iType;

}  // end function _parseElement


XMLP.prototype._parseEntity = function(iB) {
    /*******************************************************************************************************************
    function:   _parseEntity

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var iE = this.m_xml.indexOf(";", iB);
    if(iE == -1) {
        return this._setErr(XMLP.ERR_CLOSE_ENTITY);
    }

    this.m_iP = iE + 1;

    return this._replaceEntity(this.m_xml, iB, iE);

}  // end function _parseEntity


XMLP.prototype._parsePI = function(iB) {
    /*******************************************************************************************************************
    function:   _parsePI

    Author:   Scott Severtson
    *********************************************************************************************************************/

    var iE, iTB, iTE, iCB, iCE;

    iE = this.m_xml.indexOf("?>", iB);
    if(iE   == -1) {
        return this._setErr(XMLP.ERR_CLOSE_PI);
    }

    iTB = SAXStrings.indexOfNonWhitespace(this.m_xml, iB, iE);
    if(iTB == -1) {
        return this._setErr(XMLP.ERR_PI_TARGET);
    }

    iTE = SAXStrings.indexOfWhitespace(this.m_xml, iTB, iE);
    if(iTE  == -1) {
        iTE = iE;
    }

    iCB = SAXStrings.indexOfNonWhitespace(this.m_xml, iTE, iE);
    if(iCB == -1) {
        iCB = iE;
    }

    iCE = SAXStrings.lastIndexOfNonWhitespace(this.m_xml, iCB, iE);
    if(iCE  == -1) {
        iCE = iE - 1;
    }

    this.m_name = this.m_xml.substring(iTB, iTE);
    this._setContent(XMLP._CONT_XML, iCB, iCE + 1);
    this.m_iP = iE + 2;

    return XMLP._PI;

}  // end function _parsePI


XMLP.prototype._parseText = function(iB) {
    /*******************************************************************************************************************
    function:   _parseText

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var iE, iEE;

    iE = this.m_xml.indexOf("<", iB);
    if(iE == -1) {
        iE = this.m_xml.length;
    }

    iEE = this.m_xml.indexOf("&", iB);
    if((iEE != -1) && (iEE <= iE)) {
        iE = iEE;
    }

    this._setContent(XMLP._CONT_XML, iB, iE);

    this.m_iP = iE;

    return XMLP._TEXT;

} // end function _parseText


XMLP.prototype._replaceEntities = function(strD, iB, iE) {
    /*******************************************************************************************************************
    function:   _replaceEntities

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) return "";
    iB = iB || 0;
    iE = iE || strD.length;


    var iEB, iEE, strRet = "";

    iEB = strD.indexOf("&", iB);
    iEE = iB;

    while((iEB > 0) && (iEB < iE)) {
        strRet += strD.substring(iEE, iEB);

        iEE = strD.indexOf(";", iEB) + 1;

        if((iEE == 0) || (iEE > iE)) {
            return this._setErr(XMLP.ERR_CLOSE_ENTITY);
        }

        iRet = this._replaceEntity(strD, iEB + 1, iEE - 1);
        if(iRet == XMLP._ERROR) {
            return iRet;
        }

        strRet += this.m_cAlt;

        iEB = strD.indexOf("&", iEE);
    }

    if(iEE != iE) {
        strRet += strD.substring(iEE, iE);
    }

    this._setContent(XMLP._CONT_ALT, strRet);

    return XMLP._ENTITY;

}  // end function _replaceEntities


XMLP.prototype._replaceEntity = function(strD, iB, iE) {
    /*******************************************************************************************************************
    function:   _replaceEntity

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) return -1;
    iB = iB || 0;
    iE = iE || strD.length;

    switch(strD.substring(iB, iE)) {
        case "amp":  strEnt = "&";  break;
        case "lt":   strEnt = "<";  break;
        case "gt":   strEnt = ">";  break;
        case "apos": strEnt = "'";  break;
        case "quot": strEnt = "\""; break;
        default:
            if(strD.charAt(iB) == "#") {
                strEnt = String.fromCharCode(parseInt(strD.substring(iB + 1, iE)));
            } else {
                return this._setErr(XMLP.ERR_ENTITY_UNKNOWN);
            }
        break;
    }
    this._setContent(XMLP._CONT_ALT, strEnt);

    return XMLP._ENTITY;
}  // end function _replaceEntity


XMLP.prototype._setContent = function(iSrc) {
    /*******************************************************************************************************************
    function:   _setContent

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var args = arguments;

    if(XMLP._CONT_XML == iSrc) {
        this.m_cAlt = null;
        this.m_cB = args[1];
        this.m_cE = args[2];
    } else {
        this.m_cAlt = args[1];
        this.m_cB = 0;
        this.m_cE = args[1].length;
    }
    this.m_cSrc = iSrc;

}  // end function _setContent


XMLP.prototype._setErr = function(iErr) {
    /*******************************************************************************************************************
    function:   _setErr

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var strErr = XMLP._errs[iErr];

    this.m_cAlt = strErr;
    this.m_cB = 0;
    this.m_cE = strErr.length;
    this.m_cSrc = XMLP._CONT_ALT;

    return XMLP._ERROR;

}  // end function _setErr






/***************************************************************************************************************
SAXDriver is an object that basically wraps an XMLP instance, and provides an
event-based interface for parsing. This is the object users interact with when coding
with XML for <SCRIPT>
*****************************************************************************************************************/


SAXDriver = function() {
    /*******************************************************************************************************************
    function:   SAXDriver

    Author:   Scott Severtson

    Description:
        This is the constructor for the SAXDriver Object
    *********************************************************************************************************************/
    this.m_hndDoc = null;
    this.m_hndErr = null;
    this.m_hndLex = null;
}


// CONSTANTS    (these must be below the constructor)

// =========================================================================
// =========================================================================
// =========================================================================
SAXDriver.DOC_B = 1;
SAXDriver.DOC_E = 2;
SAXDriver.ELM_B = 3;
SAXDriver.ELM_E = 4;
SAXDriver.CHARS = 5;
SAXDriver.PI    = 6;
SAXDriver.CD_B  = 7;
SAXDriver.CD_E  = 8;
SAXDriver.CMNT  = 9;
SAXDriver.DTD_B = 10;
SAXDriver.DTD_E = 11;
// =========================================================================
// =========================================================================
// =========================================================================



SAXDriver.prototype.parse = function(strD) {
    /*******************************************************************************************************************
    function:   parse

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var parser = new XMLP(strD);

    if(this.m_hndDoc && this.m_hndDoc.setDocumentLocator) {
        this.m_hndDoc.setDocumentLocator(this);
    }

    this.m_parser = parser;
    this.m_bErr = false;

    if(!this.m_bErr) {
        this._fireEvent(SAXDriver.DOC_B);
    }
    this._parseLoop();
    if(!this.m_bErr) {
        this._fireEvent(SAXDriver.DOC_E);
    }

    this.m_xml = null;
    this.m_iP = 0;

}  // end function parse


SAXDriver.prototype.setDocumentHandler = function(hnd) {
    /*******************************************************************************************************************
    function:   setDocumentHandler

    Author:   Scott Severtson
    *********************************************************************************************************************/

    this.m_hndDoc = hnd;

}   // end function setDocumentHandler


SAXDriver.prototype.setErrorHandler = function(hnd) {
    /*******************************************************************************************************************
    function:   setErrorHandler

    Author:   Scott Severtson
    *********************************************************************************************************************/

    this.m_hndErr = hnd;

}  // end function setErrorHandler


SAXDriver.prototype.setLexicalHandler = function(hnd) {
    /*******************************************************************************************************************
    function:   setLexicalHandler

    Author:   Scott Severtson
    *********************************************************************************************************************/

    this.m_hndLex = hnd;

}  // end function setLexicalHandler


    /*******************************************************************************************************************
                                                LOCATOR/PARSE EXCEPTION INTERFACE
    *********************************************************************************************************************/

SAXDriver.prototype.getColumnNumber = function() {
    /*******************************************************************************************************************
    function:   getSystemId

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_parser.getColumnNumber();

}  // end function getColumnNumber


SAXDriver.prototype.getLineNumber = function() {
    /*******************************************************************************************************************
    function:   getLineNumber

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_parser.getLineNumber();

}  // end function getLineNumber


SAXDriver.prototype.getMessage = function() {
    /*******************************************************************************************************************
    function:   getMessage

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_strErrMsg;

}  // end function getMessage


SAXDriver.prototype.getPublicId = function() {
    /*******************************************************************************************************************
    function:   getPublicID

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return null;

}  // end function getPublicID


SAXDriver.prototype.getSystemId = function() {
    /*******************************************************************************************************************
    function:   getSystemId

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return null;

}  // end function getSystemId


    /*******************************************************************************************************************
                                                Attribute List Interface
    *********************************************************************************************************************/

SAXDriver.prototype.getLength = function() {
    /*******************************************************************************************************************
    function:   getLength

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_parser.getAttributeCount();

}  // end function getAttributeCount


SAXDriver.prototype.getName = function(index) {
    /*******************************************************************************************************************
    function:   getName

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_parser.getAttributeName(index);

} // end function getAttributeName


SAXDriver.prototype.getValue = function(index) {
    /*******************************************************************************************************************
    function:   getValue

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_parser.getAttributeValue(index);

}  // end function getAttributeValue


SAXDriver.prototype.getValueByName = function(name) {
    /*******************************************************************************************************************
    function:   getValueByName

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_parser.getAttributeValueByName(name);

} // end function getAttributeValueByName


    /*******************************************************************************************************************
                                                                Private functions
    *********************************************************************************************************************/

SAXDriver.prototype._fireError = function(strMsg) {
    /*******************************************************************************************************************
    function:   _fireError

    Author:   Scott Severtson
    *********************************************************************************************************************/
    this.m_strErrMsg = strMsg;
    this.m_bErr = true;

    if(this.m_hndErr && this.m_hndErr.fatalError) {
        this.m_hndErr.fatalError(this);
    }

}   // end function _fireError


SAXDriver.prototype._fireEvent = function(iEvt) {
    /*******************************************************************************************************************
    function:   _fireEvent

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var hnd, func, args = arguments, iLen = args.length - 1;

    if(this.m_bErr) return;

    if(SAXDriver.DOC_B == iEvt) {
        func = "startDocument";         hnd = this.m_hndDoc;
    }
    else if (SAXDriver.DOC_E == iEvt) {
        func = "endDocument";           hnd = this.m_hndDoc;
    }
    else if (SAXDriver.ELM_B == iEvt) {
        func = "startElement";          hnd = this.m_hndDoc;
    }
    else if (SAXDriver.ELM_E == iEvt) {
        func = "endElement";            hnd = this.m_hndDoc;
    }
    else if (SAXDriver.CHARS == iEvt) {
        func = "characters";            hnd = this.m_hndDoc;
    }
    else if (SAXDriver.PI    == iEvt) {
        func = "processingInstruction"; hnd = this.m_hndDoc;
    }
    else if (SAXDriver.CD_B  == iEvt) {
        func = "startCDATA";            hnd = this.m_hndLex;
    }
    else if (SAXDriver.CD_E  == iEvt) {
        func = "endCDATA";              hnd = this.m_hndLex;
    }
    else if (SAXDriver.CMNT  == iEvt) {
        func = "comment";               hnd = this.m_hndLex;
    }

    if(hnd && hnd[func]) {
        if(0 == iLen) {
            hnd[func]();
        }
        else if (1 == iLen) {
            hnd[func](args[1]);
        }
        else if (2 == iLen) {
            hnd[func](args[1], args[2]);
        }
        else if (3 == iLen) {
            hnd[func](args[1], args[2], args[3]);
        }
    }

}  // end function _fireEvent


SAXDriver.prototype._parseLoop = function(parser) {
    /*******************************************************************************************************************
    function:   _parseLoop

    Author:   Scott Severtson
    *********************************************************************************************************************/
    var iEvent, parser;

    parser = this.m_parser;
    while(!this.m_bErr) {
        iEvent = parser.next();

        if(iEvent == XMLP._ELM_B) {
            this._fireEvent(SAXDriver.ELM_B, parser.getName(), this);
        }
        else if(iEvent == XMLP._ELM_E) {
            this._fireEvent(SAXDriver.ELM_E, parser.getName());
        }
        else if(iEvent == XMLP._ELM_EMP) {
            this._fireEvent(SAXDriver.ELM_B, parser.getName(), this);
            this._fireEvent(SAXDriver.ELM_E, parser.getName());
        }
        else if(iEvent == XMLP._TEXT) {
            this._fireEvent(SAXDriver.CHARS, parser.getContent(), parser.getContentBegin(), parser.getContentEnd() - parser.getContentBegin());
        }
        else if(iEvent == XMLP._ENTITY) {
            this._fireEvent(SAXDriver.CHARS, parser.getContent(), parser.getContentBegin(), parser.getContentEnd() - parser.getContentBegin());
        }
        else if(iEvent == XMLP._PI) {
            this._fireEvent(SAXDriver.PI, parser.getName(), parser.getContent().substring(parser.getContentBegin(), parser.getContentEnd()));
        }
        else if(iEvent == XMLP._CDATA) {
            this._fireEvent(SAXDriver.CD_B);
            this._fireEvent(SAXDriver.CHARS, parser.getContent(), parser.getContentBegin(), parser.getContentEnd() - parser.getContentBegin());
            this._fireEvent(SAXDriver.CD_E);
        }
        else if(iEvent == XMLP._COMMENT) {
            this._fireEvent(SAXDriver.CMNT, parser.getContent(), parser.getContentBegin(), parser.getContentEnd() - parser.getContentBegin());
        }
        else if(iEvent == XMLP._DTD) {
        }
        else if(iEvent == XMLP._ERROR) {
            this._fireError(parser.getContent());
        }
        else if(iEvent == XMLP._NONE) {
            return;
        }
    }

}  // end function _parseLoop



/***************************************************************************************************************
SAXStrings: a useful object containing string manipulation functions
*****************************************************************************************************************/


SAXStrings = function() {
    /*******************************************************************************************************************
    function:   SAXStrings

    Author:   Scott Severtson

    Description:
        This is the constructor of the SAXStrings object
    *********************************************************************************************************************/
}  // end function SAXStrings


// CONSTANTS    (these must be below the constructor)

// =========================================================================
// =========================================================================
// =========================================================================
SAXStrings.WHITESPACE = " \t\n\r";
SAXStrings.QUOTES = "\"'";
// =========================================================================
// =========================================================================
// =========================================================================


SAXStrings.getColumnNumber = function(strD, iP) {
    /*******************************************************************************************************************
    function:   replace

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) {
        return -1;
    }
    iP = iP || strD.length;

    var arrD = strD.substring(0, iP).split("\n");
    var strLine = arrD[arrD.length - 1];
    arrD.length--;
    var iLinePos = arrD.join("\n").length;

    return iP - iLinePos;

}  // end function getColumnNumber


SAXStrings.getLineNumber = function(strD, iP) {
    /*******************************************************************************************************************
    function:   getLineNumber

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) {
        return -1;
    }
    iP = iP || strD.length;

    return strD.substring(0, iP).split("\n").length
}  // end function getLineNumber


SAXStrings.indexOfNonWhitespace = function(strD, iB, iE) {
    /*******************************************************************************************************************
    function:   indexOfNonWhitespace

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) {
        return -1;
    }
    iB = iB || 0;
    iE = iE || strD.length;

    for(var i = iB; i < iE; i++){
        if(SAXStrings.WHITESPACE.indexOf(strD.charAt(i)) == -1) {
            return i;
        }
    }
    return -1;

}  // end function indexOfNonWhitespace


SAXStrings.indexOfWhitespace = function(strD, iB, iE) {
    /*******************************************************************************************************************
    function:   indexOfWhitespace

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) {
        return -1;
    }
    iB = iB || 0;
    iE = iE || strD.length;

    for(var i = iB; i < iE; i++) {
        if(SAXStrings.WHITESPACE.indexOf(strD.charAt(i)) != -1) {
            return i;
        }
    }
    return -1;
}  // end function indexOfWhitespace


SAXStrings.isEmpty = function(strD) {
    /*******************************************************************************************************************
    function:   isEmpty

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return (strD == null) || (strD.length == 0);

}  // end function isEmpty


SAXStrings.lastIndexOfNonWhitespace = function(strD, iB, iE) {
    /*******************************************************************************************************************
    function:   lastIndexOfNonWhiteSpace

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) {
        return -1;
    }
    iB = iB || 0;
    iE = iE || strD.length;

    for(var i = iE - 1; i >= iB; i--){
        if(SAXStrings.WHITESPACE.indexOf(strD.charAt(i)) == -1){
            return i;
        }
    }
    return -1;
}  // end function lastIndexOfNonWhitespace


SAXStrings.replace = function(strD, iB, iE, strF, strR) {
    /*******************************************************************************************************************
    function:   replace

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(SAXStrings.isEmpty(strD)) {
        return "";
    }
    iB = iB || 0;
    iE = iE || strD.length;

    return strD.substring(iB, iE).split(strF).join(strR);

}  // end function replace



/***************************************************************************************************************
saxStack: A simple stack class, used for verifying document structure.
*****************************************************************************************************************/

saxStack = function() {
    /*******************************************************************************************************************
    function:   saxStack

    Author:   Scott Severtson

    Description:
        Constructor of the saxStack Object
    *********************************************************************************************************************/
    this.m_arr = new Array();

}  // end function saxStack


saxStack.prototype.clear = function() {
    /*******************************************************************************************************************
    function:   clear

    Author:   Scott Severtson
    *********************************************************************************************************************/

    this.m_arr = new Array();

}  // end function clear


saxStack.prototype.count = function() {
    /*******************************************************************************************************************
    function:   count

    Author:   Scott Severtson
    *********************************************************************************************************************/

    return this.m_arr.length;

}  // end function count


saxStack.prototype.destroy = function() {
    /*******************************************************************************************************************
    function:   destroy

    Author:   Scott Severtson
    *********************************************************************************************************************/

    this.m_arr = null;

}   // end function destroy


saxStack.prototype.peek = function() {
    /*******************************************************************************************************************
    function:   peek

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(this.m_arr.length == 0) {
        return null;
    }

    return this.m_arr[this.m_arr.length - 1];

}  // end function peek


saxStack.prototype.pop = function() {
    /*******************************************************************************************************************
    function:   pop

    Author:   Scott Severtson
    *********************************************************************************************************************/
    if(this.m_arr.length == 0) {
        return null;
    }

    var o = this.m_arr[this.m_arr.length - 1];
    this.m_arr.length--;
    return o;

}  // end function pop


saxStack.prototype.push = function(o) {
    /*******************************************************************************************************************
    function:   push

    Author:   Scott Severtson
    *********************************************************************************************************************/

    this.m_arr[this.m_arr.length] = o;

}  // end function push



// =========================================================================
// =========================================================================
// =========================================================================

// CONVENIENCE FUNCTIONS

// =========================================================================
// =========================================================================
// =========================================================================

function isEmpty(str) {
    /*******************************************************************************************************************
    function: isEmpty

    Author: mike@idle.org

    Description:
        convenience function to identify an empty string

    *********************************************************************************************************************/
    return (str==null) || (str.length==0);

} // end function isEmpty



function trim(trimString, leftTrim, rightTrim) {
    /*******************************************************************************************************************
    function: trim

    Author: may106@psu.edu

    Description:
        helper function to trip a string (trimString) of leading (leftTrim)
        and trailing (rightTrim) whitespace

    *********************************************************************************************************************/
    if (isEmpty(trimString)) {
        return "";
    }

    // the general focus here is on minimal method calls - hence only one
    // substring is done to complete the trim.

    if (leftTrim == null) {
        leftTrim = true;
    }

    if (rightTrim == null) {
        rightTrim = true;
    }

    var left=0;
    var right=0;
    var i=0;
    var k=0;


    // modified to properly handle strings that are all whitespace
    if (leftTrim == true) {
        while ((i<trimString.length) && (whitespace.indexOf(trimString.charAt(i++))!=-1)) {
            left++;
        }
    }
    if (rightTrim == true) {
        k=trimString.length-1;
        while((k>=left) && (whitespace.indexOf(trimString.charAt(k--))!=-1)) {
            right++;
        }
    }
    return trimString.substring(left, trimString.length - right);
} // end function trim

/**
 * function __escapeString
 *
 * author: David Joham djoham@yahoo.com
 *
 * @param  str : string - The string to be escaped
 *
 * @return : string - The escaped string
 */
function __escapeString(str) {

    var escAmpRegEx = /&/g;
    var escLtRegEx = /</g;
    var escGtRegEx = />/g;
    var quotRegEx = /"/g;
    var aposRegEx = /'/g;

    str = str.replace(escAmpRegEx, "&amp;");
    str = str.replace(escLtRegEx, "&lt;");
    str = str.replace(escGtRegEx, "&gt;");
    str = str.replace(quotRegEx, "&quot;");
    str = str.replace(aposRegEx, "&apos;");

  return str;
}

/**
 * function __unescapeString 
 *
 * author: David Joham djoham@yahoo.com
 *
 * @param  str : string - The string to be unescaped
 *
 * @return : string - The unescaped string
 */
function __unescapeString(str) {

    var escAmpRegEx = /&amp;/g;
    var escLtRegEx = /&lt;/g;
    var escGtRegEx = /&gt;/g;
    var quotRegEx = /&quot;/g;
    var aposRegEx = /&apos;/g;

    str = str.replace(escAmpRegEx, "&");
    str = str.replace(escLtRegEx, "<");
    str = str.replace(escGtRegEx, ">");
    str = str.replace(quotRegEx, "\"");
    str = str.replace(aposRegEx, "'");

  return str;
}

// =========================================================================
//
// scripts.js- sample code for the SAX Parser in XML for <SCRIPT>
//
// =========================================================================
//
// Copyright (C) 2001, 2002 - David Joham (djoham@yahoo.com)
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; eithere
// version 2.1 of the License, or (at your option) any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.

// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


/**************************************************************************************
                                        GLOBALS
***************************************************************************************/

var xmlTextArray
var xmlCDataArray
var xmlAttrArray


/**************************************************************************************
                                        FUNCTIONS
***************************************************************************************/

function showTagInfo(xpath){
    /*************************************************************************************
    Function:       void showTagInfo(xpath)

    author:         xwisdom@yahoo.com

    description:
        displays information about a node. Uses the node's xpath info

    ************************************************************************************/

    var textValue;
    var cdataValue;

    textValue = trim(xmlTextArray[xpath]);

    if (textValue == "" || textValue == null) {
        textValue = "No text value for this node";
    }

    cdataValue = trim(xmlCDataArray[xpath]);


    if (cdataValue == "" || cdataValue == null) {
        cdataValue = "No CDATA value for this node";
    }

    var src='Text:\n '+textValue+'\n\n' +'CDATA:\n '+cdataValue +'\n\n'

    if(xmlAttrArray[xpath]){
        var arr=xmlAttrArray[xpath]
        var atts=''
        for (i in arr){
            // name = value
            atts+=i+'='+arr[i]+'\n';
        }
        src+='Attributes:\n '+atts
    }

    alert(xpath+'\n\n'+src)

} // end function showTagInfo


function startParser() {
    /*************************************************************************************
    Function:       void startParser(xmldata)

    author:         xwisdom@yahoo.com

    description:
        starts the sax2 parser

    ************************************************************************************/

    var ixml = document.getElementById("xmldata").value;

    var arr,src='' ,parser = new SAXDriver();
    var handler = new xmlHandler();


    // pass handlers to the sax2 parser
    parser.setDocumentHandler(handler);
    parser.setErrorHandler(handler);
    parser.setLexicalHandler(handler);

    parser.parse(ixml);// start parsing

    // get errors from sax2 parser
    var err='\n'+handler.getError();

    xmlTextArray=handler.getText_Array()
    xmlCDataArray=handler.getCDATA_Array()
    xmlAttrArray=handler.getAttr_Array()

    arr=handler.getPath_Array();
    for (i=0;i<arr.length;i++){
        src+='<a href="javascript:void(null)" onclick="showTagInfo(\''+arr[i]+'\')">'+arr[i]+'</a>\n'
    }

    if(document.all){
        document.all.divout.innerHTML='Parsing completed  | Click on the links below for more info:<br><pre>'+src+'</pre>'
    }else if(document.getElementById){
        document.getElementById('divout').innerHTML='Parsing completed | Click on the links below for more info:<br><pre>'+src+'</pre>'
    }else{
        alert('Requires a DOM compatible browser for this test')
    }

}// end function startParser



/***************************************************************************************
                                        SAX EVENT HANDLER
***************************************************************************************/


xmlHandler = function() {
    /*************************************************************************************
    Function:       xmlHandler

    author:         xwisdom@yahoo.com

    description:
    	constructor for the xmlHandler object

    ************************************************************************************/
    this.m_strError=''
    this.m_treePath=[]
    this.m_xPath=[''] // stores current path info
    this.m_text=['']
    this.m_cdata=['']
    this.m_attr=['']
    this.m_pi=['']
    this.cdata=false

} // end function xmlHandler


xmlHandler.prototype.characters = function(data, start, length) {
    /*************************************************************************************
    Function:       object.characters(String data, Int start, Int length)
					-> data: xml data
					-> start of text/cdata entity
					-> length of text/cdata entity

    author:         xwisdom@yahoo.com

    description:
    	this event is triggered whenever a text/cdata entity is encounter by the sax2 parser

    ************************************************************************************/

    // capture characters from CDATA and Text entities
    var text=data.substr(start, length);
    if (text=='\n' ) return null // get ride of blank text lines
    if (this.m_treePath.length>0){
        if(this.cdata==false){
            if (!this.m_text[this.m_xPath.join('/')]) {
                this.m_text[this.m_xPath.join('/')]='';
            }
            this.m_text[this.m_xPath.join('/')]+=text;
        }
        else {
            if (!this.m_cdata[this.m_xPath.join('/')]) {
                this.m_cdata[this.m_xPath.join('/')]='';
            }
            this.m_cdata[this.m_xPath.join('/')]+=text;
        }
    }

} // end function characters


xmlHandler.prototype.comment = function(data, start, length) {
    /*************************************************************************************
    Function:       object.comment(String data, Int start, Int length)

    author:         xwisdom@yahoo.com

    description:
		triggered whenever a comment <!-- text --> is found. Same as the character event

    ************************************************************************************/

    var comment=data.substr(start, length)

} // end function comment


xmlHandler.prototype.endCDATA = function() {
    /*************************************************************************************
    Function:       object.endCDATA()

    author:         xwisdom@yahoo.com

    description:
    	triggered at the end of cdata entity

    ************************************************************************************/

    // end of CDATA entity
    this.cdata=false

} // end function endCDATA


xmlHandler.prototype.endDocument = function() {
    /*************************************************************************************
    Function:       object.endDocument()

    author:         xwisdom@yahoo.com

    description:
    	end of document parsing - last event triggered by the sax2 parser

    ************************************************************************************/

} // end function end Document


xmlHandler.prototype.endElement = function(name) {
    /*************************************************************************************
    Function:       object.endElement(String tagname)
					-> tagname: name of tag

    author:         xwisdom@yahoo.com

    description:
    	last event trigger when a node is encounter by the sax2 parser

    ************************************************************************************/

    this.m_xPath=this.m_xPath.slice(0,-1);

} // end function endElement

xmlHandler.prototype.error = function(exception) {
    /*************************************************************************************
    Function:       object.error(String exception)

    author:         xwisdom@yahoo.com

    description:
		triggered whenever an error is encounter by the sax2 parser

    ************************************************************************************/

    this.m_strError+='Error:'+exception.getMessage()+'\n'

} // end function error


xmlHandler.prototype.fatalError = function(exception) {
    /*************************************************************************************
    Function:       object.fatalError(String exception)

    author:         xwisdom@yahoo.com

    description:
		triggered whenever an error is encounter by the sax2 parser

    ************************************************************************************/

    this.m_strError+='fatal error:'+exception.getMessage()+'\n'

} // end function fatalError


xmlHandler.prototype.getAttr_Array= function() {
    /*************************************************************************************
    Function:       getAttr_Array

    author:         xwisdom@yahoo.com
    ************************************************************************************/

    return this.m_attr;

}   // end function getAttr_Array


xmlHandler.prototype.getCDATA_Array= function() {
    /*************************************************************************************
    Function:       getCDATA_Array

    author:         xwisdom@yahoo.com
    ************************************************************************************/
    return this.m_cdata;

}  // end function getCDATA_Array


xmlHandler.prototype.getError = function() {
    /*************************************************************************************
    Function:       getError

    author:         xwisdom@yahoo.com
    ************************************************************************************/

    return this.m_strError;

}  // end function getError


xmlHandler.prototype.getPath_Array = function() {
    /*************************************************************************************
    Function:       getError

    author:         xwisdom@yahoo.com
    ************************************************************************************/
	return this.m_treePath;
}  // end function getPath_Array


xmlHandler.prototype.getText_Array = function() {
    /*************************************************************************************
    Function:       getText_Array

    author:         xwisdom@yahoo.com
    ************************************************************************************/
    return this.m_text;

} // getTextArray


xmlHandler.prototype.processingInstruction = function(target, data) {
    /*************************************************************************************
    Function:       object.processingInstruction(String target, String data)
						-> target: is tagname of the pi
						-> data: is the content of the pi

    author:         xwisdom@yahoo.com

    description:
    	capture PI data here

    ************************************************************************************/

} // end function processingInstruction


xmlHandler.prototype.setDocumentLocator = function(locator) {
    /*************************************************************************************
    Function:       object.setDocumentLocator(SAXDriver locator)

    author:         xwisdom@yahoo.com

    description:
		passes an instance of the SAXDriver to the handler

    ************************************************************************************/

    this.m_locator = locator;

}  // end function setDocumentLocator


xmlHandler.prototype.startCDATA = function() {
    /*************************************************************************************
    Function:       object.startCDATA()

    author:         xwisdom@yahoo.com

    description:
    	triggered whenever a cdata entity is encounter by the sax2 parser

    ************************************************************************************/


    // start of CDATA entity
    this.cdata=true

} // end function startCDATA


xmlHandler.prototype.startDocument = function() {
    /*************************************************************************************
    Function:       object.startDocument()

    author:         xwisdom@yahoo.com

    description:
    	start of document - first event triggered by the sax2 parser

    ************************************************************************************/

} // end function startDocument


xmlHandler.prototype.startElement = function(name, atts) {
    /*************************************************************************************
    Function:       object.startElement(String tagname,Array content)
					-> tagname: name of tag
					-> content: [["attribute1", "value1"], ["attribute2", "value2"],....,n]

    author:         xwisdom@yahoo.com

    description:
    	First event trigger when a node is encounter by the sax2 parser
    	the name and attribute contents are passed to this event

    ************************************************************************************/
alert(name);
    // Note: the following code is used to store info about the node
    // into arrays for use the xpath layout

    var cpath,att_count=atts.getLength()
    this.m_xPath[this.m_xPath.length]=name
    cpath=this.m_xPath.join('/')
    this.m_treePath[this.m_treePath.length]=cpath

    if (att_count) {
        var attr=[]
        for (i=0;i<att_count;i++){
            attr[atts.getName(i)]=atts.getValue(i)
        }
        this.m_attr[this.m_xPath.join('/')]=attr;
    }

} // end function startElement


xmlHandler.prototype.warning = function(exception) {
    /*************************************************************************************
    Function:       object.warninng(String exception)

    author:         xwisdom@yahoo.com

    description:
		triggered whenever an error is encounter by the sax2 parser

    ************************************************************************************/

    this.m_strError+='Warning:'+exception.getMessage()+'\n'

} // end function warning


function Timer()
{
    this.startTime = null;
    this.stopTime = null;
}

Timer.prototype.start = function()
{
    var date = new Date();
    
    this.startTime = date.getTime();
}

Timer.prototype.stop = function()
{
    var date = new Date();
    
    this.stopTime = date.getTime();
}

Timer.prototype.getTime = function()
{
    if (this.startTime && this.stopTime)
    {
        return (this.stopTime - this.startTime) / 1000;
    }
        
    return 0;
}
// From: http://www.codeproject.com/KB/scripting/dom-element-abs-pos.aspx

function __getIEVersion()
{
    var rv = -1; // Return value assumes failure.
    if (navigator.appName == 'Microsoft Internet Explorer')
    {
        var ua = navigator.userAgent;
        var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
        if (re.exec(ua) != null)
            rv = parseFloat(RegExp.$1);
    }
    return rv;
}

function __getOperaVersion()
{
    var rv = 0; // Default value
    if (window.opera)
    {
        var sver = window.opera.version();
        rv = parseFloat(sver);
    }
    return rv;
}

var __userAgent = navigator.userAgent;
var __isIE = navigator.appVersion.match(/MSIE/) != null;
var __IEVersion = __getIEVersion();
var __isIENew = __isIE && __IEVersion >= 8;
var __isIEOld = __isIE && !__isIENew;

var __isFireFox = __userAgent.match(/firefox/i) != null;
var __isFireFoxOld = __isFireFox && ((__userAgent.match(/firefox\/2./i) != null) ||
	(__userAgent.match(/firefox\/1./i) != null));
var __isFireFoxNew = __isFireFox && !__isFireFoxOld;

var __isWebKit = navigator.appVersion.match(/WebKit/) != null;
var __isChrome = navigator.appVersion.match(/Chrome/) != null;
var __isOpera = window.opera != null;
var __operaVersion = __getOperaVersion();
var __isOperaOld = __isOpera && (__operaVersion < 10);

function __parseBorderWidth(width)
{
    var res = 0;
    if (typeof (width) == "string" && width != null && width != "")
    {
        var p = width.indexOf("px");
        if (p >= 0)
        {
            res = parseInt(width.substring(0, p));
        }
        else
        {
            //do not know how to calculate other values 
            //(such as 0.5em or 0.1cm) correctly now
            //so just set the width to 1 pixel
            res = 1;
        }
    }
    return res;
}

//returns border width for some element
function __getBorderWidth(element)
{
    var res = new Object();
    res.left = 0; res.top = 0; res.right = 0; res.bottom = 0;
    if (window.getComputedStyle)
    {
        //for Firefox
        var elStyle = window.getComputedStyle(element, null);
        res.left = parseInt(elStyle.borderLeftWidth.slice(0, -2));
        res.top = parseInt(elStyle.borderTopWidth.slice(0, -2));
        res.right = parseInt(elStyle.borderRightWidth.slice(0, -2));
        res.bottom = parseInt(elStyle.borderBottomWidth.slice(0, -2));
    }
    else
    {
        //for other browsers
        res.left = __parseBorderWidth(element.style.borderLeftWidth);
        res.top = __parseBorderWidth(element.style.borderTopWidth);
        res.right = __parseBorderWidth(element.style.borderRightWidth);
        res.bottom = __parseBorderWidth(element.style.borderBottomWidth);
    }

    return res;
}

//returns the absolute position of some element within document
function getElementAbsolutePos(element)
{
    var res = new Object();
    res.x = 0; res.y = 0;
    if (element !== null)
    {
        if (element.getBoundingClientRect)
        {
            var viewportElement = document.documentElement;
            var box = element.getBoundingClientRect();
            var scrollLeft = viewportElement.scrollLeft;
            var scrollTop = viewportElement.scrollTop;

            res.x = box.left + scrollLeft;
            res.y = box.top + scrollTop;

        }
        else
        { //for old browsers
            res.x = element.offsetLeft;
            res.y = element.offsetTop;

            var parentNode = element.parentNode;
            var borderWidth = null;

            while (offsetParent != null)
            {
                res.x += offsetParent.offsetLeft;
                res.y += offsetParent.offsetTop;

                var parentTagName =
					offsetParent.tagName.toLowerCase();

                if ((__isIEOld && parentTagName != "table") ||
					((__isFireFoxNew || __isChrome) &&
						parentTagName == "td"))
                {
                    borderWidth = kGetBorderWidth
							(offsetParent);
                    res.x += borderWidth.left;
                    res.y += borderWidth.top;
                }

                if (offsetParent != document.body &&
				offsetParent != document.documentElement)
                {
                    res.x -= offsetParent.scrollLeft;
                    res.y -= offsetParent.scrollTop;
                }


                //next lines are necessary to fix the problem 
                //with offsetParent
                if (!__isIE && !__isOperaOld || __isIENew)
                {
                    while (offsetParent != parentNode &&
						parentNode !== null)
                    {
                        res.x -= parentNode.scrollLeft;
                        res.y -= parentNode.scrollTop;
                        if (__isFireFoxOld || __isWebKit)
                        {
                            borderWidth =
						     kGetBorderWidth(parentNode);
                            res.x += borderWidth.left;
                            res.y += borderWidth.top;
                        }
                        parentNode = parentNode.parentNode;
                    }
                }

                parentNode = offsetParent.parentNode;
                offsetParent = offsetParent.offsetParent;
            }
        }
    }
    
    return res;
}
/**
*	The end behavior enumeration
*/
var eEndBehavior =
{
    Reset: 0,
    Constant: 1,
    Repeat: 2,
    Oscillate: 3,
    OffsetRepeat: 4,
    Linear: 5
};

var eImageAntialiasOp =
{
    None: 0,
    TwoPass: 1,
    FourPass: 2,
    EightPass: 3,
    EnumCount: 4
};

/**
 * The key frame shape enumeration
 */
var eKeyframeShape =
{
    Linear: 0,
    Stepped: 1,
    TCB: 2,
    Bezier1D: 3,
    Bezier2D: 4
};

var eTextureType =
{
    // color textures
    Color: 0,
    // diffuse textures
    Diffuse: 1,
    // luminosity (emissive) textures
    Luminosity: 2,
    // reflection textures
    Reflection: 3,
    // specularity textures
    Specularity: 4,
    // transparency textures
    Transparency: 5,
    // clip textures
    Clip: 6,
    // bump textures
    Bump: 7,
    // number of texture types
    EnumCount: 8
};

var eTextureWrap =
{
    // no texture wrapping
    None: 0,
    // clamp texture wrapping
    Clamp: 1,
    // repeat texture wrapping
    Repeat: 2,
    // mirror texture wrapping
    Mirror: 3,
    // number of texture wraps
    EnumCount: 4
};

var eHighlightType =
{
    // disable highlights
    None: 0,
    // 4-pass
    FourPass: 1,
    // 8-pass
    EightPass: 2  
};

var FLT_EPSILON = 1.192092896e-07;
var FLT_MAX     = 3.402823466e+38;

var TWOPI     = Math.PI * 2;
var HALFPI    = Math.PI / 2;
var QUARTERPI = Math.PI / 4;

function min3(x, y, z)
{
    return Math.min(x, Math.min(y, z));
}

function max3(x, y, z)
{
    return Math.max(x, Math.max(y, z));
}

function toRadians(degrees)
{
    return degrees * Math.PI / 180;
}

function toDegrees(radians)
{
    return radians * 180 / Math.PI;
}

function magnitude(x, y, z)
{
    return Math.sqrt(((x) * (x)) + ((y) * (y)) + ((z) * (z)));
}

function clamp(value, min, max)
{
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

/*
 * Normalize a degree value so that it falls between [0, 360)
 * @params deg the degree value to normalize
 * @return T the normalized value
 */
function degreeNormalize(deg)
{
    while (deg < 0)
    {
        deg += 360;
    }

    while (deg >=360)
    {
        deg -= 360;
    }

    return deg;
}

function epsilonEqual(value1, value2, epsilon)
{
    if (Math.abs(value1 - value2) < epsilon)
    {
        return true;
    }
    
    return false;
}

function determinant2x2(_11, _12, 
                        _21, _23)
{
    return (_11 * _23) - (_12 * _21);
}

function determinant3x3(_11, _12, _13, 
                        _21, _22, _23,
                        _31, _32, _33)
{
    var a = determinant2x2(_22, _23, _32, _33);
    var b = determinant2x2(_21, _23, _31, _33);
    var c = determinant2x2(_21, _22, _31, _32);
    
    return (_11 * a) - (_12 * b) + (_13 * c);
}
        
function determinant4x4(_11, _12, _13, _14,
                        _21, _22, _23, _24,
                        _31, _32, _33, _34,
                        _41, _42, _43, _44)
{
    var a = determinant3x3(_22, _23, _24, _32, _33, _34, _42, _43, _44);
    var b = determinant3x3(_21, _23, _24, _31, _33, _34, _41, _43, _44);
    var c = determinant3x3(_21, _22, _24, _31, _32, _34, _41, _42, _44);
    var d = determinant3x3(_21, _22, _23, _31, _32, _33, _41, _42, _43);
    
    return (_11 * a) - (_12 * b) + (_13 * c) - (_14 * d);  
}        

function modf(x)
{
    var integerPart = (x < 0 ? Math.ceil(x) : Math.floor(x));
    var fractionalPart = x - integerPart;
    
    return { integerPart: integerPart, fractionalPart: fractionalPart };
}

function XYZtoH(x, y, z)
{
    var heading = 0;
    
    if (x == 0)
    {
        if (z >= 0)
        {
            heading = 0.0;
        }
        else
        {
            heading = Math.PI;
        }
    }
    else if (z == 0)
    {
        if (x >= 0)
        {
            heading = 3 * HALFPI;
        }
        else
        {
            heading = HALFPI;
        }
    }
    else
    {
        if (x > 0 && z > 0) // I
        {
            heading = TWOPI - Math.atan(x / z);
        }
        else if (x < 0 && z > 0) // II
        {
            heading = -Math.atan(x / z);
        }
        else if (x < 0 && z < 0)  // III
        {
            heading = HALFPI + Math.atan(z / x);
        }
        else // (x > 0 && z < 0)  // IV
        {
            heading = 3 * HALFPI + Math.atan(z / x);
        }
    }
    
    return heading;
}

function XYZtoHP(x, y, z)
{
    var heading = 0;
    var pitch = 0;
    
    if (x == 0 && z == 0) 
    {
        heading = 0;
        if (y != 0)
        {
            pitch = (y < 0 ? -HALFPI : HALFPI);
        }
        else
        {
            pitch = 0;
        }
    }
    else 
    {
        if (z == 0)
        {
            heading = (x > 0 ? HALFPI : -HALFPI);
        }
        else if (z < 0)
        {
            heading = -Math.atan(x / z) + Math.PI;
        }
        else
        {
            heading = -Math.atan(x / z);
        }

        x = Math.sqrt(x * x + z * z);

        if (x == 0)
        {
            pitch = (y < 0 ? -HALFPI : HALFPI);
        }
        else
        {
            pitch = Math.atan(y / x);
        }
    }
    
    return { heading: heading, pitch: pitch };
}

function rectContainsPoint(x, y, rect)
{
    if (x >= rect.left &&
        y >= rect.top &&
        x <= rect.right &&
        y <= rect.bottom)
        return true;
        
    return false;
}
function Vector2D(x, y)
{
    this.x = x || 0;
    this.y = y || 0;
}

Vector2D.prototype.v = function()
{
    var values = [ this.x, this.y ];
    return values;
}

Vector2D.prototype.load = function(x, y)
{
    this.x = x;
    this.y = y;
}

Vector2D.prototype.copy = function(vector)
{
    if (vector)
    {
        this.x = vector.x;
        this.y = vector.y;
    }
}
function Vector3D(x, y, z)
{
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

    this.equals = function(rhs)
    {
        return (this.x == rhs.x &&
                this.y == rhs.y &&
                this.z == rhs.z);
    }
}

Vector3D.prototype.alert = function()
{
    var msg  = "x: " + this.x + "\n";
        msg += "y: " + this.y + "\n";
        msg += "z: " + this.z + "\n";
    alert(msg);
}

Vector3D.prototype.v = function()
{
    var values = [ this.x, this.y, this.z ];
    return values;
}

Vector3D.prototype.load = function(x, y, z)
{
    this.x = x;
    this.y = y;
    this.z = z;
}

Vector3D.prototype.copy = function(vector)
{
    if (vector)
    {
        this.x = vector.x;
        this.y = vector.y;
        this.z = vector.z;
    }
}

Vector3D.prototype.multiplyScalar = function(scalar)
{
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
}

Vector3D.prototype.multiplyVector = function(vector)
{
    this.x *= vector.x;
    this.y *= vector.y;
    this.z *= vector.z;
}

Vector3D.prototype.addVector = function(vector)
{
    this.x += vector.x;
    this.y += vector.y;
    this.z += vector.z;
}

Vector3D.prototype.subtractVector = function(vector)
{
    this.x -= vector.x;
    this.y -= vector.y;
    this.z -= vector.z;
}

Vector3D.prototype.normalize = function()
{
    var mag = magnitude(this.x, this.y, this.z);
    if (mag != 0)
    {
        this.x /= mag;
        this.y /= mag;
        this.z /= mag;
    }
}

function dotProduct(v1, v2)
{
    return ((v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z));
}

function crossProduct(v1, v2)
{
    var result = new Vector3D();
    
    result.x = (v1.y * v2.z) - (v1.z * v2.y);
    result.y = (v1.z * v2.x) - (v1.x * v2.z);
    result.z = (v1.x * v2.y) - (v1.y * v2.x);
    
    return result;
}

function cosineAngleBetween(v1, v2)
{
    var mag = magnitude(v1.x, v1.y, v1.z) * magnitude(v2.x, v2.y, v2.z);
    if (mag != 0)
    {
        var cosAngle = dotProduct(v1, v2) / mag;

        // clamp values between -1 and 1
        if (cosAngle > 1) cosAngle = 1;
        else if (cosAngle < -1) cosAngle = -1;

        return cosAngle;
    }

    return 1;
}

function midpoint(v1, v2)
{
    var result = new Vector3D();
    
    result.x = (v1.x + v2.x) / 2;
    result.y = (v1.y + v2.y) / 2;
    result.z = (v1.z + v2.z) / 2;
    
    return result;
}

function distanceBetween(v1, v2)
{
    return Math.sqrt((v1.x - v2.x) * (v1.x - v2.x) + 
                     (v1.y - v2.y) * (v1.y - v2.y) +
                     (v1.z - v2.z) * (v1.z - v2.z));
}

function subtract3D(v1, v2)
{
    var result = new Vector3D(v1.x, v1.y, v1.z);
    result.subtractVector(v2);
    return result;
}
function Vector4D(x, y, z, w)
{
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w || 0;
}

Vector4D.prototype.v = function()
{
    var values = [ this.x, this.y, this.z, this.w ];
    return values;
}

Vector4D.prototype.load = function(x, y, z, w)
{
    if (Vector4D)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
}

Vector4D.prototype.copy = function(vector)
{
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    this.w = vector.w;
}
function Matrix4x4(_11, _12, _13, _14,
                   _21, _22, _23, _24,
                   _31, _32, _33, _34,
                   _41, _42, _43, _44)
{
    this._11 = _11 || 1;
    this._12 = _12 || 0;
    this._13 = _13 || 0;
    this._14 = _14 || 0;

    this._21 = _21 || 0;
    this._22 = _22 || 1;
    this._23 = _23 || 0;
    this._24 = _24 || 0;

    this._31 = _31 || 0;
    this._32 = _32 || 0;
    this._33 = _33 || 1;
    this._34 = _34 || 0;

    this._41 = _41 || 0;
    this._42 = _42 || 0;
    this._43 = _43 || 0;
    this._44 = _44 || 1;
}

Matrix4x4.prototype.alert = function()
{
    alert([[this._11, this._12, this._13, this._14].join(" "),
           [this._21, this._22, this._23, this._24].join(" "),
           [this._31, this._32, this._33, this._34].join(" "),
           [this._41, this._42, this._43, this._44].join(" ")].join("\n") 
    );
}

Matrix4x4.prototype.flatten = function()
{
    var v = [
        this._11, this._12, this._13, this._14,
        this._21, this._22, this._23, this._24,
        this._31, this._32, this._33, this._34,
        this._41, this._42, this._43, this._44
    ];
    
    return v;
}

Matrix4x4.prototype.getAt = function(row, col)
{
    switch (row)
    {
    case 0:
        {
            switch (col)
            {
            case 0: return this._11;
            case 1: return this._12;
            case 2: return this._13;
            case 3: return this._14;
            }
        }
        break;
     
    case 1:
        {
            switch (col)
            {
            case 0: return this._21;
            case 1: return this._22;
            case 2: return this._23;
            case 3: return this._24;
            }
        }
        break;
        
    case 2:
        {
            switch (col)
            {
            case 0: return this._31;
            case 1: return this._32;
            case 2: return this._33;
            case 3: return this._34;
            }
        }
        break;
        
    case 3:
        {
            switch (col)
            {
            case 0: return this._41;
            case 1: return this._42;
            case 2: return this._43;
            case 3: return this._44;
            }
        }
        break;
    }
}

Matrix4x4.prototype.setAt = function(row, col, value)
{
    switch (row)
    {
    case 0:
        {
            switch (col)
            {
            case 0: this._11 = value; break;
            case 1: this._12 = value; break;
            case 2: this._13 = value; break;
            case 3: this._14 = value; break;
            }
        }
        break;
     
    case 1:
        {
            switch (col)
            {
            case 0: this._21 = value; break;
            case 1: this._22 = value; break;
            case 2: this._23 = value; break;
            case 3: this._24 = value; break;
            }
        }
        break;
        
    case 2:
        {
            switch (col)
            {
            case 0: this._31 = value; break;
            case 1: this._32 = value; break;
            case 2: this._33 = value; break;
            case 3: this._34 = value; break;
            }
        }
        break;
        
    case 3:
        {
            switch (col)
            {
            case 0: this._41 = value; break;
            case 1: this._42 = value; break;
            case 2: this._43 = value; break;
            case 3: this._44 = value; break;
            }
        }
        break;
    }
}

Matrix4x4.prototype.load = function(_11, _12, _13, _14,
                                    _21, _22, _23, _24,
                                    _31, _32, _33, _34,
                                    _41, _42, _43, _44)
{
    this._11 = _11;
    this._12 = _12;
    this._13 = _13;
    this._14 = _14;
    
    this._21 = _21;
    this._22 = _22;
    this._23 = _23;
    this._24 = _24;
    
    this._31 = _31;
    this._32 = _32;
    this._33 = _33;
    this._34 = _34;
    
    this._41 = _41;
    this._42 = _42;
    this._43 = _43;
    this._44 = _44;
}

Matrix4x4.prototype.loadMatrix = function(matrix)
{
    this._11 = matrix._11;
    this._12 = matrix._12;
    this._13 = matrix._13;
    this._14 = matrix._14;
    
    this._21 = matrix._21;
    this._22 = matrix._22;
    this._23 = matrix._23;
    this._24 = matrix._24;
    
    this._31 = matrix._31;
    this._32 = matrix._32;
    this._33 = matrix._33;
    this._34 = matrix._34;
    
    this._41 = matrix._41;
    this._42 = matrix._42;
    this._43 = matrix._43;
    this._44 = matrix._44;
}

Matrix4x4.prototype.loadArray = function(array)
{
    this._11 = array[0];
    this._12 = array[1];
    this._13 = array[2];
    this._14 = array[3];

    this._21 = array[4];
    this._22 = array[5];
    this._23 = array[6];
    this._24 = array[7];

    this._31 = array[8];
    this._32 = array[9];
    this._33 = array[10];
    this._34 = array[11];

    this._41 = array[12];
    this._42 = array[13];
    this._43 = array[14];
    this._44 = array[15];
}

Matrix4x4.prototype.loadIdentity = function()
{
    this._11 = 1;
    this._12 = 0;
    this._13 = 0;
    this._14 = 0;
        
    this._21 = 0;
    this._22 = 1;
    this._23 = 0;
    this._24 = 0;
    
    this._31 = 0;
    this._32 = 0;
    this._33 = 1;
    this._34 = 0;
    
    this._41 = 0;
    this._42 = 0;
    this._43 = 0;
    this._44 = 1;
}

Matrix4x4.prototype.loadTranslation = function(x, y, z)
{
    this.loadIdentity();
    
    this._41 = x;
    this._42 = y;
    this._43 = z;
}

Matrix4x4.prototype.loadRotation = function(x, y, z, degrees)
{
    // build rotation (and inverse rotation) matrix to rotate space 
    // about the X axis so that the rotation axis lies in the XZ plane
    var mX = new Matrix4x4();
    var mXinv = new Matrix4x4();
    var v = Math.sqrt(y * y + z * z);
    if (v != 0)
    {
        var y_v = y / v;
        var z_v = z / v;

        mX._22 =  z_v;
        mX._23 =  y_v;
        mX._32 = -y_v;
        mX._33 =  z_v;

        mXinv._22 =  z_v;
        mXinv._23 = -y_v;
        mXinv._32 =  y_v;
        mXinv._33 =  z_v;
    }

    // build rotation (and inverse rotation) matrix to rotate space 
    // about the Y axis so that the rotation axis is aligned with the Z axis
    var mY = new Matrix4x4();
    var mYinv = new Matrix4x4();
    var v2 = magnitude(x, y, z);
    if (v2 != 0)
    {
        var v_v2 = v / v2;
        var x_v2 = x / v2;

        mY._11 =  v_v2;
        mY._13 =  x_v2;
        mY._31 = -x_v2;
        mY._33 =  v_v2;

        mYinv._11 =  v_v2;
        mYinv._13 = -x_v2;
        mYinv._31 =  x_v2;
        mYinv._33 =  v_v2;
    }

    // build rotation matrix to rotate about the Z axis
    var mZ = new Matrix4x4();
    var cosAngle = Math.cos(toRadians(degrees));
    var sinAngle = Math.sin(toRadians(degrees));
    mZ._11 =  cosAngle;
    mZ._12 =  sinAngle;
    mZ._21 = -sinAngle;
    mZ._22 =  cosAngle;

    // sum rotations
    var result = mX.multiply(mY.multiply(mZ.multiply(mYinv.multiply(mXinv))));
    this.loadMatrix(result);
}

Matrix4x4.prototype.loadXAxisRotation = function(degrees)
{
    this.loadIdentity();

    var cosAngle = Math.cos(toRadians(degrees));
    var sinAngle = Math.sin(toRadians(degrees));

    this._22 =  cosAngle;
    this._23 =  sinAngle;
    this._32 = -sinAngle;
    this._33 =  cosAngle;
}

Matrix4x4.prototype.loadYAxisRotation = function(degrees)
{
    this.loadIdentity();

    var cosAngle = Math.cos(toRadians(degrees));
    var sinAngle = Math.sin(toRadians(degrees));

    this._11 =  cosAngle;
    this._13 = -sinAngle;
    this._31 =  sinAngle;
    this._33 =  cosAngle;
}

Matrix4x4.prototype.loadZAxisRotation = function(degrees)
{
    this.loadIdentity();

    var cosAngle = Math.cos(toRadians(degrees));
    var sinAngle = Math.sin(toRadians(degrees));

    this._11 =  cosAngle;
    this._12 =  sinAngle;
    this._21 = -sinAngle;
    this._22 =  cosAngle;
}

Matrix4x4.prototype.loadXYZAxisRotation = function(degreesX, degreesY, degreesZ)
{
    var mX = new Matrix4x4();
    var mY = new Matrix4x4();
    var mZ = new Matrix4x4();

    mX.loadXAxisRotation(degreesX);
    mY.loadYAxisRotation(degreesY);
    mZ.loadZAxisRotation(degreesZ);

    // sum rotations
    var result = mY.multiply(mX.multiply(mZ));
    this.loadMatrix(result);
}

Matrix4x4.prototype.getRotationAngles = function()
{
    var x, y, z;
    
    x = Math.asin(clamp(this._23, -1, 1));
    var cosx = Math.cos(x);
    
    if (!epsilonEqual(cosx, 0, FLT_EPSILON))
    {
        y = Math.atan2(-(this._13) / cosx, this._33 / cosx);
        z = Math.atan2(-(this._21) / cosx, this._22 / cosx); 
    }
    else // cosx == 0
    {
        // remove x-axis rotation to obtain z-axis rotation by 
        // multiplying this matrix with inverse of x-axis rotation
        var zAxisRot = new Matrix4x4();
        zAxisRot.loadXAxisRotation(toDegrees(x));
        zAxisRot.transpose(); // invert rotation
        zAxisRot.loadMatrix(zAxisRot.multiply(this));
        
        y = 0;
        z = Math.atan2(-(zAxisRot._21), zAxisRot._22);
    }
    
    return { x: toDegrees(x), y: toDegrees(y), z: toDegrees(z) };
}

Matrix4x4.prototype.loadScale = function(x, y, z)
{
    this.loadIdentity();

    this._11 = x;
    this._22 = y;
    this._33 = z;
}

Matrix4x4.prototype.getScalingFactors = function()
{
    var a, b;
    
    // x
    a = this.transform(1, 0, 0, 0);
    b = this.transform(2, 0, 0, 0);
    var scalingX = magnitude(b.x, b.y, b.z) - magnitude(a.x, a.y, a.z);
    
    // y
    a = this.transform(0, 1, 0, 0);
    b = this.transform(0, 2, 0, 0);
    var scalingY = magnitude(b.x, b.y, b.z) - magnitude(a.x, a.y, a.z);
    
    // z
    a = this.transform(0, 0, 1, 0);
    b = this.transform(0, 0, 2, 0);
    var scalingZ = magnitude(b.x, b.y, b.z) - magnitude(a.x, a.y, a.z);
    
    return { x: scalingX, y: scalingY, z: scalingZ };
}

Matrix4x4.prototype.multiply = function(rhs)
{
    var result = new Matrix4x4();
    
    if (!rhs)
    {
        return;    
    }
    
    result.load
    (
        this._11 * rhs._11 + this._12 * rhs._21 + this._13 * rhs._31 + this._14 * rhs._41,
        this._11 * rhs._12 + this._12 * rhs._22 + this._13 * rhs._32 + this._14 * rhs._42,
        this._11 * rhs._13 + this._12 * rhs._23 + this._13 * rhs._33 + this._14 * rhs._43,
        this._11 * rhs._14 + this._12 * rhs._24 + this._13 * rhs._34 + this._14 * rhs._44,
        this._21 * rhs._11 + this._22 * rhs._21 + this._23 * rhs._31 + this._24 * rhs._41,
        this._21 * rhs._12 + this._22 * rhs._22 + this._23 * rhs._32 + this._24 * rhs._42,
        this._21 * rhs._13 + this._22 * rhs._23 + this._23 * rhs._33 + this._24 * rhs._43,
        this._21 * rhs._14 + this._22 * rhs._24 + this._23 * rhs._34 + this._24 * rhs._44,
        this._31 * rhs._11 + this._32 * rhs._21 + this._33 * rhs._31 + this._34 * rhs._41,
        this._31 * rhs._12 + this._32 * rhs._22 + this._33 * rhs._32 + this._34 * rhs._42,
        this._31 * rhs._13 + this._32 * rhs._23 + this._33 * rhs._33 + this._34 * rhs._43,
        this._31 * rhs._14 + this._32 * rhs._24 + this._33 * rhs._34 + this._34 * rhs._44,
        this._41 * rhs._11 + this._42 * rhs._21 + this._43 * rhs._31 + this._44 * rhs._41,
        this._41 * rhs._12 + this._42 * rhs._22 + this._43 * rhs._32 + this._44 * rhs._42,
        this._41 * rhs._13 + this._42 * rhs._23 + this._43 * rhs._33 + this._44 * rhs._43,  
        this._41 * rhs._14 + this._42 * rhs._24 + this._43 * rhs._34 + this._44 * rhs._44
     );
     
     return result; 
}

Matrix4x4.prototype.leftMultiply = function(lhs)
{
    var result = lhs.multiply(this);
    
    return result;
}

Matrix4x4.prototype.transpose = function()
{
    var temp = new Matrix4x4();
    temp.loadMatrix(this);
    
    this._11 = temp._11;
    this._12 = temp._21;
    this._13 = temp._31;
    this._14 = temp._41;

    this._21 = temp._12;
    this._22 = temp._22;
    this._23 = temp._32;
    this._24 = temp._42;

    this._31 = temp._13;
    this._32 = temp._23;
    this._33 = temp._33;
    this._34 = temp._43;

    this._41 = temp._14;
    this._42 = temp._24;
    this._43 = temp._34;
    this._44 = temp._44;
}

Matrix4x4.prototype.invert = function()
{
    var det = determinant4x4(this._11, this._12, this._13, this._14,
                             this._21, this._22, this._23, this._24,
                             this._31, this._32, this._33, this._34,
                             this._41, this._42, this._43, this._44);
    if (det == 0)
    {
        // no inverse
        return;
    }
    
    var inverse  = new Matrix4x4();
    
    var i, j, i2, j2, k;
    
    for (i=0; i < 4; i++)
    {
        for (j=0; j < 4; j++)
        {
            var sub = [];

            for (i2=0, k=0; i2 < 4; i2++)
            {
                if (i2 == i) continue;

                for (j2=0; j2 < 4; j2++)
                {
                    if (j2 == j) continue;

                    sub[k++] = this.getAt(i2, j2);
                }
            }

            inverse.setAt(i, j, determinant3x3(sub[0], sub[1], sub[2], sub[3], sub[4], sub[5], sub[6], sub[7], sub[8]) / det * (i+j & 1 ? -1 : 1));
        }
    }

    // transpose
    inverse.transpose();

    this.loadMatrix(inverse);
}

Matrix4x4.prototype.transform = function(x, y, z, w)
{
    var tx, ty, tz;
    
    if (w == 0)
    {
        tx = this._11 * x + this._21 * y + this._31 * z;
        ty = this._12 * x + this._22 * y + this._32 * z;
        tz = this._13 * x + this._23 * y + this._33 * z;
    }
    else if (w == 1)
    {
        tx = this._11 * x + this._21 * y + this._31 * z + this._41;
        ty = this._12 * x + this._22 * y + this._32 * z + this._42;
        tz = this._13 * x + this._23 * y + this._33 * z + this._43;
    }
    else
    {
        tx = this._11 * x + this._21 * y + this._31 * z + this._41 * w;
        ty = this._12 * x + this._22 * y + this._32 * z + this._42 * w;
        tz = this._13 * x + this._23 * y + this._33 * z + this._43 * w;
    } 
    
    return { x: tx, y: ty, z: tz };
}

Matrix4x4.prototype.transformw = function(x, y, z, w)
{
    var tx, ty, tz, tw;
    
    if (w == 0)
    {
        tx = this._11 * x + this._21 * y + this._31 * z;
        ty = this._12 * x + this._22 * y + this._32 * z;
        tz = this._13 * x + this._23 * y + this._33 * z;
        tw = this._14 * x + this._24 * y + this._34 * z;
    }
    else if (w == 1)
    {
        tx = this._11 * x + this._21 * y + this._31 * z + this._41;
        ty = this._12 * x + this._22 * y + this._32 * z + this._42;
        tz = this._13 * x + this._23 * y + this._33 * z + this._43;
        tw = this._14 * x + this._24 * y + this._34 * z + this._44;
    }
    else
    {
        tx = this._11 * x + this._21 * y + this._31 * z + this._41 * w;
        ty = this._12 * x + this._22 * y + this._32 * z + this._42 * w;
        tz = this._13 * x + this._23 * y + this._33 * z + this._43 * w;
        tw = this._14 * x + this._24 * y + this._34 * z + this._44 * w;
    } 
    
    return { x: tx, y: ty, z: tz, w: tw };
}

Matrix4x4.prototype.transformVector3D = function(vector, w)
{
    return this.transform(vector.x, vector.y, vector.z, w);
}
MatrixStack.prototype = new Stack();
MatrixStack.prototype.constructor = MatrixStack;

function MatrixStack(element)
{
    Stack.call(this, element);
}

MatrixStack.prototype.push = function(element)
{
    if (element)
    {
        this.stack.push(element);
    }
    else
    {
        this.stack.push(this.top());
    }
}

MatrixStack.prototype.loadMatrix = function(matrix)
{
    this.load(matrix);
}

MatrixStack.prototype.leftMultiply = function(lhs)
{
    var result = lhs.multiply(this.top());
    this.pop();
    Stack.prototype.push.call(this, result);
}

MatrixStack.prototype.rightMultiply = function(rhs)
{
    var result = this.top().multiply(rhs);
    this.pop();
    Stack.prototype.push.call(this, result);
}

function Quaternion()
{
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
}

Quaternion.prototype.load = function(w, x, y, z)
{
    this.w = w;
    this.x = x;
    this.y = y;
    this.z = z;
}

Quaternion.prototype.loadQuaternion = function(quaternion)
{
    this.w = quaternion.w;
    this.x = quaternion.x;
    this.y = quaternion.y;
    this.z = quaternion.z;
}

Quaternion.prototype.loadArray = function(array)
{
    this.w = array[0];
    this.x = array[1];
    this.y = array[2];
    this.z = array[3];
}

Quaternion.prototype.loadIdentity = function()
{
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
}

Quaternion.prototype.magnitude = function()
{
    return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
}

Quaternion.prototype.normalize = function()
{
    var magnitude = this.magnitude();
    
    this.w /= magnitude;
    this.x /= magnitude;
    this.y /= magnitude;
    this.z /= magnitude; 
}

Quaternion.prototype.loadRotation = function(x, y, z, degrees)
{
    var radians = toRadians(degrees) / 2;
    
    var sinAngle = Math.sin(radians);
    var cosAngle = Math.cos(radians);
    
    this.w = cosAngle;
    this.x = x * sinAngle;
    this.y = y * sinAngle;
    this.z = z * sinAngle;
    
    this.normalize();
}

Quaternion.prototype.loadXAxisRotation = function(degrees)
{
    var radians = toRadians(degrees) / 2;
    
    this.w = Math.cos(radians);
    this.x = Math.sin(radians);
    this.y = 0;
    this.z = 0;
}

Quaternion.prototype.loadYAxisRotation = function(degrees)
{
    var radians = toRadians(degrees) / 2;
    
    this.w = Math.cos(radians);
    this.x = 0
    this.y = Math.sin(radians);;
    this.z = 0;
}

Quaternion.prototype.loadZAxisRotation = function(degrees)
{
    var radians = toRadians(degrees) / 2;
    
    this.w = Math.cos(radians);
    this.x = 0;
    this.y = 0;
    this.z = Math.sin(radians);
}

Quaternion.prototype.loadXYZAxisRotation = function(degreesX, degreesY, degreesZ)
{
    var radiansX = toRadians(degreesX) / 2;
    var radiansY = toRadians(degreesY) / 2;
    var radiansZ = toRadians(degreesZ) / 2;
    
    var qX = new Quaternion();
    qX.load(Math.cos(radiansX), Math.sin(radiansX), 0, 0);
    
    var qY = new Quaternion();
    qY.load(Math.cos(radiansY), 0, Math.sin(radiansY), 0);
    
    var qZ = new Quaternion();
    qZ.load(Math.cos(radiansZ), 0, 0, Math.sin(radiansZ));
    
    // sum rotations
    var result = qY.multiply(qX.multiply(qZ));
    this.loadQuaternion(result);
}

Quaternion.prototype.multiply = function(rhs)
{
    var result = new Quaternion();
    
    result.load
    (
        this.w * rhs.w - this.x * rhs.x - this.y * rhs.y - this.z * rhs.z,
        this.w * rhs.x + this.x * rhs.w + this.y * rhs.z - this.z * rhs.y,
        this.w * rhs.y + this.y * rhs.w + this.z * rhs.x - this.x * rhs.z,
        this.w * rhs.z + this.z * rhs.w + this.x * rhs.y - this.y * rhs.x    
    );
    
    return result;
}

Quaternion.prototype.getMatrix = function()
{
    var matrix = new Matrix4x4();
    
    var x2 = this.x + this.x;
    var y2 = this.y + this.y;
    var z2 = this.z + this.z;
    var xx = this.x * x2;
    var xy = this.x * y2;
    var xz = this.x * z2;
    var yy = this.y * y2;
    var yz = this.y * z2;
    var zz = this.z * z2;
    var wx = this.w * x2;
    var wy = this.w * y2;
    var wz = this.w * z2;

    matrix._11 = 1 - (yy + zz);
    matrix._21 = xy - wz;
    matrix._31 = xz + wy;
    matrix._41 = 0;

    matrix._12 = xy + wz;
    matrix._22 = 1 - (xx + zz);
    matrix._32 = yz - wx;
    matrix._42 = 0;

    matrix._13 = xz - wy;
    matrix._23 = yz + wx;
    matrix._33 = 1 - (xx + yy);
    matrix._43 = 0;

    matrix._14 = 0;
    matrix._24 = 0;
    matrix._34 = 0;
    matrix._44 = 1;
    
    return matrix;
}

function Line(point, dir)
{
    this.point = new Vector3D(point.x, point.y, point.z);
    this.dir = new Vector3D(dir.x, dir.y, dir.z);
}
function Plane(point, normal)
{
    this.point = new Vector3D();
    this.normal = new Vector3D();
    this.dot = 0;
    
    if (point && normal)
    {
        this.point.copy(point);
        this.normal.copy(normal);
        this.dot = dotProduct(this.point, this.normal);
    }
}

Plane2.prototype = new Plane();
Plane2.prototype.constructor = Plane2;

function Plane2(v0, v1, v2)
{
    var normal;

    if (v0 && v1 && v2)
    {
        var leg1 = new Vector3D(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);
        var leg2 = new Vector3D(v0.x - v1.x, v0.y - v1.y, v0.z - v1.z);
        normal = crossProduct(leg1, leg2);
        normal.normalize();
    }
    
    Plane.call(this, v0, normal);
}

/**
 * Determine if a point lies on the plane.
 * @param point     - the point.
 * @param plane     - the plane.
 * @param tolerance - tolerance amount.
 * @return bool     - true if the point lies on the plane, false if it does not.
 */
function pointOnPlane(point, plane, tolerance)
{
    return (Math.abs(dotProduct(point, plane.normal) - plane.dot) < tolerance ? true : false);
}

/**
 * Determine if a point lies on the positive side of the plane; i.e., determine if the 
 * point lies in the half-space on the side of the plane in the direction of the normal.
 * @param point     - the point.
 * @param plane     - the plane.
 * @return bool     - true if the point lies on the positive side of the plane, false if 
 *                    it does not.
 */
function pointOnPositiveSideOfPlane(point, plane)
{
    return (dotProduct(point, plane.normal) - plane.dot > 0 ? true : false);
}

/**
 * Determine if a point lies on the negative side of the plane; i.e., determine if the 
 * point lies in the half-space on the side of the plane in the opposite direction of the 
 * normal.
 * @param point     - the point.
 * @param plane     - the plane.
 * @return bool     - true if the point lies on the negative side of the plane, false if 
 *                    it does not.
 */
function pointOnNegativeSideOfPlane(point, plane)
{
    return (dotProduct(point, plane.normal) - plane.dot < 0 ? true : false);
}

/**
 * Determine if a line intersects the plane.  If it does, find the point of intersection.
 * @param line  - the line.
 * @param plane - the plane.
 * @param point - the point of intersection (if line intersects plane).
 * @return int  - returns:
 *                  0 if line does not intersect plane
 *                  1 if line intersects plane at one point
 *                  2 if line intersects plane at infinite points (line lies on plane)
 */
function lineIntersectsPlane(line, plane)
{
    var point = new Vector3D();
    var result;
    
    // solve for t in terms of plane equation Ax + By + Cz = D
    var lhs = plane.normal.x * line.dir.x + plane.normal.y * line.dir.y + plane.normal.z * line.dir.z;
    if (lhs == 0)  // plane and line are parallel
    {
        // if line point lies on the plane, consider this an intersection
        if (pointOnPlane(line.point, plane, FLT_EPSILON))
        {
            point.copy(line.point);
            result = 2;
        }

        result = 0;
    }
    else
    {
        var rhs = plane.dot - (plane.normal.x * line.point.x + plane.normal.y * line.point.y + plane.normal.z * line.point.z);
        var t = rhs / lhs;

        // calculate point of intersection
        point.x = t * line.dir.x + line.point.x;
        point.y = t * line.dir.y + line.point.y;
        point.z = t * line.dir.z + line.point.z;

        result = 1;
    }

    return { result: result, point: point };
}

/**
 * Determine if a line segment intersects the plane.  If it does, find the point of intersection.
 * @param a      - one endpoint of the line segment.
 * @param b      - other endpoint of the line segment.
 * @param plane  - the plane.
 * @return point - the point of intersection (if line segment intersects plane).
 * @return count - returns:
 *                  0 if line segment does not intersect plane
 *                  1 if line segment intersects plane at one point
 *                  2 if line segment intersects plane at infinite points (line segment lies on plane)
 */
function lineSegmentPlaneIntersection(a, b, plane)
{
    // represent line segment in parametric line equation form;
    // line through P0(x0, y0, z0) parallel to v = Ai + Bj + Ck =>
    // x = x0 + tA, y = y0 + tB, z = z0 + tC
    var ab = new Vector3D(b.x - a.x, b.y - a.y, b.z - a.z);
    var x0 = a.x;
    var y0 = a.y;
    var z0 = a.z;
    var tA = ab.x;
    var tB = ab.y;
    var tC = ab.z;

    // solve for t in terms of plane equation Ax + By + Cz = D
    var lhs = plane.normal.x * tA + plane.normal.y * tB + plane.normal.z * tC;
    if (lhs == 0)  // plane and line segment are parallel
    {
        // if a lies on the plane, consider this an intersection
        if (pointOnPlane(a, plane, FLT_EPSILON))
        {
            var point = new Vector3D(a);
            return { count: 2, point: point };
        }

        return { count: 0 };
    }

    var rhs = plane.dot - (plane.normal.x * x0 + plane.normal.y * y0 + plane.normal.z * z0);
    var t = rhs / lhs;

    // if t is not in range [0, 1], then point of intersection is not
    // within line segment
    if (t < 0 || t > 1) 
    {
        return { count: 0 };
    }

    // point of intersection is within line segment; calculate point
    var point = new Vector3D();
    point.x = t * tA + x0;
    point.y = t * tB + y0;
    point.z = t * tC + z0;

    return { count: 1, point: point };
}

/**
 * Determine if planes are coplanar.
 * @param plane1 - the first plane.
 * @param plane2 - the second plane.
 * @return bool  - true if the planes are coplanar, false if they are not.
 */
function coplanar(plane1, plane2)
{
    return (((plane1.normal == plane2.normal || plane1.normal == -plane2.normal) &&
              pointOnPlane(plane1.point, plane2)) ? true: false);
}

/**
 * Determine if planes intersect.
 * @param plane1 - the first plane.
 * @param plane2 - the second plane.
 * @return bool  - true if the planes intersect, false if they do not.
 */
function planesIntersect(plane1, plane2)
{
    // if planes are parallel (normal cross product == 0),
    // planes don't intersect (or they are coplanar)
    var zero = new Vector3D(0, 0, 0);
    if (crossProduct(plane1.normal, plane2.normal).equals(zero))
    {
        return false;
    }
 
    return true;
}

/**
 * Determine the distance between 2 parallel planes.  If planes are not parallel, 0 is returned.
 * @param plane1 - the first plane.
 * @param plane2 - the second plane.
 * @return float - the distance between the planes.
 */
function distanceBetweenPlanes(plane1, plane2)
{
    if (coplanar(plane1, plane2))
    {
        return 0;
    }

    if (!planesIntersect(plane1, plane2))
    {
        var intersection = lineIntersectsPlane(new Line(plane1.point, plane1.normal), plane2);
        if (intersection.result)
        {
            return distanceBetween(plane1.point, plane2.point);
        }
        else
        {
            return 0;
        }
    }

    // planes intersect
    return 0;
}
function ViewVolume()
{
    this.left = null;
    this.right = null;
    this.top = null;
    this.bottom = null;
    this.near = null;
    this.far = null;
}

ViewVolume.prototype.setPerspective = function(fovyRadians, aspectRatio, near, far)
{
    // calculate the front and back frustum plane quadrilateral endpoints
    // for a symmetric frustum volume

    // front quad
   
    // derive 1/2 quad height from y-FOV and distance from origin
    var height = near * Math.tan(0.5 * fovyRadians);

    // derive 1/2 quad width from aspect ratio
    var width = height * aspectRatio;

    // set front quad endpoints
    var frontTopLeft  = new Vector3D(-width, height, near);
    var frontTopRight = new Vector3D( width, height, near);
    var frontBotLeft  = new Vector3D(-width,-height, near);
    var frontBotRight = new Vector3D( width,-height, near);

    // back quad
    height = far * Math.tan(0.5 * fovyRadians);
    width = height * aspectRatio;

    var backTopLeft  = new Vector3D(-width, height, far);
    var backTopRight = new Vector3D( width, height, far);
    var backBotLeft  = new Vector3D(-width,-height, far);
    var backBotRight = new Vector3D( width,-height, far);

    // derive planes from frustum endpoints (specify points in 
    // clockwise order so that plane normals point out of frustum)
    this.left   = new Plane2(frontTopLeft, frontBotLeft, backBotLeft);
    this.right  = new Plane2(frontBotRight, frontTopRight, backTopRight);
    this.top    = new Plane2(frontTopLeft,  backTopLeft,   backTopRight);
    this.bottom = new Plane2(frontBotLeft, frontBotRight, backBotRight);
    this.near   = new Plane2(frontBotLeft,  frontTopLeft,  frontTopRight);
    this.far    = new Plane2(backBotRight,  backTopRight,  backTopLeft);
}

ViewVolume.prototype.setOrthographic = function(left, right, top, bottom, near, far)
{
    // calculate the front and back frustum plane quadrilateral endpoints
    // for a symmetric frustum volume

    // set front quad endpoints
    var frontTopLeft  = new Vector3D(left,  top,    near);
    var frontTopRight = new Vector3D(right, top,    near);
    var frontBotLeft  = new Vector3D(left,  bottom, near);
    var frontBotRight = new Vector3D(right, bottom, near);

    // back quad
    var backTopLeft   = new Vector3D(left,  top,    far);
    var backTopRight  = new Vector3D(right, top,    far);
    var backBotLeft   = new Vector3D(left,  bottom, far);
    var backBotRight  = new Vector3D(right, bottom, far);

    // derive planes from frustum endpoints (specify points in 
    // clockwise order so that plane normals point out of frustum)
    this.left   = new Plane2(backBotLeft,   backTopLeft,   frontTopLeft);
    this.right  = new Plane2(frontBotRight, frontTopRight, backTopRight);
    this.top    = new Plane2(frontTopLeft,  backTopLeft,   backTopRight);
    this.bottom = new Plane2(backBotRight,  backBotLeft,   frontBotLeft);
    this.near   = new Plane2(frontBotLeft,  frontTopLeft,  frontTopRight);
    this.far    = new Plane2(backBotRight,  backTopRight,  backTopLeft);
}
var EPSILON = 0.00000001;

function SIGN3(v) 
{
    (((v).x < 0 ) ? 4 : 0 | ((v).y < 0) ? 2 : 0 | ((v).z < 0) ? 1 : 0);
}

/**
 * Solve quadratic equation with term coefficients a (2nd degree term), 
 * b (1st degree term), and c (constant term); return number of real roots; 
 * if 1 root exists, it is set to root1, if 2 roots exist, they are set to 
 * root1 and root2.
 * @param a      - 2nd degree term coefficient.
 * @param b      - 1st degree term coefficient.
 * @param c      - constant term.
 * @return root1 - first real root.
 * @return root2 - second real root.
 * @return count - 0: no real roots exist
 *                 1: 1 real root exists
 *                 2: 2 real roots exist
 */
function solveQuadraticEquation(a, b, c)
{
   if (a == 0) 
   {
       return { count: 0 };
   }

   var sqrt_term = b * b - 4 * a * c;
   if (sqrt_term < 0) 
   {
       return { count: 0 };
   }

   if (sqrt_term == 0)
   {
      var root1 = -b / (2 * a);
      return { count: 1, root1: root1 };
   }

   sqrt_term = Math.sqrt(sqrt_term);

   var root1 = (-b + sqrt_term) / (2 * a);
   var root2 = (-b - sqrt_term) / (2 * a);

   return { count: 2, root1: root1, root2: root2 };
}

/** 
 * Determine if a ray intersects a triangle. 
 *
 * Given a ray defined by an origin and a direction, and a triangle,
 * determine if the ray intersects the triangle; if an intersection exists, 
 * determine the distance t from the ray origin to the point of intersection, and the 
 * barycentric coordinates (u, v) inside the triangle;
 *
 * Algorithm adapted from:
 *    Tomas Moller and Ben Trumbore, "Fast, Minimum Storage Ray/Triangle 
 *    Intersection", journal of graphics tool, vol. 2, no. 1, pp. 21-28, 1997.
 *    http://www.ce.chalmers.se/staff/tomasm
 *
 * @param rayOrig    - ray origination point.
 * @param rayDir     - ray direction.
 * @param v0         - first triangle vertex.
 * @param v1         - second triangle vertex.
 * @param v2         - third triangle vertex.
 * @param skipPosDet - if true, skip intersection test (return false) if the triangle's determinate 
 *                     is positive.
 * @param skipNegDet - if true, skip intersection test (return false) if the triangle's determinate 
 *                     is negative.
 * @return t         - distance from ray origin to intersection point (if ray intersects triangle).
 * @return u         - barycentric coordinate u of intersection point (if ray intersects triangle).
 * @return v         - barycentric coordinate v of intersection point (if ray intersects triangle).
 * @return result    - true if the ray intersects the triangle, false if not.
 */
function rayTriangleIntersection(rayOrig, rayDir, v0, v1, v2, skipPosDet, skipNegDet)
{
    // normalize ray direction vector
    var dir = new Vector3D(rayDir.x, rayDir.y, rayDir.z);
    dir.normalize();

    // find vectors for two edges sharing v0
    var edge1 = new Vector3D(v1.x - v0.x, v1.y - v0.y, v1.z - v0.z);
    var edge2 = new Vector3D(v2.x - v0.x, v2.y - v0.y, v2.z - v0.z);
   
    // calculate determinant
    var pvec = crossProduct(dir, edge2);
    var det = dotProduct(edge1, pvec);

    // if determinant is near zero, ray lies in plane of triangle
    if (-EPSILON < det && det < EPSILON) 
    {
        return { result: false };
    }

    // if requested, skip triangles with negative/positive determinates
    if (skipPosDet && det > 0) 
    {
        return { result: false };
    }
    if (skipNegDet && det < 0) 
    {
        return { result: false };
    }

    var inv_det = 1 / det;

    // calculate distance from v0 to ray origin
    var tvec = new Vector3D(rayOrig.x - v0.x, rayOrig.y - v0.y, rayOrig.z - v0.z);

    // calculate u parameter and test bounds
    var u = dotProduct(tvec, pvec) * inv_det;
    if (u < 0 || u > 1)
    {
        return { result: false };
    }

    var qvec = crossProduct(tvec, edge1);

    // calculate v parameter and test bounds
    var v = dotProduct(dir, qvec) * inv_det;
    if (v < 0 || u + v > 1) 
    {
        return { result: false };
    }

    // ray intersects triangle, calculate t
    var t = dotProduct(edge2, qvec) * inv_det;

    return { result: true, t: t, u: u, v: v };
}

/**
 * Determine if a ray intersects a sphere.
 *
 * Given a ray defined by an origination point (x0, y0, z0), and
 * destination point (x1, y1, z1), and represented by the parametric equations: 
 * x = x0 + t(x1 - x0), y = y0 + t(y1 - y0), z = z0 + t(z1 - z0),
 * determine if the ray intersects the sphere defined by center (a, b, c) and
 * radius r, and represented by the equation (x - a)² + (y - b)² + (z - c)² = r²;
 *
 * For convenience, define dx = x1 - x0, dy = y1 - y0, dz = z1 - z0;
 *
 * The intersection is found by substituting x, y, and z from the ray equations
 * into the sphere equation, and solving for t (after term collection):
 * 
 * (dx² + dy² + dz²)t² + 2[dx(x0 - a) + dy(y0 - b) + dz(z0 - c)]t
 *    + (x0 - a)² + (y0 - b)² + (z0 - c)² - r² = 0
 *
 * Algorithm adapted from:
 *    Computer Graphics: Principles and Practice, 2nd Edition, Foley, et al., pp. 702-703
 *
 * @param rayOrig - ray origination point.
 * @param rayDir  - ray direction.
 * @param center  - sphere center point.
 * @param radius  - sphere radius.
 * @return root1  - root 1 from solving quadratic equation (if ray intersects sphere).
 * @return root2  - root 2 from solving quadratic equation (if ray intersects sphere).
 * @return count  - 0: ray does not intersect sphere
 *                  1: ray grazes sphere - root1 will contain the one real root
 *                  2: ray intersects sphere - root1 and root2 will contain both real roots
 */
function raySphereIntersection(rayOrig, rayDir, center, radius)
{
    // normalize ray direction vector
    var dir = new Vector3D(rayDir.x, rayDir.y, rayDir.z);
    dir.normalize();
    
    var rayDest = new Vector3D(rayOrig.x + dir.x, rayOrig.y + dir.y, rayOrig.z + dir.z);

    var dx = rayDest.x - rayOrig.x;
    var dy = rayDest.y - rayOrig.y;
    var dz = rayDest.z - rayOrig.z;

    // a = dx * dx + dy * dy + dz * dz == 1
    // because distance from rayOrig to rayDest is 1

    var b = 2 * (dx * (rayOrig.x - center.x) + 
                 dy * (rayOrig.y - center.y) + 
                 dz * (rayOrig.z - center.z));

    var c = (rayOrig.x - center.x) * (rayOrig.x - center.x) +
            (rayOrig.y - center.y) * (rayOrig.x - center.y) +
            (rayOrig.z - center.z) * (rayOrig.z - center.z) -
            radius * radius;

    return solveQuadraticEquation(1, b, c);
}

/**
 * Determine if the triangle contains a point which is known to lie in the plane of the triangle.  
 * Adapted from "Triangle-Cube Intersection", Graphics Gems III, pp.236-239.
 * @param v0      - first triangle vertex.
 * @param v1      - second triangle vertex.
 * @param v2      - third triangle vertex.
 * @param point   - the point.
 * @return result - true if the triangle contains the point, false if not. 
 */
function triangleContainsPoint(v0, v1, v2, point)
{
    // for each triangle side, make a vector out of it by subtracting vertices; 
    // make another vector from one vertex to the point; the cross-product of these 
    // two vectors is orthogonal to both and the signs of its components indicate 
    // whether the point was on the inside or on the outside of this triangle side
    var sign12 = SIGN3(crossProduct(subtract3D(v0, v1), subtract3D(v0, point))); 
    var sign23 = SIGN3(crossProduct(subtract3D(v1, v2), subtract3D(v1, point))); 
    var sign31 = SIGN3(crossProduct(subtract3D(v2, v0), subtract3D(v2, point))); 

    // if all three cross-product vectors agree in their component signs,
    // then the point must be inside all three; the point cannot be outside all 
    // three sides simultaneously.
    if ((sign12 == sign23) && (sign23 == sign31))
    {
        return true;
    }

    return false;
}

/**
 * Determine if a triangle lies on the positive side of the plane (the side in the direction of
 * the plane normal).
 * @param v0    - first vertex of triangle.
 * @param v1    - second vertex of triangle.
 * @param v2    - third vertex of triangle.
 * @return bool - true if the triangle lies on the positive side of the plane, false if not.
 */
function triangleOnPositiveSideOfPlane(v0, v1, v2, plane)
{
    return pointOnPositiveSideOfPlane(v0, plane) &&
           pointOnPositiveSideOfPlane(v1, plane) &&
           pointOnPositiveSideOfPlane(v2, plane);
}

/**
 * Determine if the line segment intersects the triangle.  If so, find the point
 * of intersection.
 * @param a       - one endpoint of the line segment.
 * @param b       - other endpoint of the line segment.
 * @param v0      - first triangle vertex. 
 * @param v1      - second triangle vertex.
 * @param v2      - third triangle vertex.
 * @return point  - the point of intersection (if line segment intersects triangle). 
 * @return result - true if the line segment intersects the triangle, false if not.
 */
function lineSegmentTriangleIntersection(a, b, v0, v1, v2)
{
    // first check that line segment intersects plane of triangle
    var result = lineSegmentPlaneIntersection(a, b, new Plane2(v0, v1, v2));
    if (result.count == 0)
    {
        return { result: false };
    }

    // check that point is within triangle bounding box
    if (result.point.x < min3(v0.x, v1.x, v2.x) ||
        result.point.y < min3(v0.y, v1.y, v2.y) ||
        result.point.z < min3(v0.z, v1.z, v2.z) ||
        result.point.x > max3(v0.x, v1.x, v2.x) ||
        result.point.y > max3(v0.y, v1.y, v2.y) ||
        result.point.z > max3(v0.z, v1.z, v2.z))
    {
        return { result: false };
    }

    // check that point is within triangle
    if (triangleContainsPoint(v0, v1, v2, result.point))
    {
        return { result: true, point: result.point };
    }
    
    return { result: false };
}
var eAttrType = {
    Unknown                     :-1,
    
    Attribute                   :0,
    
    AttributeContainer          :1,
    
    AttributeVector             :2,
    
    AttributeFactory            :3,
    
    AttributeRegistry           :4,
    
    BalloonTipLabelStyleAttr    :5,
    BBoxAttr                    :6,
    BooleanAttr                 :7,
    ColorAttr                   :8,
    FontStyleAttr               :9,
    IconStyleAttr               :10,
    ImageAttr                   :11,
    KeyframeAttr                :12,
    KeyframesAttr               :13,
    LabelStyleAttr              :14,
    HTMLLabelStyleAttr          :15,
    NumberArrayAttr             :16,
    NumberAttr                  :17,
    Matrix4x4Attr               :18,
    PlaneAttr                   :19,
    PulseAttr                   :20,
    RectAttr                    :21,
    ReferenceAttr               :22,
    StringAttr                  :23,
    StyleAttr                   :24,
    StylesAttr                  :25,
    StyleMapAttr                :26,
    StylesMapAttr               :27,
    Vector2DAttr                :28,
    Vector3DAttr                :29,
    ViewportAttr                :30,
    ViewVolumeAttr              :31,
    RenderableElementStyleAttr  :32,
    
    Node                        :1000,
       
    ParentableMotionElement     :1001,
    Camera                      :1002,
    PerspectiveCamera           :1003,
    OrthographicCamera          :1004,
    Light                       :1005,
    DirectionalLight            :1006,
    PointLight                  :1007,
    SpotLight                   :1008, 
    GlobalIllumination          :1009,           
    Material                    :1010,
    Texture                     :1011, 
    RenderableElement           :1012,
    Geometry                    :1013,
    VertexGeoemtry              :1014,
    TriList                     :1015, 
    Group                       :1016,
    Isolator                    :1017,
    Dissolve                    :1018,  
    Transform                   :1019,   
    QuaternionRotate            :1020,
    Scale                       :1021,
    Rotate                      :1022,
    Translate                   :1023,   
    Model                       :1024,
    Surface                     :1025,
    MediaTexture                :1026,
    NullObject                  :1027,   
    Label                       :1028,
    HTMLLabel                   :1029,
    BalloonTipLabel             :1030, 
    PathTrace                   :1031,
    Cube                        :1032,
    
    Evaluator                   :1100,
    SceneInspector              :1101,
    KeyframeInterpolator        :1102,
    BBoxLocator                 :1103,
    ArcballInspector            :1104,
    MapProjectionCalculator     :1105,
    ObjectInspector             :1106,
    MultiTargetObserver			:1107,
    ObjectMover	 				:1108,
    AnimalMover					:1109,   
    Evaluator_End               :1199, // all evaluator types must be given a type between Evaluator and Evaluator_End

    Node_End                    :1999,

	Directive                   :2000,
    UpdateDirective             :2001,
    RenderDirective             :2002,
    RayPickDirective            :2003,
    BBoxDirective               :2004,
    SerializeDirective          :2005,
    CollideDirective            :2006,
    HighlightDirective          :2007,
    Directive_End               :2999,
    
    Command                     :3000,
    CommandSequence             :3001,
    AppendNode                  :3002,
    AttributeTrigger            :3003,
    AutoInterpolate             :3004,
    Locate                      :3005,
    Play                        :3006,
    Pause                       :3007,
    Remove                      :3008,
    ScreenCapture               :3009,
    Serialize                   :3010,
    Set                         :3011,
    Stop                        :3012,
    ConnectAttributes           :3013,
    DisconnectAttributes        :3014,
    Command_End                 :3999,

    DeviceHandler               :4000,
    MouseHandler                :4001,
    DeviceHandler_End           :4999,
    
    UserDefined                 :5000
};

var eAttrElemType = {
    // unknown
    Unknown                     :-1,

    // attribute
    Attribute                   :0,
    
    // standard C-types
    Int                         :1,
    UnsignedInt                 :2,
    Char                        :3,
    UnsignedChar                :4,
    Float                       :5,
    Double                      :6,

    // user-defined
    UserDefined                 :100
};

function enumerateAttributeTypes()
{
    var count = 0; 
    for (var i in eAttrType)
    {
        if (eAttrType[i] == 0)
            eAttrType[i] = count++;
    }
}

function enumerateAttributeElementTypes()
{
    var count = 0;
    for (var i in eAttrElemType)
    {
        if (eAttrElemType[i] == 0)
            eAttrElemType[i] = count++;
    }
}
var eAttrSetOp = {
    Replace         :0,  
    Add				:1,
    Subtract		:2,
    Multiply		:3,
    Divide			:4,
	Append			:5,
    AND				:6,
    OR				:7,
    XOR             :8,
    NAND			:9,
    NOR				:10
};

function AttributeTargetDesc(target, 
                             sourceElementIndex, 
                             targetElementIndex,
                             op,
                             converter)
{
    this.target = target || null;
    this.sourceElementIndex = sourceElementIndex || -1;
    this.targetElementIndex = targetElementIndex || -1;
    this.op = op || eAttrSetOp.Replace;
    this.converter = converter || null;
}

function AttributeSourceDesc(source,
                             sourceElementIndex,
                             targetElementIndex,
                             op,
                             converter)
{
    this.source = source || null;
    this.sourceElementIndex = sourceElementIndex || -1;
    this.targetElementIndex = targetElementIndex || -1;
    this.op = op || eAttrSetOp.Replace;
    this.converter = converter || null;
}

function AttributeGetParams(elementIndex,
                            valueElementIndex)
{
    this.elementIndex = elementIndex;
    this.valueElementIndex = valueElementIndex;
}

function AttributeSetParams(elementIndex,
                            valueElementIndex,
                            op,
                            updateTargets,
                            alertModifiedCBs,
                            caller)
{
    this.elementIndex = elementIndex || -1;
    this.valueElementIndex = valueElementIndex || -1;
    this.op = op || eAttrSetOp.Replace;
    this.updateTargets = updateTargets != undefined ? updateTargets : true;
    this.alertModifiedCBs = alertModifiedCBs != undefined ? alertModifiedCBs : true;
    this.caller = caller != undefined ? caller : null;
}
                            
Attribute.prototype = new Base();
Attribute.prototype.constructor = Attribute;

function Attribute() 
{
    Base.call(this);
    this.className = "Attribute";
    this.attrType = eAttrType.Attribute;
    this.attrElemType = eAttrElemType.Attribute;
    
    this.native = true;
    this.transient = false;
    this.persistent = false;
    this.deserialized = false;
    
    this.values = [];
    this.lastValues = [];
    this.modifiedCBs = [];
    this.modifiedCBsData = [];
    this.targets = [];
    this.sources = [];
    this.container = null;
    this.registry = null;
}

Attribute.prototype.destroy = function()
{
    // remove all targeting associated with this
    this.removeAllSources();
    this.removeAllTargets();
    
    // call base-class implementation
    Base.prototype.destroy.call(this);
}

Attribute.prototype.clone = function()
{
    return null;
}

Attribute.prototype.getValue = function(values, params)
{
    var elementIndex = (params ? params.elementIndex : -1);
    
    if (elementIndex < 0)
    {
        if (this.values == null)
        {
            values[0] = null;
        }
        else if (this.values.length == undefined)
        {
            values[0] = this.values;
        }
        else // this.values.length > 0
        {
            for (var i=0; i < this.values.length; i++)
            {
                values[i] = this.values[i];
            }
        }
    }
    else // elementIndex >= 0
    {
        var valueElementIndex = Math.max(0, params ? params.valueElementIndex : 0);
            
        values[valueElementIndex] = this.values[elementIndex];
    }
}

Attribute.prototype.setValue = function(values, params)
{
    this.lastValues = this.values.slice();
    
    var elementIndex = (params ? params.elementIndex : -1);
    var op = (params ? params.op : eAttrSetOp.Replace);

    if (elementIndex < 0)
    {
        if (values == null)
        {
            this.values[0] = null;
        }
        else if (values.length == undefined)
        {
            switch (op)
            {
                case eAttrSetOp.Add: this.values[0] += values; break;
                case eAttrSetOp.Replace: this.values[0] = values; break;
                case eAttrSetOp.AND: this.values[0] &= values; break;
                default: alert("unsupported operation passed to Attribute::setValue"); break; // TODO: add support
            }
        }
        else // values.length > 0
        {
            for (var i = 0; i < values.length; i++)
            {
                switch (op)
                {
                    case eAttrSetOp.Add: this.values[i] += values[i]; break;
                    case eAttrSetOp.Replace: this.values[i] = values[i]; break;
                    case eAttrSetOp.AND: this.values[i] &= values[i]; break;
                    default: alert("unsupported operation passed to Attribute::setValue"); break; // TODO: add support
                }
            }
        }
    }
    else // elementIndex >= 0
    {
        if (values == null)
        {
            this.values[elementIndex] = null;
        }
        else if (values.length == undefined)
        {
            this.values[elementIndex] = values;
        }
        else // values.length > 0
        {
            var valueElementIndex = Math.max(0, params ? params.valueElementIndex : 0);
            this.values[elementIndex] = values[valueElementIndex];
        }
    }

    // alert modified CBs
    var alertModifiedCBs = (params ? params.alertModifiedCBs : true);
    if (alertModifiedCBs)
    {
        for (var i = 0; i < this.modifiedCBs.length; i++)
        {
            this.modifiedCBs[i](this, this.modifiedCBsData[i]);
        }
    }

    // update targets
    var updateTargets = (params ? params.updateTargets : true);
    if (updateTargets)
    {
        var caller = (params ? params.caller : null);
        for (var i = 0; i < this.targets.length; i++)
        {
            var targetDesc = this.targets[i];
            if (caller == targetDesc.target) continue;
            var params = new AttributeSetParams(targetDesc.targetElementIndex, targetDesc.sourceElementIndex,
                                                targetDesc.op, true, true, this);
            targetDesc.target.setValue(this.values, params);
        }
    }
}

Attribute.prototype.revertValues = function()
{
    this.setValue(this.lastValues, null);
}

Attribute.prototype.getElement = function(index)
{
    if (this.values.length > index)
    {
        return this.values[index];
    }

    return undefined;
}

Attribute.prototype.setElement = function(index, value, op, updateTargets)
{
    console.debug("TODO: " + arguments.callee.name);
}

Attribute.prototype.getLength = function()
{
    if (this.values.length == undefined)
    {
        return (this.values == undefined ? 0 : 1);
    }   
    
    return this.values.length; 
}

Attribute.prototype.setLength = function(length)
{
    this.values.length = length;
}

Attribute.prototype.addModifiedCB = function(callback, data)
{
    this.modifiedCBs.push(callback);
    this.modifiedCBsData.push(data);
}

Attribute.prototype.removeModifiedCB = function(callback, data)
{   
    this.modifiedCBs.splice(this.modifiedCBs.indexOf(callback), 1);
    this.modifiedCBsData.splice(this.modifiedCBsData.indexOf(data), 1);
}

Attribute.prototype.addTarget = function(target, op, converter, setValueOnTargeting)
{
    if (op == undefined) op = eAttrSetOp.Replace;
    if (converter == undefined) converter = null;
    if (setValueOnTargeting == undefined) setValueOnTargeting = true;
    
    this.addElementTarget(target, -1, -1, op, converter, setValueOnTargeting);
}

Attribute.prototype.addSource = function(source, op, converter, setValueOnTargeting)
{
    source.addTarget(this, op, converter, setValueOnTargeting);
}

Attribute.prototype.removeTarget = function(target)
{
    this.removeElementTarget(target, -1, -1);
}

Attribute.prototype.removeSource = function(source)
{
    source.removeTarget(this);
}

Attribute.prototype.removeAllTargets = function()
{
    while (this.targets.length > 0)
    {
        this.removeElementTarget(this.targets[0].target,
                                 this.targets[0].sourceElementIndex,
                                 this.targets[0].targetElementIndex);
    }
}

Attribute.prototype.removeAllSources = function()
{
    while (this.sources.length > 0)
    {
        this.sources[0].source.removeElementTarget(this,
                                                   this.sources[0].sourceElementIndex,
                                                   this.sources[0].targetElementIndex);
    }
}

Attribute.prototype.addElementTarget = function(target, sourceElementIndex, targetElementIndex, op, converter, setValueOnTargeting)
{
    if (target)
    {
        if (sourceElementIndex == undefined) sourceElementIndex = -1;
        if (targetElementIndex == undefined) targetElementIndex = -1;
        if (op == undefined) op = eAttrSetOp.Replace;
        if (converter == undefined) converter = null;
        if (setValueOnTargeting == undefined) setValueOnTargeting = true;

        this.createTarget(new AttributeTargetDesc(target, sourceElementIndex, targetElementIndex, op, converter));

        // set this as a source of target
        target.createSource(new AttributeSourceDesc(this, sourceElementIndex, targetElementIndex, op, converter));

        if (setValueOnTargeting)
        {
            var params = new AttributeSetParams(targetElementIndex, sourceElementIndex, op, true, true);
            target.setValue(this.values, params);
        }
    }
}

Attribute.prototype.addElementSource = function(source, sourceElementIndex, targetElementIndex, op, converter, setValueOnTargeting)
{
    source.addElementTarget(this, sourceElementIndex, targetElementIndex, op, converter, setValueOnTargeting);
}

Attribute.prototype.removeElementTarget = function(target, sourceElementIndex, targetElementIndex)
{
    if (target)
    {
        this.deleteTarget(new AttributeTargetDesc(target, sourceElementIndex, targetElementIndex));

        // remove this as a source of target 
        target.deleteSource(new AttributeSourceDesc(this, sourceElementIndex, targetElementIndex));
    }
}

Attribute.prototype.removeElementSource = function(source, sourceElementIndex, targetElementIndex)
{
    source.removeElementTarget(this, sourceElementIndex, targetElementIndex);
}

Attribute.prototype.createTarget = function(targetDesc)
{
    this.targets.push(targetDesc);
}

Attribute.prototype.createSource = function(sourceDesc)
{
    this.sources.push(sourceDesc);
}

Attribute.prototype.deleteTarget = function(targetDesc)
{
    for (var i = 0; i < this.targets.length; i++)
    {
        var desc = this.targets[i];
        if (desc.target == targetDesc.target &&
            desc.sourceElementIndex == targetDesc.sourceElementIndex &&
            desc.targetElementIndex == targetDesc.targetElementIndex)
        {
            this.targets.splice(i, 1);
            break;
        }
    }
}

Attribute.prototype.deleteSource = function(sourceDesc)
{
    for (var i = 0; i < this.sources.length; i++)
    {
        var desc = this.sources[i];
        if (desc.source == sourceDesc.source &&
            desc.sourceElementIndex == sourceDesc.sourceElementIndex &&
            desc.targetElementIndex == sourceDesc.targetElementIndex)
        {
            this.sources.splice(i, 1);
            break;
        }
    }
}

Attribute.prototype.copyValue = function(source, op)
{
    source.addTarget(this, op);
    source.removeTarget(this);
}

Attribute.prototype.isContainer = function()
{
    return false;
}

Attribute.prototype.isCollection = function()
{
    return false;
}

Attribute.prototype.isNode = function()
{
    return false;
}

Attribute.prototype.getContainer = function()
{
    return this.container;
}

Attribute.prototype.setContainer = function(container)
{
    this.container = container;
}

Attribute.prototype.setNative = function(native)
{
    this.native = native;
}

Attribute.prototype.isNative = function()
{
    return this.native;    
}

Attribute.prototype.setTransient = function(transient)
{
    this.transient = transient;
}

Attribute.prototype.isTransient = function()
{
    return this.transient;    
}

Attribute.prototype.setPersistent = function(persistent)
{
    this.persistent = persistent;
}

Attribute.prototype.isPersistent = function()
{
    return this.persistent;    
}

Attribute.prototype.getRegistry = function()
{
    return this.registry;
}

Attribute.prototype.setRegistry = function(registry)
{
    this.registry = registry;
}

Attribute.prototype.onRegister = function(registry)
{
    
}

Attribute.prototype.onUnregister = function(registry)
{
    
}

Attribute.prototype.flagDeserializedFromXML = function()
{
    this.deserialized = true;

    if (this.attrContainer) // also flag container if present, otherwise serialization won't occur
    {
        this.attrContainer.flagDeserializedFromXML();
    }
}
Attribute.prototype.isDeserializedFromXML = function()
{
    return this.deserialized;
}
AttributeContainer.prototype = new Attribute();
AttributeContainer.prototype.constructor = AttributeContainer;

function AttributeContainer()
{
    Attribute.call(this);
    this.className = "AttributeContainer";
    this.attrType = eAttrType.AttributeContainer;

    this.attrNameMap = [];
    this.attrModifiedCountMap = [];
}

AttributeContainer.prototype.destroy = function()
{
    // destroy all registered attributes with this as the container
    for (var i in this.attrNameMap)
    {
        for (var j=0; j < this.attrNameMap[i].length; j++)
        {
            var attr = this.attrNameMap[i][j];
            if (attr.getContainer() == this)
            {
                attr.destroy();
            }
        }
    }

    // call base-class implementation
    Attribute.prototype.destroy.call(this);
}

AttributeContainer.prototype.isContainer = function()
{
    return true;
}

AttributeContainer.prototype.registerAttribute = function(attribute, name)
{
	if (!attribute) return;
	
    if (this.attrNameMap[name] == undefined)
    {
        this.attrNameMap[name] = new Array();
    }
    this.attrNameMap[name].push(attribute);
    //this.attrModifiedCountMap[attribute] = 0; // doesn't work
    this.attrModifiedCountMap.push(new Pair(attribute, 0));

    // set the container if null
    if (!attribute.getContainer())
    {
        attribute.setContainer(this);
    }

    attribute.addModifiedCB(AttributeContainer_AttributeModifiedCB, this);
    attribute.addModifiedCB(AttributeContainer_AttributeModifiedCounterCB, this);
}

AttributeContainer.prototype.unregisterAttribute = function(attribute)
{
	if (!attribute) return;
	
    for (var i in this.attrNameMap)
    {
        for (var j=0; j < this.attrNameMap[i].length; j++)
        {
            if (this.attrNameMap[i][j] == attribute)
            {
                attribute.removeModifiedCB(AttributeContainer_AttributeModifiedCB, this);
                attribute.removeModifiedCB(AttributeContainer_AttributeModifiedCounterCB, this);
                delete this.attrNameMap[i][j];
                this.attrNameMap[i].splice(j,1);
                break;
            }
        }
    }
}

AttributeContainer.prototype.getAttribute = function(name)
{
    if (this.attrNameMap[name] == undefined)
    {
        return null;
    }
    
    return this.attrNameMap[name][0];
}

AttributeContainer.prototype.getAttributeAt = function(index)
{
    var count = 0;
    for (var i in this.attrNameMap)
    {
        for (var j=0; j < this.attrNameMap[i].length; j++)
        {
            if (count == index)
            {
                return this.attrNameMap[i][j];
            }
            count++;
        }
    }
    
    return null;
}

AttributeContainer.prototype.getAttributeName = function(attribute)
{
    var count = 0;
    for (var i in this.attrNameMap)
    {
        for (var j=0; j < this.attrNameMap[i].length; j++)
        {
            if (this.attrNameMap[i][j] == attribute)
            {
                return i;
            }
            count++;
        }
    }

    return null;
}

AttributeContainer.prototype.getAttributeNameAt = function(index)
{
    var count = 0;
    for (var i in this.attrNameMap)
    {
        for (var j=0; j < this.attrNameMap[i].length; j++)
        {
            if (count == index)
            {
                return i;
            }
            count++;
        }
    }
    
    return null;
}

AttributeContainer.prototype.getAttributeCount = function()
{
    var count = 0;
    for (var i in this.attrNameMap) count += this.attrNameMap[i].length;
    return count;
}

AttributeContainer.prototype.getAttributeModificationCount = function(attribute)
{
    //return this.attrModifiedCountMap[attribute];
    for (var i in this.attrModifiedCountMap)
    {
        if (this.attrModifiedCountMap[i].first == attribute)
        {
            return this.attrModifiedCountMap[i].second;
        }
    }

    return undefined;
}

AttributeContainer.prototype.incrementAttributeModificationCount = function(attribute)
{
    //this.attrModifiedCountMap[attribute]++;
    for (var i in this.attrModifiedCountMap)
    {
        if (this.attrModifiedCountMap[i].first == attribute)
        {
            this.attrModifiedCountMap[i].second++;
            break;
        }
    }
}

AttributeContainer.prototype.addTarget = function(target, op, converter, setValueOnTargeting)
{
    if (target)
    {
        if (op == undefined) op = null;
        if (converter == undefined) converter = null;
        if (setValueOnTargeting == undefined) setValueOnTargeting = true;
        
        var numAttributesToConnect = Math.max(this.getAttributeCount(), target.getAttributeCount());
        if (numAttributesToConnect == 0)
        {
            return;
        }

        var sourceAttr = null;
        var targetAttr = null;
        for (var i = 0; i < numAttributesToConnect; i++)
        {
            sourceAttr = this.getAttributeAt(i);
            targetAttr = target.getAttribute(this.getAttributeNameAt(i));
            if (!sourceAttr || !targetAttr)
            {
                continue;
            }

            sourceAttr.addTarget(targetAttr, op, converter, setValueOnTargeting);
        }
    }
}

AttributeContainer.prototype.removeTarget = function(target)
{
    if (target)
    {
        var numAttributesToConnect = Math.max(this.getAttributeCount(), target.getAttributeCount());
        if (numAttributesToConnect == 0)
        {
            return;
        }

        var sourceAttr = null;
        var targetAttr = null;
        for (var i = 0; i < numAttributesToConnect; i++)
        {
            sourceAttr = this.getAttributeAt(i);
            targetAttr = target.getAttribute(this.getAttributeNameAt(i));
            if (!sourceAttr || !targetAttr)
            {
                continue;
            }

            sourceAttr.removeTarget(targetAttr);
        }
    }
}

AttributeContainer.prototype.synchronize = function(src, syncValues)
{
    if (syncValues == undefined) syncValues = true;

    for (var i in src.attrNameMap)
    {
        for (var j=0; j < src.attrNameMap.length; j++)
        {
            var attr = this.attrNameMap[i][j];
            if (!attr)
            {
                attr = src.attrNameMap[i].clone();
                if (!attr) continue;
                attr.setContainer(this);
                this.registerAttribute(attr, i);
            }
    
            if (attr && syncValues)
            {
                attr.copyValue(src.attrNameMap[i]);
            }
        }
    }
}

function AttributeContainer_AttributeModifiedCB(attribute, container)
{
    for (var i=0; i < container.modifiedCBs.length; i++)
    {
        container.modifiedCBs[i](container, container.modifiedCBsData[i]);
    }
}

function AttributeContainer_AttributeModifiedCounterCB(attribute, container)
{
    container.incrementAttributeModificationCount(attribute);  
}
AttributeRegistry.prototype = new AttributeContainer();
AttributeRegistry.prototype.constructor = AttributeRegistry;

function AttributeRegistry()
{
    AttributeContainer.call(this);
    this.className = "AttributeRegistry";
    this.attrType = eAttrType.AttributeRegistry;

    this.objectCount = 0;
    
    this.typeRegistry = [];
    this.nameRegistry = [];
    
    this.uniqueAttributes = [];
}

AttributeRegistry.prototype.addUnique = function(attribute)
{
	for (var i=0; i < this.uniqueAttributes.length; i++)
	{
		if (this.uniqueAttributes[i] == attribute) return;
	}
	
	this.uniqueAttributes.push(attribute);
}
    
AttributeRegistry.prototype.removeUnique = function(attribute)
{
	for (var i=0; i < this.uniqueAttributes.length; i++)
	{
		if (this.uniqueAttributes[i] == attribute)
		{
			this.uniqueAttributes.splice(i, 1);
			return;
		}
	}
}
    
AttributeRegistry.prototype.registerByType = function(attribute, type)
{
    if (this.typeRegistry[type] == undefined)
    {
        this.typeRegistry[type] = new Array();
    }
    
    this.typeRegistry[type].push(attribute);
}

AttributeRegistry.prototype.registerByName = function(attribute, name)
{
    if (name.length == 0)
    {
        name = "unnamed";
    }
    
    if (this.nameRegistry[name] == undefined)
    {
        this.nameRegistry[name] = new Array();
    }

    this.nameRegistry[name].push(attribute);
}

AttributeRegistry.prototype.register = function(attribute)
{
    // register using type
    this.registerByType(attribute, attribute.attrType);

    // register using name attribute if container
    if (attribute.isContainer())
    {
        var name = attribute.getAttribute("name") ||
                   attribute.getAttribute("id");
        if (name)
        {
            this.registerByName(attribute, name.getValueDirect().join(""));
            name.addModifiedCB(AttributeRegistry_AttributeContainerNameModifiedCB, this); 
        }
    }
    
    this.addUnique(attribute);
    this.objectCount++;
    
    attribute.onRegister(this);
}

AttributeRegistry.prototype.unregisterByType = function(attribute, type)
{
    if (this.typeRegistry[type])
    {
        this.typeRegistry[type].splice(this.typeRegistry[type].indexOf(attribute), 1);
    }
}

AttributeRegistry.prototype.unregisterByName = function(attribute, name)
{
    if (name.length == 0)
    {
        name = "unnamed";
    }
    
    if (this.nameRegistry[name])
    {
        this.nameRegistry[name].splice(this.nameRegistry[name].indexOf(attribute), 1);
    }
}

AttributeRegistry.prototype.unregister = function(attribute)
{
    // register using type
    this.unregisterByType(attribute, attribute.attrType);
    
    // register using name attribute if container
    if (attribute.isContainer())
    {
        var name = attribute.getAttribute("name") ||
                   attribute.getAttribute("id");
        if (name)
        {
            this.unregisterByName(attribute, name.getValueDirect().join(""));
            name.removeModifiedCB(AttributeRegistry_AttributeContainerNameModifiedCB, this); 
        }
    }
    
    this.removeUnique(attribute);
    this.objectCount--;
    
    attribute.onUnregister(this);
}

AttributeRegistry.prototype.getByType = function(type)
{
    switch (type)
    {
    case eAttrType.Camera:
        {
            var result = [];
            var perspectives = this.getByType(eAttrType.PerspectiveCamera);
            if (perspectives)
            {
                for (var j=0; j < perspectives.length; j++)
                {
                    result.push(perspectives[j]);
                }
            }
            var orthographics = this.getByType(eAttrType.OrthographicCamera);
            if (orthographics)
            {
                for (var j=0; j < orthographics.length; j++)
                {
                    result.push(orthographics[j]);
                }
            }
            return result;
        }
        break;
        
    case eAttrType.Evaluator:
        {
            var result = [];
            for (var i=eAttrType.Evaluator+1; i != eAttrType.Evaluator_End; i++)
            {
                var evaluators = this.getByType(i);
                if (evaluators)
                {
                    for (var j=0; j < evaluators.length; j++)
                    {
                        result.push(evaluators[j]);
                    }
                }    
            }   
            return result;
        }
        break;
        
    default:
        {
            return this.typeRegistry[type];
        }
        break;    
    }
}

AttributeRegistry.prototype.getByName = function(name)
{
    return this.nameRegistry[name];
}

AttributeRegistry.prototype.updateName = function(container, name)
{
    for (var i in this.nameRegistry)
    {
        for (var j=0; j < this.nameRegistry[i].length; j++)
        {
            if (this.nameRegistry[i][j] == container)
            {
                this.nameRegistry[i].splice(j, 1);
                this.registerByName(container, name);
                return;
            }
        }
    }
}

AttributeRegistry.prototype.clear = function()
{
    for (var i in this.typeRegistry)
    {
        this.typeRegistry[i] = [];
    }
    this.typeRegistry = [];
    
    for (var i in this.nameRegistry)
    {
        this.nameRegistry[i] = [];
    } 
    this.nameRegistry = [];

    this.uniqueAttributes = [];
    
    this.objectCount = 0;
}

AttributeRegistry.prototype.getObjectCount = function ()
{
    return this.uniqueAttributes.length;
}

AttributeRegistry.prototype.getObject = function(num)
{
    if (num < this.uniqueAttributes.length)
    {
    	return this.uniqueAttributes[num];
    }
    
    return null;
}

function AttributeRegistry_AttributeContainerNameModifiedCB(attribute, container)
{
    container.updateName(attribute.getContainer(), attribute.getValueDirect().join(""));
}
BooleanAttr.prototype = new Attribute();
BooleanAttr.prototype.constructor = BooleanAttr;

function BooleanAttr(value)
{
    Attribute.call(this);
    this.className = "BooleanAttr";
    this.attrType = eAttrType.BooleanAttr;
    this.setValue(value || false);
}

BooleanAttr.prototype.clone = function()
{
    var attr = new BooleanAttr();
    attr.setValue(this.values);
    return attr;
}

BooleanAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return values[0];
}

BooleanAttr.prototype.setValueDirect = function(value, params)
{
    var values = [value];
    this.setValue(value, params);
}

ColorAttr.prototype = new Attribute();
ColorAttr.prototype.constructor = ColorAttr;

function ColorAttr(r, g, b, a)
{
    Attribute.call(this);
    this.className = "ColorAttr";
    this.attrType = eAttrType.ColorAttr;
    var values = [ r || 0, g || 0, b || 0, a || 0 ];
    this.setValue(values);
}

ColorAttr.prototype.clone = function()
{
    var attr = new ColorAttr();
    attr.setValue(this.values);
    return attr;
}

ColorAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return { r: values[0], g: values[1], b: values[2], a: values[3] };
}

ColorAttr.prototype.setValueDirect = function(r, g, b, a, params)
{
    var values = [ r, g, b, a ];
    this.setValue(values, params);
}

Matrix4x4Attr.prototype = new Attribute();
Matrix4x4Attr.prototype.constructor = Matrix4x4Attr;

function Matrix4x4Attr(_11, _12, _13, _14,
                       _21, _22, _23, _24,
                       _31, _32, _33, _34,
                       _41, _42, _43, _44)
{
    Attribute.call(this);
    this.className = "Matrix4x4Attr";
    this.attrType = eAttrType.Matrix4x4Attr;
    var values = [ _11 || 1, _12 || 0, _13 || 0, _14 || 0,
                   _21 || 0, _22 || 1, _23 || 0, _24 || 0,
                   _31 || 0, _32 || 0, _33 || 1, _34 || 0,
                   _41 || 0, _42 || 0, _43 || 0, _44 || 1 ];
    this.setValue(values);
}

Matrix4x4Attr.prototype.clone = function()
{
    var attr = new Matrix4x4Attr();
    attr.setValue(this.values);
    return attr;
}

Matrix4x4Attr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    var result = new Matrix4x4();
    result.loadArray(values);
    return result;
}

Matrix4x4Attr.prototype.setValueDirect = function(matrix, params)
{
    var values = [ matrix._11, matrix._12, matrix._13, matrix._14,
                   matrix._21, matrix._22, matrix._23, matrix._24,
                   matrix._31, matrix._32, matrix._33, matrix._34,
                   matrix._41, matrix._42, matrix._43, matrix._44 ];
    this.setValue(values, params);
}

NumberArrayAttr.prototype = new Attribute();
NumberArrayAttr.prototype.constructor = NumberArrayAttr;

function NumberArrayAttr()
{
    Attribute.call(this);
    this.className = "NumberArrayAttr";
    this.attrType = eAttrType.NumberArrayAttr;
}

NumberArrayAttr.prototype.clone = function()
{
    var attr = new NumberArrayAttr();
    attr.setValue(this.values);
    return attr;
}

NumberArrayAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return values;
}

NumberArrayAttr.prototype.setValueDirect = function(values, params)
{
    this.setValue(values, params);
}

NumberAttr.prototype = new Attribute();
NumberAttr.prototype.constructor = NumberAttr;

function NumberAttr(value)
{
    Attribute.call(this);
    this.className = "NumberAttr";
    this.attrType = eAttrType.NumberAttr;
    this.setValue(value || 0);
}

NumberAttr.prototype.clone = function()
{
    var attr = new NumberAttr();
    attr.setValue(this.values);
    return attr;
}

NumberAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return values[0];
}

NumberAttr.prototype.setValueDirect = function(value, params)
{
    var values = [value];
    this.setValue(values, params);
}

PulseAttr.prototype = new BooleanAttr();
PulseAttr.prototype.constructor = PulseAttr;

function PulseAttr()
{
    BooleanAttr.call(this);
    this.className = "PulseAttr";
    this.attrType = eAttrType.PulseAttr;
    
    this.setTransient(true); // don't serialize because by definition this attribute doesn't hold "true" (it pulses)
}

PulseAttr.prototype.clone = function()
{
    var attr = new PulseAttr();
    attr.setValue(this.values);
    return attr;
}

PulseAttr.prototype.pulse = function()
{
    this.setValueDirect(true);
    this.setValueDirect(false);
}

QuaternionAttr.prototype = new Attribute();
QuaternionAttr.prototype.constructor = QuaternionAttr;

function QuaternionAttr(w, x, y, z)
{
    Attribute.call(this);
    this.className = "QuaternionAttr";
    this.attrType = eAttrType.QuaternionAttr;
    var values = [ w || 1, x || 0, y || 0, z || 0 ];
    this.setValue(values);
}

QuaternionAttr.prototype.clone = function()
{
    var attr = new QuaternionAttr();
    attr.setValue(this.values);
    return attr;
}

QuaternionAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    var result = new Quaternion();
    result.loadArray(values);
    return result;
}

QuaternionAttr.prototype.setValueDirect = function(quaternion, params)
{
    var values = [ quaternion.w, quaternion.x, quaternion.y, quaternion.z ];
    this.setValue(values, params);
}

ReferenceAttr.prototype = new Attribute();
ReferenceAttr.prototype.constructor = ReferenceAttr;

function ReferenceAttr(value)
{
    Attribute.call(this);
    this.className = "ReferenceAttr";
    this.attrType = eAttrType.ReferenceAttr;
    this.setValue(value || null);
}

ReferenceAttr.prototype.clone = function()
{
    var attr = new ReferenceAttr();
    attr.setValue(this.values);
    return attr;
}

ReferenceAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return values[0];
}

ReferenceAttr.prototype.setValueDirect = function(value, params)
{
    var values = [value];
    this.setValue(value, params);
}

StringAttr.prototype = new Attribute();
StringAttr.prototype.constructor = StringAttr;

function StringAttr(value)
{
    Attribute.call(this);
    this.className = "StringAttr";
    this.attrType = eAttrType.StringAttr;
    this.setValue(value || "");
}

StringAttr.prototype.clone = function()
{
    var attr = new StringAttr();
    attr.setValue(this.values);
    return attr;
}

StringAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return values;
}

StringAttr.prototype.setValueDirect = function(value, params)
{
    this.setValue(value, params);
}

StringAttr.prototype.setValue = function(values, params)
{
    this.values = [];
    
    // call base-class implementation
    Attribute.prototype.setValue.call(this, values, params);
}

TernaryAttr.prototype = new NumberAttr();
TernaryAttr.prototype.constructor = TernaryAttr;

function TernaryAttr(value)
{
    NumberAttr.call(this, value);
    this.className = "TernaryAttr";
    this.attrType = eAttrType.TernaryAttr;
    
    // TODO: this.setRange(-1, 1);
}

TernaryAttr.prototype.clone = function()
{
    var attr = new TernaryAttr();
    attr.setValue(this.values);
    return attr;
}

Vector2DAttr.prototype = new Attribute();
Vector2DAttr.prototype.constructor = Vector2DAttr;

function Vector2DAttr(x, y)
{
    Attribute.call(this);
    this.className = "Vector2DAttr";
    this.attrType = eAttrType.Vector2DAttr;
    var values = [ x || 0, y || 0 ];
    this.setValue(values);
}

Vector2DAttr.prototype.clone = function()
{
    var attr = new Vector2DAttr();
    attr.setValue(this.values);
    return attr;
}

Vector2DAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return { x: values[0], y: values[1] };
}

Vector2DAttr.prototype.setValueDirect = function(x, y, params)
{
    var values = [ x, y ];
    this.setValue(values, params);
}

Vector3DAttr.prototype = new Attribute();
Vector3DAttr.prototype.constructor = Vector3DAttr;

function Vector3DAttr(x, y, z)
{
    Attribute.call(this);
    this.className = "Vector3DAttr";
    this.attrType = eAttrType.Vector3DAttr;
    var values = [ x || 0, y || 0, z || 0 ];
    this.setValue(values);
}

Vector3DAttr.prototype.clone = function()
{
    var attr = new Vector3DAttr();
    attr.setValue(this.values);
    return attr;
}

Vector3DAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return { x: values[0], y: values[1], z: values[2] };
}

Vector3DAttr.prototype.setValueDirect = function(x, y, z, params)
{
    var values = [ x, y, z ];
    this.setValue(values, params);
}

Vector3DAttr.prototype.isZero = function()
{
	var values = [];
    this.getValue(values);
    return (values[0] == 0 && values[1] == 0 && values[2] == 0) ? true : false;
}

ViewportAttr.prototype = new Attribute();
ViewportAttr.prototype.constructor = ViewportAttr;

function ViewportAttr(x, y, width, height)
{
    Attribute.call(this);
    this.className = "ViewportAttr";
    this.attrType = eAttrType.ViewportAttr;
    var values = [ x || 0, y || 0, width || 0, height || 0 ];
    this.setValue(values);
}

ViewportAttr.prototype.clone = function()
{
    var attr = new ViewportAttr();
    attr.setValue(this.values);
    return attr;
}

ViewportAttr.prototype.getValueDirect = function()
{
    var values = [];
    this.getValue(values);
    return { x: values[0], y: values[1], width: values[2], height: values[3] };
}

ViewportAttr.prototype.setValueDirect = function(x, y, width, height, params)
{
    var values = [ x, y, width, height ];
    this.setValue(values, params);
}

AttributeVector.prototype = new AttributeContainer();
AttributeVector.prototype.constructor = AttributeVector;

function AttributeVector(allocator) // TODO: not sure if allocator is needed
{
    AttributeContainer.call(this);
    this.className = "AttributeVector";
    this.attrType = eAttrType.AttributeVector;
    
    this.vector = [];
    
    this.allocator = allocator;
    
    this.size = new NumberAttr(0);
    this.baseName = new StringAttr("item");
    this.appendParsedElements = new BooleanAttr(false);
    this.elementModified = new PulseAttr();
    
    this.size.addModifiedCB(AttributeVector_SizeModifiedCB, this);
    this.baseName.addModifiedCB(AttributeVector_BaseNameModifiedCB, this);
    
    this.registerAttribute(this.size, "size");
    this.registerAttribute(this.baseName, "baseName");
    this.registerAttribute(this.appendParsedElements, "appendParsedElements");
    this.registerAttribute(this.elementModified, "elementModified");
}

AttributeVector.prototype.allocatesElements = function() // TODO: necessary (?)
{
    return (this.allocator ? true : false);
}

AttributeVector.prototype.push_back = function(item)
{
    this.addElement(this.vector.length, item);

    this.size.setValueDirect(this.vector.length);
}

AttributeVector.prototype.resize = function(size)
{
    this.size.setValueDirect(size);
}

AttributeVector.prototype.clear = function()
{
    this.resize(0);
}

AttributeVector.prototype.getAt = function(index)
{
    if (this.vector.length > index)
    {
        return this.vector[index];
    }
    
    return null;
}

AttributeVector.prototype.setAt = function(index, item)
{
    if (this.vector.length > index)
    {
        this.vector[index] = item;
    }
}

AttributeVector.prototype.prev = function(element)
{
    for (var i=0; i < this.vector.length; i++)
    {
        if (this.vector[i] == element)
        {
            if (i > 0) return this.vector[i-1];
            break;
        }        
    }
    
    return null;
}

AttributeVector.prototype.next = function(element)
{
    for (var i=0; i < this.vector.length; i++)
    {
        if (this.vector[i] == element)
        {
            if (i < (this.vector.length - 1)) return this.vector[i+1];
            break;
        }        
    }
    
    return null;
}

AttributeVector.prototype.addElement = function(index, element)
{
    this.vector.splice(index, 0, element);
}

AttributeVector.prototype.removeElement = function(index)
{
    this.vector.splice(index, 1);
}

AttributeVector.prototype.Size = function()
{
    return this.size.getValueDirect();
}

AttributeVector.prototype.AppendParsedElements = function()
{
    return this.appendParsedElements.getValueDirect();
}

AttributeVector.prototype.setElementName = function(element, name)
{
    this.unregisterAttribute(element); // don't allow registration under multiple names
    this.registerAttribute(element, name);
    
    // TODO: add to element name map
    console.debug("TODO: add to element name map");
}

AttributeVector.prototype.synchronize = function(src, syncValues)
{
    // call base-class implementation
    AttributeContainer.prototype.synchronize.call(this, src, syncValues);

    // copy elements
    this.clear();
    for (var i = 0; i < src.vector.length; i++)
    {
        this.push_back(src.vector[i]);
    }
}

AttributeVector.prototype.isCollection = function()
{
    return true;
}

AttributeVector.prototype.sizeModified = function()
{
    var lastSize = this.vector.length;
    var nextSize = this.size.getValueDirect();
    var start, end;

    if (nextSize > lastSize)
    {
        start = lastSize;
        end = start + (nextSize - lastSize);

        for (var i = start; i < end; i++)
        {
            this.addElement(i, this.allocator ? this.allocator.allocate() : null);
        }
    }
    else if (nextSize < lastSize)
    {
        start = lastSize;
        end = start - (lastSize - nextSize);

        for (var i = start - 1; i >= end; i--)
        {
            this.removeElement(i);
        }
    }
}

function AttributeVector_SizeModifiedCB(attribute, container)
{
    container.sizeModified();
}

function AttributeVector_BaseNameModifiedCB(attribute, container)
{
}

StyleAttr.prototype = new AttributeContainer();
StyleAttr.prototype.constructor = StyleAttr;

function StyleAttr()
{
    AttributeContainer.call(this);
    this.className = "StyleAttr";
    this.attrType = eAttrType.StyleAttr;

    this.setOp = new NumberAttr(eAttrSetOp.Replace);
    this.styleUrl = new StringAttr();

    this.styleUrl.addModifiedCB(StyleAttr_StyleUrlModifiedCB, this);
    
    this.registerAttribute(this.setOp, "setOp");
    this.registerAttribute(this.styleUrl, "styleUrl");
}

StyleAttr.prototype.updateStyle = function(style)
{
    // implemented by derived classes
}

StyleAttr.prototype.styleUrlModified = function()
{
    var styleUrl = this.styleUrl.getValueDirect().join("");
    if (this.registry)
    {
        this.updateStyle(this.registry.find(styleUrl));
    }
}

function StyleAttr_StyleUrlModifiedCB(attribute, container)
{
    container.styleUrlModified();
}

StylesAttr.prototype = new AttributeVector();
StylesAttr.prototype.constructor = StylesAttr;

function StylesAttr()
{
    AttributeVector.call(this);
    this.className = "StylesAttr";
    this.attrType = eAttrType.StylesAttr;

    this.registeredCBs = [];
    this.registeredCBsData = [];
    
    this.enabled = new BooleanAttr(true);

    this.registerAttribute(this.enabled, "enabled");
}

StylesAttr.prototype.updateStyle = function(style)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        return;
    }

    for (var i = 0; i < style.Size(); i++)
    {
        for (var j = 0; j < this.Size(); j++)
        {
            if (this.vector[j].attrType == style.vector[i].attrType)
            {
                this.vector[j].updateStyle(style.vector[i]);
                break;
            }
        }
    }
}

StylesAttr.prototype.registerStyle = function(style, name)
{
    this.push_back(style);
    this.setElementName(style, name);
    this.alertRegisteredCBs(style, true);
}

StylesAttr.prototype.unregisterStyle = function(style)
{
    for (var i in this.vector)
    {
        if (this.vector[i] == style)
        {
            this.alertRegisteredCBs(style, false);
            delete this.vector[i];
            break;
        }
    }
}

StylesAttr.prototype.addRegisteredCB = function(callback, data)
{
    this.registeredCBs.push(callback);
    this.registeredCBsData.push(data);
}

StylesAttr.prototype.alertRegisteredCBs = function(style, registered)
{
    for (var i = 0; i < this.registeredCBs.length; i++)
    {
        this.registeredCBs[i](style, this.registeredCBs[i]);
    }
}

StylesAttr.prototype.push_back = function(item)
{
    // call base-class implementation
    AttributeVector.prototype.push_back.call(this, item);

    this.alertRegisteredCBs(item, true);
}

StylesAttr.prototype.getStyle = function(type)
{
    for (var i = 0; i < this.Size(); i++)
    {
        if (this.vector[i].attrType == type)
        {
            return this.vector[i];
        }
    }

    return undefined;
}

StyleMapAttr.prototype = new AttributeContainer();
StyleMapAttr.prototype.constructor = StyleMapAttr;

function StyleMapAttr()
{
    AttributeContainer.call(this);
    this.className = "StyleMapAttr";
    this.attrType = eAttrType.StyleMapAttr;

    this.eventType = eEventType.Unknown;
    this.targetContainer = null;
    
    this.event = new StringAttr();
    this.styles = new StylesAttr();
    this.styleUrl = new StringAttr();
    this.target = new StringAttr();

    this.event.addModifiedCB(StyleMapAttr_EventModifiedCB, this);
    this.styleUrl.addModifiedCB(StyleMapAttr_styleUrlModifiedCB, this);
    this.target.addModifiedCB(StyleMapAttr_TargetModifiedCB, this);

    this.registerAttribute(this.event, "event");
    this.registerAttribute(this.styleUrl, "styleUrl");
    this.registerAttribute(this.target, "target");
}

StyleMapAttr.prototype.getStyles = function(eventType)
{
    var styles = null;
    var target = null;

    if (this.eventType == eventType)
    {
        styles = this.styles;
        target = this.targetContainer;
    }

    return { styles: styles, target: target };
}

StyleMapAttr.prototype.setStyles = function(styles)
{
    this.styles = styles;
}

StyleMapAttr.prototype.setTargetContainer = function(targetContainer)
{
    this.targetContainer = targetContainer;
}

StyleMapAttr.prototype.eventModified = function()
{
    var eventName = this.event.getValueDirect().join("");

    this.eventType = eEventNameMap[eventName];
}

StyleMapAttr.prototype.styleUrlModified = function()
{
    var styleUrl = this.styleUrl.getValueDirect();
    if (styleUrl[0] == '#')
    {
        styleUrl.splice(0, 1);
    }
    styleUrl = styleUrl.join("");

    var styles = this.registry.find(styleUrl);
    if (styles)
    {
        this.styles = styles;
    }
}

StyleMapAttr.prototype.targetModified = function()
{
    var target = this.target.getValueDirect().join("");

    this.targetContainer = this.registry.find(target);
}

function StyleMapAttr_EventModifiedCB(attribute, container)
{
    container.eventModified();
}

function StyleMapAttr_styleUrlModifiedCB(attribute, container)
{
    container.styleUrlModified();
}

function StyleMapAttr_TargetModifiedCB(attribute, container)
{
    container.targetModified();
}

StyleMapAttrAllocator.prototype = new Allocator();
StyleMapAttrAllocator.prototype.constructor = StyleMapAttrAllocator;

function StyleMapAttrAllocator()
{
}

StyleMapAttrAllocator.prototype.allocate = function()
{
    return new StyleMapAttr();
}

StylesMapAttr.prototype = new AttributeVector();
StylesMapAttr.prototype.constructor = StylesMapAttr;

function StylesMapAttr()
{
    AttributeVector.call(this, new StyleMapAttrAllocator());
    this.className = "StylesMapAttr";
    this.attrType = eAttrType.StylesMapAttr;

    this.stylesEnabledMap = [];

    this.size.addModifiedCB(StylesMapAttr_SizeModifiedCB, this);

    this.appendParsedElements.setValueDirect(true);
}

StylesMapAttr.prototype.getStyles = function(eventType)
{
    var styles = null;
    var enabled = false;
    var target = null;

    for (var i = 0; i < this.Size(); i++)
    {
        var result = this.vector[i].getStyles(eventType);
        if (result.styles)
        {
            styles = result.styles;
            target = result.target;
            if (this.stylesEnabledMap[result.styles])
            {
                enabled = this.stylesEnabledMap[result.styles];
            }
        }
    }

    return { styles: styles, target: target, enabled: enabled };
}

StylesMapAttr.prototype.StylesMapAttr_SizeModified = function()
{
    for (var i = 0; i < this.Size(); i++)
    {
        if (!(this.vector[i].registry))
        {
            this.vector[i].setRegistry(this.registry);
        }

        if (!(this.stylesEnabledMap[this.vector[i].styles]))
        {
            this.stylesEnabledMap[this.vector[i].styles] = new BooleanAttr(true);
        }
    }
}

function StylesMapAttr_SizeModifiedCB(attribute, container)
{
    container.StylesMapAttr_SizeModified();
}
KeyframeAttr.prototype = new AttributeContainer();
KeyframeAttr.prototype.constructor = KeyframeAttr;

function KeyframeAttr()
{
    AttributeContainer.call(this);
    this.className = "KeyframeAttr";
    this.attrType = eAttrType.KeyframeAttr;
    
    this.time = new NumberAttr();
    this.value = new NumberAttr();
    this.shape = new NumberAttr();
    this.params = new AttributeVector();
    
    for (var i=0; i < 6; i++)
    {
        this.params.push_back(new NumberAttr(0));
    }
    
    this.registerAttribute(this.time, "time");
    this.registerAttribute(this.value, "value");
    this.registerAttribute(this.shape, "shape");
    this.registerAttribute(this.params, "params");
    
    this.getTime = function() { return this.time.getValueDirect(); }
    this.getValue = function() { return this.value.getValueDirect(); }
    this.getShape = function() { return this.shape.getValueDirect(); }
    this.getParams = function(i) { return this.params.getAt(i).getValueDirect(); }
}

KeyframesAttr.prototype = new AttributeVector();
KeyframesAttr.prototype.constructor = KeyframesAttr;

function KeyframesAttr()
{
    AttributeVector.call(this);
    this.className = "KeyframesAttr";
    this.attrType = eAttrType.KeyframesAttr;
}
    
BBoxAttr.prototype = new AttributeContainer();
BBoxAttr.prototype.constructor = BBoxAttr;

function BBoxAttr()
{
    AttributeContainer.call(this);
    this.className = "BBoxAttr";
    this.attrType = eAttrType.BBoxAttr;
    
    this.min = new Vector3DAttr();
    this.max = new Vector3DAttr();
    
    this.registerAttribute(this.min, "min");
    this.registerAttribute(this.max, "max");
}

BBoxAttr.prototype.setValueDirect = function(min, max)
{
    this.min.setValueDirect(min.x, min.y, min.z);
    this.max.setValueDirect(max.x, max.y, max.z);
}

ImageAttr.prototype = new AttributeContainer();
ImageAttr.prototype.constructor = ImageAttr;

function ImageAttr()
{
    AttributeContainer.call(this);
    this.className = "ImageAttr";
    this.attrType = eAttrType.ImageAttr;

    this.width = new NumberAttr(0);
    this.height = new NumberAttr(0);
    this.byteAlignment = new NumberAttr(0);
    this.pixelFormat = new NumberAttr(ePixelFormat.Unknown);
    this.pixels = new NumberArrayAttr();
    
    this.registerAttribute(this.width, "width");
    this.registerAttribute(this.height, "height");
    this.registerAttribute(this.byteAlignment, "byteAlignment");
    this.registerAttribute(this.pixelFormat, "pixelFormat");
    this.registerAttribute(this.pixels, "pixels");    
}

RectAttr.prototype = new AttributeContainer();
RectAttr.prototype.constructor = RectAttr;

function RectAttr()
{
    AttributeContainer.call(this);
    this.className = "RectAttr";
    this.attrType = eAttrType.RectAttr;

    this.left = new NumberAttr(0);
    this.top = new NumberAttr(0);
    this.right = new NumberAttr(0);
    this.bottom = new NumberAttr(0);

    this.registerAttribute(this.left, "left");
    this.registerAttribute(this.top, "top");
    this.registerAttribute(this.right, "right");
    this.registerAttribute(this.bottom, "bottom");
}

RectAttr.prototype.getValueDirect = function()
{
    var rect = new Rect();
    rect.left = this.left.getValueDirect();
    rect.top = this.top.getValueDirect();
    rect.right = this.right.getValueDirect();
    rect.bottom = this.bottom.getValueDirect();
    return rect;
}

RectAttr.prototype.setValueDirect = function(rect)
{
    this.left.setValueDirect(rect.left);
    this.top.setValueDirect(rect.top);
    this.right.setValueDirect(rect.right);
    this.bottom.setValueDirect(rect.bottom);
}

RectAttr.prototype.containsPoint = function(x, y)
{
    if (x >= this.left.getValueDirect() &&
        y >= this.top.getValueDirect() &&
        x <= this.right.getValueDirect() &&
        y <= this.bottom.getValueDirect())
        return true;

    return false;
}

FontStyleAttr.prototype = new StyleAttr();
FontStyleAttr.prototype.constructor = FontStyleAttr;

function FontStyleAttr()
{
    StyleAttr.call(this);
    this.className = "FontStyleAttr";
    this.attrType = eAttrType.FontStyleAttr;

    this.antialiasType = new NumberAttr(eImageAntialiasOp.EightPass);
    this.borderColor = new ColorAttr(0, 0, 0, 1);
    this.borderWidth = new NumberAttr(2);
    this.color = new ColorAttr(1, 1, 1, 1);
    this.effects = new StringAttr();
    this.font = new StringAttr("Arial");
    this.opacity = new NumberAttr(1);
    this.size = new NumberAttr(18);
    this.style = new StringAttr("Bold");

    this.registerAttribute(this.antialiasType, "antialiasType");
    this.registerAttribute(this.borderColor, "borderColor");
    this.registerAttribute(this.borderWidth, "borderWidth");
    this.registerAttribute(this.color, "color");
    this.registerAttribute(this.effects, "effects");
    this.registerAttribute(this.font, "font");
    this.registerAttribute(this.opacity, "opacity");
    this.registerAttribute(this.size, "size");
    this.registerAttribute(this.style, "style");
}

FontStyleAttr.prototype.updateStyle = function(style)
{
    var setOp = style.setOp.getValueDirect();

    // antialiasType
    if (style.getAttributeModificationCount(style.antialiasType))
    {
        this.antialiasType.copyValue(style.antialiasType, setOp);
    }

	// borderColor
    if (style.getAttributeModificationCount(style.borderColor))
    {
        this.borderColor.copyValue(style.borderColor, setOp);
    }

	// borderWidth
    if (style.getAttributeModificationCount(style.borderWidth))
    {
        this.borderWidth.copyValue(style.borderWidth, setOp);
    }

	// color
    if (style.getAttributeModificationCount(style.color))
    {
        this.color.copyValue(style.color, setOp);
    }
	
	// effects
    if (style.getAttributeModificationCount(style.effects))
    {
        this.effects.copyValue(style.effects, setOp);
    }

	// font
    if (style.getAttributeModificationCount(style.font))
    {
        this.font.copyValue(style.font, setOp);
    }

	// opacity
    if (style.getAttributeModificationCount(style.opacity))
    {
        this.opacity.copyValue(style.opacity, setOp);
    }

	// size
    if (style.getAttributeModificationCount(style.size))
    {
        this.size.copyValue(style.size, setOp);
    }

	// style
    if (style.getAttributeModificationCount(style.style))
    {
        this.style.copyValue(style.style, setOp);
    }
}

LabelStyleAttr.prototype = new StyleAttr();
LabelStyleAttr.prototype.constructor = LabelStyleAttr;

function LabelStyleAttr()
{
    StyleAttr.call(this);
    this.className = "LabelStyleAttr";
    this.attrType = eAttrType.LabelStyleAttr;

    this.angle = new NumberAttr(0);
    this.backgroundColor = new ColorAttr(0, 0, 0, 1);
    this.backgroundOpacity = new NumberAttr(0);
    this.fontStyle = new FontStyleAttr();
    this.format = new StringAttr("left");
    this.height = new NumberAttr(0);
    this.offset = new Vector2DAttr(0, 0);
    this.padding = new NumberAttr(0);
    this.scale = new Vector3DAttr(1, 1, 1);
    this.textAlign = new StringAttr("middleRight");
    this.width = new NumberAttr(0);

    this.registerAttribute(this.angle, "angle");
    this.registerAttribute(this.backgroundColor, "backgroundColor");
    this.registerAttribute(this.backgroundOpacity, "backgroundOpacity");
    this.registerAttribute(this.fontStyle, "fontStyle");
    this.registerAttribute(this.format, "format");
    this.registerAttribute(this.height, "height");
    this.registerAttribute(this.offset, "offset");
    this.registerAttribute(this.padding, "padding");
    this.registerAttribute(this.scale, "scale");
    this.registerAttribute(this.textAlign, "textAlign");
    this.registerAttribute(this.width, "width");
}

LabelStyleAttr.prototype.updateStyle = function(style)
{
    var setOp = style.setOp.getValueDirect();

    // angle
    if (style.getAttributeModificationCount(style.angle))
    {
        this.angle.copyValue(style.angle, setOp);
    }

    // backgroundColor
    if (style.getAttributeModificationCount(style.backgroundColor))
    {
        this.backgroundColor.copyValue(style.backgroundColor, setOp);
    }

    // backgroundOpacity
    if (style.getAttributeModificationCount(style.backgroundOpacity))
    {
        this.backgroundOpacity.copyValue(style.backgroundOpacity, setOp);
    }

    // fontStyle
    this.fontStyle.updateStyle(style.fontStyle);

    // format
    if (style.getAttributeModificationCount(style.format))
    {
        this.format.copyValue(style.format, setOp);
    }

    // height
    if (style.getAttributeModificationCount(style.height))
    {
        this.height.copyValue(style.height, setOp);
    }

    // offset
    if (style.getAttributeModificationCount(style.offset))
    {
        this.offset.copyValue(style.offset, setOp);
    }

    // padding
    if (style.getAttributeModificationCount(style.padding))
    {
        this.padding.copyValue(style.padding, setOp);
    }

    // scale
    if (style.getAttributeModificationCount(style.scale))
    {
        this.scale.copyValue(style.scale, setOp);
    }

    // textAlign
    if (style.getAttributeModificationCount(style.textAlign))
    {
        this.textAlign.copyValue(style.textAlign, setOp);
    }

    // width
    if (style.getAttributeModificationCount(style.width))
    {
        this.width.copyValue(style.width, setOp);
    }
}

IconStyleAttr.prototype = new StyleAttr();
IconStyleAttr.prototype.constructor = IconStyleAttr;

function IconStyleAttr()
{
    StyleAttr.call(this);
    this.className = "IconStyleAttr";
    this.attrType = eAttrType.IconStyleAttr;

    this.alphaUrl = new StringAttr("");
    this.color = new ColorAttr(1, 1, 1, 1);
    this.opacity = new NumberAttr(1);
    this.scale = new Vector3DAttr(1, 1, 1);
    this.url = new StringAttr("");

    this.registerAttribute(this.alphaUrl, "alphaUrl");
    this.registerAttribute(this.color, "color");
    this.registerAttribute(this.opacity, "opacity");
    this.registerAttribute(this.scale, "scale");
    this.registerAttribute(this.url, "url");
}

IconStyleAttr.prototype.updateStyle = function(style)
{
    var setOp = style.setOp.getValueDirect();

    // alphaUrl
    if (style.getAttributeModificationCount(style.alphaUrl))
    {
        this.alphaUrl.copyValue(style.alphaUrl, setOp);
    }

    // color
    if (style.getAttributeModificationCount(style.color))
    {
        this.color.copyValue(style.color, setOp);
    }

    // opacity
    if (style.getAttributeModificationCount(style.opacity))
    {
        this.opacity.copyValue(style.opacity, setOp);
    }

    // scale
    if (style.getAttributeModificationCount(style.scale))
    {
        this.scale.copyValue(style.scale, setOp);
    }

    // url
    if (style.getAttributeModificationCount(style.url))
    {
        this.url.copyValue(style.url, setOp);
    }
}

HTMLLabelStyleAttr.prototype = new StyleAttr();
HTMLLabelStyleAttr.prototype.constructor = HTMLLabelStyleAttr;

function HTMLLabelStyleAttr()
{
    StyleAttr.call(this);
    this.className = "HTMLLabelStyleAttr";
    this.attrType = eAttrType.HTMLLabelStyleAttr;
    
    this.bgColor = new ColorAttr(1, 1, 1, 1); // white
    this.height = new NumberAttr(0); // 0 (auto-calculate)
    this.html = new StringAttr(); // empty string
    this.left = new NumberAttr(0);
    //if (!(this.scrollBarLabelStyle = New<ScrollBarLabelStyleAttr>())) return;
    this.top = new NumberAttr(0);
    this.url = new StringAttr(); // empty string
    this.width = new NumberAttr(0); // 0 (auto-calculate)
    
    this.registerAttribute(this.bgColor, "bgColor");
    this.registerAttribute(this.height, "height");
    this.registerAttribute(this.html, "html");
    this.registerAttribute(this.html, "userData");          // for CDATA
    this.registerAttribute(this.left, "left");
    //this.registerAttribute(this.scrollBarLabelStyle, "scrollBarLabelStyle");
    this.registerAttribute(this.top, "top");
    this.registerAttribute(this.url, "url");
    this.registerAttribute(this.width, "width");
}

BalloonTipLabelStyleAttr.prototype = new StyleAttr();
BalloonTipLabelStyleAttr.prototype.constructor = BalloonTipLabelStyleAttr;

function BalloonTipLabelStyleAttr()
{
    StyleAttr.call(this);
    this.className = "BalloonTipLabelStyleAttr";
    this.attrType = eAttrType.BalloonTipLabelStyleAttr;
    
    this.balloonOffset = new NumberAttr(100);
    this.bgColor = new ColorAttr(1, 1, 1, 1);
    this.displayMode = new StringAttr("default");
    this.htmlLabelStyle = new HTMLLabelStyleAttr();
    this.text = new StringAttr();
    this.textColor = new ColorAttr(0, 0, 0, 1);
	
	this.registerAttribute(this.balloonOffset, "balloonOffset");
	this.registerAttribute(this.bgColor, "bgColor");
	this.registerAttribute(this.displayMode, "displayMode");
	this.registerAttribute(this.htmlLabelStyle, "htmlLabelStyle");
	this.registerAttribute(this.text, "text");
	this.registerAttribute(this.textColor, "textColor");
}

BalloonTipLabelStyleAttr.prototype.updateStyle = function(style)
{
    var setOp = style.setOp.getValueDirect();

    // balloonOffset
    if (style.getAttributeModificationCount(style.balloonOffset))
    {
        this.balloonOffset.copyValue(style.balloonOffset, setOp);
    }

    // bgColor
    if (style.getAttributeModificationCount(style.bgColor))
    {
        this.bgColor.copyValue(style.bgColor, setOp);
    }

    // displayMode
    if (style.getAttributeModificationCount(style.displayMode))
    {
        this.displayMode.copyValue(style.displayMode, setOp);
    }

    // htmlLabelStyle
    this.htmlLabelStyle.updateStyle(style.htmlLabelStyle);

    // text
    if (style.getAttributeModificationCount(style.text))
    {
        this.text.copyValue(style.text, setOp);
    }

    // textColor
    if (style.getAttributeModificationCount(style.textColor))
    {
        this.textColor.copyValue(style.textColor, setOp);
    }
}

RenderableElementStyleAttr.prototype = new StyleAttr();
RenderableElementStyleAttr.prototype.constructor = RenderableElementStyleAttr;

function RenderableElementStyleAttr()
{
    StyleAttr.call(this);
    this.className = "RenderableElementStyleAttr";
    this.attrType = eAttrType.RenderableElementStyleAttr;

    this.hasFocus = new TernaryAttr(0);
    this.selected = new TernaryAttr(0);

    this.registerAttribute(this.hasFocus, "hasFocus");
    this.registerAttribute(this.selected, "selected");
}

RenderableElementStyleAttr.prototype.updateStyle = function(style)
{
    var setOp = style.setOp.getValueDirect();

    // hasFocus
    if (style.getAttributeModificationCount(style.hasFocus))
    {
        this.hasFocus.copyValue(style.hasFocus, setOp);
    }

    // selected
    if (style.getAttributeModificationCount(style.selected))
    {
        this.selected.copyValue(style.selected, setOp);
    }
}

PlaneAttr.prototype = new AttributeContainer();
PlaneAttr.prototype.constructor = PlaneAttr;

function PlaneAttr()
{
    AttributeContainer.call(this);
    this.className = "PlaneAttr";
    this.attrType = eAttrType.PlaneAttr;

    this.point = new Vector3DAttr(0, 0, 0);
    this.normal = new Vector3DAttr(0, 0, 1);
    this.dot = new NumberAttr(0);

    this.registerAttribute(this.point, "point");
    this.registerAttribute(this.normal, "normal");
    this.registerAttribute(this.dot, "dot");
}

PlaneAttr.prototype.getValueDirect = function()
{
    var point = this.point.getValueDirect();
    var normal = this.normal.getValueDirect();
    var plane = new Plane(new Vector3D(point.x, point.y, point.z), new Vector3D(normal.x, normal.y, normal.z));
    return plane;
}

PlaneAttr.prototype.setValueDirect = function(plane)
{
    this.point.setValueDirect(plane.point.x, plane.point.y, plane.point.z);
    this.normal.setValueDirect(plane.normal.x, plane.normal.y, plane.normal.z);
    this.dot.setValueDirect(plane.dot);
}

ViewVolumeAttr.prototype = new AttributeContainer();
ViewVolumeAttr.prototype.constructor = ViewVolumeAttr;

function ViewVolumeAttr()
{
    AttributeContainer.call(this);
    this.className = "ViewVolumeAttr";
    this.attrType = eAttrType.ViewVolumeAttr;

    this.left = new PlaneAttr();
    this.right = new PlaneAttr();
    this.top = new PlaneAttr();
    this.bottom = new PlaneAttr();
    this.near = new PlaneAttr();
    this.far = new PlaneAttr();

    this.registerAttribute(this.left, "left");
    this.registerAttribute(this.right, "right");
    this.registerAttribute(this.top, "top");
    this.registerAttribute(this.bottom, "bottom");
    this.registerAttribute(this.near, "near");
    this.registerAttribute(this.far, "far");
}

ViewVolumeAttr.prototype.setValueDirect = function(left, right, top, bottom, near, far)
{
    this.left.setValueDirect(left);
    this.right.setValueDirect(right);
    this.top.setValueDirect(top);
    this.bottom.setValueDirect(bottom);
    this.near.setValueDirect(near);
    this.far.setValueDirect(far);
}
function setAttributeValue(attribute, value)
{
    switch (attribute.attrType)
    {
    case eAttrType.BooleanAttr:
        {
            if (value == "false" || value == "0")
                attribute.setValueDirect(false);
            else 
                attribute.setValueDirect(true);
        }
        break;

    case eAttrType.ColorAttr:
    case eAttrType.Matrix4x4Attr:
    case eAttrType.NumberArrayAttr:
    case eAttrType.Vector2DAttr:
    case eAttrType.Vector3DAttr:
    case eAttrType.ViewportAttr:
        {
            // convert from string to numeric
            for (var i = 0; i < value.length; i++)
            {
                value[i] = parseFloat(value[i]);
            }
            attribute.setValue(value);
        }
        break;   
    
    case eAttrType.NumberAttr:
        {
            // convert from string to numeric
            attribute.setValueDirect(parseFloat(value));
        }
        break;

    default:
        {
            attribute.setValue(value);
        }
        break;
    }
}
Agent.prototype = new AttributeContainer();
Agent.prototype.constructor = Agent;

function Agent()
{
    AttributeContainer.call(this);
    this.className = "Agent";
    
    this.running = false;
    
    this.name = new StringAttr("");
    this.enabled = new BooleanAttr(true);
    
    this.registerAttribute(this.name, "name");
    this.registerAttribute(this.enabled, "enabled");
}

Agent.prototype.start = function()
{
    this.running = true;
}

Agent.prototype.stop = function()
{
    this.running = false;
}

Agent.prototype.pause = function()
{
    this.running = false;
}



function RayIntersectRecord()
{
    this.distance = Infinity;
    this.pointModel = new Vector3D();
    this.pointWorld = new Vector3D();
    this.pointView = new Vector3D();
    this.triIndex = 0;
}

function RayIntersectParams(rayOrigin, 
                            rayDir,
                            nearDistance,
                            farDistance,
                            worldMatrix,
                            viewMatrix,
                            scale,
                            doubleSided,
                            clipPlanes)
{
    this.rayOrigin = rayOrigin || new Vector3D();
    this.rayDir = rayDir || new Vector3D();
    this.nearDistance = nearDistance || 0;
    this.farDistance = farDistance || 0;
    this.worldMatrix = worldMatrix || new Matrix4x4();
    this.viewMatrix = viewMatrix || new Matrix4x4();
    this.worldViewMatrix = this.worldMatrix.multiply(this.viewMatrix);
    this.scale = scale || 0;
    this.doubleSided = doubleSided || false;
    this.clipPlanes = clipPlanes || new Array();
    this.intersects = false;
    this.intersectRecord = new RayIntersectRecord();
}

function Triangle(x0, y0, z0, x1, y1, z1, x2, y2, z2)
{
    this.v0 = new Vector3D(x0, y0, z0);
    this.v1 = new Vector3D(x1, y1, z1);
    this.v2 = new Vector3D(x2, y2, z2);
}

function Sphere()
{
    this.center = new Vector3D();
    this.radius = 0;
    this.xcenter = new Vector3D(); // transformed center
    this.xradius = 0;              // transformed (scaled) radius
}

Sphere.prototype.intersects = function(sphere)
{
    // compare squared distances to keep from calling sqrt
    /*return (((this.xcenter.x - sphere.xcenter.x) * (this.xcenter.x - sphere.xcenter.x) + 
             (this.xcenter.y - sphere.xcenter.y) * (this.xcenter.y - sphere.xcenter.y) +
             (this.xcenter.z - sphere.xcenter.z) * (this.xcenter.z - sphere.xcenter.z)) < ((this.xradius + sphere.xradius) * (this.xradius + sphere.xradius)) ? true : false);
    */
    var distanceBetweenCenters = distanceBetween(this.xcenter, sphere.xcenter);
    var combinedRadii = this.xradius + sphere.xradius;
    
    if (distanceBetweenCenters < combinedRadii) return true;
    
    return false;
}

function Region(minX, minY, minZ, maxX, maxY, maxZ)
{
    this.min = new Vector3D(minX, minY, minZ);
    this.max = new Vector3D(maxX, maxY, maxZ);
    
    this.xpos = new Plane();
    this.xneg = new Plane();
    this.ypos = new Plane();
    this.yneg = new Plane();
    this.zpos = new Plane();
    this.zneg = new Plane();
    
    this.xpos_ypos_zpos = new Plane();
    this.xpos_ypos_zneg = new Plane();
    this.xpos_yneg_zpos = new Plane();
    this.xpos_yneg_zneg = new Plane();
    this.xneg_ypos_zpos = new Plane();
    this.xneg_ypos_zneg = new Plane();
    this.xneg_yneg_zpos = new Plane();
    this.xneg_yneg_zneg = new Plane();
    
    this.setPlanes();
}

Region.prototype.setPlanes = function()
{
    // generate axis planes
    this.xpos = new Plane(this.max, new Vector3D( 1,  0,  0));
    this.xneg = new Plane(this.min, new Vector3D(-1,  0,  0));
    this.ypos = new Plane(this.max, new Vector3D( 0,  1,  0));
    this.yneg = new Plane(this.min, new Vector3D( 0, -1,  0));
    this.zpos = new Plane(this.max, new Vector3D( 0,  0,  1));
    this.zneg = new Plane(this.min, new Vector3D( 0,  0, -1));

    // define corner points of region
    var xp_yp_zp = new Vector3D(this.max.x, this.max.y, this.max.z);
    var xp_yp_zn = new Vector3D(this.max.x, this.max.y, this.min.z);
    var xp_yn_zp = new Vector3D(this.max.x, this.min.y, this.max.z);
    var xp_yn_zn = new Vector3D(this.max.x, this.min.y, this.min.z);
    var xn_yp_zp = new Vector3D(this.min.x, this.max.y, this.max.z);
    var xn_yp_zn = new Vector3D(this.min.x, this.max.y, this.min.z);
    var xn_yn_zp = new Vector3D(this.min.x, this.min.y, this.max.z);
    var xn_yn_zn = new Vector3D(this.min.x, this.min.y, this.min.z);

    // generate corner planes
    this.xpos_ypos_zpos = new Plane(xp_yp_zp, xp_yp_zp - xn_yn_zn);
    this.xpos_ypos_zneg = new Plane(xp_yp_zn, xp_yp_zn - xn_yn_zp);
    this.xpos_yneg_zpos = new Plane(xp_yn_zp, xp_yn_zp - xn_yp_zn);
    this.xpos_yneg_zneg = new Plane(xp_yn_zn, xp_yn_zn - xn_yp_zp);
    this.xneg_ypos_zpos = new Plane(xn_yp_zp, xn_yp_zp - xp_yn_zn);
    this.xneg_ypos_zneg = new Plane(xn_yp_zn, xn_yp_zn - xp_yn_zp);
    this.xneg_yneg_zpos = new Plane(xn_yn_zp, xn_yn_zp - xp_yp_zn);
    this.xneg_yneg_zneg = new Plane(xn_yn_zn, xn_yn_zn - xp_yp_zp);   
}

Region.prototype.containsGeometry = function(tris, triIndices)
{
    var result = [];
    
    for (var i=0; i < triIndices.length; i++)
    {
        if (this.containsTriangle(tris[triIndices[i]]))
        {
            result.push(triIndices[i]);
        }
    }
    
    return result;
}

Region.prototype.containsTriangle = function(tri)
{
    var verts = new Array(3);
    verts[0] = tri.v0;
    verts[1] = tri.v1;
    verts[2] = tri.v2;
    
    // check if any vertices are within the region bounds (quick accept)
    for (var i=0; i < 3; i++)
    {
        if (verts[i].x >= this.min.x &&
            verts[i].y >= this.min.y &&
            verts[i].z >= this.min.z &&
            verts[i].x <= this.max.x &&
            verts[i].y <= this.max.y &&
            verts[i].z <= this.max.z)
        {
            return true;
        }
    }
    
    // check if all vertices are outside a region plane (quick reject)
    if (triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xpos) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xneg) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.ypos) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.yneg) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.zpos) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.zneg) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xpos_ypos_zpos) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xpos_ypos_zneg) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xpos_yneg_zpos) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xpos_yneg_zneg) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xneg_ypos_zpos) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xneg_ypos_zneg) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xneg_yneg_zpos) ||
        triangleOnPositiveSideOfPlane(verts[0], verts[1], verts[2], this.xneg_yneg_zneg))
    {
        return false;
    }
    
    // triangle has survived trivial acceptance/rejection tests...

    // test triangle line segments for cube face penetration
    // (only test segments if they span the face plane)
    var result;
    for (var i=0; i < 3; i++)
    {
        var a = verts[i];
        var b = verts[(i+1)%3];

        // +X face
        result = lineSegmentPlaneIntersection(a, b, this.xpos);
        if (result.count > 0) 
        {
            // if point lies within region face, triangle intersects region
            if (result.point.y >= this.min.y && result.point.y <= this.max.y &&
                result.point.z >= this.min.z && result.point.z <= this.max.z)
            {
                return true;
            }
        }

        // -X face
        result = lineSegmentPlaneIntersection(a, b, this.xneg);
        if (result.count > 0) 
        {
            if (result.point.y >= this.min.y && result.point.y <= this.max.y &&
                result.point.z >= this.min.z && result.point.z <= this.max.z)
            {
                return true;
            }
        }

        // +Y face
        result = lineSegmentPlaneIntersection(a, b, this.ypos);
        if (result.count > 0)
        {
            if (result.point.x >= this.min.x && result.point.x <= this.max.x &&
                result.point.z >= this.min.z && result.point.z <= this.max.z)
            {
                return true;
            }
        }

        // -Y face
        result = lineSegmentPlaneIntersection(a, b, this.yneg);
        if (result.count > 0)
        {
            if (result.point.x >= this.min.x && result.point.x <= this.max.x &&
                result.point.z >= this.min.z && result.point.z <= this.max.z)
            {
                return true;
            }
        }

        // +Z face
        result = lineSegmentPlaneIntersection(a, b, this.zpos);
        if (result.count > 0)
        {
            if (result.point.x >= this.min.x && result.point.x <= this.max.x &&
                result.point.y >= this.min.y && result.point.y <= this.max.y)
            {
                return true;
            }
        }

        // -Z face
        result = lineSegmentPlaneIntersection(a, b, this.zneg);
        if (result.count > 0)
        {
            if (result.point.x >= this.min.x && result.point.x <= this.max.x &&
                result.point.y >= this.min.y && result.point.y <= this.max.y)
            {
                return true;
            }
        }
    }
    
    // triangle and region may still intersect if a region corner is poking
    // through the interior of the triangle; check for this case by
    // determining if any of the four region diagonals intersect the triangle
    // 0
    result = lineSegmentTriangleIntersection(this.min, 
                                             this.max, 
                                             verts[0], verts[1], verts[2]);
    if (result.count > 0) return true;    
    // 1
    result = lineSegmentTriangleIntersection(new Vector3D(this.min.x, this.max.y, this.min.z), 
                                             new Vector3D(this.max.x, this.min.y, this.max.z),
                                             verts[0], verts[1], verts[2]);
    if (result.count > 0) return true;
    // 2
    result = lineSegmentTriangleIntersection(new Vector3D(this.max.x, this.min.y, this.min.z), 
                                             new Vector3D(this.min.x, this.max.y, this.max.z),
                                             verts[0], verts[1], verts[2]);
    if (result.count > 0) return true;
    // 3                                        
    result = lineSegmentTriangleIntersection(new Vector3D(this.min.x, this.min.y, this.max.z), 
                                             new Vector3D(this.max.x, this.max.y, this.min.z),
                                             verts[0], verts[1], verts[2]);
    if (result.count > 0) return true;

    // triangle and region do not intersect
    return false;
}

function SphereTreeNode()
{
    this.sphere = new Sphere();
    this.level = 0;
    this.parent = null;
    this.children = [];
    this.triIndices = [];    
}

SphereTreeNode.prototype.isLeaf = function()
{
    return this.children.length == 0 ? true : false;    
}

SphereTreeNode.prototype.addChild = function(child)
{
    this.children.push(child);
    child.parent = this;
}

SphereTreeNode.prototype.intersects = function(sphereTreeNode)
{
    return (this.sphere.intersects(sphereTreeNode.sphere));    
}

function SphereHitRec()
{
    this.target = null;
    this.testList = [];
};

function BoundingTree()
{
    this.root = null;
    this.min = new Vector3D();
    this.max = new Vector3D();
    this.tris = [];
    this.visited = [];    
}

BoundingTree.prototype.setTriangles = function(tris, min, max)
{
    this.tris = tris.slice();
    this.min.copy(min);
    this.max.copy(max);
}

BoundingTree.prototype.setTransform = function(matrix)
{
}

SphereTree.prototype = new BoundingTree();
SphereTree.prototype.constructor = SphereTree;

function SphereTree()
{
    BoundingTree.call(this);
}

SphereTree.prototype.setTransform = function(matrix)
{
    if (this.root) this.transformNode(matrix, this.root);
}

SphereTree.prototype.transformNode = function(matrix, node)
{
    var result = matrix.transform(node.sphere.center.x, node.sphere.center.y, node.sphere.center.z, 1);
    node.sphere.xcenter.x = result.x;
    node.sphere.xcenter.y = result.y;
    node.sphere.xcenter.z = result.z;
    
    var scale = matrix.getScalingFactors();
    node.sphere.xradius = node.sphere.radius * max3(scale.x, scale.y, scale.z);
    
    // recurse on node children
    for (var i = 0; i < node.children.length; i++)
    {
        this.transformNode(matrix, node.children[i]);
    }
}

SphereTree.prototype.collides = function(tree)
{
    if (!this.root || !tree.root) // must be non-NULL
    {
        return false;
    }

    // check root nodes for collision
    if (this.nodesCollide(this.root, tree.root))
    {
        // if both root nodes are leaves, return true
        if (this.root.isLeaf() && tree.root.isLeaf())
        {
            return true;
        }

        // recursively check child nodes
        var sphereHit = new SphereHitRec();
        var sphereHits = [];
        if (tree.root.isLeaf())
        {
            sphereHit.target = tree.root;
            sphereHit.testList = this.root.children;
        }
        else
        {
            sphereHit.target = this.root;
            sphereHit.testList = tree.root.children;
        }       
        sphereHits.push(sphereHit);

        return this.testSphereHits(sphereHits);
    }
    
    // root nodes do not collide
    return false;
}

SphereTree.prototype.nodesCollide = function(node1, node2)
{
    return (node1.intersects(node2));    
}

SphereTree.prototype.testSphereHits = function(sphereHits)
{
    while (sphereHits.length > 0)
    {
        if (this.testSphereHit(sphereHits[0], sphereHits))
        {
            return true;
        }
        
        sphereHits.splice(0, 1);
    }

    return false;
}

SphereTree.prototype.testSphereHit = function(sphereHit, sphereHits)
{
    for (var i = 0; i < sphereHit.testList.length; i++)
    {
        if (this.nodesCollide(sphereHit.target, sphereHit.testList[i]))
        {
            var nextSphereHit = new SphereHitRec();
            nextSphereHit.target = sphereHit.testList[i];
            if (sphereHit.target.isLeaf())
            {
                nextSphereHit.testList.push(sphereHit.target);
            }
            else
            {
                nextSphereHit.testList = sphereHit.target.children;
            }
            sphereHits.push(nextSphereHit);

            // check for leaf collision
            if (sphereHit.target.isLeaf() && sphereHit.testList[i].isLeaf())
            {
                return true;
            }
        }
    }

    // no leaf collisions
    return false;
}

SphereTree.prototype.rayIntersectsTree = function(params)
{
    if (this.root)
    {
        this.visited.length = this.tris.length;
        for (var i=0; i < this.visited.length; i++)
        {
            this.visited[i] = false;
        }

        return this.rayIntersectsTreeNode(this.root, params);
    }

    return false;
}

SphereTree.prototype.rayIntersectsTreeNode = function(root, params)
{
    // if this sphere tree node has children, and it is intersected by the ray, 
    // recurse on all sphere tree nodes in the next level, saving the smallest positive 
    // t value; if ray does not intersect this sphere tree node, or if no intersections 
    // are found for the next level, return false
    if (root.children.length > 0)
    {
        // check if this sphere tree node is intersected by the ray
        if (this.rayIntersectsSphere(root, params) == false)
        {
            return false;
        }

        // sphere tree node is intersected by the ray, recurse on children nodes
        var childIntersects = false;
        for (var i=0; i < root.children.length; i++)
        {
            if (this.rayIntersectsTreeNode(root.children[i], params) == true)
            {
                childIntersects = true;
            }
        }

        if (childIntersects)
        {
            return true;
        }
        else // !childIntersects
        {
            return false;
        }
    }
    else // root.children.empty()
    {   
        // lowest sphere tree node level (no children); check against tris
        return this.rayIntersectsTriangleList(root.triIndices, params);
    }
}

SphereTree.prototype.rayIntersectsSphere = function(node, params)
{
    // transform sphere center by world-view transform
    var center = params.worldViewMatrix.transform(node.sphere.center.x, node.sphere.center.y, node.sphere.center.z, 1);

    // adjust sphere radius by scale factor
    var radius = node.sphere.radius * max3(params.scale.x, params.scale.y, params.scale.z);

    // test for ray-sphere intersection
    var roots = raySphereIntersection(params.rayOrigin, params.rayDir, center, radius);
    switch (roots.count)
    {
    case 2:
        // two intersection points; accept if one root is positive
        if (roots.root1 <= 0 && roots.root2 <= 0)
        {
            return false;
        }
        break;

    case 1:
        // one intersection point (ray grazes sphere); accept if root is positive
        if (roots.root1 <= 0)
        {
            return false;
        }
        break;

    case 0:
    default:
        // no intersection
        return false;
    }

    return true;
}

SphereTree.prototype.rayIntersectsTriangleList = function(triIndices, params)
{
    var distance, u, v;

    // determine closest triangle intersected by ray (closest to ray origin)
    for (var i=0; i < triIndices.length; i++)
    {
        var index = triIndices[i];

        // skip triangle if already tested
        if (this.visited[index] == true)
        {
            continue;
        }

        var tri = this.tris[index];

        // transform triangle vertices by world-view transform
        var v0 = params.worldViewMatrix.transform(tri.v0.x, tri.v0.y, tri.v0.z, 1);
        var v1 = params.worldViewMatrix.transform(tri.v1.x, tri.v1.y, tri.v1.z, 1);
        var v2 = params.worldViewMatrix.transform(tri.v2.x, tri.v2.y, tri.v2.z, 1);

        var result = rayTriangleIntersection(params.rayOrigin, params.rayDir, v0, v1, v2, false,
                                            (params.doubleSided ? false : true));
        if (result.result)
        {
            if (result.t >= params.nearDistance &&
                result.t <= params.farDistance && 
                result.t <  params.intersectRecord.distance)
            {
				var pointModel = new Vector3D(tri.v0.x * (1 - result.u - result.v) + tri.v1.x * result.u + tri.v2.x * result.v,
				                              tri.v0.y * (1 - result.u - result.v) + tri.v1.y * result.u + tri.v2.y * result.v,
				                              tri.v0.z * (1 - result.u - result.v) + tri.v1.z * result.u + tri.v2.z * result.v);				
				var pointWorld = params.worldMatrix.transform(pointModel.x, pointModel.y, pointModel.z, 1);
				var pointView = params.worldViewMatrix.transform(pointModel.x, pointModel.y, pointModel.z, 1);

				// test for intersection point on negative side of clip plane(s), if any (would hence be clipped)
				for (var c=0; c < params.clipPlanes.length; c++)
				{
					if (pointOnNegativeSideOfPlane(pointWorld, params.clipPlanes[c]))
					{
						// mark triangle as tested
						this.visited[index] = true;
						break;
					}
				}
				if (this.visited[index]) // clipped by clip plane(s)
				{
					continue;
				}

                params.intersectRecord.distance = result.t;
				params.intersectRecord.pointModel.copy(pointModel);
                params.intersectRecord.pointWorld.copy(pointWorld);
                params.intersectRecord.pointView.copy(pointView);
                params.intersectRecord.triIndex = index;
                params.intersects = true;
            }
        }

        // mark triangle as tested
        this.visited[index] = true;
    }
    
    return params.intersects;
}

Octree.prototype = new SphereTree();
Octree.prototype.constructor = Octree;

function Octree()
{
    SphereTree.call(this);
}

Octree.prototype.buildTree = function(levels)
{
    if (levels < 0) return;
    
    // define root sphere
    var root = new SphereTreeNode();
    
    // sphere center is the midpoint of min/max extents
    root.sphere.center.copy(midpoint(this.min, this.max));
    root.sphere.xcenter.copy(root.sphere.center);

    // sphere radius is the distance between the midpoint of min/max extents and min/max extent
    root.sphere.radius = distanceBetween(root.sphere.center, this.max);
    root.sphere.xradius = root.sphere.radius;
    
    // set triIndices
    root.triIndices.length = this.tris.length;
    for (var i=0; i < this.tris.length; i++)
    {
        root.triIndices[i] = i;
    }

    // build subsequent levels (if requested) 
    if (levels > 0)
    {
        this.buildTreeLevels(levels, this.min, this.max, root, root.triIndices);
    }

    this.root = root;    
}

Octree.prototype.buildTreeLevels = function(levels, min, max, root, triIndices)
{
    if (root.level == levels)
    {
        // requested levels have been generated
        return;
    }
    
    // define 8 equal sub-regions occupying the span from min to max
    var mid = new Vector3D(min.x + ((max.x - min.x) / 2), 
                           min.y + ((max.y - min.y) / 2),
                           min.z + ((max.z - min.z) / 2));
                           
    var regions = new Array(8);
    regions[0] = new Region(min.x, min.y, min.z, mid.x, mid.y, mid.z);
    regions[1] = new Region(mid.x, min.y, min.z, max.x, mid.y, mid.z);
    regions[2] = new Region(min.x, min.y, mid.z, mid.x, mid.y, max.z);
    regions[3] = new Region(mid.x, min.y, mid.z, max.x, mid.y, max.z);
    regions[4] = new Region(min.x, mid.y, min.z, mid.x, max.y, mid.z);
    regions[5] = new Region(mid.x, mid.y, min.z, max.x, max.y, mid.z);
    regions[6] = new Region(min.x, mid.y, mid.z, mid.x, max.y, max.z);
    regions[7] = new Region(mid.x, mid.y, mid.z, max.x, max.y, max.z);
    
    // for each sub-region containing geometry, create a bounding sphere for the sub-region, 
    // add to the list of the root sphere node's children, and recursively call for the child 
    // sub-region
    for (var i=0; i < 8; i++)
    {
        var triIndicesContainedByRegion = regions[i].containsGeometry(this.tris, triIndices);
        if (triIndicesContainedByRegion.length > 0)
        {
            // create sphere node
            var node = new SphereTreeNode();
          
            // set level
            node.level = root.level + 1;

            // set center
            node.sphere.center.copy(midpoint(regions[i].min, regions[i].max));
            node.sphere.xcenter.copy(node.sphere.center);

            // set radius
            node.sphere.radius = distanceBetween(node.sphere.center, regions[i].max);
            node.sphere.xradius = node.sphere.radius;
            
            // set triIndices
            node.triIndices = triIndicesContainedByRegion.slice();

            // add to root sphere node
            root.addChild(node);

            // recurse on sub-region
            this.buildTreeLevels(levels, regions[i].min, regions[i].max, node, node.triIndices);
        }
    }
}

function rayPick(tree,
                 rayOrigin, 
                 rayDir,
                 nearDistance,
                 farDistance,
                 worldMatrix,
                 viewMatrix,
                 scale,
                 doubleSided,
			     clipPlanes)
{
	var params = new RayIntersectParams(rayOrigin, rayDir, nearDistance, farDistance, worldMatrix, viewMatrix, scale, doubleSided, clipPlanes);
    tree.rayIntersectsTree(params);
    if (params.intersects == true)
    {
        return params.intersectRecord;
    }
    
    return null;
}
function Context()
{
    this.clear();
}

Context.prototype.clear = function()
{
    this.container = null;
    this.attribute = null;
    this.item = 0;
    this.containerName = "";
    this.attributeName = "";
}
var eRenderContextMethod =
{
	Unknown									: 0,
	
	ApplyModelViewTransform    				: 1,
    ApplyProjectionTransform				: 2,
    Clear           						: 3,
    ClearColor								: 4,
    ClearDepth                              : 5,
    ClearStencil                            : 6,
    CreateVertexBuffer					    : 7,
    CreateTextureObject 					: 8,
    Disable     							: 9,
    Enable  								: 10,
    Enabled	    							: 11,
    EnableLight								: 12,
    EnableTextureStage						: 13,
    Finish  								: 14,
    GetEnabledLights						: 15,
    GetGlobalIllumination					: 16,
    GetLight            					: 17,
    GetMaxLightCount    					: 18,
    GetMaxTextureStages						: 19,
    PerspectiveMatrixLH						: 20,
    OrthographicMatrixLH					: 21,
    SetBlendFactor							: 22,
    SetDepthFunc                            : 23,
    SetEnabledLights						: 24,
    SetFrontMaterial						: 25,
    SetGlobalIllumination					: 26,
    SetLight 			                    : 27,
    SetShadeModel                           : 28,
    SetStencilFunc                          : 29,
    SetStencilMask                          : 30,
    SetStencilOp                            : 31,
    SetTextureBlendFactor					: 32,
    SetTextureBlendOp						: 33,
    SetViewport						        : 34,
    VB_SetPrimitiveType                     : 35,
    VB_SetVertices                          : 36,
    VB_SetNormals                           : 37,
    VB_SetColors                            : 38,
    VB_SetUVCoords                          : 39,
    VB_SetTextureStage                      : 40,
    VB_Draw                                 : 41,
    TO_SetImage                             : 42,
    TO_SetImageData                         : 43,
    TO_SetVideo                             : 44,
    SetMatrixMode							: 45,
    PushMatrix								: 46,
    PopMatrix								: 47,
    LoadMatrix								: 48,
    LeftMultMatrix							: 49,
    RightMultMatrix							: 50
}

function RenderContextMethodDesc(method, params)
{
	this.method = method;
	this.params = params;
}

function DisplayListObj(renderContext)
{
    this.renderContext = renderContext;
    this.displayList = [];	
}

DisplayListObj.prototype.record_begin = function()
{
    this.clear();
    this.renderContext.setDisplayList(this);    
}

DisplayListObj.prototype.record_end = function()
{
    this.renderContext.setDisplayList(null);    
}

DisplayListObj.prototype.play = function()
{
    for (var i=0; i < this.displayList.length; i++)
    {
        this.invokeMethod(this.displayList[i]);
    }    
}

DisplayListObj.prototype.addMethodDesc = function(desc)
{
    this.displayList.push(desc);    
}

DisplayListObj.prototype.clear = function()
{
    this.displayList = [];    
}

DisplayListObj.prototype.invokeMethod = function(desc)
{  
    switch (desc.method)
    {
        case eRenderContextMethod.ApplyModelViewTransform:
        {
            this.renderContext.applyModelViewTransform();    
        }   
        break;
        
        case eRenderContextMethod.ApplyProjectionTransform:
        {
            this.renderContext.applyProjectionTransform();
        }   
        break;
        
        case eRenderContextMethod.Clear:
        {
            return this.renderContext.clear(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.ClearColor:
        {
            this.renderContext.clearColor(desc.params[0], desc.params[1], desc.params[2], desc.params[3]);
        }
        break;
        
        case eRenderContextMethod.ClearDepth:
        {
            this.renderContext.clearDepth(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.ClearStencil:
        {
            this.renderContext.clearStencil(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.CreateVertexBuffer:
        {
            return this.renderContext.createVertexBuffer(desc.params[0]);            
        }
        break;
        
        case eRenderContextMethod.CreateTextureObject:
        {
            this.renderContext.createTextureObject();    
        }
        break;
        
        case eRenderContextMethod.Disable:
        {
            this.renderContext.disable(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.Enable:
        {
            this.renderContext.enable(desc.params[0]);    
        }
        break;
        
        case eRenderContextMethod.Enabled:
        {
            return this.renderContext.enabled(desc.params[0]);    
        }
        break;
        
        case eRenderContextMethod.EnableLight:
        {
            this.renderContext.enableLight(desc.params[0], desc.params[1]);    
        }
        break;
        
        case eRenderContextMethod.EnableTextureStage:
        {
            this.renderContext.enableTextureStage(desc.params[0], desc.params[1]);    
        }
        break;
        
        case eRenderContextMethod.Finish:
        {
            this.renderContext.finish();        
        }
        break;
        
        case eRenderContextMethod.GetEnabledLights:
        {
            return this.renderContext.getEnabledLights();    
        }
        break;
        
        case eRenderContextMethod.GetGlobalIllumination:
        {
            return this.renderContext.getGlobalIllumination();    
        }
        break;
        
        case eRenderContextMethod.GetLight:
        {
            return this.renderContext.getLight(desc.params[0]);   
        }
        break;
            
        case eRenderContextMethod.GetMaxLightCount:
        {
            return this.renderContext.getMaxLightCount();   
        }
        break;
        
        case eRenderContextMethod.getMaxTextureStages:
        {
            return this.renderContext.getMaxTextureStages();
        }
        break;
        
        case eRenderContextMethod.PerspectiveMatrixLH:
        {
            this.renderContext.perspectiveMatrixLH(desc.params[0], desc.params[1], desc.params[2],
                desc.params[3], desc.params[4], desc.params[5]);   
        }
        break;
        
        case eRenderContextMethod.OrthographicMatrixLH:
        {
            this.renderContext.orthographicMatrixLH(desc.params[0], desc.params[1], desc.params[2],
                desc.params[3], desc.params[4], desc.params[5]);
        }
        break;
        
        case eRenderContextMethod.SetBlendFactor:
        {
            this.renderContext.setBlendFactor(desc.params[0], desc.params[1]);
        }
        break;

        case eRenderContextMethod.SetDepthFunc:
        {
            this.renderContext.setDepthFunc(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.SetEnabledLights:
        {
            this.renderContext.setEnabledLights(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.SetFrontMaterial:
        {
            this.renderContext.setFrontMaterial(desc.params[0]);    
        }
        break;
        
        case eRenderContextMethod.SetGlobalIllumination:
        {
            this.renderContext.setGlobalIllumination(desc.params[0]);    
        }
        break;
        
        case eRenderContextMethod.SetLight:
        {
            this.renderContext.setLight(desc.params[0], desc.params[1]);    
        }
        break;
        
        case eRenderContextMethod.SetShadeModel:
        {
            this.renderContext.setShadeModel(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.SetStencilFunc:
        {
            this.renderContext.setStencilFunc(desc.params[0], desc.params[1], desc.params[2]);
        }
        break;
                       
        case eRenderContextMethod.SetStencilMask:
        {
            this.renderContext.setStencilMask(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.SetStencilOp:
        {
            this.renderContext.setStencilOp(desc.params[0], desc.params[1], desc.params[2]);
        }
        break;
        
        case eRenderContextMethod.SetTextureBlendFactor:
        {
            this.renderContext.setTextureBlendFactor(desc.params[0]);   
        }
        break;
        
        case eRenderContextMethod.SetTextureBlendOp:
        {
            this.renderContext.setTextureBlendOp(desc.params[0]);    
        }
        break;
        
        case eRenderContextMethod.SetViewport:
        {
            this.renderContext.setViewport(desc.params[0], desc.params[1], desc.params[2],
                desc.params[3]);    
        }
        break;
        
        case eRenderContextMethod.VB_SetPrimitiveType:
        {
            desc.params[0].setPrimitiveType(desc.params[1]);
        }
        break;
        
        case eRenderContextMethod.VB_SetVertices:
        {
            desc.params[0].setVertices(desc.params[1]);
        }
        break;
        
        case eRenderContextMethod.VB_SetNormals:
        {
            desc.params[0].setNormals(desc.params[1]);
        }
        break;
        
        case eRenderContextMethod.VB_SetColors:
        {
            desc.params[0].setColors(desc.params[1]);
        }
        break;
        
        case eRenderContextMethod.VB_SetUVCoords:
        {
            desc.params[0].setUVCoords(desc.params[1], desc.params[2]);
        }
        break;
        
        case eRenderContextMethod.VB_SetTextureStage:
        {
            desc.params[0].setTextureStage(desc.params[1], desc.params[2], desc.params[3],
                desc.params[4], desc.params[5], desc.params[6]);
        }
        break;
        
        case eRenderContextMethod.VB_Draw:
        {
            desc.params[0].draw();
        }
        break;
        
        case eRenderContextMethod.TO_SetImage:
        {
            desc.params[0].setImage(desc.params[1], desc.params[2], desc.params[3]);   
        }
        break;
        
        case eRenderContextMethod.TO_SetImageData:
        {
            desc.params[0].setImageData(desc.params[1], desc.params[2], desc.params[3], 
                desc.params[4], desc.params[5]);
        }
        break;
        
        case eRenderContextMethod.TO_SetVideo:
        {
            desc.params[0].setVideo(desc.params[1]);
        }
        break;
        
        case eRenderContextMethod.SetMatrixMode:
        {
        	this.renderContext.setMatrixMode(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.PushMatrix:
        {
        	this.renderContext.pushMatrix();
        }
        break;
        
        case eRenderContextMethod.PopMatrix:
        {
        	this.renderContext.popMatrix();
        }
        break;
        
        case eRenderContextMethod.LoadMatrix:
        {
        	this.renderContext.loadMatrix(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.LeftMultMatrix:
        {
        	this.renderContext.leftMultMatrix(desc.params[0]);
        }
        break;
        
        case eRenderContextMethod.RightMultMatrix:
        {
        	this.renderContext.rightMultMatrix(desc.params[0]);
        }
        break;
    }
}

function DL_ADD_METHOD_DESC(dlObj, method, params)
{
    if (dlObj)
    {
        dlObj.addMethodDesc(new RenderContextMethodDesc(method, params));
    }    
}

/* 
 * enable caps 
 */
var eRenderMode =
{
    AlphaBlend              : 1,
    CullBackFace            : 2,
    DepthTest               : 3,
    DepthBufferWrite        : 4,
    Lighting                : 5,
    NormalizeNormals        : 6,
    Fog                     : 7,
    StencilTest             : 8,
    PolygonOffset_Fill      : 9,
    PolygonOffset_Line      : 10,
    PolygonOffset_Point     : 11
}
 
/*
 * depth func
 */
var eDepthFunc =
{
    Never                   : 1,
    Less                    : 2,
    LessEqual               : 3,
    Equal                   : 4,
    NotEqual                : 5,
    GreaterEqual            : 6,
    Greater                 : 7,
    Always                  : 8 
}

/*
 * stencil func
 */
var eStencilFunc =
{
    Never                   : 1,
    Less                    : 2,
    LessEqual               : 3,
    Equal                   : 4,
    NotEqual                : 5,
    GreaterEqual            : 6,
    Greater                 : 7,
    Always                  : 8 
}

/*
 * stencil op
 */
var eStencilOp = 
{
    Keep                    : 0,
    Replace                 : 1,
    Increment               : 2,
    Decrement               : 3,
    Invert                  : 4,
    Zero                    : 5    
}

/*
 * shade model
 */
var eShadeModel =
{
    Flat                    : 1,
    Gouraud                 : 2
}

var RC_BLEND            = 0x0001;
var RC_CULL_FACE        = 0x0B44;

/*
 * light desc
 */
var LIGHTDESC_POSITION_BIT          = 0x001;
var LIGHTDESC_DIRECTION_BIT         = 0x002;
var LIGHTDESC_AMBIENT_BIT           = 0x004;
var LIGHTDESC_DIFFUSE_BIT           = 0x008;
var LIGHTDESC_SPECULAR_BIT          = 0x010;
var LIGHTDESC_CONSTANT_ATT_BIT      = 0x020;
var LIGHTDESC_LINEAR_ATT_BIT        = 0x040;
var LIGHTDESC_QUADRATIC_ATT_BIT     = 0x080;
var LIGHTDESC_RANGE_BIT             = 0x100;
var LIGHTDESC_OUTER_CONE_DEG_BIT    = 0x200;
var LIGHTDESC_INNER_CONE_DEG_BIT    = 0x400;
var LIGHTDESC_CONE_FALLOFF_BIT      = 0x800;

function LightDesc()
{
    this.type = "";                     // required: "directional", "point", "spot"
    this.validMembersMask = 0;
    this.position = new Vector3D();     // point, spot
    this.direction = new Vector3D();    // directional, spot
    this.ambient = new Color();         // all types
    this.diffuse = new Color();         // all types
    this.specular = new Color();        // all types
    this.constantAttenuation = 0;       // all types
    this.linearAttenuation = 0;         // all types
    this.quadraticAttenuation = 0;      // all types
    this.range = 0;                     // point, spot
    this.outerConeDegrees = 0;          // spot
    this.innerConeDegrees = 0;          // spot
    this.coneFalloff = 0;               // spot
}

/* 
 * material desc 
 */
var MATERIALDESC_AMBIENT_BIT        = 0x001;
var MATERIALDESC_DIFFUSE_BIT        = 0x002;
var MATERIALDESC_SPECULAR_BIT       = 0x004;
var MATERIALDESC_EMISSIVE_BIT       = 0x008;
var MATERIALDESC_GLOSSINESS_BIT     = 0x010;
var MATERIALDESC_ALL_BITS           = 0x01F;

function MaterialDesc()
{
    this.validMembersMask = 0;
    this.ambient = new Color();
    this.diffuse = new Color();
    this.specular = new Color();
    this.emissive = new Color();
    this.glossiness = 0;

    this.copy = function(materialDesc)
    {
        if (materialDesc)
        {
            this.validMembersMask = materialDesc.validMembersMask;
            this.ambient.copy(materialDesc.ambient);
            this.diffuse.copy(materialDesc.diffuse);
            this.specular.copy(materialDesc.specular);
            this.emissive.copy(materialDesc.emissive);
            this.glossiness = materialDesc.glossiness;
        }
    }
}

/*
 * clear mask
 */
var RC_COLOR_BUFFER_BIT             = 0x001;
var RC_DEPTH_BUFFER_BIT             = 0x002;
var RC_STENCIL_BUFFER_BIT           = 0x004;

/*
 * blend factor
 */
var RC_ZERO                         = 0x001;    
var RC_ONE                          = 0x002;
var RC_SRC_COLOR                    = 0x004;
var RC_SRC_ALPHA                    = 0x008;
var RC_ONE_MINUS_SRC_COLOR          = 0x010;
var RC_ONE_MINUS_SRC_ALPHA          = 0x020;
var RC_DEST_COLOR                   = 0x040;
var RC_DEST_ALPHA                   = 0x080;
var RC_ONE_MINUS_DEST_COLOR         = 0x100;
var RC_ONE_MINUS_DEST_ALPHA         = 0x200;

/*
 * blend op
 */
var RC_MODULATE                     = 0x001;
var RC_REPLACE                      = 0x002;
var RC_BLEND                        = 0x004;
var RC_DECAL                        = 0x008;

/*
 * texture coordinate source
 */
var eTextureCoordSrc = 
{
    VertexUVs                       : 1,
    ViewSpaceVertexPosition         : 2,
    ViewSpaceReflectionVector       : 3
}
 
/*
 * texture wrap
 */
var RC_REPEAT                      = 0x2901;
var RC_CLAMP_TO_EDGE               = 0x812F;
var RC_MIRRORED_REPEAT             = 0x8370;

/*
 * matrix mode
 */
var RC_MODELVIEW				   = 0x001;
var RC_PROJECTION				   = 0x002;
var RC_TEXTURE					   = 0x004;

/*
 * render context
 */
function RenderContext(canvas, background)
{
    this.valid = false;
    
    this.canvas = canvas;
    this.background = background;
    
    this.projectionMatrixStack = new MatrixStack(new Matrix4x4());
    this.modelViewMatrixStack = new MatrixStack(new Matrix4x4());
    this.matrixMode = RC_MODELVIEW;
    
    this.frontMaterial = new MaterialDesc();
    
    this.displayListObj = null;
    
    this.getDisplayList = function()
    {
        return this.displayListObj;    
    }
    
    this.setDisplayList = function(displayListObj)
    {
        this.displayListObj = displayListObj;
    }
    
    this.getFrontMaterial = function()
    {
        var material = new MaterialDesc();
        material.copy(this.frontMaterial); 
        return material;             
    }

    this.setBackgroundImage = function(url, width, height)
    {
        if (this.background)
        {
            this.background.src = url;
            this.background.width = width;
            this.background.height = height;
        }
    }
    
    this.setMatrixMode = function(mode) 
    { 
    	if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetMatrixMode, [mode]);
    	
    	this.matrixMode = mode; 
    }
    
    this.pushMatrix = function()
    {
    	if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.PushMatrix, null);
    	
    	switch (this.matrixMode)
    	{
    		case RC_MODELVIEW:
    		{
    			this.modelViewMatrixStack.push();
    		}
    		break;
    		
    		case RC_PROJECTION:
    		{
    			this.projectionMatrixStack.push();
    		}
    		break;
    	}	
    }
    
    this.popMatrix = function()
    {
    	if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.PopMatrix, null);
    	
    	switch (this.matrixMode)
    	{
    		case RC_MODELVIEW:
    		{
    			this.modelViewMatrixStack.pop();
    		}
    		break;
    		
    		case RC_PROJECTION:
    		{
    			this.projectionMatrixStack.pop();
    		}
    		break;
    	}
    }
    
    this.loadMatrix = function(matrix)
    {
    	if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.LoadMatrix, [matrix]);
    	
    	switch (this.matrixMode)
    	{
    		case RC_MODELVIEW:
    		{
    			this.modelViewMatrixStack.loadMatrix(matrix);
    		}
    		break;
    		
    		case RC_PROJECTION:
    		{
    			this.projectionMatrixStack.loadMatrix(matrix);
    		}
    		break;
    	}	
    }
    
    this.leftMultMatrix = function(matrix)
    {
    	if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.LeftMultMatrix, [matrix]);
    	
    	switch (this.matrixMode)
    	{
    		case RC_MODELVIEW:
    		{
    			this.modelViewMatrixStack.leftMultiply(matrix);
    		}
    		break;
    		
    		case RC_PROJECTION:
    		{
    			this.projectionMatrixStack.leftMultiply(matrix);
    		}
    		break;
    	}
    }
    
    this.rightMultMatrix = function(matrix)
    {
    	if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.RightMultMatrix, [matrix]);
    	
    	switch (this.matrixMode)
    	{
    		case RC_MODELVIEW:
    		{
    			this.modelViewMatrixStack.rightMultiply(matrix);
    		}
    		break;
    		
    		case RC_PROJECTION:
    		{
    			this.projectionMatrixStack.rightMultiply(matrix);
    		}
    		break;
    	}	
    }
    
    this.setEnabled = function(cap, enabled)
    {
        if (enabled)
        {
            this.enable(cap);    
        }
        else
        {
            this.disable(cap);
        }
    }
}

function newRenderContext(api, canvas, background)
{
    var rc = null;
    
    switch (api)
    {
    case "webgl":
        {
            rc = new webglRC(canvas, background);
        }
        break;
    }

    // return rc if valid    
    return rc.valid ? rc : null;
}

var RENDERSTATE_TRANSFORM_BIT      = 0x001;
var RENDERSTATE_LIGHTING_BIT       = 0x002;
var RENDERSTATE_MATERIAL_BIT       = 0x004;
var RENDERSTATE_FOG_BIT            = 0x008;
var RENDERSTATE_CLIP_PLANE_BIT     = 0x010;
var RENDERSTATE_ZBUFFER_BIT		   = 0x020;
var RENDERSTATE_ALL_BITS           = 0x03F;

function RenderStateRec()
{
    this.projMatrix = new Matrix4x4();
    this.worldViewMatrix = new Matrix4x4();
    // TODO: textureMatrices
    this.lightIndices = [];
    this.lightStates = [];
    this.lightMatrices = [];
    this.lightingEnabled = false;
    this.materialDesc = new MaterialDesc();
    // TODO: fogParams
    this.fogEnabled = false;
    this.clipPlaneIndices = [];
    this.clipPlanes = [];
    this.clipPlaneMatrices = [];
    this.zBufferEnabled = false;
    this.zBufferWriteEnabled = false;
}

function RenderState(rc)
{
    this.renderContext = rc;

    this.stateStack = new Stack();
    
    this.push = function(mask)
    {
        var rec = this.getState(mask);
        this.stateStack.push(rec);
    }

    this.pop = function(mask)
    {
        if (this.stateStack.empty()) return;

        var rec = this.stateStack.top();
        this.setState(mask, rec);
        this.stateStack.pop();
    }

    this.getState = function(mask)
    {
        var rec = new RenderStateRec();

        if (mask & RENDERSTATE_TRANSFORM_BIT)
        {
            rec.projMatrix = this.renderContext.projectionMatrixStack.top();
            rec.worldViewMatrix = this.renderContext.modelViewMatrixStack.top();
        }

        if (mask & RENDERSTATE_LIGHTING_BIT)
        {
            rec.lightIndices = this.renderContext.getEnabledLights();
            for (var i = 0; i < rec.lightIndices.length; i++)
            {
                var light = this.renderContext.getLight(rec.lightIndices[i]);
                rec.lightStates[i] = light.desc;
                rec.lightMatrices[i] = light.matrix;
            }
            rec.lightingEnabled = this.renderContext.enabled(eRenderMode.Lighting);
        }

        if (mask & RENDERSTATE_MATERIAL_BIT)
        {
            rec.materialDesc = this.renderContext.getFrontMaterial();
        }

        if (mask & RENDERSTATE_FOG_BIT)
        {
        }

        if (mask & RENDERSTATE_CLIP_PLANE_BIT)
        {
        }

        if (mask & RENDERSTATE_ZBUFFER_BIT)
        {
            rec.zBufferEnabled = this.renderContext.enabled(eRenderMode.DepthTest);
            rec.zBufferWriteEnabled = this.renderContext.enabled(eRenderMode.DepthBufferWrite);
        }

        return rec;
    }

    this.setState = function(mask, rec)
    {
        if (mask & RENDERSTATE_TRANSFORM_BIT)
        {
            this.renderContext.projectionMatrixStack.loadMatrix(rec.projMatrix);
            this.renderContext.applyProjectionTransform();
            this.renderContext.modelViewMatrixStack.loadMatrix(rec.worldViewMatrix);
            this.renderContext.applyModelViewTransform();
        }

        if (mask & RENDERSTATE_LIGHTING_BIT)
        {
            // set light state for each set light within this state block
            for (var i = 0; i < rec.lightIndices.length; i++)
            {
                this.renderContext.modelViewMatrixStack.push(rec.lightMatrices[i]);
                this.renderContext.setLight(rec.lightIndices[i], rec.lightStates[i]);
                this.renderContext.modelViewMatrixStack.pop();
            }

            // set light state to disabled for lights set outside this state block
            this.renderContext.setEnabledLights(rec.lightIndices);

            // set current lighting enabled
            if (rec.lightingEnabled)
            {
                this.renderContext.enable(eRenderMode.Lighting);
            }
            else
            {
                this.renderContext.disable(eRenderMode.Lighting);
            }
        }

        if (mask & RENDERSTATE_MATERIAL_BIT)
        {
            this.renderContext.setFrontMaterial(rec.materialDesc);
        }

        if (mask & RENDERSTATE_FOG_BIT)
        {
        }

        if (mask & RENDERSTATE_CLIP_PLANE_BIT)
        {
        }

        if (mask & RENDERSTATE_ZBUFFER_BIT)
        {
            if (rec.zBufferEnabled)
            {
                this.renderContext.enable(eRenderMode.DepthTest);
            }
            else
            {
                this.renderContext.disable(eRenderMode.depthTest);
            }

            if (rec.zBufferWriteEnabled)
            {
                this.renderContext.enable(eRenderMode.DepthBufferWrite);
            }
            else
            {
                this.renderContext.disable(eRenderMode.DepthBufferWrite);
            }
        }
    }
}
var RC_POINTS                       = 0x0000;
var RC_LINES                        = 0x0001;
var RC_LINE_LOOP                    = 0x0002;
var RC_LINE_STRIP                   = 0x0003;
var RC_TRIANGLES                    = 0x0004;
var RC_TRIANGLE_STRIP               = 0x0005;
var RC_TRIANGLE_FAN                 = 0x0006;
    
function VertexBuffer()
{
    this.vertices = new Array();
    this.normals = new Array();
    this.colors = new Array();
    this.vertexCount = 0;
    this.numVerticesPerPrimitive = 0;
}
function TextureObject()
{
}
//Copyright (c) 2009 The Chromium Authors. All rights reserved.
//Use of this source code is governed by a BSD-style license that can be
//found in the LICENSE file.

// Various functions for helping debug WebGL apps.

WebGLDebugUtils = function() {

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Which arguements are enums.
 * @type {!Object.<number, string>}
 */
var glValidEnumContexts = {

  // Generic setters and getters

  'enable': { 0:true },
  'disable': { 0:true },
  'getParameter': { 0:true },

  // Rendering

  'drawArrays': { 0:true },
  'drawElements': { 0:true, 2:true },

  // Shaders

  'createShader': { 0:true },
  'getShaderParameter': { 1:true },
  'getProgramParameter': { 1:true },

  // Vertex attributes

  'getVertexAttrib': { 1:true },
  'vertexAttribPointer': { 2:true },

  // Textures

  'bindTexture': { 0:true },
  'activeTexture': { 0:true },
  'getTexParameter': { 0:true, 1:true },
  'texParameterf': { 0:true, 1:true },
  'texParameteri': { 0:true, 1:true, 2:true },
  'texImage2D': { 0:true, 2:true, 6:true, 7:true },
  'texSubImage2D': { 0:true, 6:true, 7:true },
  'copyTexImage2D': { 0:true, 2:true },
  'copyTexSubImage2D': { 0:true },
  'generateMipmap': { 0:true },

  // Buffer objects

  'bindBuffer': { 0:true },
  'bufferData': { 0:true, 2:true },
  'bufferSubData': { 0:true },
  'getBufferParameter': { 0:true, 1:true },

  // Renderbuffers and framebuffers

  'pixelStorei': { 0:true, 1:true },
  'readPixels': { 4:true, 5:true },
  'bindRenderbuffer': { 0:true },
  'bindFramebuffer': { 0:true },
  'checkFramebufferStatus': { 0:true },
  'framebufferRenderbuffer': { 0:true, 1:true, 2:true },
  'framebufferTexture2D': { 0:true, 1:true, 2:true },
  'getFramebufferAttachmentParameter': { 0:true, 1:true, 2:true },
  'getRenderbufferParameter': { 0:true, 1:true },
  'renderbufferStorage': { 0:true, 1:true },

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': { 0:true },
  'depthFunc': { 0:true },
  'blendFunc': { 0:true, 1:true },
  'blendFuncSeparate': { 0:true, 1:true, 2:true, 3:true },
  'blendEquation': { 0:true },
  'blendEquationSeparate': { 0:true, 1:true },
  'stencilFunc': { 0:true },
  'stencilFuncSeparate': { 0:true, 1:true },
  'stencilMaskSeparate': { 0:true },
  'stencilOp': { 0:true, 1:true, 2:true },
  'stencilOpSeparate': { 0:true, 1:true, 2:true, 3:true },

  // Culling

  'cullFace': { 0:true },
  'frontFace': { 0:true },
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? name :
      ("*UNKNOWN WebGL ENUM");// (0x" + value.toString(16) + ")");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */ 
function glFunctionArgToString(functionName, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    if (funcInfo[argumentIndex]) {
      return glEnumToString(value);
    }
  }
  return value.toString();
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 */
function makeDebugContext(ctx, opt_onErrorFunc) {
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        for (var ii = 0; ii < args.length; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') + 
              glFunctionArgToString(functionName, ii, args[ii]);
        }
        log("WebGL error "+ glEnumToString(err) + " in "+ functionName +
            "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      var result = ctx[functionName].apply(ctx, arguments);
      var err = ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
      wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
     } else {
       wrapper[propertyName] = ctx[propertyName];
     }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow[err]) {
        glErrorShadow[err] = false;
        return err;
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

return {
  /**
   * Initializes this module. Safe to call more than once.
   * @param {!WebGLRenderingContext} ctx A WebGL context. If
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
   *   
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to" +
   *            funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   */
  'makeDebugContext': makeDebugContext
};

}();


function gl_LightSourceParameters()
{
    var enabled;
    var ambient;
    var diffuse;
    var specular;
    var position;
    var spotDirection;
    var spotExponent;
    var spotCutoff;
    var constantAttenuation;
    var linearAttenuation;
    var quadraticAttenuation;
}

var gl_MaxLights = 8;

function gl_MaterialParameters()
{
    var ambient;
    var diffuse;
    var specular;
    var emission;
    var shininess; 
}

var gl_MaxTextureStages = 2;

webglRC.prototype = new RenderContext();
webglRC.prototype.constructor = webglRC;

function webglRC(canvas, background)
{
    //
    // initialization
    //
    
    RenderContext.call(this, canvas, background);
    
    var gl = getWebGLContext(canvas, false /*set to true for debug context*/);
    if (!gl) return;

    gl.clearColor(0, 0, 0, background ? 0 : 1);
    gl.clearDepth(1);
    gl.clearStencil(0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.disable(gl.STENCIL_TEST);
    gl.frontFace(gl.CW);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
   
    // create shaders
    var shaders = getShaders(gl, eShaderType.VertexLighting);
    if (!shaders.vertex || !shaders.fragment) return;

    // create program
    var program = getProgram(gl, shaders.vertex, shaders.fragment);
    if (!program) return;

    // set valid flag
    this.valid = true;

    // misc private members
    var vLightDescs = [];
    var vLightMatrices = [];
    var vLightEnabledStates = [];
    
    //
    // methods
    //
    
    this.applyModelViewTransform = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.ApplyModelViewTransform, null);
        
        gl.uniformMatrix4fv(program.modelViewMatrix, false, new Float32Array(this.modelViewMatrixStack.top().flatten()));

        var normalMatrix = new Matrix4x4();
        normalMatrix.loadMatrix(this.modelViewMatrixStack.top());
        normalMatrix.invert();
        normalMatrix.transpose();
        gl.uniformMatrix4fv(program.normalMatrix, false, new Float32Array(normalMatrix.flatten()));
    }
    
    this.applyProjectionTransform = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.ApplyProjectionTransform, null);
        
        gl.uniformMatrix4fv(program.projectionMatrix, false, new Float32Array(this.projectionMatrixStack.top().flatten()));
    }
    
    this.clear = function(mask)
    {
        mask = mask || (RC_COLOR_BUFFER_BIT | RC_DEPTH_BUFFER_BIT);
        
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.Clear, [mask]);
        
        gl.clear((mask & RC_COLOR_BUFFER_BIT   ? gl.COLOR_BUFFER_BIT   : 0) |
                 (mask & RC_DEPTH_BUFFER_BIT   ? gl.DEPTH_BUFFER_BIT   : 0) |
                 (mask & RC_STENCIL_BUFFER_BIT ? gl.STENCIL_BUFFER_BIT : 0));
    }

    this.clearColor = function(r, g, b, a)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.ClearColor, [r, g, b, a]);
        
        gl.clearColor(r, g, b, a);
    }
    
    this.clearDepth = function(d)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.ClearDepth, [d]);
        
        gl.clearDepth(d);
    }
    
    this.clearStencil = function(s)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.ClearStencil, [s]);
        
        gl.clearStencil(s);  
    }
    
    this.createVertexBuffer = function(numVerticesPerPrimitive)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.CreateVertexBuffer, [numVerticesPerPrimitive]);
        
        return new webglVB(this, gl, program, numVerticesPerPrimitive);
    }
    
    this.createTextureObject = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.CreateTextureObject, null);
        
        return new webglTO(this, gl, program);
    }

    this.disable = function(cap)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.Disable, [cap]);
        
        switch (cap)
        {
            case eRenderMode.AlphaBlend:
                gl.disable(gl.BLEND);
                break;

            case eRenderMode.CullBackFace:
                gl.disable(gl.CULL_FACE);
                break;

            case eRenderMode.DepthBufferWrite:
                gl.depthMask(false);
                break;

            case eRenderMode.DepthTest:
                gl.disable(gl.DEPTH_TEST);
                break;

            case eRenderMode.Lighting:
                gl.uniform1i(program.lightingEnabled, false); 
                break;
                
            case eRenderMode.StencilTest:
                gl.disable(gl.STENCIL_TEST);
                break;
        }
    }

    this.enable = function(cap)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.Enable, [cap]);
        
        switch (cap)
        {
            case eRenderMode.AlphaBlend:
                gl.enable(gl.BLEND);
                break;

            case eRenderMode.CullBackFace:
                gl.enable(gl.CULL_FACE);
                break;

            case eRenderMode.DepthBufferWrite:
                gl.depthMask(true);
                break;

            case eRenderMode.DepthTest:
                gl.enable(gl.DEPTH_TEST);
                break;

            case eRenderMode.Lighting:
                gl.uniform1i(program.lightingEnabled, true);
                break;
                
            case eRenderMode.StencilTest:
                gl.enable(gl.STENCIL_TEST);
                break;
        }
    }

    this.enabled = function(cap)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.Enabled, [cap]);
        
        var e = false;

        switch (cap)
        {
            case eRenderMode.AlphaBlend:
                e = gl.getParameter(gl.BLEND);
                break;

            case eRenderMode.CullBackFace:
                e = gl.getParameter(gl.CULL_FACE);
                break;
                
            case eRenderMode.DepthBufferWrite:
                e = gl.getParameter(gl.DEPTH_WRITEMASK);
                break;

            case eRenderMode.DepthTest:
                e = gl.getParameter(gl.DEPTH_TEST);
                break;

            case eRenderMode.Lighting:
                e = gl.getUniform(program, program.lightingEnabled);
                break;
                
            case eRenderMode.StencilTest:
                e = gl.getParameter(gl.STENCIL_TEST);
                break;
        }

        return e;
    }

    this.enableLight = function(index, enable)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.EnableLight, [index, enable]);
        
        gl.uniform1i(program.lightSource[index].enabled, enable);

        vLightEnabledStates[index] = enable;
    }
    
    this.enableTextureStage = function(stage, enable)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.EnableTextureStage, [stage, enable]);
        
        gl.uniform1i(program.textureStageEnabled[stage], enable);
    }
    
    this.finish = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.Finish, null);
        
        gl.finish();
    }

    this.getEnabledLights = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.GetEnabledLights, null);
        
        var indices = [];

        for (var i = 0; i < vLightEnabledStates.length; i++)
        {
            if (vLightEnabledStates[i])
            {
                indices.push(i);
            }
        }

        return indices;
    }

    this.getGlobalIllumination = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.GetGlobalIllumination, null);
        
        var values = gl.getUniform(program, program.globalAmbientLight);

        return { r: values[0], g: values[1], b: values[2], a: values[3] };
    }
    
    this.getLight = function(index)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.GetLight, [index]);
        
        return { desc: vLightDescs[index], matrix: vLightMatrices[index] };
    }
    
    this.getMaxLightCount = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.GetMaxLightCount, null);
        
        return gl_MaxLights;
    }
    
    this.getMaxTextureStages = function()
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.GetMaxTextureStages, null);
        
        return gl_MaxTextureStages;
    }
    
    this.perspectiveMatrixLH = function(left, right, top, bottom, near, far)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.PerspectiveMatrixLH, [left, right, top, bottom, near, far]);
        
        var p = new Matrix4x4();
        
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = (far + near) / (far - near);
        var d = (2 * far * near) / (far - near);
        
        p._11 = (2 * near) / (right - left);
        p._13 = a;
        p._22 = (2 * near) / (top - bottom);
        p._23 = b;
        p._33 = c;
        p._34 = 1;
        p._43 = -d;
        p._44 = 0;
        
        return p;
    }
    
    this.orthographicMatrixLH = function(left, right, top, bottom, near, far)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.OrthographicMatrixLH, [left, right, top, bottom, near, far]);
        
        var p = new Matrix4x4();
        
        p._11 =  2 / (right - left);
        p._22 =  2 / (top - bottom);
        p._33 = -2 / (far - near);
        p._41 = -((right + left) / (right - left));
        p._42 = -((top + bottom) / (top - bottom));
        p._43 = -((far + near) / (far - near)) / 2;
              
        return p;
    }
    
    this.readFrameBuffer = function(x, y, width, height)
    {
        var pixels = new Uint8Array(width * height * 4);
        
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        
        return pixels;
    }
    
    this.setBlendFactor = function(sfactor, dfactor)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetBlendFactor, [sfactor, dfactor]);
        
        var gl_SrcFactor;
        switch (sfactor)
        {
        case RC_ZERO:                   gl_SrcFactor = gl.ZERO; break;
        case RC_ONE:                    gl_SrcFactor = gl.ONE; break;
        case RC_SRC_COLOR:              gl_SrcFactor = gl.SRC_COLOR; break;
        case RC_SRC_ALPHA:              gl_SrcFactor = gl.SRC_ALPHA; break;        
        case RC_ONE_MINUS_SRC_COLOR:    gl_SrcFactor = gl.ONE_MINUS_SRC_COLOR; break;
        case RC_ONE_MINUS_SRC_ALPHA:    gl_SrcFactor = gl.ONE_MINUS_SRC_ALPHA; break;
        case RC_DEST_COLOR:             gl_SrcFactor = gl.DEST_COLOR; break;
        case RC_DEST_ALPHA:             gl_SrcFactor = gl.DEST_ALPHA; break;        
        case RC_ONE_MINUS_DEST_COLOR:   gl_SrcFactor = gl.ONE_MINUS_DEST_COLOR; break;
        case RC_ONE_MINUS_DEST_ALPHA:   gl_SrcFactor = gl.ONE_MINUS_DEST_ALPHA; break;
        }     
        
        var gl_DestFactor;
        switch (dfactor)
        {
        case RC_ZERO:                   gl_DestFactor = gl.ZERO; break;
        case RC_ONE:                    gl_DestFactor = gl.ONE; break;
        case RC_SRC_COLOR:              gl_DestFactor = gl.SRC_COLOR; break;
        case RC_SRC_ALPHA:              gl_DestFactor = gl.SRC_ALPHA; break;        
        case RC_ONE_MINUS_SRC_COLOR:    gl_DestFactor = gl.ONE_MINUS_SRC_COLOR; break;
        case RC_ONE_MINUS_SRC_ALPHA:    gl_DestFactor = gl.ONE_MINUS_SRC_ALPHA; break;
        case RC_DEST_COLOR:             gl_DestFactor = gl.DEST_COLOR; break;
        case RC_DEST_ALPHA:             gl_DestFactor = gl.DEST_ALPHA; break;        
        case RC_ONE_MINUS_DEST_COLOR:   gl_DestFactor = gl.ONE_MINUS_DEST_COLOR; break;
        case RC_ONE_MINUS_DEST_ALPHA:   gl_DestFactor = gl.ONE_MINUS_DEST_ALPHA; break;
        }
        
        gl.blendFunc(gl_SrcFactor, gl_DestFactor);  
    }

    this.setDepthFunc = function(func)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetDepthFunc, [func]);
        
        var gl_DepthFunc;
        switch (func)
        {
        case eDepthFunc.Never:          gl_DepthFunc = gl.NEVER; break;
        case eDepthFunc.Less:           gl_DepthFunc = gl.LESS; break;
        case eDepthFunc.LessEqual:      gl_DepthFunc = gl.LEQUAL; break;
        case eDepthFunc.Equal:          gl_DepthFunc = gl.EQUAL; break;
        case eDepthFunc.NotEqual:       gl_DepthFunc = gl.NOTEQUAL; break;
        case eDepthFunc.GreaterEqual:   gl_DepthFunc = gl.GEQUAL; break;
        case eDepthFunc.Greater:        gl_DepthFunc = gl.GREATER; break;
        case eDepthFunc.Always:         gl_DepthFunc = gl.ALWAYS; break;
        }
        
        gl.depthFunc(gl_DepthFunc);
           
    }
    
    this.setEnabledLights = function(indices)
    {
        if (this.displayListObj) if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetEnabledLights, [indices]);
        
        // disable all previously enabled lights
        for (var i = 0; i < vLightEnabledStates.length; i++)
        {
            if (vLightEnabledStates[i])
            {
                this.enableLight(i, false);
            }
        }

        // enable specified lights
        for (var i = 0; i < indices.length; i++)
        {
            this.enableLight(indices[i], true);
        }
    }
    
    this.setFrontMaterial = function(desc)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetFrontMaterial, [desc]);
        
        // ambient
        if (desc.validMembersMask & MATERIALDESC_AMBIENT_BIT)
        {
            gl.uniform4fv(program.frontMaterial.ambient, new Float32Array(desc.ambient.v()));
            
            this.frontMaterial.ambient = desc.ambient;
        }
        
        // diffuse
        if (desc.validMembersMask & MATERIALDESC_DIFFUSE_BIT)
        {
            gl.uniform4fv(program.frontMaterial.diffuse, new Float32Array(desc.diffuse.v()));
            
            this.frontMaterial.diffuse = desc.diffuse;
        }
        
        // specular
        if (desc.validMembersMask & MATERIALDESC_SPECULAR_BIT)
        {
            gl.uniform4fv(program.frontMaterial.specular, new Float32Array(desc.specular.v()));
            
            this.frontMaterial.specular = desc.specular;
        }
        
        // emissive
        if (desc.validMembersMask & MATERIALDESC_EMISSIVE_BIT)
        {
            // TODO
            //gl.uniform4fv(program.frontMaterial.emission, new Float32Array(desc.emissive.v()));
            
            this.frontMaterial.emissive = desc.emissive;
        }
        
        // glossiness
        if (desc.validMembersMask & MATERIALDESC_GLOSSINESS_BIT)
        {
            // glossiness - OpenGL accepts values in the range [0, 128].
            // use the range [5, 128], because values below 5 result in wash-out
            gl.uniform1f(program.frontMaterial.shininess, clamp(desc.glossiness * 128, 5, 128));
            
            this.frontMaterial.glossiness = desc.glossiness;
        }
        
        this.frontMaterial.validMembersMask |= desc.validMembersMask;
    }

    this.setGlobalIllumination = function(ambient)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetGlobalIllumination, [ambient]);
        
        var values = [ ambient.r, ambient.g, ambient.g, ambient.a ];

        gl.uniform4fv(program.globalAmbientLight, new Float32Array(values));
    }

    this.setLight = function(index, desc)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetLight, [index, desc]);
        
        // get current modelView transform
        var modelViewMatrix = this.modelViewMatrixStack.top();

        // position
        if (desc.validMembersMask & LIGHTDESC_POSITION_BIT)
        {
            // transform to view space
            var position = modelViewMatrix.transformw(desc.position.x, desc.position.y, desc.position.z, 1);
            var values = [position.x, position.y, position.z, position.w];
            gl.uniform4fv(program.lightSource[index].position, new Float32Array(values));
        }

        // direction
        if (desc.validMembersMask & LIGHTDESC_DIRECTION_BIT)
        {
            // transform to view space
            var direction = modelViewMatrix.transform(desc.direction.x, desc.direction.y, desc.direction.z, 0);
            var values = [direction.x, direction.y, direction.z, 0];

            switch (desc.type)
            {
                case "directional":
                    {
                        values[0] *= -1;
                        values[1] *= -1;
                        values[2] *= -1;

                        // OpenGL gets a directional light's direction from position member                
                        gl.uniform4fv(program.lightSource[index].position, new Float32Array(values));
                    }
                    break;

                case "spot":
                    {
                        gl.uniform4fv(program.lightSource[index].spotDirection, new Float32Array(values));
                    }
                    break;
            }
        }

        // ambient
        if (desc.validMembersMask & LIGHTDESC_AMBIENT_BIT)
        {
            gl.uniform4fv(program.lightSource[index].ambient, new Float32Array(desc.ambient.v()));
        }

        // diffuse
        if (desc.validMembersMask & LIGHTDESC_DIFFUSE_BIT)
        {
            gl.uniform4fv(program.lightSource[index].diffuse, new Float32Array(desc.diffuse.v()));
        }

        // specular
        if (desc.validMembersMask & LIGHTDESC_SPECULAR_BIT)
        {
            gl.uniform4fv(program.lightSource[index].specular, new Float32Array(desc.specular.v()));
        }

        // constant attenuation
        if (desc.validMembersMask & LIGHTDESC_CONSTANT_ATT_BIT)
        {
            gl.uniform1f(program.lightSource[index].constantAttenuation, desc.constantAttenuation);
        }

        // linear attenuation
        if (desc.validMembersMask & LIGHTDESC_LINEAR_ATT_BIT)
        {
            gl.uniform1f(program.lightSource[index].linearAttenuation, desc.linearAttenuation);
        }

        // quadratic attenuation
        if (desc.validMembersMask & LIGHTDESC_QUADRATIC_ATT_BIT)
        {
            gl.uniform1f(program.lightSource[index].quadraticAttenuation, desc.quadraticAttenuation);
        }

        // range
        if (desc.validMembersMask & LIGHTDESC_RANGE_BIT)
        {
            // TODO
            //gl.uniform1f(program.lightSource[index].range, desc.range);
        }

        // outer cone angle
        if (desc.validMembersMask & LIGHTDESC_OUTER_CONE_DEG_BIT)
        {
            var outerConeDegrees = desc.outerConeDegrees;

            // OpenGL accepts cone degrees in the range [0, 90] or 180
            if (outerConeDegrees > 90)
            {
                outerConeDegrees = 180;
            }

            gl.uniform1f(program.lightSource[index].spotCutoff, outerConeDegrees);

            gl.uniform1f(program.lightSource[index].spotExponent, 0);
        }

        // inner cone angle
        if (desc.validMembersMask & LIGHTDESC_INNER_CONE_DEG_BIT)
        {
            // TODO
        }

        // cone falloff
        if (desc.validMembersMask & LIGHTDESC_CONE_FALLOFF_BIT)
        {
            // TODO
        }

        vLightDescs[index] = desc;
        vLightMatrices[index] = modelViewMatrix;
    }

    this.setShadeModel = function(model)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetShadeModel, [model]);
        
        // TODO
    }
    
    this.setStencilFunc = function(func, ref, mask)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetStencilFunc, [func, ref, mask]);
        
        var gl_StencilFunc;
        switch (func)
        {
        case eDepthFunc.Never:          gl_StencilFunc = gl.NEVER; break;
        case eDepthFunc.Less:           gl_StencilFunc = gl.LESS; break;
        case eDepthFunc.LessEqual:      gl_StencilFunc = gl.LEQUAL; break;
        case eDepthFunc.Equal:          gl_StencilFunc = gl.EQUAL; break;
        case eDepthFunc.NotEqual:       gl_StencilFunc = gl.NOTEQUAL; break;
        case eDepthFunc.GreaterEqual:   gl_StencilFunc = gl.GEQUAL; break;
        case eDepthFunc.Greater:        gl_StencilFunc = gl.GREATER; break;
        case eDepthFunc.Always:         gl_StencilFunc = gl.ALWAYS; break;
        }
        
        gl.stencilFunc(gl_StencilFunc, ref, mask);
    }
            
    this.setStencilMask = function(mask)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetStencilMask, [mask]);
        
        gl.stencilMask(mask);
    } 
    
    this.setStencilOp = function(fail, zFail, zPass)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetStencilOp, [fail, zFail, zPass]);
       
        var gl_Fail;
        switch (fail)
        {
        case eStencilOp.Keep:           gl_Fail = gl.KEEP; break;
        case eStencilOp.Replace:        gl_Fail = gl.REPLACE; break;
        case eStencilOp.Increment:      gl_Fail = gl.INCR; break;
        case eStencilOp.Decrement:      gl_Fail = gl.DECR; break;
        case eStencilOp.Invert:         gl_Fail = gl.INVERT; break;
        case eStencilOp.Zero:           gl_Fail = gl.ZERO; break;
        }
        
        switch (zFail)
        {
        case eStencilOp.Keep:           gl_ZFail = gl.KEEP; break;
        case eStencilOp.Replace:        gl_ZFail = gl.REPLACE; break;
        case eStencilOp.Increment:      gl_ZFail = gl.INCR; break;
        case eStencilOp.Decrement:      gl_ZFail = gl.DECR; break;
        case eStencilOp.Invert:         gl_ZFail = gl.INVERT; break;
        case eStencilOp.Zero:           gl_ZFail = gl.ZERO; break;
        }
        
        switch (zPass)
        {
        case eStencilOp.Keep:           gl_ZPass = gl.KEEP; break;
        case eStencilOp.Replace:        gl_ZPass = gl.REPLACE; break;
        case eStencilOp.Increment:      gl_ZPass = gl.INCR; break;
        case eStencilOp.Decrement:      gl_ZPass = gl.DECR; break;
        case eStencilOp.Invert:         gl_ZPass = gl.INVERT; break;
        case eStencilOp.Zero:           gl_ZPass = gl.ZERO; break;
        }
        
        gl.stencilOp(gl_Fail, gl_ZFail, gl_ZPass);
    }
    
    this.setTextureBlendFactor = function(factor)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetTextureBlendFactor, [factor]);
        
        // update material diffuse component alpha to blend factor
        var diffuse = [ this.frontMaterial.diffuse.r, this.frontMaterial.diffuse.g, this.frontMaterial.diffuse.b, factor ];
        gl.uniform4fv(program.frontMaterial.diffuse, new Float32Array(diffuse));
    }
    
    this.setTextureBlendOp = function(op)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetTextureBlendOp, [op]);
        
        gl.uniform1i(program.textureBlendOp, op);
    }

    this.setViewport = function(x, y, width, height)
    {
        if (this.displayListObj) DL_ADD_METHOD_DESC(this.displayListObj, eRenderContextMethod.SetViewport, [x, y, width, height]);
        
        gl.viewport(x, y, width, height);
    }
}

function getWebGLContext(canvas, debug) 
{
    var gl = null;
    try 
    {
        if (debug)
        {
            gl = WebGLDebugUtils.makeDebugContext(canvas.getContext("experimental-webgl", { stencil: true, antialias: false, preserveDrawingBuffer: true }));
        }
        else // !debug
        {
            gl = (canvas.getContext("webgl", { stencil: true, antialias: true, preserveDrawingBuffer: true }) || 
                  canvas.getContext("experimental-webgl", { stencil: true, antialias: true, preserveDrawingBuffer: true }));
        }
    }    
    catch (e) 
    {
    }
    if (!gl) 
    {
        var div = document.createElement("div");
        div.innerHTML = "This demo requires a WebGL-enabled browser.";
        var canvasParent = canvas.parentNode;
        canvasParent.replaceChild(div, canvas);
    }

    return gl;
}

function getProgram(gl, vShader, fShader)
{
    var program = gl.createProgram();
    if (!program) return null;
    
    gl.attachShader(program, vShader);
    gl.attachShader(program, fShader);
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        alert(gl.getProgramInfoLog(program));
        return null;
    }
    
    gl.useProgram(program);
    
    // get attributes
    program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
    gl.enableVertexAttribArray(program.vertexPositionAttribute);
    program.vertexNormalAttribute = gl.getAttribLocation(program, "aVertexNormal");
    gl.enableVertexAttribArray(program.vertexNormalAttribute);
    program.vertexColorAttribute = gl.getAttribLocation(program, "aVertexColor");
    gl.enableVertexAttribArray(program.vertexColorAttribute);
    program.textureCoordAttribute = new Array(gl_MaxTextureStages);
    for (var i=0; i < gl_MaxTextureStages; i++)
    {
        program.textureCoordAttribute[i] = gl.getAttribLocation(program, "aTextureCoord" + i);
        gl.enableVertexAttribArray(program.textureCoordAttribute[i]);
    }
    
    // get uniforms
    
    // matrices
    program.projectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");
    program.modelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
    program.normalMatrix = gl.getUniformLocation(program, "uNormalMatrix");

    // lights
    program.globalAmbientLight = gl.getUniformLocation(program, "uGlobalAmbientLight");
    program.lightSource = new Array(gl_MaxLights);
    for (var i=0; i < gl_MaxLights; i++)
    {
        program.lightSource[i] = new gl_LightSourceParameters();
      
        program.lightSource[i].enabled = gl.getUniformLocation(program, "uLightSource_enabled[" + i + "]");
        program.lightSource[i].ambient = gl.getUniformLocation(program, "uLightSource_ambient[" + i + "]"); 
        program.lightSource[i].diffuse = gl.getUniformLocation(program, "uLightSource_diffuse[" + i + "]");
        program.lightSource[i].specular = gl.getUniformLocation(program, "uLightSource_specular[" + i + "]");
        program.lightSource[i].position = gl.getUniformLocation(program, "uLightSource_position[" + i + "]");
        program.lightSource[i].spotDirection = gl.getUniformLocation(program, "uLightSource_spotDirection[" + i + "]");
        program.lightSource[i].spotExponent = gl.getUniformLocation(program, "uLightSource_spotExponent[" + i + "]");
        program.lightSource[i].spotCutoff = gl.getUniformLocation(program, "uLightSource_spotCutoff[" + i + "]");
        program.lightSource[i].constantAttenuation = gl.getUniformLocation(program, "uLightSource_constantAttenuation[" + i + "]");
        program.lightSource[i].linearAttenuation = gl.getUniformLocation(program, "uLightSource_linearAttenuation[" + i + "]");
        program.lightSource[i].quadraticAttenuation = gl.getUniformLocation(program, "uLightSource_quadraticAttenuation[" + i + "]");
        
        // set initially disabled
        gl.uniform1i(program.lightSource[i].enabled, 0);
    }
    
    // materials
    program.frontMaterial = new gl_MaterialParameters();
    program.frontMaterial.ambient = gl.getUniformLocation(program, "uFrontMaterial_ambient");
    program.frontMaterial.diffuse = gl.getUniformLocation(program, "uFrontMaterial_diffuse");
    program.frontMaterial.specular = gl.getUniformLocation(program, "uFrontMaterial_specular");
    program.frontMaterial.emission = gl.getUniformLocation(program, "uFrontMaterial_emission");
    program.frontMaterial.shininess = gl.getUniformLocation(program, "uFrontMaterial_shininess");
     
    // textures
    program.textureSamplerColor = new Array(gl_MaxTextureStages);
    program.textureSamplerAlpha = new Array(gl_MaxTextureStages);
    program.textureStageEnabled = new Array(gl_MaxTextureStages)
    for (var i=0; i < gl_MaxTextureStages; i++)
    {
        program.textureSamplerColor[i] = gl.getUniformLocation(program, "uTextureSamplerColor[" + i + "]");
        program.textureSamplerAlpha[i] = gl.getUniformLocation(program, "uTextureSamplerAlpha[" + i + "]");
        program.textureStageEnabled[i] = gl.getUniformLocation(program, "uTextureStageEnabled[" + i + "]");
    }
    program.textureBlendOp = gl.getUniformLocation(program, "uTextureBlendOp");
    
    // enabled
    program.lightingEnabled = gl.getUniformLocation(program, "uLightingEnabled");
    program.texturesEnabled = gl.getUniformLocation(program, "uTexturesEnabled");
    
    // set initially enabled/disabled
    gl.uniform1i(program.lightingEnabled, 1);
    gl.uniform1i(program.texturesEnabled, 1); 
    gl.uniform1i(program.textureStageEnabled[0], 0); 
    gl.uniform1i(program.textureStageEnabled[1], 0);
    
    return program;
}

function webglVB_uvb(buffer, coords)
{
    this.buffer = buffer;
    this.coords = coords;
}

webglVB.prototype = new VertexBuffer();
webglVB.prototype.constructor = webglVB;

function webglVB(rc, gl, program, numVerticesPerPrimitive)
{
    //
    // initialization
    //
    
    VertexBuffer.call(this);
    
    this.numVerticesPerPrimitive = numVerticesPerPrimitive;
    
    var rc = rc;
    var gl = gl;
    var program = program;
    var vb = gl.createBuffer();
    var nb = null;
    var cb = null;
    var cEmpty = gl.createBuffer(); // for VBs with no color coordinates (see below)
    var uvb = new Array(gl_MaxTextureStages);
    var uvEmpty = gl.createBuffer(); // for VBs with no texture coordinates (see below)
    var uvCoords = []; // indexed by texture
    var primitiveType = 0;
    
    //
    // methods
    //
    
    this.setPrimitiveType = function(type)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.VB_SetPrimitiveType, [this, type]);
        
        switch (type)
        {
        case RC_POINTS:         primitiveType = gl.POINTS; break;
        case RC_LINES:          primitiveType = gl.LINES; break;
        case RC_LINE_LOOP:      primitiveType = gl.LINE_LOOP; break;
        case RC_LINE_STRIP:     primitiveType = gl.LINE_STRIP; break;
        case RC_TRIANGLES:      primitiveType = gl.TRIANGLES; break;
        case RC_TRIANGLE_STRIP: primitiveType = gl.TRIANGLE_STRIP; break;
        case RC_TRIANGLE_FAN:   primitiveType = gl.TRIANGLE_FAN; break;
        }
    }
    
    this.setVertices = function(vertices)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.VB_SetVertices, [this, vertices]);
        
        if (vertices.length)
        {
            gl.bindBuffer(gl.ARRAY_BUFFER, vb);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            this.vertexCount = vertices.length / this.numVerticesPerPrimitive;
            
            // create empty color array for vb's with no colors specified (see below)
            gl.bindBuffer(gl.ARRAY_BUFFER, cEmpty);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertexCount * 4), gl.STATIC_DRAW);
            
            // create empty texture coordinate arrays for vb's with no textures (see below)
            gl.bindBuffer(gl.ARRAY_BUFFER, uvEmpty);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(new Array(this.vertexCount * 2)), gl.STATIC_DRAW);           
        }
        
        this.vertices = vertices;
    }
    
    this.setNormals = function(normals)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.VB_SetNormals, [this, normals]);
        
        if (normals.length)
        {
            if (nb == null)
            {
                nb = gl.createBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, nb);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
        }
        
        this.normals = normals;
    }

    this.setColors = function(colors)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.VB_SetColors, [this, colors]);
        
        if (colors.length)
        {
            if (cb == null)
            {
                cb = gl.createBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, cb);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        }
        
        this.colors = colors;
    }
    
    this.setUVCoords = function(texture, coords)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.VB_SetUVCoords, [this, texture, coords]);
        
        uvCoords[texture] = new webglVB_uvb(gl.createBuffer(), coords.slice());

        // flip y
        for (var i = 1; i < uvCoords[texture].coords.length; i += 2)
        {
            uvCoords[texture].coords[i] = 1 - uvCoords[texture].coords[i];
        }
    }
    
    this.setTextureStage = function(stage, textureObj, widthWrap, heightWrap, textureCoordSrc, planeCoefficients)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.VB_SetTextureStage, [this, stage, textureObj, widthWrap, heightWrap, textureCoordSrc, planeCoefficients]);
        
        switch (stage)
        {
        case 0: gl.activeTexture(gl.TEXTURE0); break;       
        case 1: gl.activeTexture(gl.TEXTURE1); break;
        }

        gl.bindTexture(gl.TEXTURE_2D, textureObj.texture);
        gl.uniform1i(program.textureSamplerColor[stage], stage);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, widthWrap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, heightWrap);
                
        if (uvCoords[textureObj])
        {
            gl.bindBuffer(gl.ARRAY_BUFFER, uvCoords[textureObj].buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvCoords[textureObj].coords), gl.STATIC_DRAW);  
            uvb[stage] = uvCoords[textureObj].buffer;
        }            
    }
    
    this.draw = function()
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.VB_Draw, [this]);

        if (this.vertices.length)
        {
            // vertices
            gl.bindBuffer(gl.ARRAY_BUFFER, vb);
            gl.vertexAttribPointer(program.vertexPositionAttribute, this.numVerticesPerPrimitive, gl.FLOAT, false, 0, 0);

            // normals
            if (nb)
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, nb);
                gl.vertexAttribPointer(program.vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);
            }
            
            // colors
            if (cb)
                gl.bindBuffer(gl.ARRAY_BUFFER, cb);    
            else
                gl.bindBuffer(gl.ARRAY_BUFFER, cEmpty);
            gl.vertexAttribPointer(program.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);
            
            // texture coords
            // NOTE: vertex shader silently fails if nothing is specified for a given program attribute, so if 
            // no texture coords are specified, use the vertex uv buffer.
            for (var i=0; i < gl_MaxTextureStages; i++)
            {
                if (uvb[i]) 
                    gl.bindBuffer(gl.ARRAY_BUFFER, uvb[i]);
                else 
                    gl.bindBuffer(gl.ARRAY_BUFFER, uvEmpty);
                gl.vertexAttribPointer(program.textureCoordAttribute[i], 2, gl.FLOAT, false, 0, 0);
            }
            
            gl.drawArrays(primitiveType, 0, this.vertexCount);
        }
    }
}
webglTO.prototype = new TextureObject();
webglTO.prototype.constructor = webglTO;

function webglTO(rc, gl, program)
{
    //
    // initialization
    //
    
    TextureObject.call(this);
    
    var rc = rc;
    var gl = gl;
    var program = program;
    
    this.texture = gl.createTexture();
    
    //
    // methods
    //

    this.setImage = function(image, pixelFormat, imageFormat)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.TO_SetImage, [this, image, pixelFormat, imageFormat]);

        var intFormat;
        switch (pixelFormat)
        {
            case ePixelFormat.R8G8B8:
            case ePixelFormat.B8G8R8:
            case ePixelFormat.X8G8R8:
                intFormat = gl.RGB;
                break;

            case ePixelFormat.R8G8B8A8:
            case ePixelFormat.B8G8R8A8:
            case ePixelFormat.A8R8G8B8:
            case ePixelFormat.A8B8G8R8:
            case ePixelFormat.X8X8X8X8:
                intFormat = gl.RGBA;
                break;

            case ePixelFormat.A8:
                intFormat = gl.ALPHA;
                break;

            default: // unsupported format
                return;
                break;
        }

        var format;
        switch (imageFormat)
        {
            case eImageFormat.RGB:
                format = gl.RGB;
                break;

            case eImageFormat.RGBA:
                format = gl.RGBA;
                break;

            case eImageFormat.Alpha:
                format = gl.ALPHA;
                break;

            case eImageFormat.Luminance:
                format = gl.LUMINANCE;
                break;

            case eImageFormat.Luminance_Alpha:
                format = gl.LUMINANCE_ALPHA;
                break;

            default: // unsupported format
                return;
                break;
        }

        // following taken from:
        // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences
        if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height))
        {
            // Scale up the texture to the next highest power of two dimensions.
            var canvas = document.createElement("canvas");
            canvas.width = nextHighestPowerOfTwo(image.width);
            canvas.height = nextHighestPowerOfTwo(image.height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image,
                0, 0, image.width, image.height,
                0, 0, canvas.width, canvas.height);
            image = canvas;
        }

        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, intFormat, format, gl.UNSIGNED_BYTE, image);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    this.setImageData = function(width, height, pixelFormat, imageFormat, pixels)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.TO_SetImageData, [this, width, height, pixelFormat, imageFormat, pixels]);

        var intFormat;
        switch (pixelFormat)
        {
            case ePixelFormat.R8G8B8:
            case ePixelFormat.B8G8R8:
            case ePixelFormat.X8G8R8:
                intFormat = gl.RGB;
                break;

            case ePixelFormat.R8G8B8A8:
            case ePixelFormat.B8G8R8A8:
            case ePixelFormat.A8R8G8B8:
            case ePixelFormat.A8B8G8R8:
            case ePixelFormat.X8X8X8X8:
                intFormat = gl.RGBA;
                break;

            case ePixelFormat.A8:
                intFormat = gl.ALPHA;
                break;

            default: // unsupported format
                return;
                break;
        }

        var format;
        switch (imageFormat)
        {
            case eImageFormat.RGB:
                format = gl.RGB;
                break;

            case eImageFormat.RGBA:
                format = gl.RGBA;
                break;

            case eImageFormat.Alpha:
                format = gl.ALPHA;
                break;

            case eImageFormat.Luminance:
                format = gl.LUMINANCE;
                break;

            case eImageFormat.Luminance_Alpha:
                format = gl.LUMINANCE_ALPHA;
                break;

            default: // unsupported format
                return;
                break;
        }
        
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, intFormat, width, height, 0, format, gl.UNSIGNED_BYTE,
            new Uint8Array(pixels));

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    	
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    this.setVideo = function(video)
    {
        if (rc.displayListObj) DL_ADD_METHOD_DESC(rc.displayListObj, eRenderContextMethod.TO_SetVideo, [this, video]);

        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        // different browsers require calls to different versions of texImage2D; possibly because 
        // complete webGL implementations are not yet available
        switch (getBrowserName())
        {
            case "Chrome":
            //gl.texImage2D(gl.TEXTURE_2D, 0, video, false);
            //break;

            case "Firefox":
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
                break;

            default:
                gl.texImage2D(gl.TEXTURE_2D, 0, video, false);
                break;
        }

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

function isPowerOfTwo(x)
{
    return (x & (x - 1)) == 0;
}

function nextHighestPowerOfTwo(x)
{
    --x;
    for (var i = 1; i < 32; i <<= 1)
    {
        x = x | x >> i;
    }
    return x + 1;
}
var eShaderType =
{
    VertexLighting: 0,
    FragmentLighting: 1
};

function getShaders(gl, type)
{
    var source_vs = null;
    var source_fs = null;
    
    switch (type)
    {
        case eShaderType.VertexLighting:
            {
                source_vs = [
                    "#ifdef GL_ES",
                    "precision highp float;",
                    "#endif",
                    "",
                    "vec4 gAmbient;",
                    "vec4 gDiffuse;",
                    "vec4 gSpecular;",
                    "",
                    "attribute vec3 aVertexPosition;",
                    "attribute vec3 aVertexNormal;",
                    "attribute vec4 aVertexColor;",
                    "attribute vec2 aTextureCoord0;",   // attributes cannot be arrays and must be specified
                    "attribute vec2 aTextureCoord1;",   // attributes cannot be arrays and must be specified      
                    "", 
                    "uniform mat4 uProjectionMatrix;",
                    "uniform mat4 uModelViewMatrix;",
                    "uniform mat4 uNormalMatrix;",
                    "",
                    "uniform vec4 uGlobalAmbientLight;",
                    "",
                    "uniform int uLightSource_enabled[" + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_ambient["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_diffuse["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_specular["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_position["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_halfVector["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_spotDirection["  + gl_MaxLights + "];",
                    "uniform float uLightSource_spotExponent["  + gl_MaxLights + "];",
                    "uniform float uLightSource_spotCutoff["  + gl_MaxLights + "];",
                    "uniform float uLightSource_spotCosCutoff["  + gl_MaxLights + "];",
                    "uniform float uLightSource_constantAttenuation["  + gl_MaxLights + "];",
                    "uniform float uLightSource_linearAttenuation["  + gl_MaxLights + "];",
                    "uniform float uLightSource_quadraticAttenuation["  + gl_MaxLights + "];",
                    "",
                    "uniform vec4 uFrontMaterial_ambient;",
                    "uniform vec4 uFrontMaterial_diffuse;",
                    "uniform vec4 uFrontMaterial_specular;",
                    "uniform vec4 uFrontMaterial_emission;",
                    "uniform float uFrontMaterial_shininess;",
                    "",
                    "uniform int uLightingEnabled;",
                    "",
                    "varying vec4 vLightingFactor;",
                    "varying vec2 vTextureCoord[" + gl_MaxTextureStages + "];",
                    "",
                    "void directionalLight(vec4 position, vec4 ambient, vec4 diffuse, vec4 specular, vec3 normal, vec3 halfVector)",
                    "{",
                    "   vec3 lightDir;",
                    "   float nDotL;",      // normal . light direction
                    "   float nDotHV;",     // normal . half-vector
                    "   float pf;",         // power factor
                    "",
                    "   lightDir = normalize(vec3(position));",
                    "",	
                    "   nDotL = max(dot(normal, lightDir), 0.0);",
                    "   if (nDotL == 0.0)",
                    "   {",
                    "       pf = 0.0;",
                    "   }",
                    "   else",
                    "   {",
                    "       nDotHV = max(0.0, dot(normal, halfVector));",
                    "       pf = pow(nDotHV, uFrontMaterial_shininess);",
                    "   }",
                    "",
                    "   gAmbient  += ambient * uFrontMaterial_ambient;",
                    "   gDiffuse  += diffuse * uFrontMaterial_diffuse * nDotL;",
                    "   gSpecular += specular * uFrontMaterial_specular * pf;",
                    "}",
                    "",
                    "void pointLight(vec4 position, float constantAttenuation, float linearAttenuation, float quadraticAttenuation,",
                    "                vec4 ambient, vec4 diffuse, vec4 specular, vec3 normal, vec3 eye, vec3 vPosition)",
                    "{",
                    "   float nDotL;",      // normal . light direction
                    "   float nDotHV;",     // normal . light half vector
                    "   float pf;",         // power factor
                    "   float attenuation;",// computed attenuation factor
                    "   float d;",          // distance from surface to light source
                    "   vec3  L;",          // direction from surface to light position
                    "   vec3  halfVector;", //
                    "",
                    "", // Compute vector from surface to light position
                    "   L = vec3(position) - vPosition;",
                    "",
                    "", // Compute distance between surface and light position
                    "   d = length(L);",
                    "",
                    "", // Normalize the vector from surface to light position,
                    "   L = normalize(L);",
                    "",
                    "", // Compute attenuation,
                    "   attenuation = 1.0 / (constantAttenuation +",
                    "      linearAttenuation * d +",
                    "      quadraticAttenuation * d * d);",
                    "",
                    "   nDotL = max(0.0, dot(normal, L));",
                    "   nDotHV = max(0.0, dot(normal, normalize(L + eye)));",
                    "",
                    "   if (nDotL == 0.0)",
                    "   {",
                    "       pf = 0.0;",
                    "   }",
                    "   else",
                    "   {",
                    "       pf = pow(nDotHV, uFrontMaterial_shininess);",
                    "   }",
                    "",    
                    "   gAmbient  += ambient * uFrontMaterial_ambient * attenuation;",
                    "   gDiffuse  += diffuse * uFrontMaterial_diffuse * nDotL * attenuation;",
                    "   gSpecular += specular * uFrontMaterial_specular * pf * attenuation;",
                    "}",
                    "",
                    "void main()",
                    "{",
                    "   vec4 vertexPosition;",
                    "   vec4 transformedNormal;",
                    "   vec4 viewPosition;",
                    "   vec4 viewDirection;",
                    "",
                    "   vertexPosition = uModelViewMatrix * vec4(aVertexPosition, 1);",
                    "",
                    "   if (uLightingEnabled != 0)",
                    "   {",                    
                    "       transformedNormal = normalize(uNormalMatrix * vec4(aVertexNormal, 0));",
                    "       viewPosition = uModelViewMatrix * vec4(0, 0, 0, 1);",
                    "       viewDirection = normalize(-viewPosition);",
                    
                    "       gAmbient = vec4(0, 0, 0, 0);",
                    "       gDiffuse = vec4(0, 0, 0, 0);",
                    "       gSpecular = vec4(0, 0, 0, 0);",
                    "",
                    "       for (int i=0; i < " + gl_MaxLights + "; i++)",
                    "       {",
                    "           if (uLightSource_enabled[i] != 0)",
                    "           {",
                    "               if (uLightSource_position[i][3] == 0.0)", // directional light
                    "               {",
                    "                   directionalLight(uLightSource_position[i], uLightSource_ambient[i],",
                    "                       uLightSource_diffuse[i], uLightSource_specular[i],",
                    "                       normalize(vec3(transformedNormal)),",
                    "                       normalize(vec3(viewDirection) + vec3(uLightSource_position[i])));",
                    "               }",
                    "               else if (uLightSource_spotCutoff[i] > 90.0)", // point light
                    "               {",
                    "                   pointLight(uLightSource_position[i], uLightSource_constantAttenuation[i],",
                    "                       uLightSource_linearAttenuation[i], uLightSource_quadraticAttenuation[i],",
                    "                       uLightSource_ambient[i], uLightSource_diffuse[i], uLightSource_specular[i],",
                    "                       normalize(vec3(transformedNormal)),",
                    "                       vec3(viewDirection), vec3(vertexPosition));",
                    "               }",
                    "               else", // spotlight
                    "               {",
                    "               }",   
                    "           }",
                    "       }",
                    "",
                    "       vLightingFactor  = uGlobalAmbientLight * uFrontMaterial_ambient;", // global ambient contribution
                    "       vLightingFactor += gAmbient + gDiffuse + gSpecular;", // light contribution(s)
                    "       vLightingFactor.a = uFrontMaterial_ambient.a / 3.0 + ",
                    "                           uFrontMaterial_diffuse.a / 3.0 + ",
                    "                           uFrontMaterial_specular.a / 3.0;",
                    "   }",
                    "   else", // uLightingEnabled == 0
                    "   {",  
                    "       vLightingFactor = aVertexColor;",
                    "   }",
                    "",
                    "   vTextureCoord[0] = aTextureCoord0;",
                    "   vTextureCoord[1] = aTextureCoord1;",        
                    "   gl_Position = uProjectionMatrix * vertexPosition;",
                    "}"
                    ].join("\n");
                    
                source_fs = [
                    "#ifdef GL_ES",
                    "precision highp float;",
                    "#endif",
                    "",
                    "uniform int uTexturesEnabled;",
                    "uniform int uTextureStageEnabled[" + gl_MaxTextureStages + "];",       
                    "uniform sampler2D uTextureSamplerColor[" + gl_MaxTextureStages + "];",
                    "uniform sampler2D uTextureSamplerAlpha[" + gl_MaxTextureStages + "];",
                    "uniform int uTextureBlendOp;",
                    "",
                    "varying vec4 vLightingFactor;",
                    "varying vec2 vTextureCoord[" + gl_MaxTextureStages + "];",
                    "",
                    "void main()",
                    "{",
                    "   vec4 fragmentColor;",
                    "   vec4 fragmentColor1;",
                    "   vec4 fragmentColor2;",
                    "   if (uTexturesEnabled == 1 && uTextureStageEnabled[0] == 1 && uTextureStageEnabled[1] == 0)",
                    "   {",
                    "       fragmentColor = texture2D(uTextureSamplerColor[0], vec2(vTextureCoord[0].s, vTextureCoord[0].t));",
                    "       if (uTextureBlendOp == " + RC_MODULATE + ")",
                    "       {",
                    "           if (fragmentColor.a == 0.0) discard;",
                    "           else gl_FragColor = fragmentColor * vLightingFactor;",
                    "       }",
                    "       else if (uTextureBlendOp == " + RC_REPLACE + ")",
                    "       {",
                    "           gl_FragColor = fragmentColor;",
                    "       }",
                    "       else",
                    "       {",
                    "           gl_FragColor = vLightingFactor;",
                    "       }",
                    "   }",
                    "   else if (uTexturesEnabled == 1 && uTextureStageEnabled[0] == 1 && uTextureStageEnabled[1] == 1)",
                    "   {",
                    "       fragmentColor1 = texture2D(uTextureSamplerColor[0], vec2(vTextureCoord[0].s, vTextureCoord[0].t));",
                    "       fragmentColor2 = texture2D(uTextureSamplerColor[1], vec2(vTextureCoord[1].s, vTextureCoord[1].t));",
                    "       if (uTextureBlendOp == " + RC_MODULATE + ")",
                    "       {",
                    "           fragmentColor1.a = fragmentColor2.a;",
                    "           if (fragmentColor1.a == 0.0) discard;",
                    "           else gl_FragColor = fragmentColor1 * vLightingFactor;",
                    "       }",
                    "       else if (uTextureBlendOp == " + RC_REPLACE + ")",
                    "       {",
                    "           gl_FragColor = fragmentColor1 * fragmentColor2;",
                    "       }",
                    "       else",
                    "       {",
                    "           gl_FragColor = vLightingFactor;",
                    "       }",
                    "   }",
                    "   else", // uTexturesEnabled == 0 || (uTextureStageEnabled[0] == 0 && uTextureStageEnabled[1] == 0)
                    "   {",
                    "       gl_FragColor = vLightingFactor;",
                    "   }",
                    "}"
                    ].join("\n");
            }
            break;
            
        case eShaderType.FragmentLighting:
            {
                source_vs = [
                    "attribute vec3 aVertexPosition;",
                    "attribute vec3 aVertexNormal;",
                    "attribute vec4 aVertexColor;",
                    "attribute vec2 aTextureCoord0;",   // attributes cannot be arrays and must be specified
                    "attribute vec2 aTextureCoord1;",   // attributes cannot be arrays and must be specified      
                    "", 
                    "uniform mat4 uProjectionMatrix;",
                    "uniform mat4 uModelViewMatrix;",
                    "uniform mat4 uNormalMatrix;",
                    "",
                    "varying vec4 vVertexPosition;",
                    "varying vec4 vTransformedNormal;",
                    "varying vec4 vVertexColor;",
                    "varying vec4 vViewPosition;",
                    "varying vec4 vViewDirection;",
                    "varying vec2 vTextureCoord[" + gl_MaxTextureStages + "];",
                    "",
                    "void main()",
                    "{",
                    "   vVertexPosition = uModelViewMatrix * vec4(aVertexPosition, 1);",
                    "   vTransformedNormal = normalize(uNormalMatrix * vec4(aVertexNormal, 0));",
                    "   vVertexColor = aVertexColor;",
                    "   vViewPosition = uModelViewMatrix * vec4(0, 0, 0, 1);",
                    "   vViewDirection = normalize(-vViewPosition);",
                    "   vTextureCoord[0] = aTextureCoord0;",
                    "   vTextureCoord[1] = aTextureCoord1;",        
                    "   gl_Position = uProjectionMatrix * vVertexPosition;",
                    "}"
                    ].join("\n");
                
                source_fs = [
                    "#ifdef GL_ES",
                    "precision highp float;",
                    "#endif",
                    "",
                    "vec4 gAmbient;",
                    "vec4 gDiffuse;",
                    "vec4 gSpecular;",
                    "",
                    "uniform vec4 uGlobalAmbientLight;",
                    "",
            //        IE 11 doesn't currently support structs
            //        "struct lightSourceParameters",
            //        "{",
            //        "   int enabled;",
            //        "   vec4 ambient;",
            //        "   vec4 diffuse;",
            //        "   vec4 specular;",
            //        "   vec4 position;",
            //        "   vec4 halfVector;",
            //        "   vec4 spotDirection;",
            //        "   float spotExponent;",
            //        "   float spotCutoff;",
            //        "   float spotCosCutoff;",
            //        "   float constantAttenuation;",
            //        "   float linearAttenuation;",
            //        "   float quadraticAttenuation;",
            //        "};",
            //        "",
            //        "uniform lightSourceParameters uLightSource[" + gl_MaxLights + "];",
                    "",
                    "uniform int uLightSource_enabled[" + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_ambient["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_diffuse["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_specular["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_position["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_halfVector["  + gl_MaxLights + "];",
                    "uniform vec4 uLightSource_spotDirection["  + gl_MaxLights + "];",
                    "uniform float uLightSource_spotExponent["  + gl_MaxLights + "];",
                    "uniform float uLightSource_spotCutoff["  + gl_MaxLights + "];",
                    "uniform float uLightSource_spotCosCutoff["  + gl_MaxLights + "];",
                    "uniform float uLightSource_constantAttenuation["  + gl_MaxLights + "];",
                    "uniform float uLightSource_linearAttenuation["  + gl_MaxLights + "];",
                    "uniform float uLightSource_quadraticAttenuation["  + gl_MaxLights + "];",
                    "",
            //        IE 11 doesn't currently support structs
            //        "struct materialParameters",
            //        "{",
            //        "   vec4 ambient;",
            //        "   vec4 diffuse;",
            //        "   vec4 specular;",
            //        "   vec4 emission;",
            //        "   float shininess;",
            //        "};",
            //        "",
            //        "uniform materialParameters uFrontMaterial;",
                    "uniform vec4 uFrontMaterial_ambient;",
                    "uniform vec4 uFrontMaterial_diffuse;",
                    "uniform vec4 uFrontMaterial_specular;",
                    "uniform vec4 uFrontMaterial_emission;",
                    "uniform float uFrontMaterial_shininess;",
                    "",
                    "uniform int uLightingEnabled;",
                    "uniform int uTexturesEnabled;",
                    "uniform int uTextureStageEnabled[" + gl_MaxTextureStages + "];",       
                    "uniform sampler2D uTextureSamplerColor[" + gl_MaxTextureStages + "];",
                    "uniform sampler2D uTextureSamplerAlpha[" + gl_MaxTextureStages + "];",
                    "uniform int uTextureBlendOp;",
                    "",
                    "varying vec4 vVertexPosition;",
                    "varying vec4 vTransformedNormal;",
                    "varying vec4 vVertexColor;",
                    "varying vec4 vViewPosition;",
                    "varying vec4 vViewDirection;",
                    "varying vec2 vTextureCoord[" + gl_MaxTextureStages + "];",
                    "",
                    "void directionalLight(vec4 position, vec4 ambient, vec4 diffuse, vec4 specular, vec3 normal, vec3 halfVector)",
                    "{",
                    "   vec3 lightDir;",
                    "   float nDotL;",      // normal . light direction
                    "   float nDotHV;",     // normal . half-vector
                    "   float pf;",         // power factor
                    "",
                    "   lightDir = normalize(vec3(position));",
                    "",	
                    "   nDotL = max(dot(normal, lightDir), 0.0);",
                    "   if (nDotL == 0.0)",
                    "   {",
                    "       pf = 0.0;",
                    "   }",
                    "   else",
                    "   {",
                    "       nDotHV = max(0.0, dot(normal, halfVector));",
                    "       pf = pow(nDotHV, uFrontMaterial_shininess);",
                    "   }",
                    "",
                    "   gAmbient  += ambient * uFrontMaterial_ambient;",
                    "   gDiffuse  += diffuse * uFrontMaterial_diffuse * nDotL;",
                    "   gSpecular += specular * uFrontMaterial_specular * pf;",
                    "}",
                    "",
                    "void pointLight(vec4 position, float constantAttenuation, float linearAttenuation, float quadraticAttenuation,",
                    "                vec4 ambient, vec4 diffuse, vec4 specular, vec3 normal, vec3 eye, vec3 vPosition)",
                    "{",
                    "   float nDotL;",      // normal . light direction
                    "   float nDotHV;",     // normal . light half vector
                    "   float pf;",         // power factor
                    "   float attenuation;",// computed attenuation factor
                    "   float d;",          // distance from surface to light source
                    "   vec3  L;",          // direction from surface to light position
                    "   vec3  halfVector;", //
                    "",
                    "", // Compute vector from surface to light position
                    "   L = vec3(position) - vPosition;",
                    "",
                    "", // Compute distance between surface and light position
                    "   d = length(L);",
                    "",
                    "", // Normalize the vector from surface to light position,
                    "   L = normalize(L);",
                    "",
                    "", // Compute attenuation,
                    "   attenuation = 1.0 / (constantAttenuation +",
                    "      linearAttenuation * d +",
                    "      quadraticAttenuation * d * d);",
                    "",
                    "   nDotL = max(0.0, dot(normal, L));",
                    "   nDotHV = max(0.0, dot(normal, normalize(L + eye)));",
                    "",
                    "   if (nDotL == 0.0)",
                    "   {",
                    "       pf = 0.0;",
                    "   }",
                    "   else",
                    "   {",
                    "       pf = pow(nDotHV, uFrontMaterial_shininess);",
                    "   }",
                    "",    
                    "   gAmbient  += ambient * uFrontMaterial_ambient * attenuation;",
                    "   gDiffuse  += diffuse * uFrontMaterial_diffuse * nDotL * attenuation;",
                    "   gSpecular += specular * uFrontMaterial_specular * pf * attenuation;",
                    "}",
                    "",
                    "void main()",
                    "{",
                    "   vec4 lightingFactor;",
                    "   if (uLightingEnabled != 0)",
                    "   {",
                    "       gAmbient = vec4(0, 0, 0, 0);",
                    "       gDiffuse = vec4(0, 0, 0, 0);",
                    "       gSpecular = vec4(0, 0, 0, 0);",
                    "",
                    "       for (int i=0; i < " + gl_MaxLights + "; i++)",
                    "       {",
                    "           if (uLightSource_enabled[i] != 0)",
                    "           {",
                    "               if (uLightSource_position[i][3] == 0.0)", // directional light
                    "               {",
                    "                   directionalLight(uLightSource_position[i], uLightSource_ambient[i],",
                    "                       uLightSource_diffuse[i], uLightSource_specular[i],",
                    "                       normalize(vec3(vTransformedNormal)),",
                    "                       normalize(vec3(vViewDirection) + vec3(uLightSource_position[i])));",
                    "               }",
                    "               else if (uLightSource_spotCutoff[i] > 90.0)", // point light
                    "               {",
                    "                   pointLight(uLightSource_position[i], uLightSource_constantAttenuation[i],",
                    "                       uLightSource_linearAttenuation[i], uLightSource_quadraticAttenuation[i],",
                    "                       uLightSource_ambient[i], uLightSource_diffuse[i], uLightSource_specular[i],",
                    "                       normalize(vec3(vTransformedNormal)),",
                    "                       vec3(vViewDirection), vec3(vVertexPosition));",
                    "               }",
                    "               else", // spotlight
                    "               {",
                    "               }",   
                    "           }",
                    "       }",
                    "",
                    "       lightingFactor  = uGlobalAmbientLight * uFrontMaterial_ambient;", // global ambient contribution
                    "       lightingFactor += gAmbient + gDiffuse + gSpecular;", // light contribution(s)
                    "       lightingFactor.a  = uFrontMaterial_ambient.a / 3.0 + ",
                    "                           uFrontMaterial_diffuse.a / 3.0 + ",
                    "                           uFrontMaterial_specular.a / 3.0;",
                    "   }",
                    "   else", // uLightingEnabled == 0
                    "   {",
                    "       lightingFactor = vVertexColor;",
                    "   }",
                    "",
                    "   vec4 fragmentColor;",
                    "   vec4 fragmentColor1;",
                    "   vec4 fragmentColor2;",
                    "   if (uTexturesEnabled == 1 && uTextureStageEnabled[0] == 1 && uTextureStageEnabled[1] == 0)",
                    "   {",
                    "       fragmentColor = texture2D(uTextureSamplerColor[0], vec2(vTextureCoord[0].s, vTextureCoord[0].t));",
                    "       if (uTextureBlendOp == " + RC_MODULATE + ")",
                    "       {",
                    "           if (fragmentColor.a == 0.0) discard;",
                    "           else gl_FragColor = fragmentColor * lightingFactor;",
                    "       }",
                    "       else if (uTextureBlendOp == " + RC_REPLACE + ")",
                    "       {",
                    "           gl_FragColor = fragmentColor;",
                    "       }",
                    "       else",
                    "       {",
                    "           gl_FragColor = lightingFactor;",
                    "       }",
                    "   }",
                    "   else if (uTexturesEnabled == 1 && uTextureStageEnabled[0] == 1 && uTextureStageEnabled[1] == 1)",
                    "   {",
                    "       fragmentColor1 = texture2D(uTextureSamplerColor[0], vec2(vTextureCoord[0].s, vTextureCoord[0].t));",
                    "       fragmentColor2 = texture2D(uTextureSamplerColor[1], vec2(vTextureCoord[1].s, vTextureCoord[1].t));",
                    "       if (uTextureBlendOp == " + RC_MODULATE + ")",
                    "       {",
                    "           fragmentColor1.a = fragmentColor2.a;",
                    "           if (fragmentColor1.a == 0.0) discard;",
                    "           else gl_FragColor = fragmentColor1 * lightingFactor;",
                    "       }",
                    "       else if (uTextureBlendOp == " + RC_REPLACE + ")",
                    "       {",
                    "           gl_FragColor = fragmentColor1 * fragmentColor2;",
                    "       }",
                    "       else",
                    "       {",
                    "           gl_FragColor = lightingFactor;",
                    "       }",
                    "   }",
                    "   else", // uTexturesEnabled == 0 || (uTextureStageEnabled[0] == 0 && uTextureStageEnabled[1] == 1)
                    "   {",
                    "       gl_FragColor = lightingFactor;",
                    "   }",
                    "}"
                    ].join("\n");
            }
            break;
        
        default:
            return { vertex: null, fragment: null };
            break;
    }
    
    var vs = gl.createShader(gl.VERTEX_SHADER); 
    if (vs)
    {
        gl.shaderSource(vs, source_vs);
        gl.compileShader(vs);

        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
        {
            alert(gl.getShaderInfoLog(vs));
        }
    }
    
    var fs = gl.createShader(gl.FRAGMENT_SHADER); 
    if (fs) 
    {
        gl.shaderSource(fs, source_fs);
        gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
        {
            alert(gl.getShaderInfoLog(fs));
        }
    }
                    
    return { vertex: vs, fragment: fs };
}
ContentHandler.prototype = new AttributeContainer();
ContentHandler.prototype.constructor = ContentHandler;

function ContentHandler()
{
    AttributeContainer.call(this);
    this.className = "ContentHandler";
    
    this.contentDirectory = new StringAttr("");
    this.url = new StringAttr("");
    
    this.registerAttribute(this.contentDirectory, "contentDirectory");
    this.registerAttribute(this.url, "url");
}

ContentHandler.prototype.parseFileStream = function(file)
{
}

ContentHandler.prototype.matchesType = function(type)
{
}

ContentBuilder.prototype = new AttributeContainer();
ContentBuilder.prototype.constructor = ContentBuilder;

function ContentBuilder()
{
    AttributeContainer.call(this);
    this.className = "ContentBuilder";
    
    this.models = [];
    this.evaluators = [];
    
    this.layer = 0;
    this.invertAlpha = new BooleanAttr(false);
    
    this.registerAttribute(this.invertAlpha, "invertAlpha");
}

ContentBuilder.prototype.visitHandler = function(handler)
{
}
/*
ContentBuilder.prototype.configure = function(models, evaluators)
{
    this.models = models;
    this.evaluators = evaluators;
}
*/
ContentBuilder.prototype.finalize = function()
{
}

ContentBuilder.prototype.matchesType = function(type)
{
}

function BinaryParser(stream, bigEndian)
{
    this.stream = stream;
    this.bigEndian = bigEndian;
    
    this.readUInt8  = function() { return this.decodeInt(8, false); }
    this.readUInt16 = function() { return this.decodeInt(16, false); }
    this.readUInt32 = function() { return this.decodeInt(32, false); }
    this.readInt8   = function() { return this.decodeInt(8, true); }
    this.readInt16  = function() { return this.decodeInt(16, true); }
    this.readInt32  = function() { return this.decodeInt(32, true); }
    this.readFloat32 = function(){ return this.decodeFloat32(); }
   
    var pos = 0;
     
    this.decodeInt = function(bits, signed)
    {
        var sum = 0;
        var bytes = bits / 8;
        var byteValue = 0;
        
        // sum bytes
        for (var B=0; B < bytes; B++)
        {
            byteValue = this.bigEndian ? this.stream.charCodeAt(pos+B) 
                                       : this.stream.charCodeAt(pos+(bytes-B-1));
            // sum bits
            for (var b=7; b >= 0; b--)
            {
                sum = sum * 2 + ((1 << b) & byteValue ? 1 : 0);
            }
        }
        
        // account for sign
        if (signed)
        {
            max = Math.pow(2, bits);
            sum = sum >= max / 2 ? sum - max : sum;
        }
        
        // advance stream position
        pos += bytes;
        
        return sum;
	}
	
	// based upon example from: http://en.wikipedia.org/wiki/Binary32
	this.decodeFloat32 = function()
	{
	    var sum = 0;
	    var bytes = 4;
	    var byteValue = new Array(bytes);
	    
	    // read the bytes representing the float
	    for (var B=0; B < bytes; B++)
	    {
	        this.bigEndian ? byteValue[B] = this.stream.charCodeAt(pos+B)
	                       : byteValue[B] = this.stream.charCodeAt(pos+(bytes-B-1));
	    }
	    
	    // read sign bit (bit 31)
	    var negative = byteValue[0] & 0x80;

	    // read exponent bits (bits 30-23)
	    var exponent = 0; 
	    for (var e=6; e >= 0; e--)
        {
            exponent = exponent * 2 + ((1 << e) & byteValue[0] ? 1 : 0);
        }
        exponent = exponent * 2 + (0x80 & byteValue[1] ? 1 : 0);
	    
	    // read significand bits (bits 22-0)
	    var significand = 0;
	    // byte 1
	    for (var s=6; s >= 0; s--)
	    {
	        significand = significand * 2 + ((1 << s) & byteValue[1] ? 1 : 0);
	    }
	    // byte 2, 3
	    for (var B=2; B <= 3; B++)
	    {
	        for (var s=7; s >= 0; s--)
	        {
	            significand = significand * 2 + ((1 << s) & byteValue[B] ? 1 : 0);
	        }
	    }

        // decode exponent by subtracting 127
        var decodedExponent = exponent - 127;
        
        // decode the significand using:
        // each of the 24 bits of the significand, bit 23 to bit 0, represents a value, 
        // starting at 1 and halves for each bit:
        // bit 23 = 1
        // bit 22 = 0.5
        // bit 21 = 0.25
        // bit 20 = 0.125
        // bit 19 = 0.0625
        // .
        // .
        // bit  0 = 0.00000011920928955078125
        var decodedSignificand = 1; // implicit 24th bit set to 1
        var bitvalue = 1;
        for (var s=23; s >= 0; s--)
        {
            decodedSignificand = decodedSignificand + ((1 << s) & significand ? bitvalue : 0);
            bitvalue /= 2;
        }
        
        // multiply significand with the base, 2, to the power of the exponent to get the final result
        sum = decodedSignificand * Math.pow(2, decodedExponent) * (negative ? -1 : 1);
        
	    // advance stream position
	    pos += bytes;
	    
	    return sum;
	}
}
function TextParser(stream)
{
    this.stream = stream;
    
    var pos = 0;
    
    this.readCharacter = function()
    {
        if (pos >= this.stream.length) return null;
        
        return this.stream[pos++];
    }
    
    this.readToken = function()
    {
        var c;
        var token = "";
        
        if (pos >= this.stream.length) return null;
        
        // read leading whitespace
        do
        {
            c = this.stream[pos++];
        }
        while (pos < this.stream.length && isSpace(c));
        
        // read token
		do
		{
			token += c;
			c = this.stream[pos++];
		}
		while (pos < this.stream.length && !isSpace(c));
		
		return (token.length > 0 ? token : null);
    }
    
    this.readLine = function()
    {
        var line = "";
        
        if (pos >= this.stream.length) return null;
        
        while (pos < this.stream.length && this.stream[pos] != '\n')
        {
            line += this.stream[pos++];
        }
        pos++;
        
        return line;        
    }
    
    this.readLineTokens = function()
    {
        var c;
        var p = 0;
        var token = "";
        var tokens = [];
        
        var line = this.readLine();
        if (line == null) return null;

        while (p < line.length)
        {
            // read leading whitespace
            do
            {
                c = line[p++];
            }
            while (p < line.length && isSpace(c));
            
            // read token
		    do
		    {
			    token += c;
			    c = line[p++];
		    }
		    while (p < line.length && !isSpace(c));
    		
		    tokens.push(token);
		    token = "";
		}
		
		return tokens;
    }
}
function XMLParser(factory, registry, contentDir)
{
    this.factory = factory;
    this.registry = registry;
    this.contentDir = contentDir;
    this.attributeStack = new Stack();
    this.collectionCountStack = new Stack();
}

XMLParser.prototype.parse = function(xml)
{
    parser = new SAXDriver();
   
    parser.setDocumentHandler(this);
    parser.setErrorHandler(this);
    parser.setLexicalHandler(this);

    parser.parse(xml);
}

XMLParser.prototype.processingInstruction = function(target, data)
{
    switch (target)
    {
        case "bw":
            {
                // TODO
                console.debug("TODO: " + target.toString());
            }
            break;

        case "bwinclude":
            {
                var dataString = new String(data);

                // url
                var url = this.parseTokenValue(dataString, "url=\"", "\"");
                if (url)
                {
                    console.debug("Processing Instruction for: " + url);
                    var ext = getFileExtension(url);
                    switch (ext) {
                    case "xml":
                        {
                            var xml = loadXMLResource(this.contentDir + "/" + url);
                            this.parse(xml);
                        }
                        break;
                        // TODO: abstract this dependency away from here
                    case "lws":
                        {
                            var pathInfo = formatPath(url);
                            console.debug("Include instruction for path: " + pathInfo[0]);
                            console.debug("Include content dir: " + pathInfo[1]);
            
                            var contentHandler = new LWSceneHandler();
                            contentHandler.getAttribute("contentDirectory").setValueDirect(pathInfo[1]);
            
                            var contentBuilder = new LWSceneBuilder(); 
                            contentBuilder.setRegistry(this.factory.registry);
                            contentBuilder.visitHandler(contentHandler);
            
                            contentHandler.parseFileStream(pathInfo[0]); 
                        }
                        break;
                    }
                }
            }
            break;
    }
}

XMLParser.prototype.startElement = function(name, atts) 
{
    // by convention, AttributeContainers start with capital letters, and 
    // complex attributes do not.
    if (isUpper(name[0]))
    {
        this.parseAttributeContainer(name, atts);
    }
    else 
    {
        this.parseComplexAttribute(name, atts);
    }
}

XMLParser.prototype.endElement = function(name) 
{
    // by convention, AttributeContainers start with capital letters, and 
    // complex attributes do not.
    if (isUpper(name[0]))
    {
        this.parseAttributeContainer(name);
    }
    else 
    {
        this.parseComplexAttribute(name);
    }
}

XMLParser.prototype.startCDATA = function()
{
}

XMLParser.prototype.endCDATA = function()
{
}

XMLParser.prototype.characters = function(data, start, length)
{
    var value = "";
    for (var i = 0; i < length; i++)
    {
        value += data[start + i];
    }
    if (value.length && !isSpace(value[0]))
    {
        var attribute = this.attributeStack.top();
        if (attribute)
        {
            // TODO: resolve reference
            deserializeAttribute(attribute, value);
        }
    }
}

XMLParser.prototype.error = function(exception) 
{
    alert('Error: ' + exception.getMessage());
}

XMLParser.prototype.fatalError = function(exception) 
{
    alert('Fatal Error: ' + exception.getMessage());
}

XMLParser.prototype.parseAttributeContainer = function(name, atts)
{
    if (atts) // element start
    {
        var attribute = this.factory.create(name);
        if (!attribute)
        {
            this.attributeStack.push(null); // for corresponding pop at closing tag
            return;
        }
        attribute.flagDeserializedFromXML();

        if (!resolveAttributeContainerReference(attribute, atts.m_parser.m_atts, this.registry))
        {
            deserializeAttributeContainer(attribute, atts.m_parser.m_atts);
        }

        this.registry.registerResource(attribute);
        
        // if a collection is at the top of the attribute stack which does not allocate its elements,
        // add the attribute it to the collection
        var container = this.attributeStack.top();
        if (container && container.isCollection())
        {
            if (!container.allocatesElements())
            {
                container.push_back(attribute);
                container.setElementName(attribute, name);

                var count = this.collectionCountStack.top();
                count++;
                this.collectionCountStack.pop();
                this.collectionCountStack.push(count);
            }
            else
            {
                container.setElementName(container.getAt(container.Size() - 1), name);
            }
        }

        this.attributeStack.push(attribute);

        if (attribute.isCollection())
        {
            this.collectionCountStack.push(0);
        }
    }
    else // element end
    {
        var attribute = this.attributeStack.top();

        this.attributeStack.pop();

        if (attribute && attribute.isCollection())
        {
            this.collectionCountStack.pop();
        }

        if (attribute)
        {
            this.factory.finalize(name, attribute);
            this.registry.finalizeResource(attribute);
        }
    }
}

XMLParser.prototype.parseComplexAttribute = function(name, atts)
{
    if (atts) // element start
    {
        var container = this.attributeStack.top();
        if (!container) return;

        var attribute = container.getAttribute(name);
        if (!attribute)
        {
            // check for collections here... if a collection is at the top of 
            // the attribute stack, resize the collection (if necessary) to accomodate
            // the current attribute being deserialized
            if (container.isCollection())
            {
                var count = this.collectionCountStack.top();
                count++;

                var size = container.Size();

                if (container.AppendParsedElements())
                {
                    container.resize(size + 1);
                    count = size;
                }
                else if (size <= count)
                {
                    container.resize(count + 1);
                }

                attribute = container.getAt(count);
            }
            else
            {
                this.attributeStack.push(container); // for corresponding pop at closing tag (push container so that child complex attributes can access)
                return;
            }
        }

        this.attributeStack.push(attribute);

        if (attribute && attribute.isContainer())
        {
            if (!resolveAttributeContainerReference(attribute, atts.m_parser.m_atts, this.registry))
            {
                deserializeAttributeContainer(attribute, atts.m_parser.m_atts);
            }

            if (attribute.isCollection())
            {
                this.collectionCountStack.push(0);
            }
        }
        else if (attribute)
        {
            if (!resolveComplexAttributeReference(attribute, atts.m_parser.m_atts))
            {
                deserializeComplexAttribute(attribute, atts.m_parser.m_atts);
            }
        }
    }
    else // element end
    {
        this.attributeStack.pop();

        if (container && container.isCollection())
        {
            this.collectionCountStack.pop();
        }
    }
}

XMLParser.prototype.parsePrimitiveAttribute = function()
{

}

XMLParser.prototype.parseTokenValue = function(string, delim_begin, delim_end)
{
    var begin = string.indexOf(delim_begin);
    if (begin == -1)
    {
        return undefined;
    }
    begin += delim_begin.length;

    var end = string.indexOf(delim_end, begin);
    if (end == -1)
    {
        return undefined;
    }

    return string.substring(begin, end);
}


Serializer.prototype = new AttributeContainer();
Serializer.prototype.constructor = Serializer;

function Serializer()
{
    AttributeContainer.call(this);
    this.className = "Serializer";

    this.pbMixed = null;
    this.bMixed = false;
    this.DOM  = null;
    this.RootElement = null;
    this.elementStack = new Stack();
    
    this.format = new StringAttr("xml");
    this.serializeMinimum = new BooleanAttr(false);
    this.serializeChildren = new BooleanAttr(false);
    
    this.registerAttribute(this.format, "format");
    this.registerAttribute(this.serializeMinimum, "serializeMinimum");
    this.registerAttribute(this.serializeChildren, "serializeChildren");
}

Serializer.prototype.serialize = function(attribute, item, attributeName, container)
{
	this.RootElement = null;
    this.DOM  = document.implementation.createDocument("", "__InitialRoot", null); 
    if (this.DOM)
    {
        if (this.RootElement)
        {
            this.DOM.removeChild(this.RootElement);
            this.RootElement = null;

            this.mixedModifiedCB(attr,data);
        }
        if (attribute)
        {
            this.serializeAttribute(attribute, item, attributeName);
        }
        else
        {
            this.serializeAttribute(container, 0, "");
        }
    }
}

Serializer.prototype.serializeAttribute = function(attribute, item, attrName)
{
    if (attribute)
    {
        if (attribute.isTransient()) // don't serialize transient attributes
        {
            return;
        }
        
        if (this.serializeMinimum.getValueDirect() == true &&
            !attribute.isDeserializedFromXML()) // if requested, don't serialize defaults
        {
            return;
        }
        
        if (attribute.attrType == eAttrType.Model)
        {
            var model = attribute;
            this.serializeModel(model);
        }
        else if (attribute.attrType == eAttrType.PerspectiveCamera)
        {
            var ctr = attribute;
            this.serializeAttributeContainer(ctr)
        }
        else if (attribute.attrType > eAttrType.Command &&
                 attribute.attrType < eAttrType.Command_End)
        {
            var cmd = attribute;
            this.serializeCommand(cmd);
        }
        else if (attribute.isContainer())
        {
            var ctr = attribute;
            this.serializeAttributeContainer(ctr);
        }
        else if (attrName && this.DOM)
        {
            var aType = attribute.attrType;
            var element = null;
            var itemElement = null;
            var itemAttr = null;
            var attrMap = null;
            var strItemAttr;
            var vecVal;
            var varVal;

            var len = attribute.getLength();
            if (attrName)
            {
                // serializer cannot put "(" or ")" in the XML tag name,
                // so convert parentheses to a string that is value,
                // which is then converted back to parentheses in the result
                // of serialization
                
                var index = 0;
                while (true)
                {
                    /* Locate the substring to replace. */
                    index = attrName.indexOf("(");
                    if (index == -1) break;

                    /* Make the replacement. */
                    attrName.replace(index, 1, "_x0028");
                }
                while (true)
                {
                    /* Locate the substring to replace. */
                    index = attrName.indexOf(")");
                    if (index == -1) break;

                    /* Make the replacement. */
                    attrName.replace(index, 1, "_x0029");
                }
                var bstr = attrName;
                if (bstr)
                {
                    element = this.DOM.createElement(bstr);
                    if (element)
                    {
                        var strValue;
                        strValue = this.getAttributeStringValue(attribute, item);
                        if (strValue == "") return;

                        if (item >= 0 || len == 1 || aType == eAttrType.StringAttr)
                        {
                            // Check for a CDATA section:
                            // CDATA sections are used for CStringAttrs
                            // containing special characters, including XML.
                            // CDATA behaves as it does in SAX, i.e., it
                            // is not parsed.  It is instead passed directly
                            // to the Attribute as a string literal.

                            // TODO:  Move this "constant" to a shared location.
                            // It is also used by XMLTokenizer
                            var strCdataStart = "<![CDATA[";
                            var strCdataEnd = "]]>";

                            var nStartPos = 0;
                            var nEndPos = strValue.indexOf(strCdataEnd);
                            if (nStartPos != -1 && nEndPos != -1)
                            {

                                nStartPos += strCdataStart.length;

                                strValue = strValue.substr(nStartPos, strValue.length-nStartPos-strCdataEnd.length);
                                var cdata = null;
                                bstr = strValue;
                                if (bstr)
                                {
                                    cdata = this.DOM.createCDATASection(bstr);
                                }
                                element.appendChild(cdata);
                            }
                            else
                            {
                                element.textContent = strValue;
                            }
                        }
                        else
                        {
                            var sv;
                            var startNdx = 0;
                            var endNdx = 0;
                            for (var i = 0; i < len; ++i)	// len - 1 = # of commas
                            {
                                strItemAttr = "item" + i.toString();

                                endNdx = (i == len-1) ? strValue.length : strValue.indexOf(",", startNdx);
                                sv = strValue.substr(startNdx, endNdx-startNdx);

                                startNdx = endNdx+1;

                                if (this.bMixed)
                                {
                                    itemElement = this.DOM.createElement(strItemAttr);
                                    itemElement.textValue = sv;
                                    element.appendChild(itemElement);
                                }
                                else
                                {
                                    itemAttr = this.DOM.createAttribute(strItemAttr);
                                    itemAttr.value = sv;
                                    element.setAttributeNode(itemAttr);
                                }
                            }
                        }

                        this.pushElement(element);
                        this.popElement();
                    }
                }
            }
        }
    }
}
Serializer.prototype.serializeAttributeReference = function(attribute, reference)
{
    if (attribute && reference && this.DOM)
    {
        var container = null;
        var element = null;
        var itemAttr = null;
        var attrMap = null;
        var pOldChild = null;

        container = attribute.getContainer();
        if (container)
        {
            var bstr = container.getAttributeName(attribute);
            if (bstr)
            {
                element = this.DOM.createElement(bstr);
            }
        }
        if (element)
        {
            if (element.attributes.length > 0)
            {
                itemAttr = this.DOM.createAttribute("ref");

                if (itemAttr)
                {
                    var refName = "";
                    var tmpName = "";
                    var nameAttr = null;
                    container = reference.getContainer();
                    if (container)
                    {
                        refName = container.getAttributeName(reference);
                        if (nameAttr = container.getAttribute("name"))
                        {
                            var s;
                            tmpName = nameAttr.getValueDirect().join("");
                            tmpName += "/";
                            tmpName += refName;
                            refName = tmpName;
                        }
                    }
                    itemAttr.textContent = refName;
                    attrMap.setNamedItem(itemAttr, pOldChild);
                }
            }

            this.pushElement(element);
            this.popElement();
        }
    }
}

Serializer.prototype.serializeModel = function(Model)
{
    // surround <Model> and <Set> tags so that both will serialize (previously the
    // <Set> was overwriting the <Model> as the root)
    var bstr = null;
    var element = null;
    if (this.DOM)
    {
        bstr = "ModelRoot";
        if (bstr)
        {
            element = this.DOM.createElement(bstr);
            if (element)
            {
                this.pushElement(element);
            }
        }
    }

    if (Model)
    {
        // serialize Model
        this.serializeAttributeContainer(Model);

        // add set command for rotation group's quaternion rotation, to retain rotation caused by object inspection
        var RotGroup = null;
        if (RotGroup = getInspectionGroup(Model))
        {
            var container = Model;
            var attr = RotGroup.getChild(2).getAttribute("rotationQuat");

            var containerName;
            var containerNameAttr = container.getAttribute("name");
            containerName = containerNameAttr.getValueDirect().join("");

            var command = null;
            var factory = this.registry.find("AttributeFactory");
            command = factory.create("Set");
            if (command)
            {
                command.getAttribute("target").setValueDirect(containerName);
                command.getAttribute("target").flagDeserializedFromXML();

                var values = [];
                attr.getValue(values);

                command.attributeValuePairs.push(new Pair(attr, values));
                
                this.serializeCommand(command);
                
                // setting the target on the SetCommand sets the attribute bin, which is normally
                // cleared by adding the command to the CommandMgr, but this doesn't occur here, because
                // it is only being serialized, not executed
                setAttributeBin(null);
                setAttributePairs(null);
            }
        }
    }

    if (element)
    {
        this.popElement();
    }
}

Serializer.prototype.serializeCommand = function(command)
{
    var i;
    // 1. create the start tag.

    if (command && this.DOM)
    {
        var element = null;
        var pcszType = command.className;
               
        // don't serialize SerializeCommand
        if (pcszType == "Serialize") return;
        
        var bstr = pcszType;
        if (bstr)
        {
            //this.DOM.createElement(bstr, element); Can only pass in a string value for this and only has 1 parameter
            element = this.DOM.createElement(bstr);
            if (element) {
                this.pushElement(element);

                // 2. serialize the native attributes (except "sourceContainer", "sourceEvaluator",
                //    "sourceAttribute", "sourceOutput", "source", "targetContainer", "targetAttribute", "target")
                var i;
                var attribute = null;
                var pcszName = null;
                var uiAttrCount = command.getAttributeCount();
                for (i = 0; i < uiAttrCount; ++i) {
                    attribute = command.getAttributeAt(i);
                    pcszName = command.getAttributeName(attribute);
                    if (!command.isBorrowed(attribute) &&
                        (pcszName != "sourceContainer") &&
                        (pcszName != "sourceEvaluator") &&
                        (pcszName != "sourceAttribute") &&
                        (pcszName != "sourceOutput") &&
                        (pcszName != "source") &&
                        (pcszName != "targetContainer") &&
                        (pcszName != "targetAttribute") &&
                        (pcszName != "target")) {
                        this.serializeAttribute(attribute, -1, pcszName);
                    }
                }

                // 3. serialize "sourceContainer", "targetContainer"
                attribute = command.getAttribute("sourceContainer");
                if (attribute) {
                    this.serializeAttribute(attribute, -1, "sourceContainer");
                }
                attribute = command.getAttribute("targetContainer");
                if (attribute) {
                    this.serializeAttribute(attribute, -1, "targetContainer");
                }

                // 4. serialize "sourceAttribute", "targetAttribute", "target" (may be multiple source/target pairs)
                var sources = [];
                var targets = [];
                for (i = 0; i < uiAttrCount; ++i) 
                {
                    //attribute = command.getAttribute(i, pcszName);
                    var attr = command.getAttributeAt(i);
                    var attrName = command.getAttributeName(attr);
                    if (attrName == "sourceAttribute") 
                    {
                        sources.push(attr);
                    }
                    else if (attrName == "targetAttribute") 
                    {
                        targets.push(attr);
                    }
                }
                
                // source/target pairs must be serialized together
                for (i = 0; i < sources.length && i < targets.length; i++) 
                {
                    this.serializeAttribute(sources[i], -1, "sourceAttribute");
                    this.serializeAttribute(targets[i], -1, "targetAttribute");
                }
                // if "targetAttribute" specified, don't serialize "target"
                if (targets.length == 0) 
                {
                    attribute = command.getAttribute("target");
                    if (attribute) 
                    {
                        this.serializeAttribute(attribute, -1, "target");
                    }
                }

                // 5. serialize the borrowed attributes that were modified by the command
                var vNewVal;
                var pRef;
                for (i = 0; i < uiAttrCount; ++i) 
                {
                    attribute = command.getAttributeAt(i);
                    var attrName = command.getAttributeName(attribute);
                    var borrowed = command.isBorrowedAndValueModified(attribute);
                    if (borrowed.borrowed)
                    {
                        var pNewAttribute = newAttribute(attribute.className);
                        if (pNewAttribute) 
                        {
                            setAttributeValue(pNewAttribute, borrowed.value);
                            pNewAttribute.flagDeserializedFromXML();
                            this.serializeAttribute(pNewAttribute, -1, attrName);
                        }
                    }
                    else 
                    {
                    	var borrowed = command.isBorrowedAndReferenceModified(attribute);
                    	if (borrowed.borrowed) 
                    	{
                        	this.serializeAttributeReference(attribute, borrowed.reference);
                        }
                    }
                }

                this.popElement();
            }
        }
    }
}

Serializer.prototype.serializeAttributeContainer = function(container)
{
    // 1. create the start tag.

    if (container && this.DOM)
    {
        var element = null;
        var pcszType = container.className;
        if (pcszType == "BwSceneInspector")
        {
        	pcszType = "SceneInspector";
        }

        var bstr = pcszType;
        if (bstr)
        {
            element = this.DOM.createElement(bstr);
            if (element)
            {
                this.pushElement(element);

                var attribute = null;
                var pcszName = null;
                var uiAttrCount = container.getAttributeCount();

                // 0. serialize any native attributes first
                for (var i = 0; i < uiAttrCount; ++i)
                {
                    attribute = container.getAttributeAt(i);
                    var attrName = container.getAttributeName(attribute);
                    if (attribute.isNative() == true)
                    {
                        this.serializeAttribute(attribute, -1, attrName);
                    }
                }

                // 1. if serialization of children is requested, serialize children
                if (this.serializeChildren.getValueDirect())
                {
                    this.doSerializeChildren(container);
                }

                // 2. serialize the non-native attributes
                for (var i = 0; i < uiAttrCount; ++i)
                {
                    attribute = container.getAttributeAt(i);
                    if (container.getAttributeModificationCount(attribute) == 0) continue;
                    var attrName = container.getAttributeName(attribute);
                    if (attribute.isNative() == false)
                    {
                        this.serializeAttribute(attribute, -1, attrName);
                    }
                }
                this.popElement();
            }
        }
    }

    // 3. create the end tag.
}

Serializer.prototype.serializeAttributeCollection = function(collection)
{
    if (collection && this.DOM)
    {
        var element = null;
        var pcszType = collection.className;

        var bstr = pcszType;
        if (bstr)
        {
            element = this.DOM.createElement(bstr);
            if (element)
            {
                this.pushElement(element);

                // vector
                var attrVec = collection;
                {
                    var elementName;
                    var baseName = attrVec.baseName.getValueDirect().join("");

                    var size = attrVec.length;
                    for (var i=0; i < size; i++)
                    {
                        elementName = baseName[0];
                        elementName += "[";
                        elementName += i.toString();
                        elementName += "]";

                        this.serializeAttribute(attrVec[i], 0, elementName);
                    }
                }

                this.popElement();
            }
        }
    }
}

Serializer.prototype.doSerializeChildren = function(root)
{
    if (root.attrType < eAttrType.Node ||
        root.attrType > eAttrType.Node_End)
    {
        return;
    }
    
    for (var i=0; i < root.getChildCount(); i++)
    {
        this.serializeAttribute(root.getChild(i), 0, null);
    }
}

Serializer.prototype.pushElement = function(element)
{
	this.elementStack.push(element);
	    
    if (this.RootElement)
    {
        this.RootElement.appendChild(element);
    }
    else // !this.RootElement
    {
        this.DOM.replaceChild(element, this.DOM.documentElement);
    }

    this.RootElement = element;
}

Serializer.prototype.popElement = function()
{
    this.elementStack.pop();

    if (this.elementStack.length() > 0)
    {
        this.RootElement = this.elementStack.top();
    }
}

Serializer.prototype.getAttributeStringValue = function(attr, item)
{
    strValue = "";

    var e = attr.attrType;

    var index = -1;

    switch (e)
    {
        case eAttrType.NumberAttr:
        {
            var i = attr.getValueDirect();
            strValue = i.toString();
        }
            break;
        case eAttrType.BooleanAttr:
        {
            var b = attr.getValueDirect();
            if (b == true)
            {
            	strValue = "true";
            }
            else
            {
            	strValue = "false";
            }
        }
            break;
        case eAttrType.StringAttr:
        {
            var len = attr.getLength();
            strValue = attr.getValueDirect().join("");
        }
            break;
        case eAttrType.ColorAttr:
        case eAttrType.Vector2DAttr:
        case eAttrType.Vector3DAttr:
        case eAttrType.Matrix4x4Attr:
        case eAttrType.QuaternionAttr:
        {
            var vecVal_F = [];
            attr.getValue(vecVal_F);
            if (item == -1)
            {
                for (var i = 0; i < vecVal_F.length; ++i)
                {
                    strValue += vecVal_F[i].toString();
                    if (i < vecVal_F.length - 1)
                    {
                        strValue += ",";
                    }
                }
            }
            else
            {
                strValue += vecVal_F[item].toString();
            }
        }
            break;
        case eAttrType.NumberArrayAttr:
        case eAttrType.ViewportAttr:
        {
            var vecVal_I = [];
            attr.getValue(vecVal_I);
            if (item == -1)
            {
                for (var i = 0; i < vecVal_I.length; ++i)
                {
                    strValue += vecVal_I[i].toString();
                    if (i < vecVal_I.length - 1)
                    {
                        strValue += ",";
                    }
                }
            }
            else
            {
                strValue += vecVal_I[item].toString();
            }
        }
            break;
        default:
        {
        }
            break;
    }
    
    return strValue;
}

Serializer.prototype.mixedModifiedCB = function(attr,data)
{
    var v = [];
    attr.getValue(v);
    var pSerializer = data;
    if (pSerializer != 0xffffffff)
    {
        pSerializer.bMixed = v[0]; //ASK MICHAEL
    }
}


/**
 *
 */
var ePixelFormat =
{
    Unknown             :-1,
    R8G8B8              : 0,  // 24-bit RGB
    B8G8R8              : 1,  // 24-bit BGR
    X8X8X8              : 2,  // 24-bit RGB (unspecified component order)
    R8G8B8A8            : 3,  // 32-bit RGB Alpha
    B8G8R8A8            : 4,  // 32-bit BGR Alpha
    A8R8G8B8            : 5,  // 32-bit Alpha RGB
    A8B8G8R8            : 6,  // 32-bit Alpha BGR
    X8X8X8X8            : 7,  // 32-bit RGB Alpha (unspecified component order)
    A8                  : 8   //  8-bit Alpha
};

var ePixelMap =
{
    Default             : 0,  // default mapping -- R to R, G to G, B to B, Alpha to Alpha
    RGBToAlpha          : 1   // average RGB components and map to Alpha component
};

function BytesPerPixel(pixelFormat)
{
    switch (pixelFormat)
    {
    case ePixelFormat.R8G8B8:
    case ePixelFormat.B8G8R8:
    case ePixelFormat.X8X8X8:
        return 3;

    case ePixelFormat.R8G8B8A8:
    case ePixelFormat.B8G8R8A8:
    case ePixelFormat.A8R8G8B8:
    case ePixelFormat.A8B8G8R8:
    case ePixelFormat.X8X8X8X8:
        return 4;

    case ePixelFormat.A8:
        return 1;

    default:
        return 0;
    }
}

function TPixel(r, g, b, a)
{
    var red = r || 0;
    var green = g || 0;
    var blue = b || 0;
    var alpha = a || 0;
}

/**
 *
 */
var eImageFormat =
{
    Unknown             :-1,
    RGB                 : 0,
    RGBA                : 1,
    Alpha               : 2,
    Luminance           : 3,
    Luminance_Alpha     : 4
}
function ScaleImage(pixelFormat, widthIn, heightIn, byteAlignmentIn, dataIn, widthOut, heightOut, byteAlignmentOut, dataOut)
{
    // currently supporting image pixel formats: RGBA
    if (pixelFormat != ePixelFormat.R8G8B8A8)
    {
        return false;
    }

    var canvasIn = document.createElement("canvas");
    canvasIn.width = widthIn;
    canvasIn.height = heightIn;
    
    var ctxIn = canvasIn.getContext("2d");
    var imageDataIn = ctxIn.createImageData(widthIn, heightIn);

    var i = 0;
    for (var row = 0; row < heightIn; row++)
    {
        for (var col = 0; col < widthIn; col++)
        {
            for (var component = 0; component < 4; component++, i++)
            {
                imageDataIn.data[i] = dataIn[i];
            }
        }
    }

    ctxIn.putImageData(imageDataIn, 0, 0);

    var canvasOut = document.createElement("canvas");
    canvasOut.width = widthOut;
    canvasOut.height = heightOut;

    var ctxOut = canvasOut.getContext("2d");
    
    ctxOut.drawImage(canvasIn,
                     0, 0, canvasIn.width, canvasIn.height,
                     0, 0, canvasOut.width, canvasOut.height);
               
    var imageDataOut = ctxOut.getImageData(0, 0, widthOut, heightOut);

    i = 0;
    for (var row = 0; row < heightOut; row++)
    {
        for (var col = 0; col < widthOut; col++)
        {
            for (var component = 0; component < 4; component++, i++)
            {
                dataOut[i] = imageDataOut.data[i];
            }
        }
    }

    return true;
}
// filter flags for GetFrameData() filterMask parameter
var FRAME_FILTER_SCALE_FRAME_BIT    = 0x001;    // scale frame to size of incoming buffer before copying
var FRAME_FILTER_INVERT_FRAME_BIT   = 0x002;    // invert frame
var FRAME_FILTER_NEGATE_COLOR_BIT   = 0x004;    // invert rgb pixel data (subtract from 255)
var FRAME_FILTER_NEGATE_ALPHA_BIT   = 0x008;    // invert alpha pixel data (subtract from 255)
var FRAME_FILTER_ALPHA_ONOFF_BIT    = 0x010;    // set alpha pixel to 0 or 255; alpha values in the range
                                                // [0, 127] are set to 0, [128, 255] are set to 255
                                                
function MediaPlayback(container, onload)
{
    this.container = container;
    this.onload = onload;

    this.url = null;
    this.video = false;
    this.ready = false;
    this.alphaPlayback = null;
    this.frameRetrieved = false;
    this.htmlImageElement = null;
    this.imageWidth = 0;
    this.imageHeight = 0;
    this.imagePitch = 0;
    this.imagePixels = null;
}

MediaPlayback.prototype.loadImage = function(url)
{
    this.ready = false;
    this.frameRetrieved = false;
    this.htmlImageElement = null;
    this.imageWidth = 0;
    this.imageHeight = 0;
    this.imagePitch = 0;
    this.imagePixels = null;

    var extension = getFileExtension(url);

    switch (extension)
    {
        case "avi":
        case "mpg":
        case "ogg":
            {

                this.htmlImageElement = document.createElement("video");
                this.htmlImageElement.container = this;
                this.htmlImageElement.controls = "controls";
                //this.htmlImageElement.preload = "auto";
                //this.htmlImageElement.autoplay = "autoplay";
                //this.htmlImageElement.setAttribute("controls", "controls");
                //this.htmlImageElement.setAttribute("preload", "preload");
                //this.htmlImageElement.setAttribute("autoplay", "autoplay");

                //this.htmlImageElement.canvas = document.createElement("canvas");
                //this.htmlImageElement.canvasContext = this.htmlImageElement.canvas.getContext("2d");

                //this.htmlImageElement.addEventListener("play", MediaTexture_OnVideoPlay, false);
                //this.htmlImageElement.onload = MediaTexture_OnVideoLoad;

                //this.onVideoPlay();
                this.htmlImageElement.src = "http://localhost/bwjs/BwContent/images/Bear.ogg"; //url;

                this.video = true;
                this.onVideoLoad();

                /*
                this.htmlImageElement = document.createElement("video"); //new Image();
                this.htmlImageElement.container = this;
                this.htmlImageElement.preload = "auto";
                this.htmlImageElement.autoplay = "autoplay";
                this.htmlImageElement.onload = MediaPlayback_OnVideoLoad;
                this.htmlImageElement.src = imageFilename;
                //this.imageSet = true;
                //this.video = true;
                */
                //var resource = loadBinaryResource(imageFilename);
                //alert(resource);
            }
            break;

        default:
            {
                this.htmlImageElement = new Image(); //document.createElement("img");
                this.htmlImageElement.container = this;
                this.htmlImageElement.onload = MediaPlayback_OnImageLoad;
                this.htmlImageElement.src = url;
            }
            break;
    }

    this.url = url;
}

MediaPlayback.prototype.onImageLoad = function()
{
    var image = this.htmlImageElement;
    this.imageWidth = image.width;
    this.imageHeight = image.height;
    this.imagePitch = image.width * 4; // rgba
    var canvas = document.createElement("canvas");
    var canvasContext = canvas.getContext("2d");
    canvas.width = image.width;
    canvas.height = image.height;
    canvasContext.drawImage(image, 0, 0);
    var imageData = canvasContext.getImageData(0, 0, image.width, image.height);
    this.imagePixels = imageData.data;

    this.ready = true;

    if (this.onload)
    {
        this.onload.call(this);
    }
}

MediaPlayback.prototype.onVideoLoad = function()
{
    this.ready = true;
}

MediaPlayback.prototype.getFrameDimensions = function()
{
    return { width: this.imageWidth, height: this.imageHeight, pitch: this.imagePitch };
}

MediaPlayback.prototype.getPixelFormat = function()
{
    return ePixelFormat.R8G8B8A8;
}

MediaPlayback.prototype.getPixelByteAlignment = function()
{
    return 4;
}

MediaPlayback.prototype.getBytesPerPixel = function()
{
    return BytesPerPixel(this.getPixelFormat());
}

/**
 * Retrieve the pixels for the current frame.
 * @param buffer        - incoming buffer to receive pixel data.
 * @param frame         - optional parameter specifying the frame number to retrieve.
 * @return number       - the frame number retrieved, -1 for single-frame images, or undefined on failure.
 */
MediaPlayback.prototype.getFramePixels = function(buffer, frame)
{
    // verify validity of image data
    if (!this.ready ||
        this.imageWidth == 0 ||
        this.imageHeight == 0 ||
        !this.imagePixels)
    {
        return undefined;
    }

    buffer.length = this.imagePixels.length;
    for (var i = 0; i < this.imagePixels.length; i++)
    {
        buffer[i] = this.imagePixels[i];
    }

    return -1; // single-frame image
}

MediaPlayback.prototype.newFrameDataAvailable = function()
{
    return this.ready && !this.frameRetrieved;
}

/**
 * Retrieve the pixels for the current frame in the specified pixel format and dimensions.
 * @param width         - width of the incoming buffer in pixels.
 * @param height        - height of the incoming buffer in pixels.
 * @param pitch         - width of a scan line of pixels in bytes; may differ from width * bytes
 *                        per pixel if pixels are padded to 2- or 4-byte boundaries.
 * @param pixelFormat   - pixel format of the incoming buffer.
 * @param buffer        - incoming buffer to receive pixel data.
 * @param filterMask    - zero or more OR'd filtering flags controlling how the image is filtered:
 *
 *                        FRAME_FILTER_SCALE_FRAME_BIT  - the frame is first scaled to the size 
 *                                                        of the incoming buffer before copying
 *                        FRAME_FILTER_INVERT_FRAME_BIT - the frame is inverted before copying
 *                        FRAME_FILTER_NEGATE_COLOR_BIT - the rgb pixel data is inverted (subtracted from 255) 
 *                        FRAME_FILTER_NEGATE_ALPHA_BIT - the alpha pixel data is inverted (subtracted from 255)
 *                        FRAME_FILTER_ALPHA_ONOFF_BIT  - set alpha pixel to 0 or 255; alpha values in the range
 *                                                        [0, 127] are set to 0, [128, 255] are set to 255
 *
 * @param pixelMap      - pixel mapping to perform; default: PixelMap_Default.
 * @param frame         - optional parameter specifying the frame number to retrieve.
 * @return number       - the frame number retrieved, -1 for single-frame images, or undefined on failure.
 */
MediaPlayback.prototype.getFrameData = function(width, height, pitch, pixelFormat, buffer, filterMask, pixelMap, frame)
{
    // verify validity of image data
    if (!this.ready ||
        this.imageWidth == 0 ||
        this.imageHeight == 0 ||
        !this.imagePixels)
    {
        return undefined;
    }

    // check params
    if (width == 0 ||
        height == 0 ||
        pitch < width ||
        pixelFormat == ePixelFormat.Unknown ||
        !buffer)
    {
        return undefined;
    }

    var frameRetrieved = -1;

    // get filter flags
    var scaleFrame = filterMask & FRAME_FILTER_SCALE_FRAME_BIT ? true : false;
    var invertFrame = filterMask & FRAME_FILTER_INVERT_FRAME_BIT ? true : false;
    var negateColor = filterMask & FRAME_FILTER_NEGATE_COLOR_BIT ? true : false;
    var negateAlpha = filterMask & FRAME_FILTER_NEGATE_ALPHA_BIT ? true : false;
    var alphaOnOff = filterMask & FRAME_FILTER_ALPHA_ONOFF_BIT ? true : false;

    // get image dimensions
    var dims = this.getFrameDimensions();
    var imageWidth = dims.width;
    var imageHeight = dims.height;
    var imagePitch = dims.pitch;

    // get image pixel format
    var imagePixelFormat = this.getPixelFormat();

    // currently supporting image pixel formats: RGBA
    if (imagePixelFormat != ePixelFormat.R8G8B8A8)
    {
        return undefined;
    }

    // get image pixels
    var pixels = [];
    var imageFrameRetrieved = this.getFramePixels(pixels, frame);
    if (imageFrameRetrieved == undefined)
    {
        return undefined;
    }

    // scale pixels if necessary
    if (scaleFrame && (width != imageWidth || height != imageHeight))
	{
		var imageBytesPerPixel = this.getBytesPerPixel();

		// calculate pitch (using byte aligment of "4")
		imagePitch = width * imageBytesPerPixel;
		imagePitch += (4 - imagePitch % 4) % 4;

		var scaledPixels = [];
		if (!ScaleImage(imagePixelFormat, imageWidth, imageHeight, this.getPixelByteAlignment(), pixels, 
			width, height, 4, scaledPixels))
		{
			return undefined;
		}

		pixels = scaledPixels;
		imageWidth = width;
		imageHeight = height;
	}

    // if no alpha channel, rgb pixel data is not to be negated, frame is not to be inverted,
    // and incoming buffer has same parameters as pixel buffer, copy bits
    if (!this.alphaPlayback &&
		!negateColor &&
		!invertFrame &&
		imagePitch == pitch &&
		imageHeight == height &&
		imagePixelFormat == pixelFormat)
    {
        for (var i = 0; i < buffer.length; i++)
        {
            buffer[i] = pixels[i];
        }
        
        this.frameRetrieved = true;
        return frameRetrieved;
    }

    // get alpha data
    var alphaWidth = 0;
	var alphaHeight = 0;
	var alphaPitch = 0;
	var alphaPixelFormat;
	var alphaPixels = null;
	if (this.alphaChannel)
	{
		// get alpha dimensions
		dims = this.alphaChannel.getFrameDimensions();
		alphaWidth = dims.width;
		alphaHeight = dims.height;
		alphaPitch = dims.pitch;

		// get alpha pixel format
		alphaPixelFormat = this.alphaChannel.getPixelFormat();
    
		// currently only supporting alpha pixel formats: RGBA
		if (alphaPixelFormat != ePixelFormat.R8G8B8A8)
		{
			return undefined;
		}

		// get alpha pixels
		var alphaFramePixels = [];
		var alphaFrameRetrieved = this.alphaChannel.getFramePixels(alphaFramePixels, imageFrameRetrieved);
		if (alphaFrameRetrieved != undefined)
		{
		    // scale alpha pixels to match frame data
		    if (alphaWidth != imageWidth ||
			    alphaHeight != imageHeight)
		    {
			    var alphaBytesPerPixel = this.alphaChannel.getBytesPerPixel();

			    // calculate pitch (using byte aligment of "4")
			    alphaPitch = imageWidth * alphaBytesPerPixel;
			    alphaPitch += (4 - alphaPitch % 4) % 4;

			    var scaledAlphaPixels = [];
			    if (ScaleImage(alphaPixelFormat, alphaWidth, alphaHeight, 
				    this.alphaChannel.getPixelByteAlignment(), alphaPixels, imageWidth, 
				    imageHeight, 4, scaledAlphaPixels))
			    {
			        alphaPixels = scaledAlphaPixels;
			        alphaWidth = imageWidth;
			        alphaHeight = imageHeight;
			    }
		    }
		    else
		    {
		        alphaPixels = alphaFramePixels;
		    }
		}
	}
	
    // determine dimensions to copy
    var copyWidth = Math.min(width, imageWidth);
    var copyHeight = Math.min(height, imageHeight);

    // set component positions for buffer pixel format
    var rPos = 0, gPos = 0, bPos = 0, aPos = 0;
    switch (pixelFormat)
    {
        case ePixelFormat.R8G8B8: rPos = 0; gPos = 1; bPos = 2; break;
        case ePixelFormat.B8G8R8: rPos = 2; gPos = 1; bPos = 0; break;
        case ePixelFormat.R8G8B8A8: rPos = 0; gPos = 1; bPos = 2; aPos = 3; break;
        case ePixelFormat.B8G8R8A8: rPos = 2; gPos = 1; bPos = 0; aPos = 3; break;
        case ePixelFormat.A8R8G8B8: rPos = 1; gPos = 2; bPos = 3; aPos = 0; break;
        case ePixelFormat.A8B8G8R8: rPos = 3; gPos = 2; bPos = 1; aPos = 0; break;
    }

    // if frame is to be inverted, start copying from last row of data
    var fromImage = 0, fromAlpha = 0, to = 0;
    if (invertFrame)
    {
        fromImage += imagePitch * (copyHeight - 1);

        if (alphaPixels)
        {
            fromAlpha += alphaPitch * (copyHeight - 1);
        }
    }

    // copy pixel data to buffer
    var pixel = new TPixel(0, 0, 0, 255);
    var alphaPixel = new TPixel(0, 0, 0, 255);
    for (var row = 0; row < copyHeight; row++)
    {
        for (var col = 0; col < copyWidth; col++)
        {
            // get image pixel
            /*
            switch (imagePixelFormat)
            {
            case ePixelFormat.R8G8B8:
            pixel.red = pixels[fromImage];
            pixel.green = pixels[fromImage + 1];
            pixel.blue = pixels[fromImage + 2];
            fromImage += 3;
            break;

                case ePixelFormat.B8G8R8:
            pixel.red = pixels[fromImage + 2];
            pixel.green = pixels[fromImage + 1];
            pixel.blue = pixels[fromImage];
            fromImage += 3;
            break;

                case ePixelFormat.R8G8B8A8:
            pixel.red = pixels[fromImage];
            pixel.green = pixels[fromImage + 1];
            pixel.blue = pixels[fromImage + 2];
            pixel.alpha = pixels[fromImage + 3];
            fromImage += 4;
            break;

                case ePixelFormat.B8G8R8A8:
            pixel.red = pixels[fromImage + 2];
            pixel.green = pixels[fromImage + 1];
            pixel.blue = pixels[fromImage];
            pixel.alpha = pixels[fromImage + 3];
            fromImage += 4;
            break;

                case ePixelFormat.A8B8G8R8:
            pixel.red = pixels[fromImage + 3];
            pixel.green = pixels[fromImage + 2];
            pixel.blue = pixels[fromImage + 1];
            pixel.alpha = pixels[fromImage];
            fromImage += 4;
            break;
            }
            */
            pixel.red = pixels[fromImage];
            pixel.green = pixels[fromImage + 1];
            pixel.blue = pixels[fromImage + 2];
            pixel.alpha = pixels[fromImage + 3];
            fromImage += 4;

            // negate rgb data if requested
            if (negateColor)
            {
                pixel.red = 255 - pixel.red;
                pixel.green = 255 - pixel.green;
                pixel.blue = 255 - pixel.blue;
                pixel.alpha = 255 - pixel.alpha;
            }

            // get alpha pixel
            if (alphaPixels)
            {
                /*
                switch (alphaPixelFormat)
                {
                case ePixelFormat.R8G8B8:
                alphaPixel.red = alphaPixels[fromAlpha];
                alphaPixel.green = alphaPixels[fromAlpha + 1];
                alphaPixel.blue = alphaPixels[fromAlpha + 2];
                fromAlpha += 3;
                break;

                    case ePixelFormat.B8G8R8:
                alphaPixel.red = alphaPixels[fromAlpha + 2];
                alphaPixel.green = alphaPixels[fromAlpha + 1];
                alphaPixel.blue = alphaPixels[fromAlpha];
                fromAlpha += 3;
                break;

                    case ePixelFormat.R8G8B8A8:
                alphaPixel.red = alphaPixels[fromAlpha];
                alphaPixel.green = alphaPixels[fromAlpha + 1];
                alphaPixel.blue = alphaPixels[fromAlpha + 2];
                alphaPixel.alpha = alphaPixels[fromAlpha + 3];
                fromAlpha += 4;
                break;

                    case ePixelFormat.B8G8R8A8:
                alphaPixel.red = alphaPixels[fromAlpha + 2];
                alphaPixel.green = alphaPixels[fromAlpha + 1];
                alphaPixel.blue = alphaPixels[fromAlpha];
                alphaPixel.alpha = alphaPixels[fromAlpha + 3];
                fromAlpha += 4;
                break;
                }
                */
                alphaPixel.red = alphaPixels[fromAlpha];
                alphaPixel.green = alphaPixels[fromAlpha + 1];
                alphaPixel.blue = alphaPixels[fromAlpha + 2];
                alphaPixel.alpha = alphaPixels[fromAlpha + 3];
                fromAlpha += 4;
            }

            // negate alpha data if requested
            if (negateAlpha)
            {
                alphaPixel.red = 255 - alphaPixel.red;
                alphaPixel.green = 255 - alphaPixel.green;
                alphaPixel.blue = 255 - alphaPixel.blue;
                alphaPixel.alpha = 255 - alphaPixel.alpha;
            }

            // copy to buffer
            switch (pixelFormat)
            {
                case ePixelFormat.R8G8B8:
                case ePixelFormat.B8G8R8:
                    buffer[to + rPos] = pixel.red;
                    buffer[to + gPos] = pixel.green;
                    buffer[to + bPos] = pixel.blue;
                    to += 3;
                    break;

                case ePixelFormat.R8G8B8A8:
                case ePixelFormat.B8G8R8A8:
                case ePixelFormat.A8R8G8B8:
                case ePixelFormat.A8B8G8R8:
                    switch (pixelMap)
                    {
                        case ePixelMap.RGBToAlpha:
                            buffer[to + rPos] = 0;
                            buffer[to + gPos] = 255;
                            buffer[to + bPos] = 0;
                            if (alphaPixels)
                            {
                                buffer[to + aPos] =
								((pixel.red + pixel.green + pixel.blue) / 3) &
								((alphaPixel.red + alphaPixel.green + alphaPixel.blue) / 3);
                            }
                            else
                            {
                                buffer[to + aPos] = (pixel.red + pixel.green + pixel.blue) / 3;
                            }
                            if (alphaOnOff)
                            {
                                buffer[to + aPos] = (buffer[to + aPos] <= 127 ? 0 : 255);
                            }
                            to += 4;
                            break;

                        case ePixelMap.Default:
                        default:
                            buffer[to + rPos] = pixel.red;
                            buffer[to + gPos] = pixel.green;
                            buffer[to + bPos] = pixel.blue;
                            if (alphaPixels)
                            {
                                buffer[to + aPos] = (alphaPixel.red + alphaPixel.green + alphaPixel.blue) / 3;
                            }
                            else
                            {
                                buffer[to + aPos] = pixel.alpha;
                            }
                            if (alphaOnOff)
                            {
                                buffer[to + aPos] = (buffer[to + aPos] <= 127 ? 0 : 255);
                            }
                            to += 4;
                            break;
                    }
                    break;

                case ePixelFormat.A8:
                    if (alphaPixels)
                    {
                        buffer[to] = (alphaPixel.red + alphaPixel.green + alphaPixel.blue) / 3;
                    }
                    else // !alphaPixels
                    {
                        buffer[to] = (pixel.red + pixel.green + pixel.blue) / 3;
                    }
                    if (alphaOnOff)
                    {
                        buffer[to] = (buffer[to] <= 127 ? 0 : 255);
                    }
                    to += 1;
                    break;
            }
        }

        if (invertFrame) fromImage -= (2 * imagePitch);
        if (alphaPixels)
        {
            if (invertFrame) fromAlpha -= (2 * alphaPitch);
        }
    }

    this.frameRetrieved = true;

    return frameRetrieved;
}

MediaPlayback.prototype.setAlphaChannel = function(playback)
{
    this.alphaPlayback = playback;
}

function MediaPlayback_OnImageLoad()
{
    this.container.onImageLoad();
}
// TODO: consider moving to a more appropriate file
function TextureArray(textureArray)
{
    this.textures = new Array(eTextureType.EnumCount);

    for (var i=0; i < this.textures.length; i++)
    {
        if (textureArray)
        {
            this.textures[i] = textureArray.textures[i].slice();
        }
        else
        {
            this.textures[i] = [];
        }
    }
}


StyleMgr.prototype = new AttributeContainer();
StyleMgr.prototype.constructor = StyleMgr;

function StyleMgr()
{
    AttributeContainer.call(this);
    this.className = "StyleMgr";
}

StyleMgr.prototype.eventPerformed = function(event, node)
{
    var result = node.stylesMap.getStyles(event.type);
    if (result.styles && result.enabled)
    {
        this.applyStyle(result.styles, result.target ? result.target : node);
    }
}

StyleMgr.prototype.applyStyle = function(style, node)
{
    node.styles.updateStyle(style);
}
GraphMgr.prototype = new AttributeContainer();
GraphMgr.prototype.constructor = GraphMgr;

function GraphMgr()
{
    AttributeContainer.call(this);
    this.className = "GraphMgr";
    
    this.renderContext = null;
    this.renderState = null;
    this.lightIndex = 0;
    this.material = null;
    this.dissolve = null;
    this.balloonTipLabel = null;
    this.drawTextures = true;
    this.textureArrayStack = new Stack(new TextureArray());
    this.projectionTextureArrayStack = new Stack(new TextureArray());
    this.labelIndex = 1;
    this.balloonTipLabelIndex = 1;
    this.styleMgr = new StyleMgr();
    
    this.name = new StringAttr("GraphMgr");
    
    this.registerAttribute(this.name, "name");
}

GraphMgr.prototype.setRenderContext = function(rc)
{
    this.renderContext = rc;
    this.renderState = new RenderState(rc);
}

GraphMgr.prototype.getAvailableLightIndex = function()
{
    return this.lightIndex++;
}

GraphMgr.prototype.getCurrentMaterial = function()
{
    return this.material;
}

GraphMgr.prototype.setCurrentMaterial = function(material)
{
    this.material = material;
}

GraphMgr.prototype.getCurrentDissolve = function()
{
    return this.dissolve;
}

GraphMgr.prototype.setCurrentDissolve = function(dissolve)
{
    this.dissolve = dissolve;
}

GraphMgr.prototype.getCurrentBalloonTipLabel = function()
{
    return this.balloonTipLabel;
}

GraphMgr.prototype.setCurrentBalloonTipLabel = function(balloonTipLabel)
{
    this.balloonTipLabel = balloonTipLabel;
}

GraphMgr.prototype.getDrawTextures = function()
{
    return this.drawTextures;
}

GraphMgr.prototype.setDrawTextures = function(drawTextures)
{
    this.drawTextures = drawTextures;
}

GraphMgr.prototype.getNextLabelIndex = function()
{
    return this.labelIndex++;
}

GraphMgr.prototype.getNextBalloonTipLabelIndex = function()
{
    return this.balloonTipLabelIndex++;    
}

GraphMgr.prototype.reset = function ()
{
    this.lightIndex = 0;
    this.labelIndex = 1;
    this.balloonTipLabelIndex = 1;
    this.setCurrentDissolve(null);
    this.setCurrentMaterial(null);
    this.setCurrentBalloonTipLabel(null);
    this.setDrawTextures(true);
    this.collisions = new Array;

    for (var i=0; i < gl_MaxLights; i++)
    {
        this.renderContext.enableLight(i, false);
    }
}
Node.prototype = new AttributeContainer();
Node.prototype.constructor = Node;

function Node()
{
    AttributeContainer.call(this);
    this.className = "Node";
    this.attrType = eAttrType.Node;
    
    this.children = [];
    this.parents = [];
    this.modificationCount = 0;
    this.thisModified = false;
    this.childModified = false;
    this.childrenModified = [];
    
    this.name = new StringAttr("");
    this.enabled = new BooleanAttr(true);
    this.orphan = new BooleanAttr(false);
    
    this.registerAttribute(this.name, "name");
    this.registerAttribute(this.enabled, "enabled");
    this.registerAttribute(this.orphan, "orphan");
}

Node.prototype.copyNode = function(clone, cloneChildren, pathSrc, pathClone)
{
    var clonedByThis = false;
    if (!clone)
    {
        if (!(clone = new Node()))
        {
            return -1;
        }

        clonedByThis = true;
    }

    // synchronize attributes
    clone.synchronize(this, false);

    // add source to path
    //pathSrc.addNode(this);
    pathSrc.push(this);

    // add clone to path
   // pathClone.AddNode(clone);
    pathClone.push(this);

    // if requested, clone children
    if (cloneChildren)
    {
      //  m_graphAccessLock.Lock("CNode::Clone");//(CReadWriteLock::eRWLockMode_Read);

        var pos;
        for (var i in this.children)
        {
            //pos = it - m_children.begin();
            pos = i - this.children.start();

            var childClone = null;
            if(!(i.getCreatedByParent()))
            {
                if (i.copyNode(childClone, cloneChildren, pathSrc, pathClone)) {
                    if (clonedByThis) {
                    }
                    return -1;
                }

                if (clone.getChildCount() > pos) {
                    clone.insertChild(childClone, pos);
                }
                else {
                    clone.addChild(childClone);
                }

                i.postCloneChild(childClone, pathSrc, pathClone);
            }
        else // created by parent -- clone child's children without allocating child
            {
                //childClone = clone.getChild(i - m_children.begin());
                childClone = clone.getChild(i - this.children.start());

                if (i.copyNode(childClone, cloneChildren, pathSrc, pathClone))
                {
                    if (clonedByThis)
                    {
                    }
                    return -1;
                }
            }
        }

        //m_graphAccessLock.Unlock();//(CReadWriteLock::eRWLockMode_Read);
    }

    this.postClone(clone, pathSrc, pathClone);

}
Node.prototype.searchTree = function(name,type,searchName,searchType,searchPredecessors,skipChild,skipParent,stopAt,matches)
{
    var names = [];
    var types = [];

    if (!(names.push(name))) return;
    if (!(types.push(type))) return;

    this.searchesTree(names, types, searchName, searchType, searchPredecessors, skipChild, skipParent,
        stopAt, matches);
}

Node.prototype.searchesTree = function(names,types,searchNames,searchTypes,searchPredecessors,skipChild,skipParent,stopAt,matches)
{
    // if this node matches any of the names and/or types, add it to the list
    var match = false;
    var nameMatch = false;
    var typeMatch = false;
    if (searchNames)
    {
        for (var i=0; i < names.size(); i++)
        {
            if (!(this.name == names[i]))
            {
                nameMatch = true;
                break;
            }
        }
    }
    if (searchTypes)
    {
        for (var i=0; i < types.size(); i++)
        {
            if (this.attrType == types[i])
            {
                typeMatch = true;
                break;
            }
        }
    }
    if (searchNames && searchTypes)
    {
        match = nameMatch && typeMatch;
    }
    else if (searchNames)
    {
        match = nameMatch;
    }
    else // searchTypes
    {
        match = typeMatch;
    }
    if (match)
    {
        if (!(matches.push(this))) return;
    }

    if (this == stopAt)
    {
        return;
    }

    // recurse on parent(s) if requested (with this set to skipChild)
    if (searchPredecessors)
    {
        for (var i=0; i < this.parents.size(); i++)
        {
            if (this.parents[i] != skipParent)
            {
                this.parents[i].searchesTree(names, types, searchNames, searchTypes, searchPredecessors,
                    this, null, stopAt, matches);
            }
        }
    }

    // recurse on children (with searchPredecessors set to false)
    for (var i=0; i < this.children.size(); i++)
    {
        if (this.children[i] != skipChild)
        {
            this.children[i].searchesTree(names, types, searchNames, searchTypes, false,
                null, null, stopAt, matches);
        }
    }
}
Node.prototype.setCreatedByParent = function(createdByParent)
{
    this.createdByParent = createdByParent;
}
Node.prototype.getCreatedByParent = function()
{
    return this.createdByParent;
}

Node.prototype.isNode = function()
{
    return true;
}

Node.prototype.addChild = function(child)
{
    this.children.push(child);
    
    this.incrementModificationCount();
    
    child.addParent(this);
}

Node.prototype.insertChild = function(child, before)
{
    this.children.splice(before, 0, child);
    
    this.incrementModificationCount();
    
    child.addParent(this);
}

Node.prototype.removeChild = function(child)
{
    this.children.splice(this.children.indexOf(child), 1);
    
    this.incrementModificationCount();
    
    child.removeParent(this);
}

Node.prototype.replaceChild = function(replacement, replacee)
{
    this.children.splice(this.children.indexOf(replacement), 1, replacee);
    replacement.removeParent(this);
    replacee.addParent(this);
}

Node.prototype.getChild = function(n)
{
    if (this.children.length > n)
    {
        return this.children[n];
    }
    
    return null;
}

Node.prototype.getNamedChild = function(name)
{
    for (var i=0; i < this.children.length; i++)
    {
        if (this.children[i].name.getValueDirect().join("") == name)
        {
            return this.children[i];
        }
    }
    
    return null;
}

Node.prototype.getChildCount = function()
{
    return this.children.length;
}

Node.prototype.getParent = function(n)
{
    if (this.parents.length > n)
    {
        return this.parents[n];
    }
    
    return null;
}

Node.prototype.getParentCount = function()
{
    return this.parents.length;
}

Node.prototype.addParent = function(parent)
{
    this.parents.push(parent);
}

Node.prototype.removeParent = function(parent)
{
    this.parents.splice(this.parents.indexOf(parent), 1);
}

Node.prototype.update = function(params, visitChildren)
{
    // only update if this and/or child has been modified
    if (!this.thisModified && !this.childModified)
    {
        // no need to update; inform parent this node is unmodified
        this.setChildModified(false, false);
        params.visited.push(this);
        return;
    }
    
    params.visited.push(this);
    
    if (visitChildren)
    {
        // call for all children
        for (var i=0; i < this.children.length; i++)
        {
            this.children[i].update(params, visitChildren);
        }
    }
    
    this.childModified = this.isChildModified();
}

Node.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        if (directive != "serialize")
        {
            return;
        }
    }

    switch (directive)
    {
        case "serialize":
        {          
            var context = new Context();
            context.attribute = this;

            var factory = this.registry.find("AttributeFactory");
            var serializer = factory.create("Serializer");
            var xmlSerializer = new XMLSerializer();
            
            // added required format setting - need to revisit to reduce number of required steps
            serializer.getAttribute("format").setValueDirect("xml");
            // set minimum flag so that only the minimum required for recreation is serialized
            serializer.getAttribute("serializeMinimum").setValueDirect(true);
            // set children flag so that child nodes are serialized
            serializer.getAttribute("serializeChildren").setValueDirect(true);
            // serialize
            serializer.serialize(context.attribute, context.item, context.attributeName, context.container);
            var serialized = xmlSerializer.serializeToString(serializer.DOM);
            if (serialized != "<__InitialRoot/>")
            {
            	params.serialized += serialized;
            }

            // do not visit children, as they were serialized by this
            visitChildren = false;
        }
        break;
    }
    
    if (visitChildren)
    {
        if (params.path)
        {
            // call for next node in path if next node in path is a child of this node
            if (params.path.length > params.pathIndex)
            {
                for (var i=0; i < this.children.length; i++)
                {
                    var next = params.path[params.pathIndex];

                    if (this.children[i] == next)
                    {
                        params.pathIndex++;
                        this.children[i].apply(directive, params, visitChildren);
                    }
                }
            }
        }
        else
        {
            // call for all children
            for (var i=0; i < this.children.length; i++)
            {
                this.children[i].apply(directive, params, visitChildren);
            }
        }
    }
}

Node.prototype.applyNode = function(node, directive, params, visitChildren)
{
    node.apply(directive, params, visitChildren);
}

Node.prototype.setModified = function()
{
    this.thisModified = true;

    // notify parent(s) of modification so that display lists can be maintained
    this.setChildModified(true, true);
}

Node.prototype.incrementModificationCount = function()
{
    this.modificationCount++;
    
    this.setModified();
}

Node.prototype.setChildModified = function(modified, recurse)
{
    // set on parent(s) of this; recurse if specified
    var parent = null;
    for (var i=0; i < this.parents.length; i++)
    {
        parent = this.parents[i];
        if (parent)
        {
            parent.childrenModified[this.name.getValueDirect().join("")] = modified;
            parent.childModified = modified ? true : parent.isChildModified();
            if (recurse) parent.setChildModified(modified, recurse);
        }
    }
}

Node.prototype.isChildModified = function()
{
    for (var i in this.childrenModified)
    {
        if (this.childrenModified[i] == true) return true;
    }

    return false;
}
SGNode.prototype = new Node();
SGNode.prototype.constructor = SGNode;

function SGNode()
{
    Node.call(this);
    this.className = "SGNode";
    
    this.graphMgr = null;
    this.recordDisplayList = false;
    this.disableDisplayLists = false;
    this.displayListObj = null;
    
    this.enableDisplayList = new BooleanAttr(false);
    this.autoDisplayList = new BooleanAttr(false);
    this.updateDisplayList = new PulseAttr();
    
    this.registerAttribute(this.enableDisplayList, "enableDisplayList");
    this.registerAttribute(this.autoDisplayList, "autoDisplayList");
    this.registerAttribute(this.updateDisplayList, "updateDisplayList");
}

SGNode.prototype.setGraphMgr = function(graphMgr)
{
    this.graphMgr = graphMgr;
}

SGNode.prototype.update = function(params, visitChildren)
{
    // don't update if not enabled and not modified
    if (!(this.enabled.getValueDirect()) && !this.thisModified)
    {
        return;
    }

    // only update if this and/or child has been modified, and
    // display lists are enabled
    if (!this.thisModified && !this.childModified &&
         this.enableDisplayList.getValueDirect() == false &&
         this.autoDisplayList.getValueDirect() == false)
    {
        // no need to update; inform parent this node is unmodified
        this.setChildModified(false, false);
        params.visited.push(this);
        return;
    }
    
    params.visited.push(this);
    
    var subtreeModified = false;

    if (this.thisModified)
    {
        subtreeModified = true;
        this.thisModified = false;
    }

    if (this.childModified)
    {
        subtreeModified = true;
    }
    
    if (this.disableDisplayLists)
    {
        params.disableDisplayLists = true;
        this.disableDisplayLists = false;
    }
    
    // if the subtree has been modified, disable display list for this node
    if (subtreeModified)
    {
        this.enableDisplayList.setValueDirect(false);
        this.recordDisplayList = true; // re-record when (and if) list is re-enabled
    }
    
    // if using auto-display lists...
    // if the subtree has not been modified, enable display list for this node
    if (this.autoDisplayList.getValueDirect() && !subtreeModified)
    {
        this.enableDisplayList.setValueDirect(true);
    }

    // if there is already a current display list, or the manual override flag for disabling display lists is set, disable display list for this node
    if (params.displayListObj || params.disableDisplayLists)
    {
        this.enableDisplayList.setValueDirect(false);
    }

    // if enable display list is true, create display list object if not yet created and set recording to true
    if (this.enableDisplayList.getValueDirect())
    {
        if (!this.displayListObj)
        {
            this.createDisplayList();

            this.recordDisplayList = true;
        }
        
        // if recording is set to false, do not visit children
        if (!this.recordDisplayList)
        {
            visitChildren = false;
        }

        params.displayListObj = this.displayListObj;
    }
    
    if (visitChildren)
    {
        // call for all children
        for (var i=0; i < this.children.length; i++)
        {
            this.children[i].update(params, visitChildren);
        }
    }
    
    // if display list object was set to the update params, clear it
    if (params.displayListObj == this.displayListObj)
    {
        params.displayListObj = null;
    }
    
    this.childModified = this.isChildModified();
}

SGNode.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        return;
    }
    
    var useDisplayList = false;
    
    switch (directive)
    {
        case "render":
            {
                if (params.resetDisplayLists)
                {
                    this.recordDisplayList = true;
                }
                
                // determine if display list should be used; if a display list (from a parent node) is already operating, don't nest record or play...
                // this node's display list operations  will be recorded by the currently operating display list; also check manual override flag for disabling
                // display lists
                useDisplayList = this.enableDisplayList.getValueDirect() && 
                                 this.displayListObj &&
                                 !params.displayListObj && 
                                 !params.disableDisplayLists;
    
                if (useDisplayList)
                {
                    // set as current display list
                    params.displayListObj = this.displayListObj;
    
                    if (this.recordDisplayList)
                    {
                        // start recording render engine calls
                        this.displayListObj.record_begin();
                    }
                    else // !this.recordDisplayList
                    {
                        // playback render engine calls and do not visit children
                        this.displayListObj.play();
                        visitChildren = false;
                    }  
                }
            }
            break;
            
        case "rayPick":
            {
                params.currentNodePath.push(this);
            }
            break;
            
        default:
            {
                // call base-class implementation
                Node.prototype.apply.call(this, directive, params, visitChildren);
                return;
            }
            break;
    }
        
    if (visitChildren)
    {
        if (params.path)
        {
            // call for next node in path if next node in path is a child of this node
            if (params.path.length > params.pathIndex)
            {
                for (var i=0; i < this.children.length; i++)
                {
                    var next = params.path[params.pathIndex];

                    if (this.children[i] == next)
                    {
                        params.pathIndex++;
                        this.children[i].apply(directive, params, visitChildren);
                    }
                }
            }
        }
        else
        {
            // call for all children
            for (var i=0; i < this.children.length; i++)
            {
                this.children[i].apply(directive, params, visitChildren);
            }
        }
    }
    
    switch (directive)
    {
        case "render":
            {
                if (useDisplayList)
                {
                    if (this.recordDisplayList)
                    {
                        // stop recording render engine calls
                        this.displayListObj.record_end();
                        this.recordDisplayList = false;
                    }
    
                    // clear current display list
                    params.displayListObj = null;
                }
            }
            break;
            
        case "rayPick":
            {
                params.currentNodePath.pop();
            }
            break;
    }
}

SGNode.prototype.isRecordingDisplayList = function()
{
    if (this.graphMgr.renderContext.getDisplayList())
    {
        return true;
    }   
    
    return false; 
}

SGNode.prototype.createDisplayList = function()
{
    this.displayListObj = new DisplayListObj(this.graphMgr.renderContext);  
}

SGNode.prototype.deleteDisplayList = function()
{
    this.displayListObj = null;    
}

SGNode.prototype.enableDisplayListModified = function()
{   
}

function SGNode_EnableDisplayListModifiedCB(attribute, container)
{
    container.enableDisplayListModified();  
}

function SGNode_AutoDisplayListModifiedCB(attribute, container)
{    
}

function SGNode_UpdateDisplayListModifiedCB(attribute, container)
{
    container.disableDisplayLists = true;    
}

RenderableElement.prototype = new SGNode();
RenderableElement.prototype.constructor = RenderableElement;

function RenderableElement()
{
    SGNode.call(this);
    this.className = "RenderableElement";
    this.attrType = eAttrType.RenderableElement;
    
    this.bbox = new BBoxAttr();
    this.renderSequenceSlot = new NumberAttr(0);
    this.hasFocus = new TernaryAttr(0);
    this.selected = new TernaryAttr(0);
    this.styles = new StylesAttr();
    this.stylesMap = new StylesMapAttr();
    this.renderableElementStyle = new RenderableElementStyleAttr();
    this.renderedSlot = new NumberAttr(0);
    
    this.registerAttribute(this.bbox, "bbox");
    this.registerAttribute(this.renderSequenceSlot, "renderSequenceSlot");
    this.registerAttribute(this.hasFocus, "hasFocus");
    this.registerAttribute(this.selected, "selected");
    this.registerAttribute(this.styles, "styles");
    this.registerAttribute(this.stylesMap, "stylesMap");
    this.registerAttribute(this.renderableElementStyle, "renderableElementStyle");
    this.registerAttribute(this.renderedSlot, "renderedSlot");
}

RenderableElement.prototype.setRegistry = function(registry)
{
    this.stylesMap.setRegistry(registry);

    // call base-class implementation
    SGNode.prototype.setRegistry.call(this, registry);
}

RenderableElement.prototype.update = function(params, visitChildren)
{
    // call base-class implementation
    SGNode.prototype.update.call(this, params, visitChildren);
}

RenderableElement.prototype.apply = function(directive, params, visitChildren)
{
    // call base-class implementation
    SGNode.prototype.apply.call(this, directive, params, visitChildren);
}

ParentableMotionElement.prototype = new RenderableElement();
ParentableMotionElement.prototype.constructor = ParentableMotionElement;

function ParentableMotionElement()
{
    RenderableElement.call(this);
    this.className = "ParentableMotionElement";
    this.attrType = eAttrType.ParentableMotionElement;
    
    this.translationMatrix = new Matrix4x4();           // matrix representing this element's position translation
    this.rotationQuat = new Quaternion();               // quaternion for calculating rotation
    this.rotationMatrix = new Matrix4x4();              // matrix representing this element's rotation
    this.scaleMatrix = new Matrix4x4();                 // matrix representing this element's scale transformation
    this.pivotMatrix = new Matrix4x4();                 // matrix representing this element's pivot translation
    this.sectorTranslationMatrix = new Matrix4x4();		// matrix representing this element's sector position translation
    this.stackMatrix = new Matrix4x4();                 // current matrix from the scene graph matrix stack (GcTransform nodes)
    this.transformSimple = new Matrix4x4();             // after Update(), contains this element's transformations (translation/
    // rotation/scale/pivot)
    this.transformCompound = new Matrix4x4();           // after Update(), contains this element's transformations combined with 
    // parent's transformations (if any)
    this.sectorTransformSimple = new Matrix4x4();		// after Update(), contains this element's transformations (translation/
    // rotation/scale/pivot) for the current sector
    this.sectorTransformCompound = new Matrix4x4();     // after Update(), contains this element's transformations combined with 
                                                        // parent's transformations (if any) for the current sector                                        
    this.updatePosition = false;
    this.updateScale = false;
    this.updatePivot = false;
    this.updateSectorPosition = false;
    this.updateInheritance = false;
    this.inheritsPosition = true;
    this.inheritsRotation = true;
    this.inheritsScale = true;
    this.inheritsPivot = true;
    this.nonZeroVelocity = false;
    this.motionParent = null;
    
    this.position = new Vector3DAttr(0, 0, 0);
    this.rotation = new Vector3DAttr(0, 0, 0);
    this.scale = new Vector3DAttr(1, 1, 1);
    this.pivot = new Vector3DAttr(0, 0, 0);
    this.center = new Vector3DAttr(0, 0, 0);
    this.worldCenter = new Vector3DAttr(0, 0, 0);
    this.worldPosition = new Vector3DAttr(0, 0, 0);
    this.worldRotation = new Vector3DAttr(0, 0, 0);
    this.worldScale = new Vector3DAttr(1, 1, 1);
    this.screenPosition = new Vector3DAttr(0, 0, 0);
    this.sectorOrigin = new Vector3DAttr(0, 0, 0);
    this.sectorPosition = new Vector3DAttr(0, 0, 0);
    this.sectorWorldCenter = new Vector3DAttr(0, 0, 0);
    this.sectorWorldPosition = new Vector3DAttr(0, 0, 0);
    this.panVelocity = new Vector3DAttr(0, 0, 0);          // linear velocity along direction vectors in world-units/second
    this.linearVelocity = new Vector3DAttr(0, 0, 0);       // linear velocity in world-units/second
    this.angularVelocity = new Vector3DAttr(0, 0, 0);      // angular velocity in degrees/second
    this.scalarVelocity = new Vector3DAttr(0, 0, 0);       // scalar velocity in world-units/second
    this.worldTransform = new Matrix4x4Attr(1, 0, 0, 0,
                                            0, 1, 0, 0,
                                            0, 0, 1, 0,
                                            0, 0, 0, 1);
    this.sectorWorldTransform = new Matrix4x4Attr(1, 0, 0, 0,
                                                  0, 1, 0, 0,
                                                  0, 0, 1, 0,
                                                  0, 0, 0, 1);
    this.parent = new StringAttr("");
    this.inheritPosition_X = new BooleanAttr(true);
    this.inheritPosition_Y = new BooleanAttr(true);
    this.inheritPosition_Z = new BooleanAttr(true);
    this.inheritRotation_X = new BooleanAttr(true);
    this.inheritRotation_Y = new BooleanAttr(true);
    this.inheritRotation_Z = new BooleanAttr(true);
    this.inheritScale_X = new BooleanAttr(true);
    this.inheritScale_Y = new BooleanAttr(true);
    this.inheritScale_Z = new BooleanAttr(true);
    this.inheritPivot_X = new BooleanAttr(true);
    this.inheritPivot_Y = new BooleanAttr(true);
    this.inheritPivot_Z = new BooleanAttr(true);
    this.transformModified = new PulseAttr();               // pulsed when transform has been modified
    
    this.position.addModifiedCB(ParentableMotionElement_PositionModifiedCB, this);
    this.rotation.addModifiedCB(ParentableMotionElement_RotationModifiedCB, this);
    this.scale.addModifiedCB(ParentableMotionElement_ScaleModifiedCB, this);
    this.pivot.addModifiedCB(ParentableMotionElement_PivotModifiedCB, this);
    this.sectorOrigin.addModifiedCB(ParentableMotionElement_SectorOriginModifiedCB, this);
    this.sectorPosition.addModifiedCB(ParentableMotionElement_SectorPositionModifiedCB, this);
    this.parent.addModifiedCB(ParentableMotionElement_ParentModifiedCB, this);
    this.inheritPosition_X.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritPosition_Y.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritPosition_Z.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritRotation_X.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritRotation_Y.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritRotation_Z.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritScale_X.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritScale_Y.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritScale_Z.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritPivot_X.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritPivot_Y.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.inheritPivot_Z.addModifiedCB(ParentableMotionElement_InheritanceModifiedCB, this);
    this.panVelocity.addModifiedCB(ParentableMotionElement_VelocityModifiedCB, this);
    this.linearVelocity.addModifiedCB(ParentableMotionElement_VelocityModifiedCB, this);
    this.angularVelocity.addModifiedCB(ParentableMotionElement_VelocityModifiedCB, this);
    this.scalarVelocity.addModifiedCB(ParentableMotionElement_VelocityModifiedCB, this);
    
    this.registerAttribute(this.position, "position");
    this.registerAttribute(this.rotation, "rotation");
    this.registerAttribute(this.scale, "scale");
    this.registerAttribute(this.pivot, "pivot");
    this.registerAttribute(this.center, "center");
    this.registerAttribute(this.worldCenter, "worldCenter");
    this.registerAttribute(this.worldPosition, "worldPosition");
    this.registerAttribute(this.worldRotation, "worldRotation");
    this.registerAttribute(this.worldScale, "worldScale");    
    this.registerAttribute(this.screenPosition, "screenPosition"); 
    this.registerAttribute(this.sectorOrigin, "sectorOrigin"); 
    this.registerAttribute(this.sectorPosition, "sectorPosition"); 
    this.registerAttribute(this.sectorWorldCenter, "sectorWorldCenter"); 
    this.registerAttribute(this.sectorWorldPosition, "sectorWorldPosition");
    this.registerAttribute(this.worldTransform, "worldTransform");
    this.registerAttribute(this.sectorWorldTransform, "sectorWorldTransform");
    this.registerAttribute(this.panVelocity, "panVelocity");
    this.registerAttribute(this.linearVelocity, "linearVelocity");
    this.registerAttribute(this.angularVelocity, "angularVelocity");
    this.registerAttribute(this.scalarVelocity, "scalarVelocity");
    this.registerAttribute(this.parent, "parent");
    this.registerAttribute(this.inheritPosition_X, "inheritPosition_X");
    this.registerAttribute(this.inheritPosition_Y, "inheritPosition_Y");
    this.registerAttribute(this.inheritPosition_Z, "inheritPosition_Z");
    this.registerAttribute(this.inheritRotation_X, "inheritRotation_X");
    this.registerAttribute(this.inheritRotation_Y, "inheritRotation_Y");
    this.registerAttribute(this.inheritRotation_Z, "inheritRotation_Z");
    this.registerAttribute(this.inheritScale_X, "inheritScale_X");
    this.registerAttribute(this.inheritScale_Y, "inheritScale_Y");
    this.registerAttribute(this.inheritScale_Z, "inheritScale_Z");
    this.registerAttribute(this.inheritPivot_X, "inheritPivot_X");
    this.registerAttribute(this.inheritPivot_X, "inheritPivot_Y");
    this.registerAttribute(this.inheritPivot_X, "inheritPivot_Z");
    this.registerAttribute(this.transformModified, "transformModified");
}

ParentableMotionElement.prototype.getTransform = function()
{
    var matrix = new Matrix4x4();
    matrix.loadMatrix(this.transformCompound);
    return matrix;
}

ParentableMotionElement.prototype.getSectorTransform = function()
{
    var matrix = new Matrix4x4();
    matrix.loadMatrix(this.sectorTransformCompound);
    return matrix;
}

ParentableMotionElement.prototype.update = function(params, visitChildren)
{
	// update this element's position/rotation as affected by velocity
	if (this.nonZeroVelocity)
	{
    	this.updateVelocityMotion(params.timeIncrement);
    }
        
    if (this.updateInheritance)
    {
        this.updateInheritance = false;

        this.inheritsPosition = this.inheritPosition_X.getValueDirect() &&
        this.inheritPosition_Y.getValueDirect() &&
        this.inheritPosition_Z.getValueDirect();

        this.inheritsRotation = this.inheritRotation_X.getValueDirect() &&
        this.inheritRotation_Y.getValueDirect() &&
        this.inheritRotation_Z.getValueDirect();

        this.inheritsScale    = this.inheritScale_X.getValueDirect() &&
        this.inheritScale_Y.getValueDirect() &&
        this.inheritScale_Z.getValueDirect();

        this.inheritsPivot    = this.inheritPivot_X.getValueDirect() &&
        this.inheritPivot_Y.getValueDirect() &&
        this.inheritPivot_Z.getValueDirect();
    }
    
    // update this element's transformations (translation/rotation/scale/pivot)
    var modified = this.updateSimpleTransform();
    if (modified)
    {
    	this.incrementModificationCount();
    }
    if (this.motionParent)
    {
        this.motionParent.update(params, false);
    }
    this.updateCompoundTransform();
    this.updateWorldMotionInfo();
    
    // call base-class implementation
    RenderableElement.prototype.update.call(this, params, visitChildren);
}

ParentableMotionElement.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        RenderableElement.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
        case "render":
        {
            var screen = toScreenSpace(this.sectorWorldPosition.getValueDirect(),
                params.viewMatrix, params.projMatrix, params.viewport);
            this.screenPosition.setValueDirect(screen.x, screen.y, screen.z);
        }
        break;
    }
    
    // call base-class implementation
    RenderableElement.prototype.apply.call(this, directive, params, visitChildren);
}

ParentableMotionElement.prototype.updateChildDisplayLists = function()
{
    /*for (var i=0; i < this.motionChildren.length; i++)
    {
        this.motionChildren[i].updateDisplayList.pulse();
    }*/
}

ParentableMotionElement.prototype.applyTransform = function()
{
    // TODO: if scaling factors are not 1, apply inverse scale before this transformation is
    // applied to avoid translation caused by scaling  
    
    // set transformation matrix
    this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
    this.graphMgr.renderContext.leftMultMatrix(this.sectorTransformCompound);
    this.graphMgr.renderContext.applyModelViewTransform();
    
	// TODO: if invsere scale was applied, re-apply scale
}

ParentableMotionElement.prototype.updateVelocityMotion = function(timeIncrement)
{
    // pan, linear velocity
    var panVelocity = this.panVelocity.getValueDirect();
    var linearVelocity = this.linearVelocity.getValueDirect();
    if (panVelocity.x != 0 || panVelocity.y != 0 || panVelocity.z != 0 ||
        linearVelocity.x != 0 || linearVelocity.y != 0 || linearVelocity.z != 0)
    {
        // position
        var position = this.position.getValueDirect();

        // get direction vectors for pan
        var directionVectors = this.getDirectionVectors();

        // update position
        position.x = position.x + (directionVectors.right.x   * panVelocity.x * timeIncrement) +
        						  (directionVectors.up.x 	  * panVelocity.y * timeIncrement) +
        						  (directionVectors.forward.x * panVelocity.z * timeIncrement) + 
        						  (linearVelocity.x * timeIncrement);
        position.y = position.y + (directionVectors.right.y   * panVelocity.x * timeIncrement) +
        						  (directionVectors.up.y 	  * panVelocity.y * timeIncrement) +
        						  (directionVectors.forward.y * panVelocity.z * timeIncrement) + 
        						  (linearVelocity.y * timeIncrement);
        position.z = position.z + (directionVectors.right.z   * panVelocity.x * timeIncrement) +
        						  (directionVectors.up.z 	  * panVelocity.y * timeIncrement) +
        						  (directionVectors.forward.z * panVelocity.z * timeIncrement) + 
        						  (linearVelocity.z * timeIncrement);						  

        this.position.setValueDirect(position.x, position.y, position.z);
    }

    // angular velocity
    var angularVelocity = this.angularVelocity.getValueDirect();
    if (angularVelocity.x != 0 || angularVelocity.y != 0 || angularVelocity.z != 0)
    {
        // rotation
        var rotation = this.rotation.getValueDirect();

        // update rotation
        rotation.x = rotation.x + (angularVelocity.x * timeIncrement);
        rotation.y = rotation.y + (angularVelocity.y * timeIncrement);
        rotation.z = rotation.z + (angularVelocity.z * timeIncrement);
        
        this.rotation.setValueDirect(rotation.x, rotation.y, rotation.z);
    }

    // scalar velocity
    var scalarVelocity = this.scalarVelocity.getValueDirect();
    if (scalarVelocity.x != 0 || scalarVelocity.y != 0 || scalarVelocity.z != 0)
    {
        // rotation
        var scale = this.scale.getValueDirect();

        // update rotation
        scale.x = scale.x + (scalarVelocity.x * timeIncrement);
        scale.y = scale.y + (scalarVelocity.y * timeIncrement);
        scale.z = scale.z + (scalarVelocity.z * timeIncrement);
        
        this.scale.setValueDirect(scale.x, scale.y, scale.z);
    }   
}

ParentableMotionElement.prototype.updateSimpleTransform = function()
{
    var modified = false;
    
    if (this.updatePosition || this.updateRotation || this.updateScale || this.updatePivot)
    {
        var values;
        
        if (this.updatePosition)
        {
            this.updatePosition = false;
            
            values = this.position.getValueDirect();
            this.translationMatrix.loadTranslation(values.x, values.y, values.z);
            
            modified = true;
        }
        
        if (this.updateRotation)
        {
            this.updateRotation = false;
            
            values = this.rotation.getValueDirect();
            this.rotationQuat.loadXYZAxisRotation(values.x, values.y, values.z);
            this.rotationMatrix = this.rotationQuat.getMatrix();
            
            modified = true;
        }
        
        if (this.updateScale)
        {
            this.updateScale = false;
            
            values = this.scale.getValueDirect();
            this.scaleMatrix.loadScale(values.x, values.y, values.z);
            
            modified = true;
        }
        
        if (this.updatePivot)
        {
            this.updatePivot = false;
            
            values = this.pivot.getValueDirect();
            this.pivotMatrix.loadTranslation(-values.x, -values.y, -values.z);
            
            modified = true;
        }
        
        if (this.updateSectorPosition)
        {
            this.updateSectorPosition = false;
            
            values = this.sectorPosition.getValueDirect();
            this.sectorTranslationMatrix.loadTranslation(values.x, values.y, values.z);
            
            modified = true;
        }
        
        if (modified)
        {
            this.transformModified.pulse();
            
            // pre-multiply pivot/scale/rotation since this is applied to both regular and sector transforms
            var psr = new Matrix4x4();
            psr.loadMatrix(this.pivotMatrix.multiply(this.scaleMatrix.multiply(this.rotationMatrix)));
    
            this.transformSimple.loadMatrix(psr.multiply(this.translationMatrix));
            this.sectorTransformSimple.loadMatrix(psr.multiply(this.sectorTranslationMatrix));
            
            // force any motion children to update their display lists
            this.updateChildDisplayLists();
        }
    }
    
    return modified;
}

ParentableMotionElement.prototype.updateCompoundTransform = function()
{
    this.transformCompound.loadMatrix(this.transformSimple);
    this.sectorTransformCompound.loadMatrix(this.sectorTransformSimple);
    
    if (this.motionParent)
    {
        if (this.inheritsPosition && this.inheritsRotation && this.inheritsScale && this.inheritsPivot)
        {
            this.transformCompound.loadMatrix(this.transformCompound.multiply(this.motionParent.transformCompound));
            this.sectorTransformCompound.loadMatrix(this.sectorTransformCompound.multiply(this.motionParent.sectorTransformCompound));
        }
        else // !m_inheritsPosition || !m_inheritsRotation || !m_inheritsScale || !m_inheritsPivot
        {
        // TODO
        }
    }
}

ParentableMotionElement.prototype.updateWorldMotionInfo = function()
{
    this.worldTransform.setValueDirect(this.transformCompound);
    this.sectorWorldTransform.setValueDirect(this.sectorTransformCompound);
    
    this.updateWorldCenter();
    this.updateWorldPosition();
    this.updateWorldRotation();
    this.updateWorldScale();
}

ParentableMotionElement.prototype.updateWorldCenter = function()
{
    var center = this.center.getValueDirect();
    center = this.transformCompound.transform(center.x, center.y, center.z, 1);
    this.worldCenter.setValueDirect(center.x, center.y, center.z);
    
    center = this.center.getValueDirect();
    center = this.sectorTransformCompound.transform(center.x, center.y, center.z, 1);
    this.sectorWorldCenter.setValueDirect(center.x, center.y, center.z);
}

ParentableMotionElement.prototype.updateWorldPosition = function()
{
    var position = this.transformCompound.transform(0, 0, 0, 1);
    this.worldPosition.setValueDirect(position.x, position.y, position.z);
    
    position = this.sectorTransformCompound.transform(0, 0, 0, 1);
    this.sectorWorldPosition.setValueDirect(position.x, position.y, position.z);
}

ParentableMotionElement.prototype.updateWorldRotation = function()
{
    var rotation = this.transformCompound.getRotationAngles();
    this.worldRotation.setValueDirect(rotation.x, rotation.y, rotation.z);
}

ParentableMotionElement.prototype.updateWorldScale = function()
{
    var scale = this.transformCompound.getScalingFactors();
    this.worldScale.setValueDirect(scale.x, scale.y, scale.z);
}

ParentableMotionElement.prototype.synchronizePosition = function()
{
    // synchronize position with sector position if necessary (don't sync if not necessary to avoid 
    // the circular dependency between position & sector position

    // get sector origin (use [0, 0, 0] for parented objects)
    var sectorOrigin = new Vector3D();
    if (this.motionParent)
    {
        sectorOrigin.x = 0;
        sectorOrigin.y = 0;
        sectorOrigin.z = 0;
    }
    else // !motionParent
    {
        sectorOrigin = this.sectorOrigin.getValueDirect();
    }
    
    // get sector position
    var sectorPosition = this.sectorPosition.getValueDirect();
    
    // get world position
    var position = new Vector3D();
    position.x = sectorOrigin.x + sectorPosition.x;
    position.y = sectorOrigin.y + sectorPosition.y;
    position.z = sectorOrigin.z + sectorPosition.z;
    
    // update position
    this.position.removeModifiedCB(ParentableMotionElement_PositionModifiedCB, this);
    this.position.setValueDirect(position.x, position.y, position.z);
    this.position.addModifiedCB(ParentableMotionElement_PositionModifiedCB, this);
    
    // flag a position update
    this.updatePosition = true;
}

ParentableMotionElement.prototype.synchronizeSectorPosition = function()
{
    // synchronize sector position with position if necessary (don't sync if not necessary to avoid 
    // the circular dependency between position & sector position
	
    // get sector origin (use [0, 0, 0] for parented objects)
    var sectorOrigin = new Vector3D;
    if (this.motionParent)
    {
        sectorOrigin.x = 0;
        sectorOrigin.y = 0;
        sectorOrigin.z = 0;
    }
    else // !motionParent
    {
        sectorOrigin = this.sectorOrigin.getValueDirect();
    }

    // get world position
    var position = this.position.getValueDirect();

    // get sector position
    var sectorPosition = new Vector3D;
    sectorPosition.x = position.x - sectorOrigin.x;
    sectorPosition.y = position.y - sectorOrigin.y;
    sectorPosition.z = position.z - sectorOrigin.z;

    // update sector position
    this.sectorPosition.removeModifiedCB(ParentableMotionElement_SectorPositionModifiedCB, this);
    this.sectorPosition.setValueDirect(sectorPosition.x, sectorPosition.y, sectorPosition.z);
    this.sectorPosition.addModifiedCB(ParentableMotionElement_SectorPositionModifiedCB, this);

    // flag a sector position update
    this.updateSectorPosition = true;
}

ParentableMotionElement.prototype.getDirectionVectors = function()
{
    var up = this.sectorTransformCompound.transform(0, 1, 0, 0);
    var right = this.sectorTransformCompound.transform(1, 0, 0, 0);
    var forward = this.sectorTransformCompound.transform(0, 0, 1, 0);
    
    return {
        up: up, 
        right: right, 
        forward: forward
    };
}

ParentableMotionElement.prototype.setMotionParent = function(parent)
{
    this.motionParent = parent;
    
    // set sector position to account for parenting
    this.synchronizeSectorPosition();       
}

ParentableMotionElement.prototype.velocityModified = function()
{
	if (this.panVelocity.isZero() &&
		this.linearVelocity.isZero() &&
		this.angularVelocity.isZero() &&
		this.scalarVelocity.isZero())
	{
		this.nonZeroVelocity = false;
	}
	else
	{
		this.nonZeroVelocity = true;
	}
}

function ParentableMotionElement_PositionModifiedCB(attribute, container)
{
    container.updatePosition = true;
    container.synchronizeSectorPosition();
    container.incrementModificationCount();
}

function ParentableMotionElement_RotationModifiedCB(attribute, container)
{
    container.updateRotation = true;
    container.incrementModificationCount();
}

function ParentableMotionElement_ScaleModifiedCB(attribute, container)
{
    container.updateScale = true;
    container.incrementModificationCount();
}

function ParentableMotionElement_PivotModifiedCB(attribute, container)
{
    container.updatePivot = true;
    container.incrementModificationCount();
}

function ParentableMotionElement_SectorOriginModifiedCB(attribute, container)
{
    container.synchronizeSectorPosition();
    container.incrementModificationCount();
}

function ParentableMotionElement_SectorPositionModifiedCB(attribute, container)
{
    container.updateSectorPosition = true;
    container.synchronizePosition();
    container.incrementModificationCount();
}

function ParentableMotionElement_ParentModifiedCB(attribute, container)
{
    container.setMotionParent(container.registry.find(attribute.getValueDirect().join("")));
}

function ParentableMotionElement_VelocityModifiedCB(attribute, container)
{
	container.velocityModified();
	container.incrementModificationCount();
}

function ParentableMotionElement_InheritanceModifiedCB(attribute, container)
{
    container.updateInheritance = true;
    container.incrementModificationCount();
}
function DirectiveParams()
{
    this.directive = null;
    this.path = null;
    this.pathIndex = 0;
    this.currentNodePath = new Stack();
    this.userData = null;
}

Directive.prototype = new AttributeContainer();
Directive.prototype.constructor = Directive;

function Directive()
{
    AttributeContainer.call(this);
    this.className = "Directive";
    this.attrType = eAttrType.Directive;
    
    this.name = new StringAttr("");
    this.enabled = new BooleanAttr(true);
    this.rootNode = new ReferenceAttr(null);
    
    this.registerAttribute(this.name, "name");
    this.registerAttribute(this.enabled, "enabled");
    this.registerAttribute(this.rootNode, "rootNode");
}
SGDirective.prototype = new Directive();
SGDirective.prototype.constructor = SGDirective;

function SGDirective()
{
    Directive.call(this);
    this.className = "SGDirective";
    
    this.graphMgr = null;
}

SGDirective.prototype.setGraphMgr = function(graphMgr)
{
    this.graphMgr = graphMgr;
}
UpdateParams.prototype = new DirectiveParams();
UpdateParams.prototype.constructor = UpdateParams();

function UpdateParams() // combined CUpdateParams & GtUpdateParams in this version
{
    DirectiveParams.call(this);
    
    this.pass = 0;
    this.timeIncrement = 0;
    this.visited = [];
    this.nextPass = [];
    this.displayListObj = null;
    this.disableDisplayLists = false;
}

UpdateDirective.prototype = new SGDirective();
UpdateDirective.prototype.constructor = UpdateDirective;

function UpdateDirective()
{
    SGDirective.call(this);
    this.className = "UpdateDirective";
    this.attrType = eAttrType.UpdateDirective;
    
    this.name.setValueDirect("UpdateDirective");
    
    this.timeIncrement = new NumberAttr(0);
    
    this.registerAttribute(this.timeIncrement, "timeIncrement");
}

UpdateDirective.prototype.execute = function(root, params)
{
    root = root || this.rootNode.getValueDirect();
    
    params.timeIncrement = this.timeIncrement.getValueDirect();
    
    // update (perform first pass)
    root.update(params, true);
    
    // update (perform subsequent passes while nextPass vector is not empty)
    while (params.nextPass.length > 0)
    {
        params.pass++;
        
        // get nodes to visit this pass
        var nodes = [];
        for (var i=0; i < params.nextPass.length; i++)
        {
            nodes[i] = params.nextPass[i];
        }
        params.nextPass.length = 0;
          
        for (var i=0; i < nodes.length; i++)
        {
            nodes[i].update(params, false);
        }
    }
    
    return params.visited;
}
Camera.prototype = new ParentableMotionElement();
Camera.prototype.constructor = Camera;

function Camera()
{
    ParentableMotionElement.call(this);
    this.className = "Camera";
    this.attrType = eAttrType.Camera;
    
    this.projectionMatrix = new Matrix4x4();
    this.viewport = new Viewport();
    this.updateNearDistance = false;
    this.updateFarDistance = false;
    this.updateClipPlanes = true;
    this.near = 0;
    this.far = 0;
    
    this.nearDistance = new NumberAttr(0);
    this.farDistance = new NumberAttr(0);
    this.viewVolume = new ViewVolumeAttr();
    //this.viewports
    this.sectorOriginUpdatesEnabled = new BooleanAttr(false);
    //this.updateSectorOrigin
    
    this.nearDistance.addModifiedCB(Camera_NearDistanceModifiedCB, this);
    this.farDistance.addModifiedCB(Camera_FarDistanceModifiedCB, this);
    
    this.registerAttribute(this.nearDistance, "nearDistance");
    this.registerAttribute(this.farDistance, "farDistance");
    this.registerAttribute(this.viewVolume, "viewVolume");
}

Camera.prototype.update = function(params, visitChildren)
{
    if (this.updateNearDistance)
    {
        this.updateNearDistance = false;
        
        this.near = this.nearDistance.getValueDirect();
        
        this.updateClipPlanes = true;
    }
    
    if (this.updateFarDistance)
    {
        this.updateFarDistance = false;
        
        this.far = this.farDistance.getValueDirect();
        
        this.updateClipPlanes = true;
    }
    
    // call base-class implementation
    ParentableMotionElement.prototype.update.call(this, params, visitChildren);
}

Camera.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    switch (directive)
    {
        case "render":
            {
                this.applyTransform();

                params.projMatrix.loadMatrix(this.projectionMatrix);
                params.viewMatrix.loadMatrix(this.sectorTransformCompound);
                params.viewMatrix.invert(); // put in view-space
            }
            break;

        case "rayPick":
            {
                // if a specific camera is specified in the ray pick params,
                // make sure this is the specified camera
                if (!params.camera || params.camera == this)
                {
                    var ray = this.getViewSpaceRay(params.viewport, params.clickPoint);
                    params.rayOrigin = ray.origin;
                    params.rayDir = ray.direction;
                    params.currentCamera = this;
                    params.nearDistance = this.nearDistance.getValueDirect();
                    params.farDistance = this.farDistance.getValueDirect();
                    params.viewMatrix.loadMatrix(this.sectorTransformCompound);
                    params.viewMatrix.invert(); // put in view-space
                }
            }
            break;

        case "bbox":
            {
                // caller wants bbox in view space; set view matrix so that geometry nodes 
                // can multiply world matrix by view matrix to get worldView matrix
                params.viewMatrix.loadMatrix(this.sectorTransformCompound);
                params.viewMatrix.invert(); // put in view-space
            }
            break;
            
        case "collide":
            {
                // caller wants bbox in view space; set view matrix so that geometry nodes 
                // can multiply world matrix by view matrix to get worldView matrix
                params.viewMatrix.loadMatrix(this.sectorTransformCompound);
                params.viewMatrix.invert(); // put in view-space
            }
            break;
            
        case "highlight":
            {
                params.projMatrix.loadMatrix(this.projectionMatrix); // TODO: using jittered allows for antialiasing
                params.viewMatrix.loadMatrix(this.transformCompound);
                params.viewMatrix.invert(); // put in view-space
                params.camera = this;
                params.viewport = this.viewport;
            }
            break;
    }

    // call base-class implementation
    ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
}

Camera.prototype.applyTransform = function()
{
    var matrix = new Matrix4x4();
    matrix.loadMatrix(this.sectorTransformCompound);
    matrix.invert();

    this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
    this.graphMgr.renderContext.loadMatrix(matrix);
    this.graphMgr.renderContext.applyModelViewTransform();
}

function Camera_NearDistanceModifiedCB(attribute, container)
{
    container.updateNearDistance = true;
    container.incrementModificationCount();
}

function Camera_FarDistanceModifiedCB(attribute, container)
{
    container.updateFarDistance = true;
    container.incrementModificationCount();
}
OrthographicCamera.prototype = new Camera();
OrthographicCamera.prototype.constructor = OrthographicCamera;

function OrthographicCamera()
{
    Camera.call(this);
    this.className = "OrthographicCamera";
    this.attrType = eAttrType.OrthographicCamera;
    
    this.updateWidth = false;
    
    this.width = new NumberAttr(2);
    
    this.width.addModifiedCB(OrthographicCamera_WidthModifiedCB, this);
    
    this.registerAttribute(this.width, "width");
}

OrthographicCamera.prototype.update = function(params, visitChildren)
{
    if (this.updateWidth)
    {
        this.updateWidth = false;

        this.updateClipPlanes = true;
    }
    
    // call base-class implementation
    Camera.prototype.update.call(this, params, visitChildren);
}

OrthographicCamera.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Camera.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {
            if (!this.viewport.equals(params.viewport))
            {
                this.viewport = params.viewport;
                this.updateClipPlanes = true;  
            }
            
            if (this.updateClipPlanes)
            {
                this.updateClipPlanes = false;
                
                this.setClipPlanes();
            }
            
            this.applyOrthographicTransform();
        }
        break;
    }
    
    // call base-class implementation
    Camera.prototype.apply.call(this, directive, params, visitChildren);
}

OrthographicCamera.prototype.setClipPlanes = function()
{
    var width = this.width.getValueDirect();
    var height = width * this.viewport.height / this.viewport.width;
    
    this.top = height / 2;
    this.bottom = -this.top;
    this.right = width / 2;
    this.left = -this.right;
    
    this.projectionMatrix.loadMatrix(this.graphMgr.renderContext.orthographicMatrixLH(this.left, this.right,
        this.top, this.bottom, this.near, this.far));
        
    // update view-volume attribute
    var viewVolume = new ViewVolume();
    viewVolume.setOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
    this.viewVolume.setValueDirect(viewVolume.left, viewVolume.right, viewVolume.top, viewVolume.bottom,
        viewVolume.near, viewVolume.far);    
}

OrthographicCamera.prototype.applyOrthographicTransform = function()
{
    this.graphMgr.renderContext.projectionMatrixStack.top().loadMatrix(this.projectionMatrix);
    this.graphMgr.renderContext.applyProjectionTransform();
}

OrthographicCamera.prototype.getViewSpaceRay = function(viewport, clickPoint)
{
    // normalize click coordinates so they span [-1, 1] on each axis
    var normX =  ((clickPoint.x - viewport.x) / viewport.width  * 2 - 1);
    var normY = -((clickPoint.y - viewport.y) / viewport.height * 2 - 1);

    // determine the width/2 of the visible portion of the x axis on the 
    // far clipping plane
    var farX  = (this.right - this.left) / 2;

    // determine the height/2 of the visible portion of the y axis on the
    // far clipping plane
    var farY  = (this.top - this.bottom) / 2;

    // set ray origin as point within visible portion of x, y on the 
    // near clipping plane corresponding to the normalized screen coordinates
    var origin = new Vector3D(normX * farX, normY * farY, this.near);

    // set ray direction as point within visible portion of x, y on the 
    // far clipping plane corresponding to the normalized screen coordinates
    //rayDir = CVector3Df(normX * farX, normY * farY, m_far);
    var direction = new Vector3D(0, 0, 1);
    
    return { origin: origin, direction: direction };  
}

function OrthographicCamera_WidthModifiedCB(attribute, container)
{
    container.updateWidth = true;
    container.incrementModificationCount();
}
PerspectiveCamera.prototype = new Camera();
PerspectiveCamera.prototype.constructor = PerspectiveCamera;

function PerspectiveCamera()
{
    Camera.call(this);
    this.className = "PerspectiveCamera";
    this.attrType = eAttrType.PerspectiveCamera;
    
    this.updateZoom = false;
    this.fovyRadians = 0;
    this.left = 0;
    this.right = 0;
    this.top = 0;
    this.bottom = 0;
    
    this.zoom = new NumberAttr(0);
    
    this.zoom.addModifiedCB(PerspectiveCamera_ZoomModifiedCB, this);
    
    this.registerAttribute(this.zoom, "zoom");
}

PerspectiveCamera.prototype.update = function(params, visitChildren)
{
    if (this.updateZoom)
    {
        this.updateZoom = false;
        
        this.fovyRadians = 2 * Math.atan2(1, this.zoom.getValueDirect());

        this.updateClipPlanes = true;
    }
    
    // call base-class implementation
    Camera.prototype.update.call(this, params, visitChildren);
}

PerspectiveCamera.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Camera.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {
            if (!this.viewport.equals(params.viewport))
            {
                this.viewport = params.viewport;
                this.updateClipPlanes = true;  
            }
            
            if (this.updateClipPlanes)
            {
                this.updateClipPlanes = false;
                
                this.setClipPlanes();
            }
            
            this.applyPerspectiveTransform();
        }
        break;
    }
    
    // call base-class implementation
    Camera.prototype.apply.call(this, directive, params, visitChildren);
}

PerspectiveCamera.prototype.setClipPlanes = function()
{
    this.top = Math.tan(this.fovyRadians / 2) * this.near;
    this.bottom = -this.top;
    this.right = this.top * (this.viewport.width / this.viewport.height);
    this.left = -this.right;
    
    this.projectionMatrix.loadMatrix(this.graphMgr.renderContext.perspectiveMatrixLH(this.left, this.right,
        this.top, this.bottom, this.near, this.far));
        
    // update view-volume attribute
    var viewVolume = new ViewVolume();
    viewVolume.setPerspective(this.fovyRadians, this.viewport.width / this.viewport.height, this.near, this.far);
    this.viewVolume.setValueDirect(viewVolume.left, viewVolume.right, viewVolume.top, viewVolume.bottom,
        viewVolume.near, viewVolume.far);    
}

PerspectiveCamera.prototype.applyPerspectiveTransform = function()
{
    this.graphMgr.renderContext.projectionMatrixStack.top().loadMatrix(this.projectionMatrix);
    this.graphMgr.renderContext.applyProjectionTransform();
}

PerspectiveCamera.prototype.getViewSpaceRay = function(viewport, clickPoint)
{
    // normalize click coordinates so they span [-1, 1] on each axis
    var normX =  ((clickPoint.x - viewport.x) / viewport.width  * 2 - 1);
    var normY = -((clickPoint.y - viewport.y) / viewport.height * 2 - 1);

    // get vertical field of view in radians
    var fovY = this.fovyRadians;

    // get horizontal field of view in radians
    var fovX = 2 * Math.atan(viewport.width / viewport.height * Math.tan(fovY / 2));

    // determine the width/2 of the visible portion of the x axis on the 
    // far clipping plane
    var farX  = Math.tan(fovX / 2) * this.far;

    // determine the height/2 of the visible portion of the y axis on the
    // far clipping plane
    var farY  = Math.tan(fovY / 2) * this.far;

    // set ray origin
    var origin = new Vector3D(0, 0, 0);

    // set ray direction as point within visible portion of x, y on the 
    // far clipping plane corresponding to the normalized screen coordinates
    var direction = new Vector3D(normX * farX, normY * farY, this.far);
    
    return { origin: origin, direction: direction };  
}

function PerspectiveCamera_ZoomModifiedCB(attribute, container)
{
    container.updateZoom = true;
    container.incrementModificationCount();
}
Light.prototype = new ParentableMotionElement();
Light.prototype.constructor = Light;

function Light()
{
    ParentableMotionElement.call(this);
    this.className = "Light";
    this.attrType = eAttrType.Light;
    
    this.updateAmbient = true;
    this.updateDiffuse = true;
    this.updateSpecular = true;
    this.updateConstantAttenuation = true;
    this.updateLinearAttenuation = true;
    this.updateQuadraticAttenuation = true;
    this.lightDesc = new LightDesc();
    this.lightDesc.validMembersMask = 0;
    this.lightIndex = 0;
    this.setLightDesc = false;
    
    this.ambient = new ColorAttr(0, 0, 0, 1);
	this.diffuse = new ColorAttr(1, 1, 1, 1);
	this.specular = new ColorAttr(1, 1, 1, 1);
	this.constantAttenuation = new NumberAttr(1);
	this.linearAttenuation = new NumberAttr(0);
	this.quadraticAttenuation = new NumberAttr(0);
    this.shadowCaster = new BooleanAttr(false);

    this.ambient.addModifiedCB(Light_AmbientModifiedCB, this);
    this.diffuse.addModifiedCB(Light_DiffuseModifiedCB, this);
    this.specular.addModifiedCB(Light_SpecularModifiedCB, this);
    this.constantAttenuation.addModifiedCB(Light_ConstantAttenuationModifiedCB, this);
    this.linearAttenuation.addModifiedCB(Light_LinearAttenuationModifiedCB, this);
    this.quadraticAttenuation.addModifiedCB(Light_QuadraticAttenuationModifiedCB, this);

    this.registerAttribute(this.ambient, "ambient");
    this.registerAttribute(this.diffuse, "diffuse");
    this.registerAttribute(this.specular, "specular");
    this.registerAttribute(this.constantAttenuation, "constantAttenuation");
    this.registerAttribute(this.linearAttenuation, "linearAttenuation");
    this.registerAttribute(this.quadraticAttenuation, "quadraticAttenuation");
    this.registerAttribute(this.shadowCaster, "shadowCaster");
}

Light.prototype.setGraphMgr = function(graphMgr)
{
    this.lightIndex = graphMgr.getAvailableLightIndex();
    
    // call base-class implementation
    ParentableMotionElement.prototype.setGraphMgr.call(this, graphMgr);
}

Light.prototype.update = function(params, visitChildren)
{  
    if (this.updateAmbient)
    {
        this.updateAmbient = false;

        this.lightDesc.ambient.copy(this.ambient.getValueDirect());
        this.lightDesc.validMembersMask |= LIGHTDESC_AMBIENT_BIT;
    }

    if (this.updateDiffuse)
    {
        this.updateDiffuse = false;

        this.lightDesc.diffuse.copy(this.diffuse.getValueDirect());
        this.lightDesc.validMembersMask |= LIGHTDESC_DIFFUSE_BIT;
    }

    if (this.updateSpecular)
    {
        this.updateSpecular = false;

        this.lightDesc.specular.copy(this.specular.getValueDirect());
        this.lightDesc.validMembersMask |= LIGHTDESC_SPECULAR_BIT;
    }

    if (this.updateConstantAttenuation)
    {
        this.updateConstantAttenuation = false;

        this.lightDesc.constantAttenuation = this.constantAttenuation.getValueDirect();
        this.lightDesc.validMembersMask |= LIGHTDESC_CONSTANT_ATT_BIT;
    }

    if (this.updateLinearAttenuation)
    {
        this.updateLinearAttenuation = false;

        this.lightDesc.linearAttenuation = this.linearAttenuation.getValueDirect();
        this.lightDesc.validMembersMask |= LIGHTDESC_LINEAR_ATT_BIT;
    }

    if (this.updateQuadraticAttenuation)
    {
        this.updateQuadraticAttenuation = false;

        this.lightDesc.quadraticAttenuation = this.quadraticAttenuation.getValueDirect();
        this.lightDesc.validMembersMask |= LIGHTDESC_QUADRATIC_ATT_BIT;
    }

    if (this.lightDesc.validMembersMask)
    {
        this.setLightDesc = true;
    }
    
    // ensure continued update (lights are transformed by view matrix)
    this.setModified();
    
    // call base-class implementation
    ParentableMotionElement.prototype.update.call(this, params, visitChildren);
}

Light.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        switch (directive)
        {
        case "render":
            {
                this.setLightEnabled();
            }
            break;
        }
        
        // call base-class implementation
        ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {
            if (this.setLightDesc)
            {
                this.setLightDesc = false;
                
                this.applyLightDesc();
            }

            this.setLightEnabled();   
        }
        break;
    }
    
    // call base-class implementation
    ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
}

Light.prototype.applyLightDesc = function()
{
    this.graphMgr.renderContext.setLight(this.lightIndex, this.lightDesc);  
}

Light.prototype.setLightEnabled = function()
{
    this.graphMgr.renderContext.enableLight(this.lightIndex, this.enabled.getValueDirect() ? 1 : 0);
}

function Light_AmbientModifiedCB(attribute, container)
{
    container.updateAmbient = true;
    container.incrementModificationCount();
}

function Light_DiffuseModifiedCB(attribute, container)
{
    container.updateDiffuse = true;
    container.incrementModificationCount();
}

function Light_SpecularModifiedCB(attribute, container)
{
    container.updateSpecular = true;
    container.incrementModificationCount();
}

function Light_ConstantAttenuationModifiedCB(attribute, container)
{
    container.updateConstantAttenuation = true;
    container.incrementModificationCount();
}
    
function Light_LinearAttenuationModifiedCB(attribute, container)
{
    container.updateLinearAttenuation = true;
    container.incrementModificationCount();
}

function Light_QuadraticAttenuationModifiedCB(attribute, container)
{
    container.updateQuadraticAttenuation = true;
    container.incrementModificationCount();
}

DirectionalLight.prototype = new Light();
DirectionalLight.prototype.constructor = DirectionalLight;

function DirectionalLight()
{
    Light.call(this);
    this.className = "DirectionalLight";
    this.attrType = eAttrType.DirectionalLight;
    
    this.lightDesc.type = "directional";
}

DirectionalLight.prototype.update = function(params, visitChildren)
{
    this.validMembersMask = 0;
    
    // call base-class implementation
    Light.prototype.update.call(this, params, visitChildren);
}

DirectionalLight.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Light.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {      
            var direction = this.sectorTransformCompound.transform(0, 0, 1, 0);
            this.lightDesc.direction.copy(direction);
            this.lightDesc.validMembersMask |= LIGHTDESC_DIRECTION_BIT; 
            
            // must re-update direction every frame because OpenGL transforms
            // light direction by the current modelView matrix
            this.setLightDesc = true;
        }
        break;
    }
    
    // call base-class implementation
    Light.prototype.apply.call(this, directive, params, visitChildren);
}
PointLight.prototype = new Light();
PointLight.prototype.constructor = PointLight;

function PointLight()
{
    Light.call(this);
    this.className = "PointLight";
    this.attrType = eAttrType.PointLight;
    
    this.lightDesc.type = "point";
    
    this.updateRange = false;
    
    this.range = new NumberAttr();
    
    this.range.addModifiedCB(PointLight_RangeModifiedCB, this);

    this.registerAttribute(this.range, "range");
}

PointLight.prototype.update = function(params, visitChildren)
{
    this.validMembersMask = 0;
    
    if (this.updateRange)
    {
        this.updateRange = false;

        this.lightDesc.range = this.range.getValueDirect();
        this.lightDesc.validMembersMask |= LIGHTDESC_RANGE_BIT;
    }
    
    // call base-class implementation
    Light.prototype.update.call(this, params, visitChildren);
}

PointLight.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Light.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {      
            var position = this.sectorTransformCompound.transform(0, 0, 0, 1);
            this.lightDesc.position.copy(position);
            this.lightDesc.validMembersMask |= LIGHTDESC_POSITION_BIT;

            // signifies this is a point light (not a spot light)
            this.lightDesc.outerConeDegrees = 180;
            this.lightDesc.validMembersMask |= LIGHTDESC_OUTER_CONE_DEG_BIT;
            
            // must re-update position every frame because OpenGL transforms
            // light position by the current modelView matrix
            this.setLightDesc = true;
        }
        break;
    }
    
    // call base-class implementation
    Light.prototype.apply.call(this, directive, params, visitChildren);
}

function PointLight_RangeModifiedCB(attribute, container)
{
    container.updateRange = true;
    container.incrementModificationCount();
}
GlobalIllumination.prototype = new SGNode();
GlobalIllumination.prototype.constructor = GlobalIllumination;

function GlobalIllumination()
{
    SGNode.call(this);
    this.className = "GlobalIllumination";
    this.attrType = eAttrType.GlobalIllumination;
    
    this.updateAmbient = true;
    this.setGlobalIllumination = false;
    
    this.ambient = new ColorAttr(0, 0, 0, 1);
    
    this.ambient.addModifiedCB(GlobalIllumination_AmbientModifiedCB, this);
    
    this.registerAttribute(this.ambient, "ambient");
}

GlobalIllumination.prototype.update = function(params, visitChildren)
{
    if (this.updateAmbient)
    {
        this.updateAmbient = false;
        
        this.setGlobalIllumination = true;
    }
    
    // call base-class implementation
    SGNode.prototype.update.call(this, params, visitChildren);
}

GlobalIllumination.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {
            if (this.setGlobalIllumination)
            {
                this.setGlobalIllumination = false;
                
                this.applyGlobalIllumination();
            }
        }
        break;
    }
    
    // call base-class implementation
    SGNode.prototype.apply.call(this, directive, params, visitChildren);
}

GlobalIllumination.prototype.applyGlobalIllumination = function()
{
    this.graphMgr.renderContext.setGlobalIllumination(this.ambient.getValueDirect());
}

function GlobalIllumination_AmbientModifiedCB(attribute, container)
{
    container.updateAmbient = true;
    container.incrementModificationCount();
}
Group.prototype = new SGNode();
Group.prototype.constructor = Group;

function Group()
{
    SGNode.call(this);
    this.className = "Group";
    this.attrType = eAttrType.Group;
    
    this.proxyChildAttrs = new BooleanAttr(false);
    
    this.proxyChildAttrs.addModifiedCB(Group_ProxyChildAttrsModifiedCB, this);
    
    this.registerAttribute(this.proxyChildAttrs, "proxyChildAttrs");
    
    this.enableDisplayList.addModifiedCB(Group_EnableDisplayListModifiedCB, this);
    
    // enable auto-display lists
    this.autoDisplayList.setValueDirect(true);
    this.autoDisplayList.addModifiedCB(Group_AutoDisplayListModifiedCB, this);
}

Group.prototype.addChild = function(child)
{
	if (this.proxyChildAttrs.getValueDirect() == true)
    {
        this.proxyAttributes(child);
    }

    var autoDL = child.getAttribute("autoDisplayList");
    if (autoDL)
    {
        autoDL.addTarget(this.autoDisplayList, eAttrSetOp.AND);
        autoDL.addModifiedCB(Group_ChildAutoDisplayListModifiedCB, this);
    }
	else // cannot use auto display lists because child doesn't support them
	{
		this.autoDisplayList.setValueDirect(false);
	}

    // call base-class implementation
    SGNode.prototype.addChild.call(this, child);
}

Group.prototype.insertChild = function(child, before)
{
    if (this.proxyChildAttrs.getValueDirect() == true)
    {
        this.proxyAttributes(child);
    }

    var autoDL = child.getAttribute("autoDisplayList");
    if (autoDL)
    {
        autoDL.addTarget(this.autoDisplayList, eAttrSetOp.AND);
        autoDL.addModifiedCB(Group_ChildAutoDisplayListModifiedCB, this);
    }
	else // cannot use auto display lists because child doesn't support them
	{
		this.autoDisplayList.setValueDirect(false);
	}

    // call base-class implementation
    SGNode.prototype.insertChild.call(this, child, before);
}
    
Group.prototype.removeChild = function(child)
{
    if (this.proxyChildAttrs.getValueDirect() == true)
    {
        //UnProxyAttributes(child);
        this.synchronizeProxiedAttributes();
    }

    var autoDL = child.getAttribute("autoDisplayList");
    if (autoDL)
    {
        autoDL.removeTarget(this.autoDisplayList, eAttrSetOp.AND);
        autoDL.removeModifiedCB(Group_ChildAutoDisplayListModifiedCB, this);
    }

    // call base-class implementation
    return SGNode.prototype.removeChild.call(this, child);
}

Group.prototype.replaceChild = function(replacement, replacee)
{
    if (this.proxyChildAttrs.getValueDirect() == true)
    {
        //UnProxyAttributes(replacee);
        this.proxyAttributes(replacement);
        this.synchronizeProxiedAttributes(); // replacement might not be the same type as replacee
    }

	var autoDL = replacee.getAttribute("autoDisplayList");
    if (autoDL)
    {
        autoDL.removeTarget(this.autoDisplayList, eAttrSetOp.AND);
        autoDL.removeModifiedCB(Group_ChildAutoDisplayListModifiedCB, this);
    }
    
    autoDL = replacement.getAttribute("autoDisplayList");
    if (autoDL)
    {
    	autoDL.addTarget(this.autoDisplayList, eAttrSetOp.AND);
    	autoDL.addModifiedCB(Group_ChildAutoDisplayListModifiedCB, this);	
    }
    else // cannot use auto display lists because replacement doesn't support them
	{
		this.autoDisplayList.setValueDirect(false);
	}

    // call base-class implementation
    return SGNode.prototype.replaceChild.call(this, replacement, replacee);
}

Group.prototype.update = function(params, visitChildren)
{
    // call base-class implementation
    SGNode.prototype.update.call(this, params, visitChildren);
}

Group.prototype.apply = function(directive, params, visitChildren)
{
    // call base-class implementation
    SGNode.prototype.apply.call(this, directive, params, visitChildren);
}

Group.prototype.proxyChildAttrsModified = function()
{
    // TODO
}

Group.prototype.childAutoDisplayListModified = function()
{
    // check the state of all children's autoDisplayList.  If all are set to true, set this node's autoDisplayList to true; if any
    // are set to false, set this node's autoDisplayList to false (cannot rely solely upon the fact that the children's autoDisplayList
    // attribute are 'AND' targeted to this node's autoDisplayList, because as soon as this node's autoDisplayList is false, 'AND' with
    // all children will still be false, even if all children are true; that portion of the algorithm handles the case when a child with
    // autoDisplayList set to false is added to this; this step handles the other portion of the algorithm).
    var autoDL = true;
    for (var i=0; i < this.children.length; i++)
    {
        childAutoDL = this.children[i].getAttribute("autoDisplayList");
        if (childAutoDL)
        {
            autoDL &= childAutoDL.getValueDirect();
            if (!autoDL)
            {
                break;
            }
        }
    }

    this.autoDisplayList.setValueDirect(autoDL);
}

function Group_ProxyChildAttrsModifiedCB(attribute, container)
{
    container.proxyChildAttrsModified();
}

function Group_ProxiedAttrModifiedCB(attribute, data)
{
    data.group.proxiedAttrModified(data.proxiedNodeTypeString, attribute, data.proxiedAttrName);
}

function Group_EnableDisplayListModifiedCB(attribute, container)
{
    var enableDL = attribute.getValueDirect();    
}

function Group_AutoDisplayListModifiedCB(attribute, container)
{
    var autoDL = attribute.getValueDirect();
    if (!autoDL && container)
    {
        if (container.enableDisplayList.getValueDirect() == true)
        {
            container.enableDisplayList.setValueDirect(attribute.getValueDirect());
        }
    }  
}

function Group_ChildAutoDisplayListModifiedCB(attribute, container)
{
    container.childAutoDisplayListModified();
}


Isolator.prototype = new Group();
Isolator.prototype.constructor = Isolator;

function Isolator()
{
    Group.call(this);
    this.className = "Isolator";
    this.attrType = eAttrType.Isolator;
    
    this.updateIsolateTransforms = true;
    this.updateIsolateLights = true;
    this.updateIsolateMaterials = true;
    this.updateIsolateTextures = true;
    this.updateIsolateFog = true;
    this.updateIsolateClipPlanes = true;
    
    this.isolateTransforms = new BooleanAttr(false);
    this.isolateLights = new BooleanAttr(false);
    this.isolateMaterials = new BooleanAttr(false);
    this.isolateTextures = new BooleanAttr(false);
    this.isolateDissolves = new BooleanAttr(false);
    this.isolateGlobalIlluminations = new BooleanAttr(false);
    this.isolateLightModels = new BooleanAttr(false);
    this.isolateFog = new BooleanAttr(false);
    this.isolateClipPlanes = new BooleanAttr(false);
    this.isolateRenderModes = new BooleanAttr(false);

    this.isolateTransforms.addModifiedCB(Isolator_IsolateTransformsModifiedCB, this);
    this.isolateLights.addModifiedCB(Isolator_IsolateLightsModifiedCB, this);
    this.isolateMaterials.addModifiedCB(Isolator_IsolateMaterialsModifiedCB, this);
    this.isolateTextures.addModifiedCB(Isolator_IsolateTexturesModifiedCB, this);
    this.isolateFog.addModifiedCB(Isolator_IsolateFogModifiedCB, this);
    this.isolateClipPlanes.addModifiedCB(Isolator_IsolateClipPlanesModifiedCB, this);
    
    this.registerAttribute(this.isolateTransforms, "isolateTransforms");
    this.registerAttribute(this.isolateLights, "isolateLights");
    this.registerAttribute(this.isolateMaterials, "isolateMaterials");
    this.registerAttribute(this.isolateTextures, "isolateTextures");
    this.registerAttribute(this.isolateDissolves, "isolateDissolves");
    this.registerAttribute(this.isolateGlobalIlluminations, "isolateGlobalIlluminations");
    this.registerAttribute(this.isolateLightModels, "isolateLightModels");
    this.registerAttribute(this.isolateFog, "isolateFog");
    this.registerAttribute(this.isolateClipPlanes, "isolateClipPlanes");
    this.registerAttribute(this.isolateRenderModes, "isolateRenderModes");
}

Isolator.prototype.update = function(params, visitChildren)
{
    // call base-class implementation
    Group.prototype.update.call(this, params, visitChildren);
}

Isolator.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Group.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    var isolateTransforms = this.isolateTransforms.getValueDirect();
    var isolateTextures = this.isolateTextures.getValueDirect();
    var isolateDissolves = this.isolateDissolves.getValueDirect();
    var isolateClipPlanes = this.isolateClipPlanes.getValueDirect();

    var lastDissolve = 0;
    var dissolveNode = null;

    var lastProjMatrix = null;
    var lastViewMatrix = null;
    var lastWorldMatrix = null;
    
    switch (directive)
    {
        case "render":
            {
                this.pushIsolatedStates();

                // TODO

                // push transforms
                if (isolateTransforms)
                {
                    lastProjMatrix = params.projMatrix;
                    lastViewMatrix = params.viewMatrix;
                    lastWorldMatrix = params.worldMatrix;
                    
                    // TEMP -- move to pushIsolatedStates
                	this.graphMgr.renderContext.setMatrixMode(RC_PROJECTION);
                	this.graphMgr.renderContext.pushMatrix();
                	this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
                	this.graphMgr.renderContext.pushMatrix();
                }
                
                // push textures
                if (isolateTextures)
                {
                    this.graphMgr.textureArrayStack.push(new TextureArray(this.graphMgr.textureArrayStack.top()));

                    // TODO: projection stack 
                }
            }
            break;

        case "rayPick":
            {
                // push dissolve and dissolve node
                if (isolateDissolves)
                {
                    lastDissolve = params.dissolve;
                    dissolveNode = this.graphMgr.getCurrentDissolve();
                }

                // push transforms
                if (isolateTransforms)
                {
                    // TODO
                }

                // push clip planes
                if (isolateClipPlanes)
                {
                    // TODO
                }
            }
            break;

        case "bbox":
            {
                // push transforms
                if (isolateTransforms)
                {
                    lastWorldMatrix = params.worldMatrix;
                }
            }
            break;
            
        case "collide":
            {
                // push transforms
                if (isolateTransforms)
                {
                    lastWorldMatrix = params.worldMatrix;
                }
            }
            break;
            
        case "highlight":
            {
                // push transforms
                if (isolateTransforms)
                {
                    lastWorldMatrix = params.worldMatrix;
                }
            }
            break;
    }

    // call base-class implementation
    Group.prototype.apply.call(this, directive, params, visitChildren);

    switch (directive)
    {
        case "render":
            {
                this.popIsolatedStates();

                // TODO

                // pop transforms
                if (isolateTransforms)
                {
                    params.projMatrix = lastProjMatrix;
                    params.viewMatrix = lastViewMatrix;
                    params.worldMatrix = lastWorldMatrix;
                    
                    // TEMP -- move to popIsolatedStates
                    this.graphMgr.renderContext.setMatrixMode(RC_PROJECTION);
                	this.graphMgr.renderContext.popMatrix();
                	this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
                	this.graphMgr.renderContext.popMatrix();
                }
                    
                // pop textures
                if (isolateTextures)
                {
                    this.graphMgr.textureArrayStack.pop();

                    // TODO: projection stack 
                }
            }
            break;

        case "rayPick":
            {
                // pop dissolve
                if (isolateDissolves)
                {
                    params.dissolve = lastDissolve;
                    this.graphMgr.setCurrentDissolve(dissolveNode);
                }

                // pop transforms
                if (isolateTransforms)
                {
                    // TODO
                }

                // pop clip planes
                if (isolateClipPlanes)
                {
                    // TODO
                }
            }
            break;

        case "bbox":
            {
                // pop transforms
                if (isolateTransforms)
                {
                    params.worldMatrix = lastWorldMatrix;
                }
            }
            break;
            
        case "collide":
            {
                // pop transforms
                if (isolateTransforms)
                {
                    params.worldMatrix = lastWorldMatrix;
                }
            }
            break;
            
        case "highlight":
            {
                // pop transforms
                if (isolateTransforms)
                {
                    params.worldMatrix = lastWorldMatrix;
                }
            }
            break;
    }
}

Isolator.prototype.pushIsolatedStates = function()
{
    // TODO
    
    
}

Isolator.prototype.popIsolatedStates = function()
{
    // TODO
}

function Isolator_IsolateTransformsModifiedCB(attribute, container)
{
    container.updateIsolateTransforms = true;
    container.incrementModificationCount();
}

function Isolator_IsolateLightsModifiedCB(attribute, container)
{
    container.updateIsolateLights = true;
    container.incrementModificationCount();
}

function Isolator_IsolateMaterialsModifiedCB(attribute, container)
{
    container.updateIsolateMaterials = true;
    container.incrementModificationCount();
}
 
function Isolator_IsolateTexturesModifiedCB(attribute, container)
{
    container.updateIsolateTextures = true;
    container.incrementModificationCount();
}

function Isolator_IsolateFogModifiedCB(attribute, container)
{
    container.updateIsolateFog = true;
    container.incrementModificationCount();
}

function Isolator_IsolateClipPlanesModifiedCB(attribute, container)
{
    container.updateIsolateClipPlanes = true;
    container.incrementModificationCount();
}

Dissolve.prototype = new SGNode();
Dissolve.prototype.constructor = Dissolve;

function Dissolve()
{
    SGNode.call(this);
    this.className = "Dissolve";
    this.attrType = eAttrType.Dissolve;
    
    this.lastDissolve = 0;

    this.dissolve = new NumberAttr(0);

    this.dissolve.addModifiedCB(Dissolve_DissolveModifiedCB, this);

    this.registerAttribute(this.dissolve, "dissolve");
}

Dissolve.prototype.update = function(params, visitChildren)
{
    // call base-class implementation
    SGNode.prototype.update.call(this, params, visitChildren);
}

Dissolve.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Group.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    switch (directive)
    {
        case "render":
            {
                var dissolve = this.dissolve.getValueDirect();
                this.lastDissolve = dissolve;
                
                params.dissolve = dissolve;
            }
            break;

        case "rayPick":
            {
                params.dissolve = this.lastDissolve;
            }
            break;
    }

    // call base-class implementation
    SGNode.prototype.apply.call(this, directive, params, visitChildren);
}

function Dissolve_DissolveModifiedCB(attribute, container)
{
    container.incrementModificationCount();   
}
RenderParams.prototype = new DirectiveParams();
RenderParams.prototype.constructor = RenderParams();

function RenderParams()
{
    DirectiveParams.call(this);
    
    this.viewport = new Viewport();
    this.projMatrix = new Matrix4x4();
    this.viewMatrix = new Matrix4x4();
    this.worldMatrix = new Matrix4x4();
    this.dissolve = 0;
    this.opacity = 1;
    this.distanceSortAgent = null;
    this.drawTextures = true;
    this.displayListObj = null;
    this.disableDisplayLists = false;
    this.resetDisplayLists = false;
}

RenderDirective.prototype = new SGDirective();
RenderDirective.prototype.constructor = RenderDirective;

function RenderDirective()
{
    SGDirective.call(this);
    this.className = "RenderDirective";
    this.attrType = eAttrType.RenderDirective;
    
    this.name.setValueDirect("RenderDirective");

    this.distanceSortAgent = new DistanceSortAgent();
    
    this.viewport = new ViewportAttr();
    this.backgroundImageFilename = new StringAttr("");
    this.foregroundImageFilename = new StringAttr("");
    this.foregroundAlphaFilename = new StringAttr("");
    this.foregroundFadeEnabled = new BooleanAttr(false);
    this.texturesEnabled = new BooleanAttr(true);
    this.timeIncrement = new NumberAttr(0);
    this.highlightType = new NumberAttr(eHighlightType.None);
    
    this.viewport.addModifiedCB(RenderDirective_ViewportModifiedCB, this);
    this.backgroundImageFilename.addModifiedCB(RenderDirective_BackgroundImageFilenameModifiedCB, this);
    
    this.registerAttribute(this.viewport, "viewport"); 
    this.registerAttribute(this.backgroundImageFilename, "backgroundImageFilename");
    this.registerAttribute(this.foregroundImageFilename, "foregroundImageFilename");
    this.registerAttribute(this.foregroundAlphaFilename, "foregroundAlphaFilename");   
    this.registerAttribute(this.foregroundFadeEnabled, "foregroundFadeEnabled");   
    this.registerAttribute(this.texturesEnabled, "texturesEnabled");   
    this.registerAttribute(this.timeIncrement, "timeIncrement");
    this.registerAttribute(this.highlightType, "highlightType");
    
    this.updateDirective = new UpdateDirective();
    this.timeIncrement.addTarget(this.updateDirective.getAttribute("timeIncrement"));
    this.resetDisplayLists = false;
    
    this.collideDirective = new CollideDirective();
    
    this.highlightDirective = new HighlightDirective();
    this.highlightType.addTarget(this.highlightDirective.getAttribute("highlightType"));
}

RenderDirective.prototype.setGraphMgr = function(graphMgr)
{
    this.distanceSortAgent.setGraphMgr(graphMgr);
    this.updateDirective.setGraphMgr(graphMgr);
    this.collideDirective.setGraphMgr(graphMgr);
    this.highlightDirective.setGraphMgr(graphMgr);
    
    // call base-class implementation
    SGDirective.prototype.setGraphMgr.call(this, graphMgr);
}

RenderDirective.prototype.execute = function(root)
{
    root = root || this.rootNode.getValueDirect();

    // update; combined CUpdateParams & GtUpdateParams in this version
    var params = new UpdateParams();
    params.directive = this.updateDirective;
    params.disableDisplayLists = this.resetDisplayLists;
     
    var visited = this.updateDirective.execute(root, params);

    // detect collisions
    var params = new CollideParams();
    params.directive = this.collideDirective;
    this.collideDirective.execute(root, params);
    
    // render
    var params = new RenderParams();
    /*
    renderParams.path = NULL;//m_path;
    renderParams.pathIndex = 1;
    renderParams.viewport = m_currentViewport;
    renderParams.jitterAmt = m_currentJitterAmt + jitterAmt; // RenderDirective jitter + AA jitter
    renderParams.distanceSortAgent = m_distanceSortAgent;
    renderParams.polygonSortAgent = m_polygonSortAgent;
    renderParams.renderSequenceAgent = m_renderSequenceAgent;
    renderParams.shadowRenderAgent = m_shadowRenderAgent;
    renderParams.drawTextures = m_texturesEnabled->GetValueDirect();
    renderParams.userData = m_userData->GetValueDirect();
     */
    params.directive = this;
    params.path = null;
    params.pathIndex = 1;
    params.viewport.loadViewport(this.viewport.getValueDirect());
    params.distanceSortAgent = this.distanceSortAgent;
    params.drawTextures = this.texturesEnabled.getValueDirect();

	// if resetting display lists, set the disableDisplayLists renderParams flag this render
    if (this.resetDisplayLists)
    {
    	params.resetDisplayLists = true;
        this.resetDisplayLists = false;
    }
        
    visited[0].apply("render", params, true);
    
    // sort and draw semi-transparent geometries (if any)
    if (!this.distanceSortAgent.isEmpty())
    {
        this.distanceSortAgent.sort();
        this.distanceSortAgent.draw();
        this.distanceSortAgent.clear();
    }
    
    // draw highlights
    this.drawHighlights(root);
}

RenderDirective.prototype.drawHighlights = function(root)
{
    // apply highlight directive if specified
    switch (this.highlightType.getValueDirect())
    {
    case eHighlightType.FourPass:
    case eHighlightType.EightPass:
        this.highlightDirective.execute(root);
        break;

    case eHighlightType.None:
    default:
        break;
    }   
}

function RenderDirective_ViewportModifiedCB(attribute, container)
{
//    var vp = container.viewport.getValueDirect();
//    var url = container.backgroundImageFilename.getValueDirect().join("");
//    container.graphMgr.renderContext.setBackgroundImage(url, vp.width, vp.height);
}

function RenderDirective_BackgroundImageFilenameModifiedCB(attribute, container)
{
    var vp = container.viewport.getValueDirect();
    var pathInfo = formatPath(container.backgroundImageFilename.getValueDirect().join(""));
    
    container.backgroundImageFilename.removeModifiedCB(RenderDirective_BackgroundImageFilenameModifiedCB, container);
    container.backgroundImageFilename.setValueDirect(pathInfo[0]);
    container.backgroundImageFilename.addModifiedCB(RenderDirective_BackgroundImageFilenameModifiedCB, container);
    
    container.graphMgr.renderContext.setBackgroundImage(pathInfo[0], vp.width, vp.height);
}
RayPickParams.prototype = new DirectiveParams();
RayPickParams.prototype.constructor = RayPickParams();

function RayPickParams()
{
    DirectiveParams.call(this);
    
    /// camera to perform selection testing with
    this.camera = null;
    /// current camera
    this.currentCamera = null;
    /// current viewport
    this.viewport = new Viewport();
    /// click point
    this.clickPoint = new Vector2D();
    /// origin of the ray
    this.rayOrigin = new Vector3D();
    /// direction of the ray
    this.rayDir = new Vector3D();
    /// camera near distance
    this.nearDistance = 0;
    /// camera far distance
    this.farDistance = 0;
    /// current view matrix
    this.viewMatrix = new Matrix4x4();
    /// current world matrix
    this.worldMatrix = new Matrix4x4();
    /// current sector origin
    this.sectorOrigin = new Vector3D();
    /// current material double-sided setting 
    this.doubleSided = false;
    /// current material opacity setting
    this.opacity = 0;
    /// current dissolve
    this.dissolve = 0;
    /// current clip plane(s)
    this.clipPlanes = [];
}

function RayPickRecord(path, intersectRecord, camera)
{
    /// the path of the picked geometry
    this.path = path.copy();
    /// intersection record
    this.intersectRecord = intersectRecord;
    /// the camera viewing the picked geometry
    this.camera = camera;
}

RayPickDirective.prototype = new SGDirective();
RayPickDirective.prototype.constructor = RayPickDirective;

function RayPickDirective()
{
    SGDirective.call(this);
    this.className = "RayPickDirective";
    this.attrType = eAttrType.RayPickDirective;
    
    this.name.setValueDirect("RayPickDirective");
    
    this.picked = [];
    
    this.viewport = new ViewportAttr();
    this.camera = new ReferenceAttr(null);
    this.clickPoint = new Vector2DAttr();
    
    this.registerAttribute(this.viewport, "viewport");
    this.registerAttribute(this.camera, "camera");
    this.registerAttribute(this.clickPoint, "clickPoint");
}

RayPickDirective.prototype.execute = function(root)
{
    root = root || this.rootNode.getValueDirect();
    
    // clear previous picks
    this.picked.length = 0;
    
    // pick
    var params = new RayPickParams();
    params.directive = this;
    params.camera = this.camera.getValueDirect();
    params.viewport.loadViewport(this.viewport.getValueDirect());
    params.clickPoint.copy(this.clickPoint.getValueDirect());

    root.apply("rayPick", params, true);
}

RayPickDirective.prototype.addPickRecord = function(record)
{
    // add to picked list according to distance
    for (var i=0; i < this.picked.length; i++)
    {
        if (this.picked[i].intersectRecord.distance > record.intersectRecord.distance)
        {
            break;
        }
    }
    this.picked.splice(i, 0, record);
}






BBoxParams.prototype = new DirectiveParams();
BBoxParams.prototype.constructor = BBoxParams();

function BBoxParams()
{
    DirectiveParams.call(this);

    this.viewSpace = false;
    this.viewMatrix = new Matrix4x4();
    this.worldMatrix = new Matrix4x4();
    this.minPoint = new Vector3D();
    this.maxPoint = new Vector3D();
    this.minMaxSet = false;
}

BBoxDirective.prototype = new SGDirective();
BBoxDirective.prototype.constructor = BBoxDirective;

function BBoxDirective()
{
    SGDirective.call(this);
    this.className = "BBoxDirective";
    this.attrType = eAttrType.BBoxDirective;

    this.min = new Vector3D();
    this.max = new Vector3D();
    
    this.name.setValueDirect("BBoxDirective");

    this.viewSpace = new BooleanAttr(false);
    this.viewTransform = new Matrix4x4Attr(1, 0, 0, 0,
                                           0, 1, 0, 0,
                                           0, 0, 1, 0,
                                           0, 0, 0, 1);

    this.registerAttribute(this.viewSpace, "viewSpace");
    this.registerAttribute(this.viewTransform, "viewTransform");
}

BBoxDirective.prototype.execute = function(root)
{
    root = root || this.rootNode.getValueDirect();

    // setup bbox params structure
    var params = new BBoxParams();
    params.viewSpace = this.viewSpace.getValueDirect();
    var viewMatrix = this.viewTransform.getValueDirect();
    params.viewMatrix.load(viewMatrix._11, viewMatrix._12, viewMatrix._13, viewMatrix._14,
                           viewMatrix._21, viewMatrix._22, viewMatrix._23, viewMatrix._24,
                           viewMatrix._31, viewMatrix._32, viewMatrix._33, viewMatrix._34,
                           viewMatrix._41, viewMatrix._42, viewMatrix._43, viewMatrix._44);

    // calculate bounding box
    root.apply("bbox", params, true);

    this.min = params.minPoint;
    this.max = params.maxPoint;
}

BBoxDirective.prototype.getBounds = function()
{
    return { min: this.min, max: this.max };
}

Geometry.prototype = new RenderableElement();
Geometry.prototype.constructor = Geometry;

function Geometry()
{
    RenderableElement.call(this);
    this.className = "Geometry";
    this.attrType = eAttrType.Geometry;

    this.boundingTree = new Octree();
    this.updateBoundingTree = false;

    this.selectable = new BooleanAttr(true);
    this.cullable = new BooleanAttr(true);
    this.show = new BooleanAttr(true);
    this.approximationLevels = new NumberAttr(1);
    this.sortPolygons = new BooleanAttr(false);
    this.flipPolygons = new BooleanAttr(false);
    this.shadowCaster = new BooleanAttr(false);
    this.shadowTarget = new BooleanAttr(true);
    this.highlight = new BooleanAttr(false);

    this.selectable.addModifiedCB(Geometry_SelectableModifiedCB, this);
    this.show.addModifiedCB(Geometry_ShowModifiedCB, this);
    this.approximationLevels.addModifiedCB(Geometry_ApproximationLevelsModifiedCB, this);

    this.registerAttribute(this.selectable, "selectable");
    this.registerAttribute(this.cullable, "cullable");
    this.registerAttribute(this.show, "show");
    this.registerAttribute(this.approximationLevels, "approximationLevels");
    this.registerAttribute(this.sortPolygons, "sortPolygons");
    this.registerAttribute(this.flipPolygons, "flipPolygons");
    this.registerAttribute(this.shadowCaster, "shadowCaster");
    this.registerAttribute(this.shadowTarget, "shadowTarget");
    this.registerAttribute(this.highlight, "highlight");
}

Geometry.prototype.update = function(params, visitChildren)
{
    if (this.updateBoundingTree)
    {
        this.updateBoundingTree = false;

        this.buildBoundingTree();
    }
    
    // call base-class implementation
    RenderableElement.prototype.update.call(this, params, visitChildren);
}

Geometry.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        RenderableElement.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    switch (directive)
    {
        case "render":
            {
                var drawNow = true;
                var dissolve = params.dissolve;
                var opacity = params.opacity;
                if (dissolve == 1)// || opacity == 0) // completely transparent objects can still reflect specularity
                {
                    // completely transparent, skip drawing
                    drawNow = false;
                }
                else if (dissolve > 0 ||
                         opacity < 1 ||
                         this.graphMgr.textureArrayStack.top().textures[eTextureType.Transparency].length > 0 ||
                         this.graphMgr.projectionTextureArrayStack.top().textures[eTextureType.Transparency].length > 0)
                {
                    // get bbox of geometry
                    var bounds = this.getBBox();

                    // add geometry to distance sort agent for sorted drawing
                    params.distanceSortAgent.addGeometry(this, bounds.min, bounds.max, dissolve);
                    drawNow = false;
                }

                if (drawNow)
                {
                    this.draw(dissolve);
                }
            }
            break;       

        case "rayPick":
            {
                if (this.selectable.getValueDirect() == true &&
                    params.opacity > 0 &&
                    params.dissolve < 1)
                {
                    var worldViewMatrix = params.worldMatrix.multiply(params.viewMatrix);
                    var scale = worldViewMatrix.getScalingFactors();

                    var intersectRecord = rayPick(this.boundingTree, params.rayOrigin, params.rayDir,
                                                  params.nearDistance, params.farDistance,
                                                  params.worldMatrix, params.viewMatrix,
                                                  max3(scale.x, scale.y, scale.z),
                                                  params.doubleSided, params.clipPlanes);
                    if (intersectRecord)
                    {
                        params.currentNodePath.push(this);
                        params.directive.addPickRecord(new RayPickRecord(params.currentNodePath, intersectRecord, params.camera));
                        params.currentNodePath.pop();
                    }
                }
            }
            break;

        case "bbox":
            {
                var bounds = this.getBBox();

                var matrix = new Matrix4x4();
                matrix.loadMatrix(params.worldMatrix);

                if (params.viewSpace)
                {
                    // user wants bbox in view space; multiply world matrix by view matrix
                    // to get worldView matrix
                    matrix.loadMatrix(matrix.multiply(params.viewMatrix));
                }

                var min = matrix.transform(bounds.min.x, bounds.min.y, bounds.min.z, 1);
                var max = matrix.transform(bounds.max.x, bounds.max.y, bounds.max.z, 1);

                if (params.minMaxSet)
                {
                    params.minPoint.x = Math.min(params.minPoint.x, Math.min(min.x, max.x));
                    params.minPoint.y = Math.min(params.minPoint.y, Math.min(min.y, max.y));
                    params.minPoint.z = Math.min(params.minPoint.z, Math.min(min.z, max.z));

                    params.maxPoint.x = Math.max(params.maxPoint.x, Math.max(min.x, max.x));
                    params.maxPoint.y = Math.max(params.maxPoint.y, Math.max(min.y, max.y));
                    params.maxPoint.z = Math.max(params.maxPoint.z, Math.max(min.z, max.z));
                }
                else // !params.minMaxSet
                {
                    params.minPoint.x = Math.min(min.x, max.x);
                    params.minPoint.y = Math.min(min.y, max.y);
                    params.minPoint.z = Math.min(min.z, max.z);

                    params.maxPoint.x = Math.max(min.x, max.x);
                    params.maxPoint.y = Math.max(min.y, max.y);
                    params.maxPoint.z = Math.max(min.z, max.z);

                    params.minMaxSet = true;
                }
            }
            break;
            
        case "highlight":
            {
                if (this.highlight.getValueDirect())
                {
                    if (params.targets.length > 0)
                    {
                        params.targets[params.targets.length-1].geometries.push(this);
                    }
                }
            }
            break;
    }

    // call base-class implementation
    RenderableElement.prototype.apply.call(this, directive, params, visitChildren);
}

Geometry.prototype.draw = function(dissolve)
{
}

Geometry.prototype.drawPrimitives = function()
{
}

Geometry.prototype.getBBox = function()
{
    return { min: this.bbox.min.getValueDirect(), max: this.bbox.max.getValueDirect() };
}

Geometry.prototype.getTriangles = function()
{
    return new Array();
}

function Geometry_SelectableModifiedCB(attribute, container)
{
}

function Geometry_ShowModifiedCB(attribute, container)
{
    container.incrementModificationCount();
}

function Geometry_ApproximationLevelsModifiedCB(attribute, container)
{
    container.updateBoundingTree = true;
    container.incrementModificationCount();
}
VertexGeometry.prototype = new Geometry();
VertexGeometry.prototype.constructor = VertexGeometry;

function VertexGeometry()
{
    Geometry.call(this);
    this.className = "VertexGeometry";
    this.attrType = eAttrType.VertexGeometry;

    this.updateVertices = false;
    this.updateUVCoords = [];
    this.uvCoords = [];
    this.vertexBuffer = null;
    
    this.vertices = new NumberArrayAttr();
    
    this.vertices.addModifiedCB(VertexGeometry_VerticesModifiedCB, this);
    
    this.registerAttribute(this.vertices, "vertices");
}

VertexGeometry.prototype.postCloneChild = function(childClone,pathSrc,pathClone)
{
    var i;
    var node;

    // setup uv-coords for cloned vertex geometry

    // find texture nodes affecting this node
    var textureNodes;
    for (i=0; i < pathSrc.length(); i++)
    {
        node = pathSrc.stack[i];
        if (node.getAttribute() == eAttrType.Texture)
        {
            if (!(textureNodes.push(node))) return;
        }
    }

    // find texture nodes affecting the clone
    var textureNodesClone;
    for (i=0; i < pathClone.length(); i++)
    {
        node = pathClone.stack[i];
        if (node.getAttribute() == eAttrType.Texture)
        {
            if (!(textureNodesClone.push(node))) return;
        }
    }

    // for each texture node, setup the uv-coords (textureNodes.size() and
    // textureNodesClone.size() should be the same, but check anyway)
   // CFloatArrayAttr* uvCoords = null;
    var uvCoords = new NumberArrayAttr();

    for (i=0; i < textureNodes.size() && i < textureNodesClone.size(); i++)
    {
        //uvCoords = FindUVCoords(dynamic_cast<GcTexture*>(textureNodes[i]));
        uvCoords = this.findUVCoords(textureNodes[i]);

        if (uvCoords)
        {
            var uvCoords2 = new NumberArrayAttr();
            uvCoords2 = childClone.getUVCoords(textureNodesClone[i]);
            uvCoords2.copyValue(uvCoords);
        }
    }

    // call base-class implementation
    //GcSGNode::Post_Clone_Child(childClone, pathSrc, pathClone); Not being used right now. Maybe used in the futrue.
}


VertexGeometry.prototype.getUVCoords = function(texture)
{
    for (var i=0; i < this.uvCoords.length; i++)
    {
        if (this.uvCoords[i].first == texture)
            return this.uvCoords[i].second;
    }       
    
    var uvCoords = new NumberArrayAttr();
    uvCoords.addModifiedCB(VertexGeometry_UVCoordsModifiedCB, this);
    this.uvCoords.push(new Pair(texture, uvCoords));
    
    return uvCoords;
}
VertexGeometry.prototype.findUVCoords = function(texture)
{
    if (!texture)
    {
        return null;
    }

    for (var i=0; i < this.uvCoords.length; i++)
    {
        if (this.uvCoords[i].first == texture)
            return this.uvCoords[i].second;
    }

    return null;
}

VertexGeometry.prototype.update = function(params, visitChildren)
{
    if (this.updateVertices)
    {
        this.updateVertices = false;
        
        this.vertexBuffer.setVertices(this.vertices.getValueDirect());
        
        this.updateBoundingTree = true;
        
        this.calculateBBox();
    }
    
    if (this.updateUVCoords.length)
    {
        for (var i=0; i < this.updateUVCoords.length; i++)
        {
            for (var j=0; j < this.uvCoords.length; j++)
            {
                if (this.uvCoords[j].second == this.updateUVCoords[i])
                {
                    this.vertexBuffer.setUVCoords(this.uvCoords[j].first.textureObj, this.uvCoords[j].second.getValueDirect());
                    break;
                }
            }   
        }
        this.updateUVCoords.length = 0;
    }
    
    // call base-class implementation
    Geometry.prototype.update.call(this, params, visitChildren);
}

VertexGeometry.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Geometry.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
        case "render":
            {
            }
            break;
    }
    
    // call base-class implementation
    Geometry.prototype.apply.call(this, directive, params, visitChildren);
}

VertexGeometry.prototype.drawTextured = function(dissolve)
{
    var texture0 = null;
    var texture1 = null;

    // enable blending
    this.graphMgr.renderContext.enable(eRenderMode.AlphaBlend);

    // set blend factors
    this.graphMgr.renderContext.setBlendFactor(RC_SRC_ALPHA, RC_ONE_MINUS_SRC_ALPHA);

    // get number of texture stages
    var maxStages = this.graphMgr.renderContext.getMaxTextureStages();

    // get texture array
    var textureArray = this.graphMgr.textureArrayStack.top();

    // get current material node component levels
    var ambientLevel = 1;
    var diffuseLevel = 1;
    var specularLevel = 1;
    var emissiveLevel = 1;
    var material = this.graphMgr.getCurrentMaterial();
    if (material)
    {
        ambientLevel = material.getAttribute("ambientLevel").getValueDirect();
        diffuseLevel = material.getAttribute("diffuseLevel").getValueDirect();
        specularLevel = material.getAttribute("specularLevel").getValueDirect();
        emissiveLevel = material.getAttribute("emissiveLevel").getValueDirect();
    }

    // get current material
    var currMatDesc = this.graphMgr.renderContext.getFrontMaterial();

    // push current material
    this.graphMgr.renderState.push(RENDERSTATE_MATERIAL_BIT);

    // if non-zero dissolve, set to material
    if (dissolve > 0)
    {
        currMatDesc.ambient.a *= (1 - dissolve);
        currMatDesc.diffuse.a *= (1 - dissolve);
        currMatDesc.specular.a *= (1 - dissolve);
        currMatDesc.emissive.a *= (1 - dissolve);
        this.graphMgr.renderContext.setFrontMaterial(currMatDesc);
    }

    // if transparency texture, set to stage 0
    if (textureArray.textures[eTextureType.Transparency].length)
    {
        var texture = textureArray.textures[eTextureType.Transparency][0];
        var uvCoords = this.getUVCoords(texture);

        if (uvCoords && uvCoords.getLength() > 0)
        {
            // lock texture (keep it from being modified)
            //texture->Lock();

            this.setTextureStage(0, eTextureType.Transparency, texture, texture.transformCompound);
            texture0 = texture;
        }

        // disable stage 1
        if (maxStages > 1)
        {
            this.graphMgr.renderContext.enableTextureStage(1, 0);
            texture1 = null;
        }
    }

    // if color texture, set material for blending
    if (textureArray.textures[eTextureType.Color].length)
    {
        this.setBlendingMaterial(textureArray.textures[eTextureType.Color][0].getAttribute("opacity").getValueDirect(),
        ambientLevel, diffuseLevel, specularLevel, emissiveLevel);
    }

    // set texture blend factor
    this.graphMgr.renderContext.setTextureBlendFactor(currMatDesc.diffuse.a * (1 - dissolve));

    // draw untextured if no color texture is present, or if color texture's opacity < 1
    if (textureArray.textures[eTextureType.Color].length == 0 ||
        textureArray.textures[eTextureType.Color][0].getAttribute("opacity").getValueDirect() < 1)
    {
        this.vertexBuffer.draw();
    }

    if (texture0)
    {
        this.graphMgr.renderContext.enableTextureStage(0, 0);
        //texture0->Unlock();
        texture0 = null;
    }
    if (texture1)
    {
        this.graphMgr.renderContext.enableTextureStage(1, 0);
        //texture1->Unlock();
        texture1 = null;
    }
    
    // draw color texture(s)
    for (var i = 0; i < textureArray.textures[eTextureType.Color].length; i++)
    {
        var texture = textureArray.textures[eTextureType.Color][i];
        var uvCoords = this.getUVCoords(texture);

        if (uvCoords && uvCoords.getLength() > 0)
        {
            // lock texture (keep it from being modified)
            //texture->Lock();

            this.setTextureStage(0, eTextureType.Color, texture, texture.transformCompound);
            texture0 = texture;

            // set material for blending
            this.setBlendingMaterial(texture.getAttribute("opacity").getValueDirect(),
            ambientLevel, diffuseLevel, specularLevel, emissiveLevel);

            // set texture blend factor
            this.graphMgr.renderContext.setTextureBlendFactor(currMatDesc.diffuse.a * (1 - dissolve) * texture.getAttribute("opacity").getValueDirect());
        }

        // if transparency texture, and maxStages > 1, set to stage 1
        if (maxStages > 1)
        {
            if (textureArray.textures[eTextureType.Transparency].length)
            {
                texture = textureArray.textures[eTextureType.Transparency][0];
                uvCoords = this.getUVCoords(texture);

                if (uvCoords && uvCoords.getLength() > 0)
                {
                    // lock texture (keep it from being modified)
                    //texture->Lock();

                    this.setTextureStage(1, eTextureType.Transparency, texture, texture.transformCompound);
                    texture1 = texture;
                }
            }
        }

        // draw primitives
        this.vertexBuffer.draw();

        if (texture0)
        {
            this.graphMgr.renderContext.enableTextureStage(0, 0);
            //texture0->Unlock();
            texture0 = null;
        }
        if (texture1)
        {
            this.graphMgr.renderContext.enableTextureStage(1, 0);
            //texture1->Unlock();
            texture1 = null;
        }
    }

    // TODO
    /*
    // if object doesn't contain any specularity textures,
    // make an additional pass to add specular highlights;
    // skip this step if fog is enabled (causes ultra-white surface artifacts)
    var numSpecularityTextures = textureArray.textures[eTextureType.Specularity].length;
    // TODO: + m_graphMgr->GetProjectionTextureStack().top().textures[GeTextureType_Color].size();

    if (numSpecularityTextures == 0 &&
        specularLevel > 0) // TODO: && !renderEngine->IsRenderModeEnabled(Re_Fog)
    {
        this.setSpecularMaterial(currMatDesc.specular, currMatDesc.glossiness);
        this.graphMgr.renderContext.setBlendFactor(RC_ONE, RC_ONE);
        
        // if transparency texture, set to stage 0
        if (textureArray.textures[eTextureType.Transparency].length)
        {
            var texture = textureArray.textures[eTextureType.Transparency][0];
            var uvCoords = this.getUVCoords(texture);

            if (uvCoords && uvCoords.getLength() > 0)
            {
                // lock texture (keep it from being modified)
                //texture->Lock();

                this.setTextureStage(0, eTextureType.Transparency, texture, texture.transformCompound);
                texture0 = texture;
            }

            // disable stage 1
            if (maxStages > 1)
            {
                this.graphMgr.renderContext.enableTextureStage(1, 0);
                texture1 = null;
            }
        }
        
        // draw primitives
        this.vertexBuffer.draw();
        
        if (texture0)
        {
            this.graphMgr.renderContext.enableTextureStage(0, 0);
            //texture0->Unlock();
            texture0 = null;
        }
    }
    */
    // disable texture stage 0, 1
    this.graphMgr.renderContext.enableTextureStage(0, 0);
    this.graphMgr.renderContext.enableTextureStage(1, 0);
    
    // disable blending
    this.graphMgr.renderContext.disable(eRenderMode.AlphaBlend);

    // pop current material
    this.graphMgr.renderState.pop(RENDERSTATE_MATERIAL_BIT);
}

VertexGeometry.prototype.drawPrimitives = function()
{
    this.vertexBuffer.draw();
}

VertexGeometry.prototype.setTextureStage = function(stage, type, texture, textureTransform, 
                                                    textureCoordSrc, planeCoefficients)
{
    // get optional parameters
    textureTransform = textureTransform || new Matrix4x4();
    textureCoordSrc = textureCoordSrc || eTextureCoordSrc.VertexUVs;
    planeCoefficients = planeCoefficients ||  new Matrix4x4();   
    
    // enable texture stage
    this.graphMgr.renderContext.enableTextureStage(stage, 1);

    // get texture wrap
    var widthWrap = texture.getAttribute("widthWrap").getValueDirect();
    var heightWrap = texture.getAttribute("heightWrap").getValueDirect();
    var widthWrapType, heightWrapType;
    switch (widthWrap)
    {
        case eTextureWrap.Clamp:
            widthWrapType = RC_CLAMP_TO_EDGE;
            break;

        case eTextureWrap.Repeat:
        default:
            widthWrapType = RC_REPEAT;
            break;
    }
    switch (heightWrap)
    {
        case eTextureWrap.Clamp:
            heightWrapType = RC_CLAMP_TO_EDGE;
            break;

        case eTextureWrap.Repeat:
        default:
            heightWrapType = RC_REPEAT;
            break;
    }
    
    // set texture
    this.vertexBuffer.setTextureStage(stage, texture.textureObj, 
    widthWrapType, heightWrapType, textureCoordSrc, planeCoefficients);

    // set texture blend operation
    var op;
    switch (type)
    {
        case eTextureType.Color:
            op = RC_MODULATE;
            break;

        case eTextureType.Diffuse:
        case eTextureType.Luminosity:
        case eTextureType.Specularity:
            op = RC_REPLACE;
            break;

        case eTextureType.Transparency:
            op = RC_MODULATE;//BLEND;
            break;

        default:
            return;
    }

    this.graphMgr.renderContext.setTextureBlendOp(op);

    /* TODO
    // set texture matrix
    // TODO: only load texture transforms if they are enabled
    ReMatrixMode mode;
    switch (stage)
    {
    case 0: mode = ReMatrixMode_Texture0; break;
    case 1: mode = ReMatrixMode_Texture1; break;
    case 2: mode = ReMatrixMode_Texture2; break;
    case 3: mode = ReMatrixMode_Texture3; break;
    case 4: mode = ReMatrixMode_Texture4; break;
    case 5: mode = ReMatrixMode_Texture5; break;
    case 6: mode = ReMatrixMode_Texture6; break;
    case 7: mode = ReMatrixMode_Texture7; break;
    }
    this.graphMgr.renderContext.SetMatrixMode(mode);
    this.graphMgr.renderContext.LoadMatrix(textureTransform);
    
    this.graphMgr.renderContext.SetMatrixMode(ReMatrixMode_WorldView);
     */
}

VertexGeometry.prototype.setBlendingMaterial = function(opacity, ambientLevel, diffuseLevel, 
specularLevel, emissiveLevel)
{
    var matDesc = this.graphMgr.renderContext.getFrontMaterial();
    
    // setup material for texture blending operations
    var ambientBlend  = opacity * ambientLevel;
    var diffuseBlend  = opacity * diffuseLevel;
    var specularBlend = opacity * specularLevel;
    var emissiveBlend = opacity * emissiveLevel;

    // ambient
    matDesc.ambient.r = ambientBlend + matDesc.ambient.r * (1-opacity);
    matDesc.ambient.g = ambientBlend + matDesc.ambient.g * (1-opacity);
    matDesc.ambient.b = ambientBlend + matDesc.ambient.b * (1-opacity);
    //matDesc.ambient.a *= opacity;
    
    // diffuse
    matDesc.diffuse.r = diffuseBlend + matDesc.diffuse.r * (1-opacity);
    matDesc.diffuse.g = diffuseBlend + matDesc.diffuse.g * (1-opacity);
    matDesc.diffuse.b = diffuseBlend + matDesc.diffuse.b * (1-opacity);
    //matDesc.diffuse.a *= opacity;

    // specular (turn off)
    matDesc.specular.r = 0;//specularBlend + matDesc.specular.r * (1-opacity);
    matDesc.specular.g = 0;//specularBlend + matDesc.specular.g * (1-opacity);
    matDesc.specular.b = 0;//specularBlend + matDesc.specular.b * (1-opacity);
    //matDesc.specular.a *= opacity;
    matDesc.glossiness = 1;//matDesc.glossiness;

    // emissive
    matDesc.emissive.r = emissiveBlend + matDesc.emissive.r * (1-opacity);
    matDesc.emissive.g = emissiveBlend + matDesc.emissive.g * (1-opacity);
    matDesc.emissive.b = emissiveBlend + matDesc.emissive.b * (1-opacity);
    //matDesc.emissive.a *= opacity;
    
    matDesc.validMembersMask = MATERIALDESC_ALL_BITS;

    this.graphMgr.renderContext.setFrontMaterial(matDesc);
}

VertexGeometry.prototype.setSpecularMaterial = function(specular, glossiness)
{
    var matDesc = new MaterialDesc();
    matDesc.validMembersMask = MATERIALDESC_ALL_BITS;
    matDesc.specular = specular;
    matDesc.glossiness = glossiness;

    this.graphMgr.renderContext.setFrontMaterial(matDesc);
    this.graphMgr.renderContext.setBlendFactor(RC_ONE_MINUS_SRC_ALPHA, RC_ONE);
}

VertexGeometry.prototype.calculateBBox = function()
{
    var vertices = this.vertices.getValueDirect();
    if (vertices.length < 3) return;
    
    var min = new Vector3D(vertices[0], vertices[1], vertices[2]);
    var max = new Vector3D(vertices[0], vertices[1], vertices[2]);
    
    for (var i=3; i < vertices.length; i+=3)
    {
        min.x = Math.min(min.x, vertices[i  ]);
        min.y = Math.min(min.y, vertices[i+1]);
        min.z = Math.min(min.z, vertices[i+2]);

        max.x = Math.max(max.x, vertices[i  ]);
        max.y = Math.max(max.y, vertices[i+1]);
        max.z = Math.max(max.z, vertices[i+2]);
    }

    this.bbox.getAttribute("min").setValueDirect(min.x, min.y, min.z);
    this.bbox.getAttribute("max").setValueDirect(max.x, max.y, max.z);
}

function VertexGeometry_VerticesModifiedCB(attribute, container)
{
    container.updateVertices = true;
    container.incrementModificationCount();
}

function VertexGeometry_UVCoordsModifiedCB(attribute, container)
{
    container.updateUVCoords.push(attribute);
    container.incrementModificationCount();
}
TriList.prototype = new VertexGeometry();
TriList.prototype.constructor = TriList;

function TriList()
{
    VertexGeometry.call(this);
    this.className = "TriList";
    this.attrType = eAttrType.TriList;
    
    this.updateNormals = false;
    
    this.normals = new NumberArrayAttr();
    
    this.vertices.addModifiedCB(TriList_NormalsModifiedCB, this);
    this.normals.addModifiedCB(TriList_NormalsModifiedCB, this);
    
    this.registerAttribute(this.normals, "normals");
}

TriList.prototype.update = function(params, visitChildren)
{
    if (!this.vertexBuffer)
    {
        this.vertexBuffer = this.graphMgr.renderContext.createVertexBuffer(3);
        this.vertexBuffer.setPrimitiveType(RC_TRIANGLES);
    }
       
    if (this.updateNormals)
    {
        this.updateNormals = false;
        
        this.vertexBuffer.setNormals(this.normals.getValueDirect());
    }
    
    // call base-class implementation
    VertexGeometry.prototype.update.call(this, params, visitChildren);
}

TriList.prototype.apply = function(directive, params, visitChildren)
{
    // call base-class impementation
    VertexGeometry.prototype.apply.call(this, directive, params, visitChildren);
}

TriList.prototype.draw = function(dissolve)
{
    // TODO
    
    // draw with textures
    this.drawTextured(dissolve);
}

TriList.prototype.buildBoundingTree = function()
{
    var min = this.bbox.getAttribute("min").getValueDirect();
    var max = this.bbox.getAttribute("max").getValueDirect();
    
    this.boundingTree.setTriangles(this.getTriangles(), min, max);
    this.boundingTree.buildTree(this.approximationLevels.getValueDirect());
}

TriList.prototype.getTriangles = function()
{
    var vertices = this.vertices.getValueDirect();
    
    var tris = [];
    for (var i=0, vertex=0; vertex+8 < vertices.length; i++, vertex+=9)
    {
        tris.push(new Triangle(vertices[vertex  ],  // v0
                               vertices[vertex+1],
                               vertices[vertex+2],
                               
                               vertices[vertex+3],  // v1
                               vertices[vertex+4],
                               vertices[vertex+5],
                               
                               vertices[vertex+6],  // v2
                               vertices[vertex+7],
                               vertices[vertex+8]));
    }
    
    return tris;
}

function TriList_NormalsModifiedCB(attribute, container)
{
    container.updateNormals = true;
    container.incrementModificationCount();
}
Material.prototype = new SGNode();
Material.prototype.constructor = Material;

function Material()
{
    SGNode.call(this);
    this.className = "Material";
    this.attrType = eAttrType.Material;
    
    this.updateColor = false;
    this.updateAmbientLevel = false;
    this.updateDiffuseLevel = false;
    this.updateSpecularLevel = false;
    this.updateEmissiveLevel = false;
    this.updateAmbient = true;
    this.updateDiffuse = true;
    this.updateSpecular = true;
    this.updateEmissive = true;
    this.updateGlossiness = true;
    this.updateOpacity = true;
    this.lastOpacity = 0;
    this.lastDoubleSided = false;
    this.materialDesc = new MaterialDesc();
    this.materialDesc.validMembersMask = MATERIALDESC_ALL_BITS;
    
    this.color = new ColorAttr(1, 1, 1, 1);
    this.ambientLevel = new NumberAttr(1);
    this.diffuseLevel = new NumberAttr(1);
    this.specularLevel = new NumberAttr(1);
    this.emissiveLevel = new NumberAttr(0);
    this.ambient = new ColorAttr(0.2, 0.2, 0.2, 1);
    this.diffuse = new ColorAttr(0.8, 0.8, 0.8, 1);
    this.specular = new ColorAttr(0, 0, 0, 1);
    this.emissive = new ColorAttr(0, 0, 0, 1);
    this.glossiness = new NumberAttr(0);
    this.opacity = new NumberAttr(1);
    this.doubleSided = new BooleanAttr(false);
	
    this.color.addModifiedCB(Material_ColorModifiedCB, this);
    this.ambientLevel.addModifiedCB(Material_AmbientLevelModifiedCB, this);
    this.diffuseLevel.addModifiedCB(Material_DiffuseLevelModifiedCB, this);
    this.specularLevel.addModifiedCB(Material_SpecularLevelModifiedCB, this);
    this.emissiveLevel.addModifiedCB(Material_EmissiveLevelModifiedCB, this);
    this.ambient.addModifiedCB(Material_AmbientModifiedCB, this);
    this.diffuse.addModifiedCB(Material_DiffuseModifiedCB, this);
    this.specular.addModifiedCB(Material_SpecularModifiedCB, this);
    this.emissive.addModifiedCB(Material_EmissiveModifiedCB, this);
    this.glossiness.addModifiedCB(Material_GlossinessModifiedCB, this);
    this.opacity.addModifiedCB(Material_OpacityModifiedCB, this);
    this.doubleSided.addModifiedCB(Material_DoubleSidedModifiedCB, this);

    this.registerAttribute(this.color, "color");
    this.registerAttribute(this.ambientLevel, "ambientLevel");
    this.registerAttribute(this.diffuseLevel, "diffuseLevel");
    this.registerAttribute(this.specularLevel, "specularLevel");
    this.registerAttribute(this.emissiveLevel, "emissiveLevel");
    this.registerAttribute(this.ambient, "ambient");
    this.registerAttribute(this.diffuse, "diffuse");
    this.registerAttribute(this.specular, "specular");
    this.registerAttribute(this.emissive, "emissive");
    this.registerAttribute(this.glossiness, "glossiness");
    this.registerAttribute(this.opacity, "opacity");
    this.registerAttribute(this.doubleSided, "doubleSided");
}

Material.prototype.update = function(params, visitChildren)
{
    if (this.updateColor)
    {
        this.updateColor = false;

        this.updateAmbientLevel = true;
        this.updateDiffuseLevel = true;
        this.updateSpecularLevel = true;
        this.updateEmissiveLevel = true;
    }

    if (this.updateAmbientLevel || this.updateDiffuseLevel || this.updateSpecularLevel || this.updateEmissiveLevel)
    {
        var color = this.color.getValueDirect();

        if (this.updateAmbientLevel)
        {
            this.updateAmbientLevel = false;
            
            var level = this.ambientLevel.getValueDirect();
            this.ambient.setValueDirect(color.r * level, color.g * level, color.b * level, color.a);
        }

        if (this.updateDiffuseLevel)
        {
            this.updateDiffuseLevel = false;
            
            var level = this.diffuseLevel.getValueDirect();
            this.diffuse.setValueDirect(color.r * level, color.g * level, color.b * level, color.a);
        }

        if (this.updateSpecularLevel)
        {
            this.updateSpecularLevel = false;
            
            var level = this.specularLevel.getValueDirect();
            this.specular.setValueDirect(color.r * level, color.g * level, color.b * level, color.a);
        }

        if (this.updateEmissiveLevel)
        {
            this.updateEmissiveLevel = false;
            
            var level = this.emissiveLevel.getValueDirect();
            this.emissive.setValueDirect(color.r * level, color.g * level, color.b * level, color.a);
        }
    }

    var opacity = this.opacity.getValueDirect();

    var forceUpdate = false;

    if (this.updateOpacity)
    {
        this.updateOpacity = false;
        
        this.lastOpacity = opacity;

        // have to re-update all members
        forceUpdate = true;
    }

    if (this.updateAmbient || forceUpdate)
    {
        this.updateAmbient = false;
        
        this.materialDesc.ambient.copy(this.ambient.getValueDirect());
        this.materialDesc.ambient.a *= opacity;
    }

    if (this.updateDiffuse || forceUpdate)
    {
        this.updateDiffuse = false;
        
        this.materialDesc.diffuse.copy(this.diffuse.getValueDirect());
        this.materialDesc.diffuse.a *= opacity;
    }

    if (this.updateSpecular || forceUpdate)
    {
        this.updateSpecular = false;
        
        this.materialDesc.specular.copy(this.specular.getValueDirect());
        this.materialDesc.specular.a *= opacity;
    }

    if (this.updateEmissive || forceUpdate)
    {
        this.updateEmissive = false;
        
        this.materialDesc.emissive.copy(this.emissive.getValueDirect());
        this.materialDesc.emissive.a *= opacity;
    }

    if (this.updateGlossiness || forceUpdate)
    {
        this.updateGlossiness = false;
        
        this.materialDesc.glossiness = this.glossiness.getValueDirect();
    }
    
    // call base-class implementation
    SGNode.prototype.update.call(this, params, visitChildren);
}

Material.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        SGNode.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    this.graphMgr.setCurrentMaterial(this);
    
    switch (directive)
    {
        case "render":
        {
            params.opacity = this.lastOpacity; // set in update()
            
            this.applyMaterialDesc();
        }
        break;
        
        case "rayPick":
        {
            params.doubleSided = this.lastDoubleSided;
            params.opacity = this.lastOpacity;
        }
        break;
    }
    
    // call base-class implementation
    SGNode.prototype.apply.call(this, directive, params, visitChildren);
}

Material.prototype.applyMaterialDesc = function()
{
    // set material
    this.graphMgr.renderContext.setFrontMaterial(this.materialDesc);
    
    // enable/disable backface culling
    var doubleSided = this.doubleSided.getValueDirect();
    this.lastDoubleSided = doubleSided;
    if (doubleSided)
    {
        this.graphMgr.renderContext.disable(eRenderMode.CullBackFace);
    }
    else // !doubleSided
    {
        this.graphMgr.renderContext.enable(eRenderMode.CullBackFace);
    }
}

function Material_ColorModifiedCB(attribute, container)
{
    container.updateColor = true;
    container.incrementModificationCount();
}

function Material_AmbientLevelModifiedCB(attribute, container)
{
    container.updateAmbientLevel = true;
    container.incrementModificationCount();
}

function Material_DiffuseLevelModifiedCB(attribute, container)
{
    container.updateDiffuseLevel = true;
    container.incrementModificationCount();
}

function Material_SpecularLevelModifiedCB(attribute, container)
{
    container.updateSpecularLevel = true;
    container.incrementModificationCount();
}

function Material_EmissiveLevelModifiedCB(attribute, container)
{
    container.updateEmissiveLevel = true;
    container.incrementModificationCount();
}

function Material_AmbientModifiedCB(attribute, container)
{
    container.updateAmbient = true;
    container.incrementModificationCount();
}
    
function Material_DiffuseModifiedCB(attribute, container)
{
    container.updateDiffuse = true;
    container.incrementModificationCount();
}
    
function Material_SpecularModifiedCB(attribute, container)
{
    container.updateSpecular = true;
    container.incrementModificationCount();
}
    
function Material_EmissiveModifiedCB(attribute, container)
{
    container.updateEmissive = true;
    container.incrementModificationCount();
}
    
function Material_GlossinessModifiedCB(attribute, container)
{
    container.updateGlosiness = true;
    container.incrementModificationCount();
}
    
function Material_OpacityModifiedCB(attribute, container)
{
    container.updateOpacity = true;
    container.incrementModificationCount();
}

function Material_DoubleSidedModifiedCB(attribute, container)
{
    container.incrementModificationCount();
}
Surface.prototype = new Isolator();
Surface.prototype.constructor = Surface;

function Surface()
{
    Isolator.call(this);
    this.className = "Surface";
    this.attrType = eAttrType.Surface;
    
    this.color = new ColorAttr(1, 1, 1, 1);
    this.ambientLevel = new NumberAttr(1);
    this.diffuseLevel = new NumberAttr(1);
    this.specularLevel = new NumberAttr(1);
    this.emissiveLevel = new NumberAttr(0);
    this.ambient = new ColorAttr(0.8, 0.8, 0.8, 1);
    this.diffuse = new ColorAttr(0.2, 0.2, 0.2, 1);
    this.specular = new ColorAttr(0, 0, 0, 1);
    this.emissive = new ColorAttr(0, 0, 0, 1);
    this.glossiness = new NumberAttr(0);
    this.opacity = new NumberAttr(1);
    this.doubleSided = new BooleanAttr(false);
    this.texturesEnabled = new BooleanAttr(true);
    this.colorTexturesPresent = new BooleanAttr(true);
    this.diffuseTexturesPresent = new BooleanAttr(true);
    this.luminosityTexturesPresent = new BooleanAttr(true);
    this.specularityTexturesPresent = new BooleanAttr(true);
    this.transparencyTexturesPresent = new BooleanAttr(true);
    this.numColorTextures = new NumberAttr(0);
    this.numDiffuseTextures = new NumberAttr(0);
    this.numLuminosityTextures = new NumberAttr(0);
    this.numSpecularityTextures = new NumberAttr(0);
    this.numTransparencyTextures = new NumberAttr(0);
    
    this.colorTexturesPresent.addModifiedCB(Surface_TexturesPresentModifiedCB, this);
    this.diffuseTexturesPresent.addModifiedCB(Surface_TexturesPresentModifiedCB, this);
    this.luminosityTexturesPresent.addModifiedCB(Surface_TexturesPresentModifiedCB, this);
    this.specularityTexturesPresent.addModifiedCB(Surface_TexturesPresentModifiedCB, this);
    this.transparencyTexturesPresent.addModifiedCB(Surface_TexturesPresentModifiedCB, this);

    this.registerAttribute(this.color, "color");
    this.registerAttribute(this.ambientLevel, "ambientLevel");
    this.registerAttribute(this.diffuseLevel, "diffuseLevel");
    this.registerAttribute(this.specularLevel, "specularLevel");
    this.registerAttribute(this.emissiveLevel, "emissiveLevel");
    this.registerAttribute(this.ambient, "ambient");
    this.registerAttribute(this.diffuse, "diffuse");
    this.registerAttribute(this.specular, "specular");
    this.registerAttribute(this.emissive, "emissive");
    this.registerAttribute(this.glossiness, "glossiness");
    this.registerAttribute(this.opacity, "opacity");
    this.registerAttribute(this.doubleSided, "doubleSided");
    this.registerAttribute(this.texturesEnabled, "texturesEnabled");
    this.registerAttribute(this.colorTexturesPresent, "colorTexturesPresent");
    this.registerAttribute(this.diffuseTexturesPresent, "diffuseTexturesPresent");
    this.registerAttribute(this.luminosityTexturesPresent, "luminosityTexturesPresent");
    this.registerAttribute(this.specularityTexturesPresent, "specularityTexturesPresent");
    this.registerAttribute(this.transparencyTexturesPresent, "transparencyTexturesPresent");
    this.registerAttribute(this.numColorTextures, "numColorTextures");
    this.registerAttribute(this.numDiffuseTextures, "numDiffuseTextures");
    this.registerAttribute(this.numLuminosityTextures, "numLuminosityTextures");
    this.registerAttribute(this.numSpecularityTextures, "numSpecularityTextures");
    this.registerAttribute(this.numTransparencyTextures, "numTransparencyTextures");

    this.isolateTextures.setValueDirect(true);

    this.materialNode = new Material();
    this.materialNode.getAttribute("name").setValueDirect("Material");
    this.addChild(this.materialNode);

    this.colorTexturesNode = new Group();
    this.colorTexturesNode.getAttribute("name").setValueDirect("Color Textures");
    this.addChild(this.colorTexturesNode);

    this.diffuseTexturesNode = new Group();
    this.diffuseTexturesNode.getAttribute("name").setValueDirect("Diffuse Textures");
    this.addChild(this.diffuseTexturesNode);

    this.luminosityTexturesNode = new Group();
    this.luminosityTexturesNode.getAttribute("name").setValueDirect("Luminosity Textures");
    this.addChild(this.luminosityTexturesNode);

    this.specularityTexturesNode = new Group();
    this.specularityTexturesNode.getAttribute("name").setValueDirect("Specularity Textures");
    this.addChild(this.specularityTexturesNode);

    this.transparencyTexturesNode = new Group();
    this.transparencyTexturesNode.getAttribute("name").setValueDirect("Transparency Textures");
    this.addChild(this.transparencyTexturesNode);

    this.connectMaterialAttributes(this.materialNode);
}

Surface.prototype.setGraphMgr = function(graphMgr)
{
    this.materialNode.setGraphMgr(graphMgr);
    this.colorTexturesNode.setGraphMgr(graphMgr);
    this.diffuseTexturesNode.setGraphMgr(graphMgr);
    this.luminosityTexturesNode.setGraphMgr(graphMgr);
    this.specularityTexturesNode.setGraphMgr(graphMgr);
    this.transparencyTexturesNode.setGraphMgr(graphMgr);
    
    // call base-class implementation
    Isolator.prototype.setGraphMgr.call(this, graphMgr);
}

Surface.prototype.update = function(params, visitChildren)
{
    // call base-class implementation
    Isolator.prototype.update.call(this, params, visitChildren);
}

Surface.prototype.apply = function(directive, params, visitChildren)
{
    // call base-class implementation
    Isolator.prototype.apply.call(this, directive, params, visitChildren);
}

Surface.prototype.connectMaterialAttributes = function(material)
{
    this.connectMaterialAttribute(material, this.color, "color");
    this.connectMaterialAttribute(material, this.ambientLevel, "ambientLevel");
    this.connectMaterialAttribute(material, this.diffuseLevel, "diffuseLevel");
    this.connectMaterialAttribute(material, this.specularLevel, "specularLevel");
    this.connectMaterialAttribute(material, this.emissiveLevel, "emissiveLevel");
    this.connectMaterialAttribute(material, this.ambient, "ambient");
    this.connectMaterialAttribute(material, this.diffuse, "diffuse");
    this.connectMaterialAttribute(material, this.specular, "specular");
    this.connectMaterialAttribute(material, this.emissive, "emissive");
    this.connectMaterialAttribute(material, this.glossiness, "glossiness");
    this.connectMaterialAttribute(material, this.opacity, "opacity");
    this.connectMaterialAttribute(material, this.doubleSided, "doubleSided");
}

Surface.prototype.connectMaterialAttribute = function(material, attribute, name)
{
    var modified = this.getAttributeModificationCount(attribute) > 0 ? true : false;
    attribute.addTarget(material.getAttribute(name), eAttrSetOp.Replace, null, modified);
}

Surface.prototype.addTexture = function(texture)
{
    // TODO
    this.colorTexturesNode.addChild(texture);
}

function Surface_TexturesPresentModifiedCB(attribute, container)
{
}
Model.prototype = new ParentableMotionElement();
Model.prototype.constructor = Model;

function Model()
{
    ParentableMotionElement.call(this);
    this.className = "Model";
    this.attrType = eAttrType.Model;
    
    this.geometry = [];
    this.geometryBBoxesMap = [];
    this.geometryAttrConnections = [];
    this.surfaceAttrConnections = [];
    this.boundingTree = new Octree();
    this.updateBoundingTree = false;
    
    this.url = new StringAttr("");
    this.layer = new NumberAttr(0);//0xffffffff);
    this.selectable = new BooleanAttr(true);
    this.moveable = new BooleanAttr(true);
    this.cullable = new BooleanAttr(true);
    this.show = new BooleanAttr(true);
    this.approximationLevels = new NumberAttr(2);
    this.showApproximationLevel = new NumberAttr(-1);
    this.sortPolygons = new BooleanAttr(false);
    this.flipPolygons = new BooleanAttr(false);
    this.shadowCaster = new BooleanAttr(false);
    this.shadowTarget = new BooleanAttr(true);
    this.indexedGeometry = new BooleanAttr(true);
    this.enableSharing = new BooleanAttr(true);
    this.vertices = new NumberArrayAttr();
    this.dissolve = new NumberAttr(0);
    this.color = new ColorAttr(1, 1, 1, 1);
    this.ambientLevel = new NumberAttr(1);
    this.diffuseLevel = new NumberAttr(1);
    this.specularLevel = new NumberAttr(1);
    this.emissiveLevel = new NumberAttr(0);
    this.ambient = new ColorAttr(0.8, 0.8, 0.8, 1);
    this.diffuse = new ColorAttr(0.2, 0.2, 0.2, 1);
    this.specular = new ColorAttr(0, 0, 0, 1);
    this.emissive = new ColorAttr(0, 0, 0, 1);
    this.glossiness = new NumberAttr(0);
    this.opacity = new NumberAttr(1);
    this.textureOpacity = new NumberAttr(1);
    this.doubleSided = new BooleanAttr(false);
    this.texturesEnabled = new BooleanAttr(true);
    this.pivotAboutGeometricCenter = new BooleanAttr(true);
    this.screenScaleEnabled = new BooleanAttr(false);
    this.screenScalePixels = new Vector3DAttr(0, 0, 0);
    this.detectCollision = new BooleanAttr(false);
    this.collisionDetected = new BooleanAttr(false);
    this.collisionList = new AttributeVector();
    this.highlight = new BooleanAttr(false);
    this.highlightColor = new ColorAttr(1, 1, 0, 1);
    this.highlightWidth = new NumberAttr(5);
    
    this.show.addTarget(this.enabled);
    
    this.selectable.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.cullable.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.show.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.approximationLevels.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    //this.showApproximationLevel.addModifiedCB(Model_ShowApproximationLevelModifiedCB, this);
    this.sortPolygons.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.sortPolygons.addModifiedCB(Model_SortPolygonsModifiedCB, this);
    this.flipPolygons.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.shadowCaster.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.shadowTarget.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.renderSequenceSlot.addModifiedCB(Model_GeometryAttrModifiedCB, this);
    this.renderSequenceSlot.addModifiedCB(Model_RenderSequenceSlotModifiedCB, this);
    this.dissolve.addModifiedCB(Model_DissolveModifiedCB, this);
    this.color.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.ambientLevel.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.diffuseLevel.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.specularLevel.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.emissiveLevel.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.ambient.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.diffuse.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.specular.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.emissive.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.glossiness.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.opacity.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.opacity.addModifiedCB(Model_OpacityModifiedCB, this);
    this.textureOpacity.addModifiedCB(Model_TextureOpacityModifiedCB, this);
    this.doubleSided.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.texturesEnabled.addModifiedCB(Model_SurfaceAttrModifiedCB, this);
    this.detectCollision.addModifiedCB(Model_DetectCollisionModifiedCB, this);
    this.collisionDetected.addModifiedCB(Model_CollisionDetectedModifiedCB, this);

    this.registerAttribute(this.url, "url");
    this.registerAttribute(this.layer, "layer");
    this.registerAttribute(this.selectable, "selectable");
    this.registerAttribute(this.moveable, "moveable");
    this.registerAttribute(this.cullable, "cullable");
    this.registerAttribute(this.show, "show");
    this.registerAttribute(this.approximationLevels, "approximationLevels");
    this.registerAttribute(this.showApproximationLevel, "showApproximationLevel");
    this.registerAttribute(this.sortPolygons, "sortPolygons");
    this.registerAttribute(this.flipPolygons, "flipPolygons");
    this.registerAttribute(this.shadowCaster, "shadowCaster");
    this.registerAttribute(this.shadowTarget, "shadowTarget");
    this.registerAttribute(this.indexedGeometry, "indexedGeometry");
    this.registerAttribute(this.enableSharing, "enableSharing");
    this.registerAttribute(this.vertices, "vertices");
    this.registerAttribute(this.dissolve, "dissolve");
    this.registerAttribute(this.color, "color");
    this.registerAttribute(this.ambientLevel, "ambientLevel");
    this.registerAttribute(this.diffuseLevel, "diffuseLevel");
    this.registerAttribute(this.specularLevel, "specularLevel");
    this.registerAttribute(this.emissiveLevel, "emissiveLevel");
    this.registerAttribute(this.ambient, "ambient");
    this.registerAttribute(this.diffuse, "diffuse");
    this.registerAttribute(this.specular, "specular");
    this.registerAttribute(this.emissive, "emissive");
    this.registerAttribute(this.glossiness, "glossiness");
    this.registerAttribute(this.opacity, "opacity");
    this.registerAttribute(this.textureOpacity, "textureOpacity");
    this.registerAttribute(this.doubleSided, "doubleSided");
    this.registerAttribute(this.texturesEnabled, "texturesEnabled");
    this.registerAttribute(this.pivotAboutGeometricCenter, "pivotAboutGeometricCenter");
    this.registerAttribute(this.screenScaleEnabled, "screenScaleEnabled");
    this.registerAttribute(this.screenScalePixels, "screenScalePixels");
    this.registerAttribute(this.detectCollision, "detectCollision");
    this.registerAttribute(this.collisionDetected, "collisionDetected");
    this.registerAttribute(this.collisionList, "collisionList");
    this.registerAttribute(this.highlight, "highlight");
    this.registerAttribute(this.highlightColor, "highlightColor");
    this.registerAttribute(this.highlightWidth, "highlightWidth");
        
    this.isolatorNode = new Isolator();
    this.isolatorNode.getAttribute("name").setValueDirect("Isolator");
    this.isolatorNode.getAttribute("isolateDissolves").setValueDirect(true);
    //this.isolatorNode.setCreatedByParent(true);
    this.addChild(this.isolatorNode);

    this.dissolveNode = new Dissolve();
    this.dissolveNode.getAttribute("name").setValueDirect("Dissolve");
    this.addChild(this.dissolveNode);
    this.dissolve.addTarget(this.dissolveNode.getAttribute("dissolve"));
    //this.dissolve.setCreatedByParent(true);

    this.surfacesNode = new Group();
    this.surfacesNode.getAttribute("name").setValueDirect("Surfaces");
    this.addChild(this.surfacesNode);

    // enable auto-display lists
    this.autoDisplayList.setValueDirect(true);
    this.autoDisplayList.addModifiedCB(Model_AutoDisplayListModifiedCB, this);

    //this.surfacesNode.setCreatedByParent(true);
}

Model.prototype.copyModel = function(clone,cloneChildren,pathSrc,pathClone)
{
    var clonedByThis = false;
    if(!clone)
    {
        if (!(clone = new Model()))
        {
            return -1;
        }

        clonedByThis = true;
    }

    // call base-class implementation
    if (this.copyNode(clone, cloneChildren, pathSrc, pathClone))
    {
        return -1;
    }
}

/*Model.prototype.postClone = function(clone,pathSrc,pathClone)
{
    var i;
    var j;
    var node;
    var type;
    // setup uv-coords for cloned vertex geometry

    // find vertex geometry nodes under this node
    var names = [];
    var types = [];
    if (!(types.push(eAttrType.TriList))) return;
    if (!(types.push(eAttrType.LineList))) return;
    if (!(types.push(eAttrType.PointList))) return;
    var vertexGeometryNodes = [];
    this.searchTree(names, types, false, true, false, null, null, null, vertexGeometryNodes);
    //if (!(types.push(eAttrType.IndexedTriList))) return;
    //if (!(Push_Back<eAttrType>(types, eAttrType_Node_IndexedLineList))) return;
    //if (!(Push_Back<eAttrType>(types, eAttrType_Node_IndexedPointList))) return;


    // find vertex geometry nodes under the clone
    var vertexGeometryNodesClone = [];
    for (i=0; i < pathClone.length(); i++)
    {
        node = pathClone.stack[i];
        type = node.getAttribute();
        if (type == eAttrType.TriList ||
            type == eAttrType.LineList ||
            type == eAttrType.PointList)
//            type == eAttrType_Node_IndexedTriList ||
//            type == eAttrType_Node_IndexedLineList ||
//            type == eAttrType_Node_IndexedPointList)
        {
            if (!(vertexGeometryNodesClone.push(node))) return;
        }
    }

    // find media texture nodes affecting this node
    var textureNodes = [];
    this.searchTree(null, eAttrType.MediaTexture, false, true, false, null, null, null, textureNodes);

    // find media texture nodes affecting the clone
    var textureNodesClone = [];
    for (i=0; i < pathClone.length(); i++)
    {
        node = pathClone.stack[i];
        if (node.getAttribute() == eAttrType.MediaTexture)
        {
            if (!(textureNodesClone.push(node))) return;
        }
    }

    // for each vertex geometry node
    for (i=0; i < vertexGeometryNodes.size(); i++)
    {
        // for each texture node, setup the uv-coords
        var uvCoords = new NumberArrayAttr();
        for (j=0; j < textureNodes.size() && j < textureNodesClone.size(); j++)
        {
            uvCoords = vertexGeometryNodes[i].findUVCoords(textureNodes[j]);
            if (uvCoords)
            {
                var uvCoords2 = new NumberArrayAttr();
                uvCoords2 = vertexGeometryNodesClone[i].getUVCoords(textureNodesClone[j]);
                if (uvCoords2) uvCoords2.copyValue(uvCoords);
            }
        }
    }

    // setup m_geometry, m_geometryIndicesMap, m_geometryBBoxesMap, and m_surfaceNameMap
    var modelClone = clone;

    // find geometry nodes under the clone
    var geometryNodesClone = [];
    clone.searchesTree(names, types, false, true, false, null, null, null, geometryNodesClone);

    // synchronize m_geometryAttrConnections using "OR" operation (this will ensure attributes set inline on the clone are not lost)
    //std::vector<std::pair<CAttribute*, bool> >::const_iterator it;
    //this.geometryAttrConnections[]
    //std::vector<std::pair<CAttribute*, bool> >::iterator clone_it;
    */
   /* for (it = m_geometryAttrConnections.begin(), clone_it = modelClone->m_geometryAttrConnections.begin();
         it != m_geometryAttrConnections.end(), clone_it != modelClone->m_geometryAttrConnections.end();
         it++, clone_it++)*/
    /*for(var i = 0;i<this.geometryAttrConnections.length;i++)
    {
        // if this node has had a geometry attribute set, and the clone has not, copy the value from this
        if (it->second && !clone_it->second)
        {
            clone_it->first->CopyValue(it->first);
        }

        clone_it->second = clone_it->second | it->second;
    }

    var geometry;
    var srcGeometry;
    var srcIndices = [];
    const std::pair<CVector3Df, CVector3Df>* srcBBox;
    for (i=0; i < geometryNodesClone.size(); i++)
    {
        geometry = geometryNodesClone[i];

        srcGeometry = GetGeometry(i);
        srcIndices = GetGeometryIndices(srcGeometry);
        srcBBox = GetGeometryBBox(srcGeometry);

        if (!(Push_Back<GcGeometry*>(modelClone->m_geometry, geometry))) return;
        if (srcIndices) modelClone.m_geometryIndicesMap[geometry] = *srcIndices;
        if (srcBBox) modelClone->m_geometryBBoxesMap[geometry] = *srcBBox;

        modelClone->UpdateGeometryAttrConnections(geometry, true);
        modelClone->AddGeometryBBox(geometry);
    }

    // find surface nodes under the clone
    var surfaceNodesClone = [];
    clone.searchTree(null, eAttrType.Surface, false, true, false, null, null, null, surfaceNodesClone);

    // synchronize m_surfaceAttrConnectionsMap using "OR" operation (this will ensure attributes set inline on the clone are not lost)
    for (it = m_surfaceAttrConnections.begin(), clone_it = modelClone->m_surfaceAttrConnections.begin();
         it != m_surfaceAttrConnections.end(), clone_it != modelClone->m_surfaceAttrConnections.end();
         it++, clone_it++)
    {
        // if this node has had a surface attribute set, and the clone has not, copy the value from this
        if (it->second && !clone_it->second)
        {
            clone_it->first->CopyValue(it->first);
        }

        clone_it->second = clone_it->second | it->second;
    }

    var surface;
    for (i=0; i < surfaceNodesClone.size(); i++)
    {
        surface = surfaceNodesClone[i];

        modelClone->m_surfaceNameMap[surface->GetName()->GetValueDirect(buffer, sizeof(buffer))] = surface;

        // register surface to this for accessiblity with Set
        modelClone->RegisterAttribute(surface, buffer);
        if (surface.getContainer() == modelClone)
        {
            // don't want modelClone to be the registered container for the surface otherwise it will be released
            // when unregistered
            surface.setContainer(null);
        }

        modelClone->UpdateSurfaceAttrConnections(surface, true);
    }

    // call base-class implementation
    this.postClone(clone, pathSrc, pathClone);
}
*/
Model.prototype.initializeSurfaceAttrConnectionsMap = function()
{
    this.surfaceAttrConnections.push(new Pair(this.color, false));
    this.surfaceAttrConnections.push(new Pair(this.ambientLevel, false));
    this.surfaceAttrConnections.push(new Pair(this.diffuseLevel, false));
    this.surfaceAttrConnections.push(new Pair(this.specularLevel, false));
    this.surfaceAttrConnections.push(new Pair(this.emissiveLevel, false));
    this.surfaceAttrConnections.push(new Pair(this.ambient, false));
    this.surfaceAttrConnections.push(new Pair(this.diffuse, false));
    this.surfaceAttrConnections.push(new Pair(this.specular, false));
    this.surfaceAttrConnections.push(new Pair(this.emissive, false));
    this.surfaceAttrConnections.push(new Pair(this.glossiness, false));
    this.surfaceAttrConnections.push(new Pair(this.opacity, false));
    this.surfaceAttrConnections.push(new Pair(this.doubleSided, false));
    this.surfaceAttrConnections.push(new Pair(this.texturesEnabled, false));
    this.surfaceAttrConnections.push(new Pair(this.renderSequenceSlot, false));
}

Model.prototype.initializeGeometryAttrConnectionsMap = function()
{
    this.geometryAttrConnections.push(new Pair(this.selectable, false));
    this.geometryAttrConnections.push(new Pair(this.cullable, false));
    this.geometryAttrConnections.push(new Pair(this.show, false));
    this.geometryAttrConnections.push(new Pair(this.approximationLevels, false));
    this.geometryAttrConnections.push(new Pair(this.showApproximationLevel, false));
    this.geometryAttrConnections.push(new Pair(this.sortPolygons, false));
    this.geometryAttrConnections.push(new Pair(this.flipPolygons, false));
    this.geometryAttrConnections.push(new Pair(this.intersector, false));
    this.geometryAttrConnections.push(new Pair(this.intersectee, false));
    this.geometryAttrConnections.push(new Pair(this.stationary, false));
    this.geometryAttrConnections.push(new Pair(this.shadowCaster, false));
    this.geometryAttrConnections.push(new Pair(this.shadowTarget, false));
}

Model.prototype.clearSurfaceAttrConnectionMap = function()
{
    this.surfaceAttrConnections = [];

    this.initializeSurfaceAttrConnectionsMap();
}

Model.prototype.clearGeometryAttrConnectionsMap = function()
{
    this.geometryAttrConnections = [];

    this.initializeGeometryAttrConnectionsMap();
}

Model.prototype.setGraphMgr = function(graphMgr)
{
    this.isolatorNode.setGraphMgr(graphMgr);
    this.dissolveNode.setGraphMgr(graphMgr);
    this.surfacesNode.setGraphMgr(graphMgr);
    
    // call base-class implementation
    ParentableMotionElement.prototype.setGraphMgr.call(this, graphMgr);
}

Model.prototype.update = function(params, visitChildren)
{
    if (this.updateBoundingTree)
    {
        this.updateBoundingTree = false;

        this.buildBoundingTree();
    }
    
    // call base-class implementation
    ParentableMotionElement.prototype.update.call(this, params, visitChildren);
}

Model.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    switch (directive)
    {
        case "render":
            {
                var show = this.show.getValueDirect();
                if (!show)
                {
                    // call base-class implementation
                    ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
                    return;
                }

                this.pushMatrix();

                this.applyTransform();

                // call base-class implementation
                ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);

                this.popMatrix();
            }
            break;

        case "rayPick":
            {
                var lastWorldMatrix = new Matrix4x4();
                lastWorldMatrix.loadMatrix(params.worldMatrix);
                var lastSectorOrigin = new Vector3D(params.sectorOrigin.x, params.sectorOrigin.y, params.sectorOrigin.z);

                params.worldMatrix = params.worldMatrix.multiply(this.sectorTransformCompound);
                params.sectorOrigin.load(this.sectorOrigin.getValueDirect());

                // call base-class implementation
                ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);

                params.worldMatrix.loadMatrix(lastWorldMatrix);
                params.sectorOrigin.copy(lastSectorOrigin);
            }
            break;

        case "bbox":
            {
                var lastWorldMatrix = new Matrix4x4();
                lastWorldMatrix.loadMatrix(params.worldMatrix);
                params.worldMatrix.loadMatrix(this.sectorTransformCompound.multiply(params.worldMatrix));

                // call base-class implementation
                ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);

                params.worldMatrix.loadMatrix(lastWorldMatrix);
            }
            break;

        case "collide":
            {
                var lastWorldMatrix = new Matrix4x4();
                lastWorldMatrix.loadMatrix(params.worldMatrix);
                params.worldMatrix.loadMatrix(this.sectorTransformCompound.multiply(params.worldMatrix));

                if (this.detectCollision.getValueDirect()) 
                {
                    this.boundingTree.setTransform(params.worldMatrix);
                    params.detectCollisions[this.name.getValueDirect().join("")] = new CollideRec(this, this.boundingTree);
                    this.collisionDetected.setValueDirect(false);
                }
                
                // call base-class implementation
                ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);

                params.worldMatrix.loadMatrix(lastWorldMatrix);
            }
            break;
           
        case "highlight":
            {
                if (this.highlight.getValueDirect())
                {
                    var target = new HighlightTarget();
                    target.projMatrix = params.projMatrix;
                    target.viewMatrix = params.viewMatrix;
                    target.worldMatrix = this.sectorTransformCompound.multiply(params.worldMatrix);
                    target.camera = params.camera;
                    target.viewport = params.viewport;
                    target.center = this.center.getValueDirect();
                    var highlightColor = this.highlightColor.getValueDirect();
                    target.highlightColor_r = highlightColor.r;
                    target.highlightColor_g = highlightColor.g;
                    target.highlightColor_b = highlightColor.b;
                    target.highlightColor_a = highlightColor.a;
                    target.highlightWidth = this.highlightWidth.getValueDirect();
                    params.targets.push(target);

                    // call base-class implementation
                    ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
                }
            }
            break;  
         
        default:
            {
                // call base-class implementation
                ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
            }
            break;
    }
}

Model.prototype.pushMatrix = function()
{
    this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
    this.graphMgr.renderContext.pushMatrix();
}

Model.prototype.popMatrix = function()
{
    this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
    this.graphMgr.renderContext.popMatrix();
    this.graphMgr.renderContext.applyModelViewTransform();    
}

Model.prototype.addSurface = function(surface)
{
    this.surfacesNode.addChild(surface);
    
    // register surface to this for accessiblity with Set
    this.registerAttribute(surface, surface.getAttribute("name").getValueDirect().join(""));
	
    this.connectSurfaceAttributes(surface);
}

Model.prototype.addGeometry = function(geometry, surface)
{
    surface.addChild(geometry);
    
    this.connectGeometryAttributes(geometry);
    this.addGeometryBBox(geometry);
    this.geometry.push(geometry);
        
    this.updateBoundingTree = true;
}

Model.prototype.addIndexedGeometry = function(geometry, indices, surface)
{
    this.addGeometry(geometry, surface);
    
    // TODO: what to do with indices?
}

Model.prototype.connectSurfaceAttributes = function(surface)
{
    this.connectSurfaceAttribute(surface, this.color, "color");
    this.connectSurfaceAttribute(surface, this.ambientLevel, "ambientLevel");
    this.connectSurfaceAttribute(surface, this.diffuseLevel, "diffuseLevel");
    this.connectSurfaceAttribute(surface, this.specularLevel, "specularLevel");
    this.connectSurfaceAttribute(surface, this.emissiveLevel, "emissiveLevel");
    this.connectSurfaceAttribute(surface, this.ambient, "ambient");
    this.connectSurfaceAttribute(surface, this.diffuse, "diffuse");
    this.connectSurfaceAttribute(surface, this.specular, "specular");
    this.connectSurfaceAttribute(surface, this.emissive, "emissive");
    this.connectSurfaceAttribute(surface, this.glossiness, "glossiness");
    this.connectSurfaceAttribute(surface, this.opacity, "opacity");
    this.connectSurfaceAttribute(surface, this.doubleSided, "doubleSided");
    this.connectSurfaceAttribute(surface, this.texturesEnabled, "texturesEnabled");
    this.connectSurfaceAttribute(surface, this.enabled, "enabled");
}

Model.prototype.connectSurfaceAttribute = function(surface, attribute, name)
{
    var modified = this.getAttributeModificationCount(attribute) > 0 ? true : false;
    attribute.addTarget(surface.getAttribute(name), eAttrSetOp.Replace, null, modified);
}

Model.prototype.connectGeometryAttributes = function(geometry)
{
	this.connectGeometryAttribute(geometry,	this.name, "name");
    this.connectGeometryAttribute(geometry, this.selectable, "selectable");
    this.connectGeometryAttribute(geometry, this.cullable, "cullable");
    this.connectGeometryAttribute(geometry, this.show, "show");
    this.connectGeometryAttribute(geometry, this.approximationLevels, "approximationLevels");
    this.connectGeometryAttribute(geometry, this.sortPolygons, "sortPolygons");
    this.connectGeometryAttribute(geometry, this.flipPolygons, "flipPolygons");
    this.connectGeometryAttribute(geometry, this.shadowCaster, "shadowCaster");
    this.connectGeometryAttribute(geometry, this.shadowTarget, "shadowTarget");
    this.connectGeometryAttribute(geometry, this.renderSequenceSlot, "renderSequenceSlot");
    this.connectGeometryAttribute(geometry, this.highlight, "highlight");
}

Model.prototype.connectGeometryAttribute = function(geometry, attribute, name)
{
    var modified = this.getAttributeModificationCount(attribute) > 0 ? true : false;
    attribute.addTarget(geometry.getAttribute(name), eAttrSetOp.Replace, null, modified);
}

Model.prototype.addGeometryBBox = function(geometry)
{
    if (geometry == null ||
        geometry == undefined)
        return;
    
    geometry.bbox.min.addModifiedCB(Model_GeometryBBoxModifiedCB, this);
    geometry.bbox.max.addModifiedCB(Model_GeometryBBoxModifiedCB, this);

    this.updateGeometryBBox(geometry);
}

Model.prototype.updateGeometryBBox = function(geometry)
{
    if (geometry == null ||
        geometry == undefined)
        return;
    
    var min = geometry.bbox.min.getValueDirect();
    var max = geometry.bbox.max.getValueDirect();
    
    this.geometryBBoxesMap.push(new Pair(min, max));
    
    this.updateBBox();
}

Model.prototype.updateBBox = function()
{
    var min = new Vector3D();
    var max = new Vector3D();
    var first = true;
    for (var i in this.geometryBBoxesMap)
    {
        if (first)
        {
            min.x = this.geometryBBoxesMap[i].first.x;
            min.y = this.geometryBBoxesMap[i].first.y;
            min.z = this.geometryBBoxesMap[i].first.z;
            
            max.x = this.geometryBBoxesMap[i].second.x;
            max.y = this.geometryBBoxesMap[i].second.y;
            max.z = this.geometryBBoxesMap[i].second.z;
            
            first = false;
            continue;
        }
        
        min.x = Math.min(min.x, this.geometryBBoxesMap[i].first.x);
        min.y = Math.min(min.y, this.geometryBBoxesMap[i].first.y);
        min.z = Math.min(min.z, this.geometryBBoxesMap[i].first.z);
        
        max.x = Math.max(max.x, this.geometryBBoxesMap[i].second.x);
        max.y = Math.max(max.y, this.geometryBBoxesMap[i].second.y);
        max.z = Math.max(max.z, this.geometryBBoxesMap[i].second.z);
    }
    
    this.bbox.min.setValueDirect(min.x, min.y, min.z);
    this.bbox.max.setValueDirect(max.x, max.y, max.z);
    
    var center = new Vector3D((min.x + max.x) / 2.0,
                              (min.y + max.y) / 2.0,
                              (min.z + max.z) / 2.0);
                              
    this.center.setValueDirect(center.x, center.y, center.z);
    
    this.updateBoundingTree = true;
}

Model.prototype.buildBoundingTree = function()
{
    var tris = [];
    for (var i = 0; i < this.geometry.length; i++)
    {
        tris = tris.concat(this.geometry[i].getTriangles());
    }
    
    this.boundingTree = new Octree();
    this.boundingTree.setTriangles(tris, this.bbox.min.getValueDirect(), this.bbox.max.getValueDirect());
    this.boundingTree.buildTree(this.approximationLevels.getValueDirect());
}

Model.prototype.autoDisplayListModified = function()
{
    
}

function Model_AutoDisplayListModifiedCB(attribute, container)
{
    container.autoDisplayListModified();
}

function Model_SortPolygonsModifiedCB(attribute, container)
{
    // TODO
    //container.sortPolygonsModified();
}
    
function Model_RenderSequenceSlotModifiedCB(attribute, container)
{
    var slot = attribute.getValueDirect();

    // if render seqence slot is non-zero, cannot use display lists
    if (slot > 0)
    {
        container.autoDisplayList.setValueDirect(false);
        container.enableDisplayList.setValueDirect(false);
    }
}

function Model_DissolveModifiedCB(attribute, container)
{
    var dissolve = attribute.getValueDirect();

    if (dissolve > 0)
    {
        container.autoDisplayList.setValueDirect(false);
        container.enableDisplayList.setValueDirect(false);
    }

    //this.updateDisableOnDissolve(); // TODO
}

function Model_OpacityModifiedCB(attribute, container)
{
    var opacity = attribute.getValueDirect();
    
    // if opacity is less than 1, cannot use display lists
    if (opacity < 1)
    {
        container.autoDisplayList.setValueDirect(false);
        container.enableDisplayList.setValueDirect(false);
    }
}

function Model_TextureOpacityModifiedCB(attribute, container)
{
    //container.textureOpacityModified();
}

function Model_Surface_NumTransparencyTexturesModifiedCB(attribute, container)
{
    var numTransparencyTextures = attribute.getValueDirect();
    
    // if count is greater than 0, cannot use display lists
    if (numTransparencyTextures > 0)
    {
        container.autoDisplayList.setValueDirect(false);
        container.enableDisplayList.setValueDirect(false);
    }
}

function Model_GeometryBBoxModifiedCB(attribute, container)
{
    container.updateGeometryBBox(attribute.getContainer().getContainer());
}

function Model_SurfaceAttrModifiedCB(attribute, container)
{
    //container.incrementModificationCount();
}

function Model_GeometryAttrModifiedCB(attribute, container)
{
    //container.incremementModificationCount();
}

function Model_DetectCollisionModifiedCB(attribute, container)
{
	var detectCollision = attribute.getValueDirect();
    
    // if detecting collisions, cannot use display lists
    if (detectCollision)
    {
        container.autoDisplayList.setValueDirect(false);
        container.enableDisplayList.setValueDirect(false);
    }
}

function Model_CollisionDetectedModifiedCB(attribute, container)
{
}
Texture.prototype = new ParentableMotionElement();
Texture.prototype.constructor = Texture;

function Texture()
{
    ParentableMotionElement.call(this);
    this.className = "Texture";
    this.attrType = eAttrType.Texture;
   
    this.updateImage = false;
    this.updateTextureType = false;
    this.updateMipmappingEnabled = false;
    this.setImage = false;
    this.imageSet = false;
    this.textureObj = null;
    this.pitch = 0;
    
    this.image = new ImageAttr(); 
    this.opacity = new NumberAttr(1);
    this.textureType = new NumberAttr(eTextureType.Color);
    this.widthWrap = new NumberAttr(eTextureWrap.None);
    this.heightWrap = new NumberAttr(eTextureWrap.None);
    this.mipmappingEnabled = new BooleanAttr(false);
    
    this.image.setTransient(true); // don't serialize image data
    
    this.image.getAttribute("width").addModifiedCB(Texture_ImageModifiedCB, this);
    this.image.getAttribute("height").addModifiedCB(Texture_ImageModifiedCB, this);
    this.image.getAttribute("byteAlignment").addModifiedCB(Texture_ImageModifiedCB, this);
    this.image.getAttribute("pixelFormat").addModifiedCB(Texture_ImageModifiedCB, this);
    this.image.getAttribute("pixels").addModifiedCB(Texture_ImagePixelsModifiedCB, this);
    this.textureType.addModifiedCB(Texture_TextureTypeModifiedCB, this);
    this.opacity.addModifiedCB(Texture_OpacityModifiedCB, this);
    this.widthWrap.addModifiedCB(Texture_WrapModifiedCB, this);
    this.heightWrap.addModifiedCB(Texture_WrapModifiedCB, this);
    this.mipmappingEnabled.addModifiedCB(Texture_MipmappingEnabledModifiedCB, this);

    this.registerAttribute(this.image, "image");
    this.registerAttribute(this.opacity, "opacity");
    this.registerAttribute(this.textureType, "textureType");
    this.registerAttribute(this.widthWrap, "widthWrap");
    this.registerAttribute(this.heightWrap, "heightWrap");
    this.registerAttribute(this.mipmappingEnabled, "mipmappingEnabled");
}

Texture.prototype.setGraphMgr = function(graphMgr)
{
    // create texture object
    this.textureObj = graphMgr.renderContext.createTextureObject();
    
    // call base-class implementation
    ParentableMotionElement.prototype.setGraphMgr.call(this, graphMgr);
}

Texture.prototype.update = function(params, visitChildren)
{
    if (this.updateImage)
    {
        this.updateImage = false;

        this.setImage = true;
    }

    if (this.updateMipmappingEnabled)
    {
        // only reset image to use/not use mipmaps if image has been specified
        if (this.imageSet)
        {
            this.setImage = true;
            this.updateMipmappingEnabled = false;
        }
    }

    if (this.setImage)
    {
        this.setImage = !(this.SetImage());
    }

    // only call direct-base class implementation if position, rotation, or scale has been modified
    // (avoids unnecessary calculations for textures)
    if (this.updatePosition || this.updateRotation || this.updateScale)
    {
        ParentableMotionElement.prototype.update.call(this, params, visitChildren);
    }
    else
    {
        SGNode.prototype.update.call(this, params, visitChildren);
    }
}

Texture.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    switch (directive)
    {
        case "render":
            {
                // if texture is ready, add to texture array
                if (this.imageSet)
                {
                    var drawTextures = params.drawTextures && this.graphMgr.getDrawTextures();
                    if (drawTextures)
                    {
                        // TODO: if current projector object, add texture to projection texture array
                        var textures = this.graphMgr.textureArrayStack.top().textures;
                        var i = this.textureType.getValueDirect();
                        // Added this error handling when several scenes
                        // where textures[i] is undefined but have no
                        // idea why textures[i] is undefined - KMC
                        if (textures[i])
                        {
                            textures[i].push(this);
                        }
                    }
                }
                
            }
            break;
    }

    // call base-class implementation
    ParentableMotionElement.prototype.apply.call(this, directive, params, visitChildren);
}

Texture.prototype.SetImage = function()
{
    var width = this.image.width.getValueDirect();
    var height = this.image.height.getValueDirect();
    var pixelFormat = this.image.pixelFormat.getValueDirect();
    var pixels = this.image.pixels.getValueDirect();

    if (width == 0 ||
        height == 0 ||
        pixelFormat == ePixelFormat.Unknown ||
        pixels == null)
    {
        return false;
    }
    
    var imageFormat;
    switch (this.textureType.getValueDirect())
    {
        case eTextureType.Diffuse:
        case eTextureType.Luminosity:
        case eTextureType.Specularity:
        case eTextureType.Transparency:
            imageFormat = eImageFormat.Alpha;
            break;

        case eTextureType.Color:
        default:
            imageFormat = eImageFormat.RGBA;
            break;
    }

    this.textureObj.setImageData(width, height, pixelFormat, imageFormat, pixels);

    this.imageSet = true;
    
    return true;
}

function Texture_ImageModifiedCB(attribute, container)
{
    container.updateImage = true;
    container.incrementModificationCount();
}

function Texture_ImagePixelsModifiedCB(attribute, container)
{
    container.updateImage = true;
    container.incrementModificationCount();
}

function Texture_OpacityModifiedCB(attribute, container)
{
    container.incrementModificationCount();
}

function Texture_TextureTypeModifiedCB(attribute, container)
{
    container.updateTextureType = true;
    container.incrementModificationCount();
}

function Texture_WrapModifiedCB(attribute, container)
{
    container.incrementModificationCount();
}

function Texture_MipmappingEnabledModifiedCB(attribute, container)
{
    container.updateMipmappingEnabled = true;
    container.incrementModificationCount();
}
MediaTexture.prototype = new Texture();
MediaTexture.prototype.constructor = MediaTexture;

function MediaTexture()
{
    Texture.call(this);
    this.className = "MediaTexture";
    this.attrType = eAttrType.MediaTexture;
    
    this.updateImageFilename = false;
    this.updateAlphaFilename = false;
    this.updateNegateImage = false;
    this.updateNegateAlpha = false;
    this.imagePlayback = null;
    this.alphaPlayback = null;
    this.pixelMap = ePixelMap.Default;
    this.forceImageUpdate = false;
    
    this.imageFilename = new StringAttr("");
    this.alphaFilename = new StringAttr("");
    this.negateImage = new BooleanAttr(false);
    this.negateAlpha = new BooleanAttr(false);
    this.frame = new NumberAttr(-1);
    this.frameRetrieved = new NumberAttr(-1);
    
    this.imageFilename.addModifiedCB(MediaTexture_ImageFilenameModifiedCB, this);
    this.alphaFilename.addModifiedCB(MediaTexture_AlphaFilenameModifiedCB, this);
    this.negateImage.addModifiedCB(MediaTexture_NegateImageModifiedCB, this);
    this.negateAlpha.addModifiedCB(MediaTexture_NegateAlphaModifiedCB, this);
   
    this.registerAttribute(this.imageFilename, "imageFilename");
    this.registerAttribute(this.alphaFilename, "alphaFilename");
    this.registerAttribute(this.negateImage, "negateImage");
    this.registerAttribute(this.negateAlpha, "negateAlpha");
    this.registerAttribute(this.frame, "frame");
    this.registerAttribute(this.frameRetrieved, "frameRetrieved");
}

MediaTexture.prototype.setGraphMgr = function(graphMgr)
{
    // call base-class implementation
    Texture.prototype.setGraphMgr.call(this, graphMgr);
}

MediaTexture.prototype.update = function(params, visitChildren)
{
    if (this.updateImageFilename ||
        this.updateAlphaFilename)
    {
        this.updateImageFilename = false;
        this.updateAlphaFilename = false;

        this.frame.setValueDirect(-1);

        this.loadMedia();
    }

    if (this.updateTextureType)
    {
        this.updateTextureType = false;

        this.setImageSize();

        this.forceImageUpdate = true;
    }

    if (this.updateNegateImage)
    {
        this.updateNegateImage = false;

        this.forceImageUpdate = true;
    }

    if (this.updateNegateAlpha)
    {
        this.updateNegateAlpha = false;

        this.forceImageUpdate = true;
    }

    // update texture image if enabled
    if (this.enabled.getValueDirect())
    {
        this.updateMediaTextureImage();
    }

    // call base-class implementation
    Texture.prototype.update.call(this, params, visitChildren);
}

MediaTexture.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        Texture.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    // call base-class implementation
    Texture.prototype.apply.call(this, directive, params, visitChildren);
}

MediaTexture.prototype.loadMedia = function()
{
    var imageFilename = this.imageFilename.getValueDirect().join("");
    if (imageFilename &&
        imageFilename != "" &&
       !this.imagePlayback || (this.imagePlayback && this.imagePlayback.url != imageFilename))
    {
        this.imagePlayback = new MediaPlayback(this, MediaTexture_OnImageLoad);
        this.imagePlayback.container = this;
        this.imagePlayback.loadImage(imageFilename);
    }
    else if (imageFilename == "")
    {
        // TODO: remove texture
    }

    var alphaFilename = this.alphaFilename.getValueDirect().join("");
    if (alphaFilename &&
        alphaFilename != "" &&
       !this.alphaPlayback || (this.alphaPlayback && this.alphaPlayback.url != alphaFilename))
    {
        this.alphaPlayback = new MediaPlayback(this, MediaTexture_OnAlphaLoad);
        this.alphaPlayback.container = this;
        this.alphaPlayback.loadImage(alphaFilename);

        if (this.imagePlayback)
        {
            this.imagePlayback.setAlphaChannel(this.alphaPlayback);
        }
    }
    else if (alphaFilename == "")
    {
        // TODO: remove texture
    }
    
    // increment modification count
    this.incrementModificationCount();
}

MediaTexture.prototype.setImageSize = function()
{
    // only perform this action if texture type is not color and/or an alpha channel is present
    if (this.textureType.getValueDirect() == eTextureType.Color &&
       !this.alphaPlayback)
    {
        return;
    }

    if (!this.imagePlayback)
    {
        return;
    }

    // get image playback dimensions
    var dims = this.imagePlayback.getFrameDimensions();
    var width = nextHighestPowerOfTwo(dims.width);
    var height = nextHighestPowerOfTwo(dims.height);

    // based on texture type, determine pixel format
    var pixelFormat;
    switch (this.textureType.getValueDirect())
    {
        case eTextureType.Diffuse:
        case eTextureType.Luminosity:
        case eTextureType.Specularity:
        case eTextureType.Transparency:
        case eTextureType.Clip:
            pixelFormat = ePixelFormat.A8;
            this.pixelMap = ePixelMap.RGBToAlpha;
            break;

        case eTextureType.Color:
        default:
            pixelFormat = this.imagePlayback.getPixelFormat();
            this.pixelMap = ePixelMap.Default;
            break;
    }

    // if alpha playback, ensure pixel format has an alpha channel
    if (this.alphaPlayback)
    {
        switch (pixelFormat)
        {
            case ePixelFormat.R8G8B8:
                pixelFormat = ePixelFormat.R8G8B8A8;
                break;

            case ePixelFormat.B8G8R8:
                pixelFormat = ePixelFormat.B8G8R8A8;
                break;
        }
    }

    // get image playback byte alignment
    var byteAlignment = this.imagePlayback.getPixelByteAlignment();

    // calculate pitch
    this.pitch = width * BytesPerPixel(pixelFormat);
    this.pitch += (byteAlignment - this.pitch % byteAlignment) % byteAlignment;

    // set image attributes
    this.image.width.setValueDirect(width);
    this.image.height.setValueDirect(height);
    this.image.pixelFormat.setValueDirect(pixelFormat);
    this.image.byteAlignment.setValueDirect(byteAlignment);

    // allocate pixel buffer
    this.image.pixels.setLength(height * this.pitch);
}

MediaTexture.prototype.updateMediaTextureImage = function()
{
    // only perform this action if texture type is not color and an alpha channel is present
    if (this.textureType.getValueDirect() == eTextureType.Color &&
       !this.alphaPlayback)
    {
        return;
    }
    
    if (this.imagePlayback &&
        this.imagePlayback.ready &&
       (this.imagePlayback.newFrameDataAvailable() ||
       (this.alphaPlayback && this.alphaPlayback.newFrameDataAvailable()) ||
        this.forceImageUpdate))
    {
        var width = this.image.width.getValueDirect();
        var height = this.image.height.getValueDirect();
        var pixelFormat = this.image.pixelFormat.getValueDirect();

        // set filter mask
        var filterMask = FRAME_FILTER_SCALE_FRAME_BIT;
        if (this.negateImage.getValueDirect())
        {
            filterMask |= FRAME_FILTER_NEGATE_COLOR_BIT;
        }
        if (this.negateAlpha.getValueDirect())
        {
            filterMask |= FRAME_FILTER_NEGATE_ALPHA_BIT;
        }

        // get image data
        var frameRetrieved = this.imagePlayback.getFrameData(width, height, this.pitch, pixelFormat, this.image.pixels.values, filterMask, this.pixelMap, this.frame.getValueDirect());
        this.frameRetrieved.setValueDirect(frameRetrieved);

        this.forceImageUpdate = false;
    }
    
    // increment modification count
    this.incrementModificationCount();
}

MediaTexture.prototype.onImageLoad = function()
{
    // only perform this action if texture type is not color and/or an alpha channel is present
    if (this.textureType.getValueDirect() == eTextureType.Color &&
       !this.alphaPlayback)
    {
        this.textureObj.setImage(this.imagePlayback.htmlImageElement, ePixelFormat.R8G8B8, eImageFormat.RGB);
        this.imageSet = true;
        this.incrementModificationCount();
        return;
    }
    
    this.setImageSize();
}

MediaTexture.prototype.onAlphaLoad = function()
{
}

MediaTexture.prototype.onVideoLoad = function()
{   /*
    var image = this.htmlImageElement;
    var canvas = document.createElement("canvas");
    var canvasContext = canvas.getContext("2d");
    canvas.width = 200; //image.width;
    canvas.height = 200; //image.height;
    canvasContext.drawImage(image, 0, 0);
    var imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
    this.textureObj.setImageData(imageData);
    this.imageSet = true;
    this.video = true;
    //alert(imageData.data[0]);
    //alert(imageData.data[1]);
    //alert(imageData.data[2]);
    //alert(imageData.data[3]);
    */
    this.textureObj.setVideo(this.htmlImageElement);
    this.textureObj.negate = this.negateImage.getValueDirect();
    this.imageSet = true;
}

function MediaTexture_OnImageLoad()
{
    this.container.onImageLoad();
}

function MediaTexture_OnAlphaLoad()
{
    this.container.onAlphaLoad();
}

function MediaTexture_OnVideoLoad()
{
    alert("MediaTexture_OnVideoLoad");
    this.container.onVideoLoad();
}

function MediaTexture_ImageFilenameModifiedCB(attribute, container)
{
    container.updateImageFilename = true;
    container.incrementModificationCount();
}

function MediaTexture_AlphaFilenameModifiedCB(attribute, container)
{
    container.updateAlphaFilename = true;
    container.incrementModificationCount();
}

function MediaTexture_NegateImageModifiedCB(attribute, container)
{
    container.updateNegateImage = true;
    container.incrementModificationCount();
}

function MediaTexture_NegateAlphaModifiedCB(attribute, container)
{
    container.updateNegateAlpha = true;
    container.incrementModificationCount();
}
Evaluator.prototype = new SGNode();
Evaluator.prototype.constructor = Evaluator;

function Evaluator()
{
    SGNode.call(this);
    this.className = "Evaluator";
    this.attrType = eAttrType.Evaluator;
    
    this.expired = new BooleanAttr(false);
    
    this.registerAttribute(this.expired, "expired");
    this.registerAttribute(this.enabled, "evaluate");
}

Evaluator.prototype.evaluate = function()
{
}

Evaluator.prototype.update = function(params, visitChildren)
{
    // evaluate if evaluator is "enabled" and has not "expired"
    var enabled = this.enabled.getValueDirect();
    var expired = this.expired.getValueDirect();
    if (enabled && !expired)
    {
        this.evaluate();
    }
    
    // call base-class implementation
    SGNode.prototype.update.call(this, params, visitChildren);
}
SceneInspector.prototype = new Evaluator();
SceneInspector.prototype.constructor = SceneInspector;

function SceneInspector()
{
    Evaluator.call(this);
    this.className = "SceneInspector";
    this.attrType = eAttrType.SceneInspector;
    
    this.viewPosition = new Vector3DAttr(0, 0, 0);
    this.viewRotation = new Vector3DAttr(0, 0, 0);
    this.translationDelta = new Vector3DAttr(0, 0, 0);
    this.panDelta = new Vector3DAttr(0, 0, 0);
    this.trackDelta = new Vector3DAttr(0, 0, 0);
    this.rotationDelta = new Vector3DAttr(0, 0, 0);
    this.viewRelativeXAxisRotation = new BooleanAttr(false);
    this.viewRelativeYAxisRotation = new BooleanAttr(false);
    this.viewRelativeZAxisRotation = new BooleanAttr(false);
    this.pivotDistance = new NumberAttr(0);
    this.pivotPointWorld = new Vector3DAttr(0, 0, 0);
    this.resultPosition = new Vector3DAttr(0, 0, 0);
    this.resultRotation = new Vector3DAttr(0, 0, 0);
    
    this.registerAttribute(this.viewPosition, "viewPosition");
    this.registerAttribute(this.viewRotation, "viewRotation");
    this.registerAttribute(this.translationDelta, "translationDelta");
    this.registerAttribute(this.panDelta, "panDelta");
    this.registerAttribute(this.trackDelta, "trackDelta");
    this.registerAttribute(this.rotationDelta, "rotationDelta");
    this.registerAttribute(this.viewRelativeXAxisRotation, "viewRelativeXAxisRotation");
    this.registerAttribute(this.viewRelativeYAxisRotation, "viewRelativeYAxisRotation");
    this.registerAttribute(this.viewRelativeZAxisRotation, "viewRelativeZAxisRotation");
    this.registerAttribute(this.pivotDistance, "pivotDistance");
    this.registerAttribute(this.pivotPointWorld, "pivotPointWorld");
    this.registerAttribute(this.resultPosition, "resultPosition");
    this.registerAttribute(this.resultRotation, "resultRotation");
}

SceneInspector.prototype.evaluate = function()
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        return;
    }
    
    // get input values
    
    // view position
    var viewPosition = this.viewPosition.getValueDirect();
    
    // view rotation
    var viewRotation = this.viewRotation.getValueDirect();
    
    // translation delta
    var translationDelta = this.translationDelta.getValueDirect();
    
    // pan delta
    var panDelta = this.panDelta.getValueDirect();
    
    // track delta
    var trackDelta = this.trackDelta.getValueDirect();
    
    // rotation delta
    var rotationDelta = this.rotationDelta.getValueDirect();
    
    // view-relative rotation flags
    var viewRelativeXAxisRotation = this.viewRelativeXAxisRotation.getValueDirect();
    var viewRelativeYAxisRotation = this.viewRelativeYAxisRotation.getValueDirect();
    var viewRelativeZAxisRotation = this.viewRelativeZAxisRotation.getValueDirect();
    
    // pivot distance
    var pivotDistance = this.pivotDistance.getValueDirect();
    
    // formulate view transform
    var viewTrans = new Matrix4x4();
    viewTrans.loadTranslation(-viewPosition.x, -viewPosition.y, -viewPosition.z);
    var viewRot = new Matrix4x4();
    viewRot.loadXYZAxisRotation(-viewRotation.x, -viewRotation.y, -viewRotation.z);
    var viewTransform = viewTrans.multiply(viewRot);

    // calculate camera direction vectors
    var cameraUp = this.transformDirectionVector(0, 1, 0, viewTransform);
    var cameraRight = this.transformDirectionVector(1, 0, 0, viewTransform);
    var cameraForward = this.transformDirectionVector(0, 0, 1, viewTransform);
    
    // set rotation matrix
    var sceneRotX = new Matrix4x4();
    var sceneRotY = new Matrix4x4();
    var sceneRotZ = new Matrix4x4();
    // x
    if (viewRelativeXAxisRotation)
    {
        sceneRotX.loadRotation(cameraRight.x, cameraRight.y, cameraRight.z, -rotationDelta.x);
    }
    else
    {
        sceneRotX.loadXAxisRotation(-rotationDelta.x);
    }
    // y
    if (viewRelativeYAxisRotation)
    {
        sceneRotY.loadRotation(cameraUp.x, cameraUp.y, cameraUp.z, -rotationDelta.y);
    }
    else
    {
        sceneRotY.loadYAxisRotation(-rotationDelta.y);
    }
    // z
    if (viewRelativeZAxisRotation)
    {
        sceneRotZ.loadRotation(cameraForward.x, cameraForward.y, cameraForward.z, -rotationDelta.z);
    }
    else
    {
        sceneRotZ.loadXAxisRotation(-rotationDelta.z);
    }
    var sceneRot = sceneRotY.multiply(sceneRotX.multiply(sceneRotZ)); // this multiplication order eliminates roll when x- and y-axis rotations are combined
    
    // set translation matrix
    var sceneTrans = new Matrix4x4();
    sceneTrans.loadTranslation(translationDelta.x, -translationDelta.y, -translationDelta.z);
    
    // set pan/track
    if (panDelta.x != 0 || panDelta.y != 0 || panDelta.z != 0 ||
        trackDelta.x != 0 || trackDelta.y != 0 || trackDelta.z != 0)
    {
        // calculate direction vectors after scene rotation matrix is applied
        var cameraUpRot = this.transformDirectionVector(cameraUp.x, cameraUp.y, cameraUp.z, sceneRot);
        var cameraRightRot = this.transformDirectionVector(cameraRight.x, cameraRight.y, cameraRight.z, sceneRot);    
        var cameraForwardRot = this.transformDirectionVector(cameraForward.x, cameraForward.y, cameraForward.z, sceneRot);    
            
        var scenePan = new Matrix4x4();
        scenePan.loadTranslation(
            cameraRightRot.x * panDelta.x + cameraUpRot.x * -panDelta.y + cameraForwardRot.x * -panDelta.z, 
            cameraRightRot.y * panDelta.x + cameraUpRot.y * -panDelta.y + cameraForwardRot.y * -panDelta.z, 
            cameraRightRot.z * panDelta.x + cameraUpRot.z * -panDelta.y + cameraForwardRot.z * -panDelta.z);
            
        sceneTrans = sceneTrans.multiply(scenePan);
        
        // formulate "track" or "dolly" vectors:
        // track forward = cameraForwardRot (calculated above) rotated about cameraRightRot 
        // (calculated above) viewRotation.x (camera pitch) degrees;
        // track up = track forward rotated about the camera right vector 90 degrees;
        // track right = cameraRightRot (calculated above)
        var sceneTrack = new Matrix4x4();
        var cameraVectorRot = new Matrix4x4();
        
        var flipIt = false;
        var abs_heading = Math.abs(viewRotation.y);
        var abs_pitch = Math.abs(viewRotation.x);
        var abs_bank = Math.abs(viewRotation.z);
        if (viewRotation.z >= 90 && viewRotation.z <= 270)
        {
            flipIt = true;
        }
        else if (viewRotation.z <= -90 && viewRotation.z >= -270)
        {
            flipIt = true
        }
        else
        {
            if (viewRotation.x <= -45 || (viewRotation.x >= 45 && viewRotation.x <= 90))
            {
                flipIt = true;
            }
        }
        
        var lastCameraForwardRot = cameraForwardRot;

        cameraVectorRot.loadRotation(cameraRightRot.x, cameraRightRot.y, cameraRightRot.z, viewRotation.x);
        cameraForwardRot = this.transformDirectionVector(cameraForwardRot.x, cameraForwardRot.y, cameraForwardRot.z, cameraVectorRot);

        var angle = toDegrees(Math.acos(cosineAngleBetween(lastCameraForwardRot, cameraForwardRot)));

        cameraVectorRot.loadRotation(cameraRightRot.x, cameraRightRot.y, cameraRightRot.z, 90);
        cameraUpRot = this.transformDirectionVector(cameraUpRot.x, cameraUpRot.y, cameraUpRot.z, cameraVectorRot);
        sceneTrack.loadTranslation(
            cameraRightRot.x * trackDelta.x + cameraUpRot.x * -trackDelta.y + cameraForwardRot.x * -trackDelta.z, 
            cameraRightRot.y * trackDelta.x + cameraUpRot.y * -trackDelta.y + 0, /*cameraForwardRot.y * -trackDelta.z,*/ // don't set y-component when z-tracking
            cameraRightRot.z * trackDelta.x + cameraUpRot.z * -trackDelta.y + cameraForwardRot.z * -trackDelta.z);

        sceneTrans = sceneTrans.multiply(sceneTrack);
    }
    
    // set pivot distance transforms

    // get camera position in world coordinates
    var viewTransformWorld = new Matrix4x4();
    viewTransformWorld.loadMatrix(viewTransform);
    viewTransformWorld.invert();
    var cameraPos = new Vector3D();
    cameraPos.load(viewTransformWorld._41, viewTransformWorld._42, viewTransformWorld._43);

    var pivotTrans = new Vector3D();
    pivotTrans.load(
        cameraPos.x + cameraForward.x * pivotDistance,
        cameraPos.y + cameraForward.y * pivotDistance,
        cameraPos.z + cameraForward.z * pivotDistance);                
	this.pivotPointWorld.setValueDirect(pivotTrans.x, pivotTrans.y, pivotTrans.z);

    var scenePivot = new Matrix4x4();
    var scenePivotInv = new Matrix4x4();
    scenePivot.loadTranslation(-pivotTrans.x, -pivotTrans.y, -pivotTrans.z);
    scenePivotInv.loadTranslation(pivotTrans.x, pivotTrans.y, pivotTrans.z);
    
    // set overall transform
    var resultTransform = sceneTrans.multiply(scenePivot.multiply(sceneRot.multiply(scenePivotInv.multiply(viewTransform))));

    var resultRotation = resultTransform.getRotationAngles();

    var resultPosition = new Vector3D();
    resultPosition.load(resultTransform._41, resultTransform._42, resultTransform._43);
    resultTransform.transpose(); // invert rotation
    resultPosition = resultTransform.transform(resultPosition.x, resultPosition.y, resultPosition.z, 0);

    // output results
    this.resultPosition.setValueDirect(-resultPosition.x, -resultPosition.y, -resultPosition.z);
    this.resultRotation.setValueDirect(-resultRotation.x, -resultRotation.y, -resultRotation.z);
}

SceneInspector.prototype.transformDirectionVector = function(x, y, z, matrix)
{
    var m = new Matrix4x4();
    m.loadMatrix(matrix);
    m.transpose(); // invert rotation
    
    return m.transform(x, y, z, 0);
}

/*
SceneInspector.prototype.zoomIn = function()
{
   var x = bridgeworks.registry.find("SceneInspector");
   x.panDelta.z+=30;
    x.panDelta.setValueDirect(this.panDelta.x, this.panDelta.y, this.panDelta.z, this.viewTransform);
    x.updateScene();
}

SceneInspector.prototype.zoomOut = function()
{
    this.panDelta.z-=30;
    this.panDelta.setValueDirect(this.panDelta.x, this.panDelta.y, this.panDelta.z,this.viewTransform);
    this.updateScene();
}
*/


ArcballInspector.prototype = new Evaluator();
ArcballInspector.prototype.constructor = ArcballInspector;

function ArcballInspector()
{
    Evaluator.call(this);
    this.className = "ArcballInspector";
    this.attrType = eAttrType.ArcballInspector;

    this.sphereCenter = new Vector3DAttr(0, 0, 0);
    this.sphereRadius = new NumberAttr(0);
    this.mouseDown = new Vector2DAttr(0, 0);
    this.mouseNow = new Vector2DAttr(0, 0);
    this.quatAtMouseDown = new QuaternionAttr(1, 0, 0, 0);
    this.viewport = new ViewportAttr(0, 0, 0, 0);
    this.worldTransform = new Matrix4x4Attr();
    this.viewTransform = new Matrix4x4Attr();
    this.constrainToAxis = new BooleanAttr(false);
    this.constraintAxis = new Vector3DAttr(0, 0, 0);
    this.resultQuat = new QuaternionAttr(1, 0, 0, 0);

    this.registerAttribute(this.sphereCenter, "sphereCenter");
    this.registerAttribute(this.sphereRadius, "sphereRadius");
    this.registerAttribute(this.mouseDown, "mouseDown");
    this.registerAttribute(this.mouseNow, "mouseNow");
    this.registerAttribute(this.quatAtMouseDown, "quatAtMouseDown");
    this.registerAttribute(this.viewport, "viewport");
    this.registerAttribute(this.worldTransform, "worldTransform");
    this.registerAttribute(this.viewTransform, "viewTransform");
    this.registerAttribute(this.constrainToAxis, "constrainToAxis");
    this.registerAttribute(this.constraintAxis, "constraintAxis");
    this.registerAttribute(this.resultQuat, "resultQuat");
}

ArcballInspector.prototype.evaluate = function()
{
    if (!(this.enabled.getValueDirect()))
    {
        return;
    }

    // get input values

    // sphere center
    var center = this.sphereCenter.getValueDirect();

    // sphere radius
    var radius = this.sphereRadius.getValueDirect();

    // mouse coords
    var mouseDown = this.mouseDown.getValueDirect();
    var mouseNow = this.mouseNow.getValueDirect();

    // mouse down quat
    var quatDown = this.quatAtMouseDown.getValueDirect();

    // viewport
    var vp = this.viewport;
 
    // world transform
    var world = this.worldTransform.getValueDirect();

    // view transform
    var view = this.viewTransform.getValueDirect();

    // invert world transform (to account for existing transformations) and combine with view transform
    world.invert();
    view = view.multiply(world);

    // constrain to axis
    var constrain = this.constrainToAxis.getValueDirect();

    // normalize screen coordinates to [-1, 1] (invert y -- screen y coords are reversed)
    center.x    = 2 * (center.x - vp.x) / vp.width -1;
    center.y    = 2 * (vp.height - center.y - vp.y) / vp.height - 1;
    mouseDown.x = 2 * (mouseDown.x - vp.x) / vp.width  - 1;
    mouseDown.y = 2 * (vp.height - mouseDown.y - vp.y) / vp.height - 1;
    mouseNow.x  = 2 * (mouseNow.x  - vp.x) / vp.width  - 1;
    mouseNow.y  = 2 * (vp.height - mouseNow.y  - vp.y) / vp.height - 1;
    
    // get points on sphere corresponding to mouse down and mouse now
    var ptDown, ptNow;
    if (!constrain)
    {
        ptDown = this.getSpherePoint(mouseDown, center, radius);
        ptNow = this.getSpherePoint(mouseNow, center, radius);
    }
    else // constrain
    {
        // constraint axis
        var axis = this.constraintAxis.getValueDirect();

        ptDown = this.getSpherePointAboutAxis(mouseDown, center, radius, axis);
        ptNow = this.getSpherePointAboutAxis(mouseNow, center, radius, axis);
    }

    // transform by view matrix
    var ptDownX = view.transform(ptDown.x, ptDown.y, ptDown.z, 0);
    var ptNowX = view.transform(ptNow.x, ptNow.y, ptNow.z, 0);
    ptDown.x = ptDownX.x;
    ptDown.y = ptDownX.y;
    ptDown.z = ptDownX.z;
    ptNow.x = ptNowX.x;
    ptNow.y = ptNowX.y;
    ptNow.z = ptNowX.z;
    ptDown.normalize();
    ptNow.normalize();

    // construct unit quaternion from the two points on sphere
    var quatDrag = this.getQuatFromSpherePoints(ptDown, ptNow);

    // multiply drag quaternion with down quaternion
    quatDrag = quatDrag.multiply(quatDown);
    
    this.resultQuat.setValueDirect(quatDrag);
}

ArcballInspector.prototype.getSpherePoint = function(mouse, center, radius)
{
    var point = new Vector3D();
    
    point.x = (mouse.x - center.x) / radius;
    point.y = (mouse.y - center.y) / radius;

    var mag = point.x * point.x + point.y * point.y;
    if (mag > 1.0)
    {
        var scale = 1 / Math.sqrt(mag);
        point.x *= scale;
        point.y *= scale;
        point.z = 0;
    }
    else // mag <= 1.0f
    {
        point.z = -(Math.sqrt(1 - mag));
    }
    return point;
}

ArcballInspector.prototype.getSpherePointAboutAxis = function(mouse, center, radius, axis)
{
    point = this.getSpherePoint(mouse, center, radius);

    var dot = dotProduct(point, axis);
    
    axis.multiplyScalar(dot);
    
    var proj = new Vector3D(point.x, point.y, point.z);
    
    proj.subtractVector(axis);
    
    var norm = magnitude(proj.x, proj.y, proj.z);
    
    point = null;
    
    if (norm > 0)
    {
        var s = 1 / Math.sqrt(norm);
        if (proj.z < 0)
        {
            proj.x = -proj.x;
            proj.y = -proj.y;
            proj.z = -proj.z;
        }

        point = proj.multiplyScalar(s);
    }
    else if (axis.z == 1.0)
    {
        point = new Vector3D(1, 0, 0);
    }
    else
    {
        point.normalize();
    }
}

ArcballInspector.prototype.getQuatFromSpherePoints = function(pt1, pt2)
{
    var quat = new Quaternion();
    quat.x = pt1.y * pt2.z - pt1.z * pt2.y;
    quat.y = pt1.z * pt2.x - pt1.x * pt2.z;
    quat.z = pt1.x * pt2.y - pt1.y * pt2.x;
    quat.w = pt1.x * pt2.x + pt1.y * pt2.y + pt1.z * pt2.z;
    return quat;
}

// doesn't do anything
function ArcballInspector_ViewTransformModifiedCB(attribute, container)
{
    /*
    if (attr)
    {
        CMatrix4x4FloatAttr* viewTransform = dynamic_cast<CMatrix4x4FloatAttr*>(attr);
        if (viewTransform)
        {
            CMatrix4x4f m;
            viewTransform.getValueDirect(m);
        }
    }
    */
}


KeyframeInterpolator.prototype = new Evaluator();
KeyframeInterpolator.prototype.constructor = KeyframeInterpolator;

function EndState()
 {
    this.initialized = false;
    this.startKeyIts = []; // one for each channel
    this.endKeyIts = [];  // one for each channel
    this.startTime = -FLT_MAX;    // across all channels
    this.endTime = FLT_MAX;     // across all channels
 }
    
function KeyframeInterpolator()
{
    Evaluator.call(this);
    this.className = "KeyframeInterpolator";
    this.attrType = eAttrType.KeyframeInterpolator;

    this.lastTime = 0;
    this.evaluated = false;
    this.endState =  new EndState();
    
    this.time = new NumberAttr(0);
    this.channels = new AttributeVector();
    this.startKeys = new AttributeVector();
    this.endKeys = new AttributeVector();
    this.preBehaviors = new AttributeVector();
    this.postBehaviors = new AttributeVector();
    this.resultValues = new AttributeVector();

    this.time.addModifiedCB(KeyframeInterpolator_TimeModifiedCB, this);
    
    this.registerAttribute(this.time, "time");
    this.registerAttribute(this.channels, "channels");
    this.registerAttribute(this.startKeys, "startKeys");
    this.registerAttribute(this.endKeys, "endKeys");
    this.registerAttribute(this.preBehaviors, "preBehaviors");
    this.registerAttribute(this.postBehaviors, "postBehaviors");
    this.registerAttribute(this.resultValues, "resultValues");
}

KeyframeInterpolator.prototype.setNumChannels = function(numChannels)
{
    // clear
    this.channels.resize(0);
    this.startKeys.resize(0);
    this.endKeys.resize(0);
    this.preBehaviors.resize(0);
    this.postBehaviors.resize(0);
    this.resultValues.resize(0);
    
    for (var i=0; i < numChannels; i++)
    {
        this.channels.push_back(new KeyframesAttr());
        this.startKeys.push_back(new NumberAttr(-1));
        this.endKeys.push_back(new NumberAttr(-1));
        this.preBehaviors.push_back(new NumberAttr(eEndBehavior.Reset));
        this.postBehaviors.push_back(new NumberAttr(eEndBehavior.Reset));
        this.resultValues.push_back(new NumberAttr(0));
    }
}

KeyframeInterpolator.prototype.evaluate = function()
{
    // initialize end state if not already initialized
    if (!this.endState.initialized)
    {
        // initialize
        this.updateEndState();
        this.endState.initialized = true;
    }
    
    // get input values

    // time
    var time = this.time.getValueDirect();

    var first, last;
    var pre, post;

    // for each channel...
    for (var i = 0; i < this.channels.vector.length; i++)
    {
        var keyframes = this.channels.getAt(i);
        if (keyframes.vector.length == 0) continue;

        first = this.endState.startKeyIts[i];
        last = this.endState.endKeyIts[i];

        pre = this.preBehaviors.getAt(i).getValueDirect();
        post = this.postBehaviors.getAt(i).getValueDirect();

        // interpolate
        var value = interpolate(time, keyframes, first, last, pre, post);

        // output result
        this.resultValues.getAt(i).setValueDirect(value);
    }

    this.lastTime = time;
    this.evaluated = true;
}

KeyframeInterpolator.prototype.timeModified = function()
{
    this.updateExpired();
}

KeyframeInterpolator.prototype.updateExpired = function()
{
    // determine if kfi has "expired"
    this.expired.setValueDirect(false);

    // NOTE: this code moved from RenderAgent

    // an multi-channel Evaluator (i.e., KeyframeInterpolator) is considered
    // animating if any 1 of its channels meet the requirements for determining
    // whether or not Evaluate is called.  For KeyframeInterpolators, "at least
    // one channel is animating" if any one of the channels' keys has a time 
    // value greater than the current time.
    var bAtLeastOneChannelAnimating = false;

    // for each channel in the interpolator, compare current time
    // with both end behavior and stop time to determine whether or 
    // not this kfi should continue to be evaluated
    var fEvalTime = this.time.getValueDirect();
    var iPost = 0;
    var postBehavior = null;
    var numChannels = this.channels.vector.length;
    for (var i=0; i < numChannels; i++)
    {
        postBehavior = this.postBehaviors.getAt(i);
        if (postBehavior)
        {
            iPost = postBehavior.getValueDirect();
        }

        // if *expression* is TRUE then the end behavior is 
        // repeat, oscillate, or some other continuous behavior
        if (iPost != eEndBehavior.Constant)
        {
            bAtLeastOneChannelAnimating = true;
            break;
        }
    }

    // if the eval's current time either:
    // 1. has advanced passed its longest keyframe OR
    // 2. is not yet at its start time
    // then stop evaluating it.
    // NOTE: only check Constant end behaviors b/c Repeats and
    // Oscillators should keep running.  By definition, scenes w/
    // non-constant end behaviors will never AA
    if (!bAtLeastOneChannelAnimating &&
        (fEvalTime < this.endState.startTime || fEvalTime > this.endState.endTime))
    {
        // set expired flag
        this.expired.setValueDirect(true);
    }
}

KeyframeInterpolator.prototype.updateEndState = function()
{
    var fStartTime = -1;
    var fEndTime = -1;
    var fShortest = FLT_MAX;
    var fLongest = -FLT_MAX;
    var startKey = -1, endKey = -1;
    var keyframes = null;
    var numChannels = this.channels.vector.length;
    
    this.startKeys.resize(numChannels);
    this.endKeys.resize(numChannels);
    
    for (var i=0; i < numChannels; i++)
    {
        keyframes = this.channels.getAt(i);
        
        startKey = this.startKeys.vector.length > i ? this.startKeys.getAt(i).getValueDirect() : -1;
        endKey = this.endKeys.vector.length > i ? this.endKeys.getAt(i).getValueDirect() : -1;
        
        if (endKey < startKey)
        {
            endKey = startKey;
        }
        
        // set first/last keys to evaluate
        this.endState.startKeyIts[i] = keyframes.getAt(0);
        this.endState.endKeyIts[i] = keyframes.getAt(keyframes.vector.length - 1);

        if (startKey >= 0 && startKey < keyframes.vector.length)
        {
            this.endState.startKeyIts[i] = keyframes.getAt(startKey);
        }

        if (endKey >= 0 && endKey < keyframes.vector.length)
        {
            this.endState.endKeyIts[i] = keyframes.getAt(endKey);
        }

	fStartTime = this.endState.startKeyIts[i].getTime();
        fEndTime = this.endState.endKeyIts[i].getTime();

	// save the smallest start time for all channels
	fShortest = fStartTime < fShortest ? fStartTime : fShortest;

	// save the longest end time for all channels
	fLongest = fEndTime >= fLongest ? fEndTime : fLongest;
    }
    
    this.endState.startTime = fShortest;
    this.endState.endTime = fLongest;
}

function KeyframeInterpolator_TimeModifiedCB(attribute, container)
{
    container.timeModified();
}

function KeyframeInterpolator_EndStateModifiedCB(attribute, container)
{
    container.updateEndState();
}
BBoxLocator.prototype = new Evaluator();
BBoxLocator.prototype.constructor = BBoxLocator;

function BBoxLocator()
{
    Evaluator.call(this);
    this.className = "BBoxLocator";
    this.attrType = eAttrType.BBoxLocator;

    this.viewPosition = new Vector3DAttr(0, 0, 0);
    this.viewTransform = new Matrix4x4Attr(1, 0, 0, 0,
                                           0, 1, 0, 0,
                                           0, 0, 1, 0,
                                           0, 0, 0, 1);
    this.viewVolume = new ViewVolumeAttr();
    this.viewport = new ViewportAttr(0, 0, 0, 0);
    this.nearDistance = new NumberAttr(0);
    this.bbox = new BBoxAttr();
    this.bboxView = new BBoxAttr();
    this.closeness = new NumberAttr(0.5);
    this.resultPosition = new Vector3DAttr(0, 0, 0);
    this.resultWidth = new NumberAttr(0);
    this.resultFarDistance = new NumberAttr(0);
    this.resultPivotDistance = new NumberAttr(0);
    
    this.registerAttribute(this.viewPosition, "viewPosition");
    this.registerAttribute(this.viewTransform, "viewTransform");
    this.registerAttribute(this.viewVolume, "viewVolume");
    this.registerAttribute(this.viewport, "viewport");
    this.registerAttribute(this.nearDistance, "nearDistance");
    this.registerAttribute(this.bbox, "bbox");
    this.registerAttribute(this.bboxView, "bboxView");
    this.registerAttribute(this.closeness, "closeness");
    this.registerAttribute(this.resultPosition, "resultPosition");
    this.registerAttribute(this.resultWidth, "resultWidth");
    this.registerAttribute(this.resultFarDistance, "resultFarDistance");
    this.registerAttribute(this.resultPivotDistance, "resultPivotDistance");
}

BBoxLocator.prototype.evaluate = function()
{
    // get input values

    // position
    var viewPosition = this.viewPosition.getValueDirect();

    // view transform
    var viewTransform = this.viewTransform.getValueDirect();

    // view volume planes
    var left = this.viewVolume.left.getValueDirect();
    var right = this.viewVolume.right.getValueDirect();
    var top = this.viewVolume.top.getValueDirect();
    var bottom = this.viewVolume.bottom.getValueDirect();
    var near = this.viewVolume.near.getValueDirect();
    var far = this.viewVolume.far.getValueDirect();

    // viewport
    var viewport = this.viewport.getValueDirect();

    // bbox min/max points
    var min = this.bbox.min.getValueDirect();
    var max = this.bbox.max.getValueDirect();

    // closeness
    var closeness = this.closeness.getValueDirect();
    if (closeness != 0)
    {
        var bbw = max.x - min.x;
        var bbh = max.y - min.y;

        bbw += bbw * closeness;
        bbh += bbh * closeness;

        if (viewport.width / viewport.height < bbw / bbh)
        {
            bbw = (bbw - (max.x - min.x)) / 2;
            min.x -= bbw;
            max.x += bbw;
        }
        else // (viewport.width / viewport.height >= bbw / bbh)
        {
            bbh = (bbh - (max.y - min.y)) / 2;
            min.y -= bbh;
            max.y += bbh;
        }
    }

    // formulate bbox endpoints
    var p = new Array(8);
    p[0] = new Vector3D(min.x, min.y, min.z);
    p[1] = new Vector3D(min.x, min.y, max.z);
    p[2] = new Vector3D(min.x, max.y, min.z);
    p[3] = new Vector3D(min.x, max.y, max.z);
    p[4] = new Vector3D(max.x, min.y, min.z);
    p[5] = new Vector3D(max.x, min.y, max.z);
    p[6] = new Vector3D(max.x, max.y, min.z);
    p[7] = new Vector3D(max.x, max.y, max.z);

    // get center of world-space bbox
    var center = new Vector3D((min.x + max.x) / 2,
                              (min.y + max.y) / 2,
                              (min.z + max.z) / 2);

    // get camera forward vector
    var fwd = new Vector3D();
    fwd.copy(viewTransform.transform(0, 0, 1, 0));
    fwd.normalize();

    var distance = 0;
    var resultPosition;
    var perspectiveViewVolume = planesIntersect(left, right);

    // if perspective camera...
    if (perspectiveViewVolume)
    {
        // formulate camera-oriented view-volume planes centered at bbox center
        var vvPlanes = new Array(5); // don't consider far plane

        vvPlanes[0] = this.getPlane(left.point, center, left.normal, viewTransform);
        vvPlanes[1] = this.getPlane(right.point, center, right.normal, viewTransform);
        vvPlanes[2] = this.getPlane(top.point, center, top.normal, viewTransform);
        vvPlanes[3] = this.getPlane(bottom.point, center, bottom.normal, viewTransform);
        vvPlanes[4] = this.getPlane(near.point, center, near.normal, viewTransform);

        // for each bbox point, determine the maximum distance necessary to move all points to within the
        // view-volume along the camera forward vector		
        for (var i = 0; i < 8; i++)
        {
            for (var j = 0; j < 5; j++)
            {
                if (pointOnPositiveSideOfPlane(p[i], vvPlanes[j]))
                {
                    var d = this.distanceFromPlane(p[i], fwd, vvPlanes[j]);
                    if (d.intersection)
                    {
                        distance = Math.max(distance, d.distance);
                    }
                }
            }
        }

        resultPosition = new Vector3D(center.x, center.y, center.z);
        fwd.multiplyScalar(distance);
        resultPosition.subtractVector(fwd);
    }
    else // orthographic camera
    {
        resultPosition = new Vector3D(center.x, center.y, center.z);
        distance = magnitude(viewPosition.x, viewPosition.y, viewPosition.z);
        fwd.multiplyScalar(distance);
        resultPosition.subtractVector(fwd);

        // set width

        // get bboxView min/max points
        var vmin = this.bboxView.min.getValueDirect();
        var vmax = this.bboxView.max.getValueDirect();

        var width = distanceBetweenPlanes(right, left);
        var height = distanceBetweenPlanes(top, bottom);
        var aspect = width / height;

        var xDim = Math.abs(vmax.x - vmin.x);
        var yDim = Math.abs(vmax.y - vmin.y);

        // this could probably be simplified, but it works
        if (xDim > yDim)
        {
            width = xDim;

            height = width / aspect;
            if (height < yDim)
            {
                height = yDim;
                width = height * aspect;
            }
        }
        else
        {
            height = yDim;
            width = height * aspect;

            if (width < xDim)
            {
                width = xDim;
            }
        }

        // output result
        this.resultWidth.setValueDirect(width);
    }

    // output result(s)
    this.resultPosition.setValueDirect(resultPosition.x, resultPosition.y, resultPosition.z);

    // determine distance of all points from near clipping plane
    distance = 0;
    for (var i = 0; i < 8; i++)
    {
        var px = viewTransform.transform(p[i].x, p[i].y, p[i].z, 1);
        distance = Math.max(distance, distanceBetween(p[i], resultPosition));
    }

    this.resultFarDistance.setValueDirect(this.nearDistance.getValueDirect() + distance);

    // determine pivot distance (distance between camera and center of bbox in world-space)
    distance = distanceBetween(resultPosition, new Vector3D(center.x, center.y, center.z));
    this.resultPivotDistance.setValueDirect(distance);
}

BBoxLocator.prototype.getPlane = function(point, offset, normal, transform)
{
    var xpoint = transform.transformVector3D(point, 0);
    xpoint.x += offset.x;
    xpoint.y += offset.y;
    xpoint.z += offset.z;

    var xnormal = transform.transformVector3D(normal, 0);

    var plane = new Plane(new Vector3D(xpoint.x, xpoint.y, xpoint.z), new Vector3D(xnormal.x, xnormal.y, xnormal.z));

    return plane;
}

BBoxLocator.prototype.distanceFromPlane = function(point, dir, plane)
{
    var line = new Line(point, dir);
    var distance;

    var intersection = lineIntersectsPlane(line, plane);
    switch (intersection.result)
    {
    case 0: // no intersection
        distance = FLT_MAX;
        break;

    case 1: // intersection at 1 point
        distance = distanceBetween(point, intersection.point);
        break;

    case 2: // intersection at infinite points (line on plane) 
    default:
        distance = 0;
        break;
    }

    return { intersection: intersection.result, distance: distance };
}
function worldUnitsPerPixelPersp(viewport, zoom, viewSpace_Z)
{
    // get vertical field of view in radians
    var fovY = 2 * Math.atan2(1, zoom);

    // get horizontal field of view in radians
    var fovX = 2 * Math.atan(viewport.width / viewport.height * Math.tan(fovY / 2));

    // determine the width of the visible portion of the x axis on the 
    // clipping plane at viewSpace_Z
    var clipPlaneWidth  = Math.tan(fovX / 2) * viewSpace_Z * 2;

    // determine the height of the visible portion of the y axis on the
    // clipping plane at viewSpace_Z
    var clipPlaneHeight  = Math.tan(fovY / 2) * viewSpace_Z * 2;

    // determine the per-pixel clipPlaneWidth and clipPlaneHeight
    var x = clipPlaneWidth  / viewport.width;
    var y = clipPlaneHeight / viewport.height;
    
    return { x: x, y: y };
}

function worldUnitsPerPixelOrtho(viewport, width)
{
    // calculate height
    var height = width * (viewport.height / viewport.width);

    // determine the per-pixel width and height
    var x = width  / viewport.width;
    var y = height / viewport.height;
    
    return { x: x, y: y };
}

function toScreenSpace(world, view, proj, viewport)
{
    // transform to view space
    var screen = view.transformw(world.x, world.y, world.z, 1);

    // transform to projection space
	screen = proj.transformw(screen.x, screen.y, screen.z, screen.w);

    if (screen.w == 0)
    {
        return { x: -Infinity, y: -Infinity, z: -Infinity };
    }

    // normalize to [-1, 1]
    // (if x or y is outside the range (-w, w), the screen coordinate(s) will be 
    // outside the viewport
    screen.x /= screen.w;
    screen.y /= screen.w;
    //screen.z /= screen.w;

    // clip to viewport
    screen.x = viewport.x + viewport.width  - ((-screen.x + 1) * viewport.width  / 2);
    screen.y = viewport.y + viewport.height - (( screen.y + 1) * viewport.height / 2);
	screen.z = 0;
	
	return { x: screen.x, y: screen.y, z: screen.z };    
} 
RasterComponent.prototype = new ParentableMotionElement();
RasterComponent.prototype.constructor = RasterComponent;

function RasterComponent()
{
    ParentableMotionElement.call(this);
    this.className = "RasterComponent";
    this.attrType = eAttrType.RasterComponent;
    
    this.rcEventListener = null;
    
    this.opacity = new NumberAttr(1);				// opaque
	this.anchor = new Vector2DAttr(0, 0);			// 0, 0
	this.origin = new StringAttr("bottomLeft");		// bottom-left
	this.show = new BooleanAttr(true);				// true
	this.selectable = new BooleanAttr(true);		// true
	this.cullable = new BooleanAttr(true);			// true
	this.clampToViewport = new BooleanAttr(false);	// false
	this.rasterPosition = new Vector3DAttr();
	this.inspectionOffset = new Vector3DAttr();
	this.componentRect = new RectAttr();
	this.screenRect = new RectAttr();

	this.stylesMap.size.addModifiedCB(RasterComponent_StylesMapSizeModifiedCB, this);
	this.show.addModifiedCB(RasterComponent_ShowModifiedCB, this);
	
	this.registerAttribute(this.opacity, "opacity");
	this.registerAttribute(this.anchor, "anchor");
	this.registerAttribute(this.origin, "origin");
	this.registerAttribute(this.show, "show");
	this.registerAttribute(this.selectable, "selectable");
	this.registerAttribute(this.cullable, "cullable");
	this.registerAttribute(this.rasterPosition, "rasterPosition");
	this.registerAttribute(this.inspectionOffset, "inspectionOffset");
	this.registerAttribute(this.clampToViewport, "clampToViewport");
	this.registerAttribute(this.componentRect, "componentRect");
	this.registerAttribute(this.screenRect, "screenRect");

	this.renderSequenceSlot.setValueDirect(0xffff);
}

RasterComponent.prototype.setRegistry = function(registry)
{
    var bworks = registry.find("Bridgeworks");
    if (bworks)
    {
        this.rcEventListener = bworks.rasterComponentEventListener;
        if (this.rcEventListener)
        {
            this.rcEventListener.registerComponent(this); // TODO: unable to unregister without dtor
            this.rcEventListener.Listen(this);
        }
    }

    ParentableMotionElement.prototype.setRegistry.call(this, registry);
}

RasterComponent.prototype.isSelected = function(x, y)
{
    var show = this.show.getValueDirect();
    if (show)
    {
        if (this.screenRect.containsPoint(x, y))
        {
            return true;
        }
    }

    return false;
}

RasterComponent.prototype.stylesMapSizeModified = function()
{
    var size = this.stylesMap.Size();
    for (var i = 0; i < size; i++)
    {
        var styleMap = this.stylesMap.getAt(i);
        if (styleMap)
        {
            // add modified CBs for styles map elements' events (remove first to eliminate duplicates)
            styleMap.event.removeModifiedCB(RasterComponent_StylesMapElementEventModifiedCB, this);
            styleMap.event.addModifiedCB(RasterComponent_StylesMapElementEventModifiedCB, this);
            // invoke CB now for stylesMap that are set by reference
            RasterComponent_StylesMapElementEventModifiedCB(styleMap.event, this);
        }
    }
}

RasterComponent.prototype.stylesMapElementEventModified = function(eventName)
{
    this.rcEventListener.listenEvent(this, eEventNameMap[eventName]);
}

RasterComponent.prototype.showModified = function()
{
}

function RasterComponent_StylesMapSizeModifiedCB(attribute, container)
{
    container.stylesMapSizeModified();
}

function RasterComponent_StylesMapElementEventModifiedCB(attribute, container)
{
    container.stylesMapElementEventModified(attribute.getValueDirect().join(""));    
}

function RasterComponent_ShowModifiedCB(attribute, container)
{
    container.showModified();
}
Label.prototype = new RasterComponent();
Label.prototype.constructor = Label;

function Label()
{
    RasterComponent.call(this);
    this.className = "Label";
    this.attrType = eAttrType.Label;

    this.iconRect = new Rect(0, 0, 0, 0);
    this.labelRect = new Rect(0, 0, 0, 0);
    
    this.text = new StringAttr("");
    this.description = new StringAttr("");
    this.depthShadingEnabled = new BooleanAttr(true);
    this.labelStyle = new LabelStyleAttr();
    this.iconStyle = new IconStyleAttr();
    this.balloonTipLabelStyle = new BalloonTipLabelStyleAttr();
    
    this.text.addModifiedCB(Label_TextModifiedCB, this);
    this.description.addModifiedCB(Label_DescriptionModifiedCB, this);
    this.labelStyle.backgroundColor.addModifiedCB(Label_LabelStyleBackgroundColorModifiedCB, this);
    this.labelStyle.backgroundOpacity.addModifiedCB(Label_LabelStyleBackgroundOpacityModifiedCB, this);
    this.labelStyle.fontStyle.borderColor.addModifiedCB(Label_LabelStyleFontBorderModifiedCB, this);
    this.labelStyle.fontStyle.borderWidth.addModifiedCB(Label_LabelStyleFontBorderModifiedCB, this);    
    this.labelStyle.fontStyle.color.addModifiedCB(Label_LabelStyleFontStyleColorModifiedCB, this);
    this.labelStyle.fontStyle.font.addModifiedCB(Label_LabelStyleFontStyleFontModifiedCB, this);
    this.labelStyle.fontStyle.opacity.addModifiedCB(Label_LabelStyleFontStyleOpacityModifiedCB, this);
    this.labelStyle.fontStyle.size.addModifiedCB(Label_LabelStyleFontStyleSizeModifiedCB, this);
    this.labelStyle.fontStyle.style.addModifiedCB(Label_LabelStyleFontStyleStyleModifiedCB, this);
    this.labelStyle.format.addModifiedCB(Label_LabelStyleFormatModifiedCB, this);
    this.labelStyle.padding.addModifiedCB(Label_LabelStylePaddingModifiedCB, this);
    this.iconStyle.url.addModifiedCB(Label_IconStyleUrlModifiedCB, this);
    this.balloonTipLabelStyle.addModifiedCB(Label_BalloonTipLabelStyleModifiedCB, this);
    
    this.registerAttribute(this.text, "text");
    this.registerAttribute(this.description, "description");
    this.registerAttribute(this.depthShadingEnabled, "depthShadingEnabled");
    this.registerAttribute(this.labelStyle, "labelStyle");
    this.registerAttribute(this.iconStyle, "iconStyle");
    this.registerAttribute(this.balloonTipLabelStyle, "balloonTipLabelStyle");
    
    this.styles.registerStyle(this.iconStyle, "iconStyle");
	this.styles.registerStyle(this.labelStyle, "labelStyle");
	this.styles.registerStyle(this.balloonTipLabelStyle, "balloonTipLabelStyle");
}

Label.prototype.setGraphMgr = function(graphMgr)
{
    // call base-class implementation
    RasterComponent.prototype.setGraphMgr.call(this, graphMgr);
    
    // create id
    this.id = "Label" + this.graphMgr.getNextLabelIndex();
    this.labelId = this.id + "_label";
    this.iconId = this.id + "_icon";
    
    // create html div for canvas overlay
    var htmlLabel = CreateHTMLLabel(this.id, this.labelId, this.iconId);
    this.htmlLabel = htmlLabel.label;
    this.htmlIconImg = htmlLabel.iconImg;
    this.htmlIconDiv = htmlLabel.iconDiv;
    
    // initialize base dimensions of icon (used for scaling)
    this.htmlIconImg.baseWidth = 0;
    this.htmlIconImg.baseHeight = 0;
    
    // set initial style
    Label_LabelStyleBackgroundColorModifiedCB(this.labelStyle.backgroundColor, this);
    Label_LabelStyleBackgroundOpacityModifiedCB(this.labelStyle.backgroundOpacity, this);
    Label_LabelStyleFontBorderModifiedCB(null, this); // handles borderColor and borderWidth
    Label_LabelStyleFontStyleColorModifiedCB(this.labelStyle.fontStyle.color, this);
    Label_LabelStyleFontStyleFontModifiedCB(this.labelStyle.fontStyle.font, this);
    Label_LabelStyleFontStyleOpacityModifiedCB(this.labelStyle.fontStyle.opacity, this);
    Label_LabelStyleFontStyleSizeModifiedCB(this.labelStyle.fontStyle.size, this);
    Label_LabelStyleFontStyleStyleModifiedCB(this.labelStyle.fontStyle.style, this);
    Label_LabelStyleFormatModifiedCB(this.labelStyle.format, this);
    Label_LabelStylePaddingModifiedCB(this.labelStyle.padding, this);
    Label_IconStyleUrlModifiedCB(this.iconStyle.url, this);
}

Label.prototype.update = function(params, visitChildren)
{
    // update icon scale
    // (necessary because dimensions are not available until image is actually loaded)
    this.updateIconScale();
    
    // call base-class implementation
    RasterComponent.prototype.update.call(this, params, visitChildren);
}

Label.prototype.updateIconScale = function()
{
    var scale = this.iconStyle.scale.getValueDirect();
        
    // obtain original dimensions
    if (this.htmlIconImg.baseWidth == 0)
    {
        this.htmlIconImg.baseWidth = this.htmlIconImg.offsetWidth;
        this.htmlIconImg.baseHeight = this.htmlIconImg.offsetHeight;
    }
    
    // scale
    if (this.htmlIconImg.baseWidth)
    {
        this.htmlIconImg.width = this.htmlIconImg.baseWidth * scale.x;
        this.htmlIconImg.height = this.htmlIconImg.baseHeight * scale.y;
    }
}

Label.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        RasterComponent.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {
            this.draw(params.viewport);
        }
        break;
        
    case "rayPick":
        {
            if (this.selectable.getValueDirect() == true &&
                this.show.getValueDirect() == true)
            {
                if (this.isSelected(params.clickPoint.x, params.clickPoint.y))
                {
                    var intersectRecord = new RayIntersectRecord();
                    intersectRecord.distance = 0;
                    
                    params.currentNodePath.push(this);           
                    params.directive.addPickRecord(new RayPickRecord(params.currentNodePath, intersectRecord, params.camera));                   
                    params.currentNodePath.pop();
                }
            }    
        }
        break;
    }
    
    // call base-class implementation
    RasterComponent.prototype.apply.call(this, directive, params, visitChildren);
}

Label.prototype.draw = function(viewport)
{
    var bworks = this.registry.find("Bridgeworks");

    // show
    if (this.show.getValueDirect() == false)
    {
        this.htmlLabel.style.visibility = "hidden";
        this.htmlIconImg.style.visibility = "hidden";
        return;
    }

    this.htmlLabel.style.visibility = "visible";
    this.htmlIconImg.style.visibility = "visible";

    // update visibility with respect to color/opacity
    if (this.labelStyle.fontStyle.opacity.getValueDirect() == 0)
    {
        this.htmlLabel.style.visibility = "hidden";
    }
    var iconColor = this.iconStyle.color.getValueDirect();
    if (iconColor.a == 0 ||
        this.iconStyle.opacity.getValueDirect() == 0)
    {
        this.htmlIconImg.style.visibility = "hidden";
    }

    // determine the rendering positions
    var positions = this.getRenderingPositions();

    var labelWidth = this.htmlLabel.offsetWidth; // * this.htmlLabel.style.zoom;
    var labelHeight = this.htmlLabel.offsetHeight; // * this.htmlLabel.style.zoom;
    var iconWidth = this.htmlIconImg.offsetWidth;
    var iconHeight = this.htmlIconImg.offsetHeight;

    // determine if label is fully contained within viewport
    if (positions.labelX < 0 ||
	    positions.labelY < 0 ||
	    positions.labelX + labelWidth > bworks.canvas.width ||
	    positions.labelY + labelHeight > bworks.canvas.height)
    {
        this.htmlLabel.style.visibility = "hidden";
    }

    // determine if icon is fully contained within viewport
    if (positions.iconX < 0 ||
	    positions.iconY < 0 ||
	    positions.iconX + iconWidth > bworks.canvas.width ||
	    positions.iconY + iconHeight > bworks.canvas.height)
    {
        this.htmlIconImg.style.visibility = "hidden";
    }

    // update positions if visible
    if (this.htmlLabel.style.visibility == "visible")
    {
        this.htmlLabel.style.left = bworks.canvas.offsetLeft + positions.labelX;
        this.htmlLabel.style.top = bworks.canvas.offsetTop + positions.labelY;

        this.labelRect.load(bworks.canvas.offsetLeft + positions.labelX,
                            bworks.canvas.offsetTop + positions.labelY,
                            this.labelRect.left + labelWidth,
                            this.labelRect.top + labelHeight);
    }
    else
    {
        this.labelRect.load(0, 0, 0, 0);
    }
    if (this.htmlIconImg.style.visibility == "visible")
    {
        this.htmlIconDiv.style.left = bworks.canvas.offsetLeft + positions.iconX;
        this.htmlIconDiv.style.top = bworks.canvas.offsetTop + positions.iconY;

        this.iconRect.load(bworks.canvas.offsetLeft + positions.iconX,
                           bworks.canvas.offsetTop + positions.iconY,
                           this.iconRect.left + iconWidth,
                           this.iconRect.top + iconHeight);
    }
    else
    {
        this.iconRect.load(0, 0, 0, 0);
    }

    // update screen rect
    var screenRect = new Rect(0, 0, 0, 0);
    if (this.htmlLabel.style.visibility == "visible" &&
        this.htmlIconImg.style.visibility == "visible")
    {
        screenRect.left = Math.min(this.labelRect.left, this.iconRect.left);
        screenRect.top = Math.min(this.labelRect.top, this.iconRect.top);
        screenRect.right = Math.max(this.labelRect.right, this.iconRect.right);
        screenRect.bottom = Math.max(this.labelRect.bottom, this.iconRect.bottom);
    }
    else if (this.htmlLabel.style.visibility == "visible")
    {
        screenRect.loadRect(this.labelRect);
    }
    else if (this.htmlIconImg.style.visibility == "visible")
    {
        screenRect.loadRect(this.iconRect);
    }
    this.screenRect.setValueDirect(screenRect);
}

Label.prototype.getRenderingPositions = function()
{
    // initialize
    var labelX = 0;
    var labelY = 0;
    var iconX = 0;
    var iconY = 0;
    
    // get screen position
    var screen = this.screenPosition.getValueDirect();
    
    // get anchor position
    var anchor = this.anchor.getValueDirect();
    
    // get label offset
    var offset = this.labelStyle.offset.getValueDirect();
    
    if (this.htmlIconImg.offsetWidth > 0 && 
        this.htmlLabel.offsetWidth > 0) // icon and label present
    {	
        var labelWidth = this.htmlLabel.offsetWidth;// * this.htmlLabel.style.zoom;
        var labelHeight = this.htmlLabel.offsetHeight;// * this.htmlLabel.style.zoom;
        var iconWidth = this.htmlIconImg.offsetWidth;
        var iconHeight = this.htmlIconImg.offsetHeight;
        
        // measure from origin
        if (this.origin.getValueDirect().join("") == "bottomLeft")
        {
            anchor.y = iconHeight - anchor.y;
        }
        
        // 
        iconX  = screen.x - anchor.x;
		iconY  = screen.y - anchor.y;
		labelX = iconX + offset.x;
		labelY = iconY + offset.y;
        
		// adjust according to alignment
		switch (this.labelStyle.textAlign.getValueDirect().join(""))
        {
        case "topLeft":
			labelX -= labelWidth;
			labelY -= labelHeight / 2;
			break;
			
		case "middleLeft":
			labelX -= labelWidth;
			labelY += iconHeight / 2 - labelHeight / 2;
		    break;
		    
		case "bottomLeft":
			labelX -= labelWidth;
			labelY += iconHeight - labelHeight / 2;
			break;
			
		case "topCenter":
			labelX += iconWidth / 2 - labelWidth / 2;
			labelY -= labelHeight;
		    break;
		    
	    case "middleCenter":
			labelX += iconWidth / 2 - labelWidth / 2;
			labelY += iconHeight / 2 - labelHeight / 2;
			break;
			
		case "bottomCenter":
			labelX += iconWidth / 2 - labelWidth / 2;
			labelY += iconHeight;
		    break;
		    
		case "topRight":
			labelX += iconWidth;
			labelY -= labelHeight / 2;
		    break;
		    
		case "bottomRight":
			labelX += iconWidth;
			labelY += iconHeight - labelHeight / 2;
			break;
			
		case "middleRight": // default
		default:
			labelX += iconWidth;
			labelY += iconHeight / 2 - labelHeight / 2;
			break;
		}
    }
    else if (this.htmlLabel.offsetWidth > 0)
    {   
        var labelWidth = this.htmlLabel.offsetWidth;// * this.htmlLabel.style.zoom;
        var labelHeight = this.htmlLabel.offsetHeight;// * this.htmlLabel.style.zoom;
        
        // 
        labelX = screen.x + anchor.x + offset.x;
        labelY = screen.y - anchor.y + offset.y;
        
        // adjust according to alignment
        switch (this.labelStyle.textAlign.getValueDirect().join(""))
        {
        case "topLeft":
	        labelX -= labelWidth;
		    labelY -= labelHeight;
		    break;
    		
	    case "middleLeft":
	        labelX -= labelWidth;
		    labelY -= labelHeight / 2;	
		    break;
    		
	    case "bottomLeft":
		    labelX -= labelWidth;
	        break;
    	    
	    case "topCenter":
		    labelX -= labelWidth / 2;
		    labelY -= labelHeight;
		    break;
    		
	    case "middleCenter":
		    labelX -= labelWidth / 2;
		    labelY -= labelHeight / 2;
	        break;
    	    
	    case "bottomCenter":
		    labelX -= labelWidth / 2;
		    break;
    		
	    case "topRight":
		    labelY -= labelHeight;
		    break;
    			
	    case "bottomRight":
		    break;
    		
	    case "middleRight": // default
	    default:
		    labelY -= labelHeight / 2;
		    break;
        }
    }
    else // only icon present
    {
        var iconWidth = this.htmlIconImg.offsetWidth;
        var iconHeight = this.htmlIconImg.offsetHeight;
        
        // measure from bottom left
		anchor.y = iconHeight - anchor.y;

		iconX = screen.x - anchor.x;
		iconY = screen.y - anchor.y;
    }
    
    return { labelX: labelX, labelY: labelY, iconX: iconX, iconY: iconY };
}

Label.prototype.eventPerformed = function(event)
{
    if (!(this.show.getValueDirect()))
    {
        return false;
    }

    var selected = this.isSelected(event.x, event.y);

    return selected;
}

Label.prototype.labelStyleFontBorderModified = function()
{
    var color = this.labelStyle.fontStyle.borderColor.getValueDirect();
    color.a *= this.labelStyle.fontStyle.opacity.getValueDirect();
    var width = this.labelStyle.fontStyle.borderWidth.getValueDirect();
    
    var shadow = "";
    for (var i=0; i < color.a; i+=0.2)
    {
        if (i > 0) shadow += ", ";
        
        shadow += "rgba(" + color.r * 255 + "," 
                          + color.g * 255 + "," 
                          + color.b * 255 + "," 
                          + color.a + ")" + " 0px 0px " + width * 2 + "px";
    }
 
    this.htmlLabel.style.textShadow = shadow;
}

function CreateHTMLLabel(id, labelId, iconId)
{
    var newDiv = null;
    var newLabel = null;
    var newIconImg = null;
    var newIconDiv = null;

    // Needs further refactoring. Currently set in an app Helper
    // because we don't have container scope here to append these elements
    if (bridgeworks.rasterComponents)
    {
        // containing div
        newDiv = document.createElement("div");
        if (newDiv)
        {
            newDiv.setAttribute("id", id);

            // label
            newLabel = document.createElement("span");
            if (newLabel)
            {
                newLabel.setAttribute("id", labelId);
                newLabel.setAttribute("class", "labelText");
                newLabel.style.visibility = "hidden";
                newLabel.style.position = "absolute";
                newLabel.style.zIndex = 3;
                //newLabel.style.zoom = 1;//.95;
                newLabel.onmousedown = function() { /*onMouseDown();*/ };
                newLabel.onmouseup = function() { /*onMouseUp();*/ };
                newLabel.onmousemove = function() { /*onMouseMove();*/ };
                // disable selection
                newLabel.onselectstart = new Function("return false");

                newDiv.appendChild(newLabel);
            }

            // icon
            newIconDiv = document.createElement("div");
            if (newIconDiv)
            {
                newIconDiv.setAttribute("id", iconId);
                newIconDiv.style.position = "absolute";
                newIconDiv.style.zIndex = 3;

                newIconImg = document.createElement("img");
                if (newIconImg)
                {
                    newIconImg.setAttribute("class", "labelIcon");
                    newIconImg.style.visibility = "hidden";
                    newIconImg.src = "BwContent/images/1x1.png";
                    //newIconImg.onmousedown = function(){onMouseDown();};
                    newIconImg.onmouseup = function() { /*onMouseUp();*/ };
                    newIconImg.onmousemove = function() { /*onMouseMove();*/ };
                    // disable selection
                    newIconImg.onmousedown = function() { return false; };

                    newIconDiv.appendChild(newIconImg);
                }
                newDiv.appendChild(newIconDiv);
            }

            bridgeworks.rasterComponents.appendChild(newDiv);
        }
    }

    return { div: newDiv, label: newLabel, iconDiv: newIconDiv, iconImg: newIconImg };
}

function Label_TextModifiedCB(attribute, container)
{
    container.htmlLabel.innerHTML = attribute.getValueDirect().join("");
}

function Label_DescriptionModifiedCB(attribute, container)
{
    var description = attribute.getValueDirect().join("");
    if (description.length > 0)
    {
        // desired dimensions; if 0, use 50% canvas size
        var width = container.balloonTipLabelStyle.htmlLabelStyle.width.getValueDirect();
        var height = container.balloonTipLabelStyle.htmlLabelStyle.height.getValueDirect();
        if (width == 0 || height == 0)
        {
            var viewportMgr = container.registry.find("ViewportMgr");
            if (width == 0) width = viewportMgr.getAttribute("width").getValueDirect() * 0.5;
            if (height == 0) height = viewportMgr.getAttribute("height").getValueDirect() * 0.5;
        }
        
        var id = '#' + container.iconId;
        description = "<div class='gmap' style='" + 
                      "width:" + (width + 12) + "px;" + // (+ 12 accounts for close button)
                      "height:12px;'>" + 
                      "<a href='javascript:void($(\"" +
                      id + 
                      "\").btOff());'><img src='libs/jquery/bt/close.gif' alt='close' width='12' height='12' class='gmap-close' /></a> " + 
                      "</div>" +
                      "<div style='" +
                      "width:" + (width + 12) + "px;" + // (+ 12 accounts for close button)
                      "height:" + height + "px;" + 
                      "overflow:auto;'>" +
                      description +
                      "</div>";
            
        var bgColor = container.balloonTipLabelStyle.bgColor.getValueDirect();
        var fill = "rgba(" + bgColor.r * 255 + "," 
                           + bgColor.g * 255 + "," 
                           + bgColor.b * 255 + ","
                           + bgColor.a * 255 + ")"; 
                                                  
        $(id).bt(description, {trigger: 'click',
                               width: width + 12 + "px", // (+ 12 accounts for close button)
                               height: height + 12 + "px", // (+ 12 accounts for close button)
                               shrinkToFit: ((width == 0 && height == 0) ? true : false),
                               centerPointX: .9,
                               spikeLength: container.balloonTipLabelStyle.balloonOffset.getValueDirect(),
                               spikeGirth: 30,
                               padding: 15,
                               cornerRadius: 25,
                               fill: fill,
                               strokeStyle: '#ABABAB',
                               strokeWidth: 1,
                               shadow: true,
                               shadowOffsetX: 3,
                               shadowOffsetY: 3,
                               shadowBlur: 8,
                               shadowColor: 'rgba(0,0,0,.9)',
                               shadowOverlap: false,
                               noShadowOpts: {strokeStyle: '#999', strokeWidth: 2}});
    }
    else
    {
        var id = '#' + container.iconId;
        $(id).bt("", {trigger: 'click'});
    }
}

function Label_LabelStyleBackgroundColorModifiedCB(attribute, container)
{
    var color = attribute.getValueDirect();
    color.a *= attribute.getContainer().getAttribute("backgroundOpacity").getValueDirect();
    container.htmlLabel.style.backgroundColor = "rgba(" + color.r * 255 + "," 
                                                        + color.g * 255 + "," 
                                                        + color.b * 255 + ","
                                                        + color.a + ")";
}

function Label_LabelStyleBackgroundOpacityModifiedCB(attribute, container)
{
    Label_LabelStyleBackgroundColorModifiedCB(container.labelStyle.backgroundColor, container);
}

function Label_LabelStyleFontBorderModifiedCB(attribute, container)
{
    container.labelStyleFontBorderModified();
}

function Label_LabelStyleFontStyleColorModifiedCB(attribute, container)
{
    var color = attribute.getValueDirect();
    color.a *= attribute.getContainer().getAttribute("opacity").getValueDirect();
    container.htmlLabel.style.color = "rgba(" + color.r * 255 + "," 
                                              + color.g * 255 + "," 
                                              + color.b * 255 + ","
                                              + color.a + ")";
}

function Label_LabelStyleFontStyleFontModifiedCB(attribute, container)
{
    container.htmlLabel.style.fontFamily = attribute.getValueDirect().join("");
}

function Label_LabelStyleFontStyleOpacityModifiedCB(attribute, container)
{
    Label_LabelStyleFontStyleColorModifiedCB(container.labelStyle.fontStyle.color, container);
    Label_LabelStyleFontBorderModifiedCB(null, container);
}

function Label_LabelStyleFontStyleSizeModifiedCB(attribute, container)
{
    container.htmlLabel.style.fontSize = attribute.getValueDirect() + "pt";
}

function Label_LabelStyleFontStyleStyleModifiedCB(attribute, container)
{
    switch (attribute.getValueDirect().join(""))
    {
    case "Bold":
        container.htmlLabel.style.fontWeight = "bold";
        break;
        
    case "Heavy":
        container.htmlLabel.style.fontWeight = "bolder";  
        break;
        
    case "Normal":
        container.htmlLabel.style.fontWeight = "normal";
        break;
        
    case "Thin":
        container.htmlLabel.style.fontWeight = "lighter";
        break;
    }
}

function Label_LabelStyleFormatModifiedCB(attribute, container)
{
    var format = attribute.getValueDirect().join("");
    //container.htmlLabel.style.setProperty("textAlign", format, "normal");
    // TODO
}

function Label_LabelStylePaddingModifiedCB(attribute, container)
{
    var padding = attribute.getValueDirect() + "px";
    container.htmlLabel.style.paddingLeft = padding;
    container.htmlLabel.style.paddingRight = padding;
    container.htmlLabel.style.paddingTop = padding;
    container.htmlLabel.style.paddingBottom = padding;    
}

function Label_IconStyleUrlModifiedCB(attribute, container)
{
    var url = attribute.getValueDirect().join("");
    switch (url)
    {
    case "":
        //container.htmlIconImg.src = null;
        break;

    default:
        container.htmlIconImg.src = document.location.href + "/../BwContent/" + url;
        break;
    }
}

function Label_BalloonTipLabelStyleModifiedCB(attribute, container)
{
    Label_DescriptionModifiedCB(container.description, container);   
}
BalloonTipLabel.prototype = new RasterComponent();
BalloonTipLabel.prototype.constructor = BalloonTipLabel;

function BalloonTipLabel()
{
    RasterComponent.call(this);
    this.className = "BallonTipLabel";
    this.attrType = eAttrType.BalloonTipLabel;
    
    this.qtip = null;
    this.qtip_api = null;
    
    this.labelRect = new Rect(0, 0, 0, 0);
    
    this.balloonTipLabelStyle = new BalloonTipLabelStyleAttr();
    this.labelWidth = new NumberAttr(0);
    this.labelHeight = new NumberAttr(0);
    
    this.balloonTipLabelStyle.bgColor.addModifiedCB(BalloonTipLabel_balloonTipLabelStyleBgColorModifiedCB, this);
    this.balloonTipLabelStyle.htmlLabelStyle.addModifiedCB(BalloonTipLabel_BalloonTipLabelStyleHTMLLabelStyleModifiedCB, this);
    this.balloonTipLabelStyle.displayMode.addModifiedCB(BalloonTipLabel_balloonTipLabelStyleDisplayModeModifiedCB, this);
    this.show.addModifiedCB(BalloonTipLabel_showModifiedCB, this);
    this.renderSequenceSlot.addModifiedCB(BalloonTipLabel_renderSequenceSlotModifiedCB, this);

    this.registerAttribute(this.balloonTipLabelStyle, "balloonTipLabelStyle");
    this.registerAttribute(this.labelWidth, "labelWidth");
    this.registerAttribute(this.labelHeight, "labelHeight");
    
    this.styles.registerStyle(this.balloonTipLabelStyle, "balloonTipLabelStyle");
}

BalloonTipLabel.prototype.setGraphMgr = function(graphMgr)
{
    // call base-class implementation
    RasterComponent.prototype.setGraphMgr.call(this, graphMgr);
    
    // create id
    this.id = "BalloonTipLabel" + this.graphMgr.getNextBalloonTipLabelIndex();
    
    // create html components for canvas overlay
    var htmlBalloonTipLabel = CreateHTMLBalloonTipLabel(this.id);
    this.htmlBalloonTipLabel = htmlBalloonTipLabel.label;
    this.qtip = htmlBalloonTipLabel.qtip;
    
    // get qtip api 
    this.qtip_api = $('a[id=' + this.id + ']').qtip("api");
}

BalloonTipLabel.prototype.update = function(params, visitChildren)
{
    if (params.userData)
    {
        var updateParams = params.userData;
        if (this.show.getValueDirect())// && (this.updateLabel || isRenderStateModified(updateParams.viewport)))
        {
            this.updateLabel = false;

            //updateLabel(updateParams.viewport);
        }
    }

    // call base-class implementation
    RasterComponent.prototype.update.call(this, params, visitChildren);
}

BalloonTipLabel.prototype.apply = function(directive, params, visitChildren)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        // call base-class implementation
        RasterComponent.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    switch (directive)
    {
    case "render":
        {
            this.draw(params.viewport);
        }
        break;
    }
    
    // call base-class implementation
    RasterComponent.prototype.apply.call(this, directive, params, visitChildren);
}

BalloonTipLabel.prototype.updateLabel = function(viewport)
{
}

BalloonTipLabel.prototype.updateLabelDimensions = function(viewport)
{
}

BalloonTipLabel.prototype.updateShowStates = function()
{
}

BalloonTipLabel.prototype.draw = function()
{
    if (!(this.show.getValueDirect()))
    {
        if (this.graphMgr.getCurrentBalloonTipLabel() == this)
        {
            this.graphMgr.setCurrentBalloonTipLabel(null);
        }
        return;
    }
    /*
     // only allow one balloon tip to display at a time (per Ted)
     BalloonTipLabel* currentBTL = this.graphMgr.getCurrentBalloonTipLabel();
     if (currentBTL && currentBTL != this)
     {
     this.show.setValueDirect(false, false);
     return;
     }
     */
    this.graphMgr.setCurrentBalloonTipLabel(this);
    
    var bworks = this.registry.find("Bridgeworks");
    
    // determine the rendering positions
    var positions = this.getRenderingPositions();
    
    var labelWidth = this.htmlBalloonTipLabel.offsetWidth; // * this.htmlLabel.style.zoom;
    var labelHeight = this.htmlBalloonTipLabel.offsetHeight; // * this.htmlLabel.style.zoom;
    
    // update positions if visible
    //if (this.show.getValueDirect())
    {
        this.htmlBalloonTipLabel.style.left = bworks.canvas.offsetLeft + positions.labelX;
        this.htmlBalloonTipLabel.style.top = bworks.canvas.offsetTop + positions.labelY;

        this.labelRect.load(bworks.canvas.offsetLeft + positions.labelX,
                            bworks.canvas.offsetTop + positions.labelY,
                            this.labelRect.left + labelWidth,
                            this.labelRect.top + labelHeight);
        
        if (this.qtip_api)
        {
            this.qtip_api.reposition(null, false); // Reposition without animation
            //this.qtip_api.show();
        }
    }
    //else
    //{
    //    this.labelRect.load(0, 0, 0, 0);
    //}
    
    // update screen rect
    var screenRect = new Rect(0, 0, 0, 0);
    //if (this.show.getValueDirect())
    {
        screenRect.loadRect(this.labelRect);
    }
    this.screenRect.setValueDirect(screenRect);
}

BalloonTipLabel.prototype.getRenderingPositions = function()
{
    // initialize
    var labelX = 0;
    var labelY = 0;
    
    // get screen position
    var screen = this.screenPosition.getValueDirect();
    
    // get anchor position
    var anchor = this.anchor.getValueDirect();
    
    labelX = screen.x + anchor.x;
    labelY = screen.y - anchor.y;
    
    return { labelX: labelX, labelY: labelY };
}

BalloonTipLabel.prototype.eventPerformed = function(event)
{
    if (!(this.show.getValueDirect()))
    {
        return false;
    }

    var selected = this.isSelected(event.x, event.y);

    return selected;
}

BalloonTipLabel.prototype.balloonTipLabelStyleModified = function(update)
{
}

BalloonTipLabel.prototype.balloonTipLabelStyleBgColorModified = function()
{
}

BalloonTipLabel.prototype.balloonTipLabelStyleDisplayModeModified = function(mode)
{
    switch (mode)
    {
        case "default":
        {
            this.show.setValueDirect(true, false);
        }
        break;
        
        case "hide":
        {
            // don't hide if parent has focus
            if (this.motionParent && this.motionParent.getAttribute("hasFocus").getValueDirect() > 0)
            {
                // a bit kludgy for this programmer, but this is nessary to get the "Google Earth"-like behavior [MCB]
                this.hasFocus.setValueDirect(1);
                //DisableInspectionState();
            }
            else
            {
                this.show.setValueDirect(false, false);
            }
        }
        break;
    }
        
    this.incrementModificationCount();
}

BalloonTipLabel.prototype.balloonTipLabelStyleHtmlLabelStyleModified = function()
{
    // html
    var html = this.balloonTipLabelStyle.htmlLabelStyle.html.getValueDirect().join("");
    
    if (this.qtip_api)
    {
        this.qtip_api.set("content.text", html);
    }
    
    this.incrementModificationCount();
}

BalloonTipLabel.prototype.renderSequenceSlotModified = function()
{
}

BalloonTipLabel.prototype.showModified = function(show)
{
    if (this.qtip_api)
    {
        if (show)
        {
            this.qtip_api.show();
        }
        else
        {
            this.qtip_api.hide();
        }
    }
}

function CreateHTMLBalloonTipLabel(id)
{
    var newA = null;

    // Needs further refactoring. Currently set in an app Helper
    // because we don't have container scope here to append these elements
    if (bridgeworks.rasterComponents)
    {
        newA = document.createElement("a");
        if (newA)
        {
            newA.setAttribute("id", id);
            //newA.innerHTML = "";
            newA.style.visibility = "hidden";
            newA.style.position = "absolute";

            bridgeworks.rasterComponents.appendChild(newA);
        }
    }

    var id = 'a[id=' + id + ']';
    var qtip = $(id).qtip(
    {
        style:
        {
            classes: 'qtip-bootstrap qtip-rounded qtip-shadow qtip-close'
        },
        content :
        {
            text: '',
            button: true
        },
        //show : true,
        hide:
        {
            event: false
        }
    });
   
    return { label: newA, qtip: qtip };
}

function BalloonTipLabel_balloonTipLabelStyleModifiedCB(attribute, container)
{
    container.balloonTipLabelStyleModified();
}

function BalloonTipLabel_balloonTipLabelStyleBgColorModifiedCB(attribute, container)
{
}

function BalloonTipLabel_balloonTipLabelStyleDisplayModeModifiedCB(attribute, container)
{
    container.balloonTipLabelStyleDisplayModeModified(attribute.getValueDirect().join(""));
}

function BalloonTipLabel_BalloonTipLabelStyleHTMLLabelStyleModifiedCB(attribute, container)
{
    container.balloonTipLabelStyleHtmlLabelStyleModified();
}

function BalloonTipLabel_HTMLLabel_PageDimensionsModifiedCB(attribute, container)
{
}

function BalloonTipLabel_showModifiedCB(attribute, container)
{
    container.showModified(attribute.getValueDirect());
}

function BalloonTipLabel_renderSequenceSlotModifiedCB(attribute, container)
{
}

LineList.prototype = new VertexGeometry();
LineList.prototype.constructor = LineList;

function LineList()
{
    VertexGeometry.call(this);
    this.className = "LineList";
    this.attrType = eAttrType.LineList;
    this.width = 1;
}

LineList.prototype.update = function(params, visitChildren)
{
    if (!this.vertexBuffer)
    {
        this.vertexBuffer = this.graphMgr.renderContext.createVertexBuffer(3);
        this.vertexBuffer.setPrimitiveType(RC_LINES);
    }
    
    // call base-class implementation
    VertexGeometry.prototype.update.call(this, params, visitChildren);
}

LineList.prototype.apply = function(directive, params, visitChildren)
{
    // call base-class impementation
    VertexGeometry.prototype.apply.call(this, directive, params, visitChildren);
}

LineList.prototype.draw = function(dissolve)
{
    // TODO
    
    this.vertexBuffer.draw();
}

LineList.prototype.buildBoundingTree = function()
{
    
}
PointList.prototype = new VertexGeometry();
PointList.prototype.constructor = PointList;

function PointList()
{
    VertexGeometry.call(this);
    this.className = "PointList";
    this.attrType = eAttrType.PointList;
    this.width = 1;
}

PointList.prototype.update = function(params, visitChildren)
{
    if (!this.vertexBuffer)
    {
        this.vertexBuffer = this.graphMgr.renderContext.createVertexBuffer(3);
        this.vertexBuffer.setPrimitiveType(RC_POINTS);
    }
    
    // call base-class implementation
    VertexGeometry.prototype.update.call(this, params, visitChildren);
}

PointList.prototype.apply = function(directive, params, visitChildren)
{
    // call base-class impementation
    VertexGeometry.prototype.apply.call(this, directive, params, visitChildren);
}

PointList.prototype.draw = function(dissolve)
{
    // TODO
    
    this.vertexBuffer.draw();
}

PointList.prototype.buildBoundingTree = function()
{
    
}
/*
======================================================================
range()

Given the value v of a periodic function, returns the equivalent value
v2 in the principal interval [lo, hi].  If i isn't NULL, it receives
the number of wavelengths between v and v2.

   v2 = v - i * (hi - lo)

For example, range( 3 pi, 0, 2 pi, i ) returns pi, with i = 1.
====================================================================== */

function range( v, lo, hi )
{
   var v2, r = hi - lo;

   if ( r == 0.0 ) {
      return { value: lo, i: 0 };
   }

   v2 = v - r * Math.floor(( v - lo ) / r );

   return { value: v2, i: -(Math.floor(( v2 - v ) / r + ( ( v2 > v ) ? 0.5 : -0.5 ))) };
}


/*
======================================================================
hermite()

Calculate the Hermite coefficients.
====================================================================== */

function hermite( t )
{
   var t2, t3;

   t2 = t * t;
   t3 = t * t2;

   var h2 = 3 * t2 - t3 - t3;
   var h1 = 1 - h2;
   var h4 = t3 - t2;
   var h3 = h4 - t2 + t;
   
   return { h1: h1, h2: h2, h3: h3, h4: h4 };
}


/*
======================================================================
bezier()

Interpolate the value of a 1D Bezier curve.
====================================================================== */

function bezier( x0, x1, x2, x3, t )
{
   var a, b, c, t2, t3;

   t2 = t * t;
   t3 = t2 * t;

   c = 3 * ( x1 - x0 );
   b = 3 * ( x2 - x1 ) - c;
   a = x3 - x0 - c - b;

   return a * t3 + b * t2 + c * t + x0;
}


/*
======================================================================
bez2_time()

Find the t for which bezier() returns the input time.  The handle
endpoints of a BEZ2 curve represent the control points, and these have
(time, value) coordinates, so time is used as both a coordinate and a
parameter for this curve type.
====================================================================== */

function bez2_time( x0, x1, x2, x3, time, t0, t1 )
{
   var v, t;

   t = t0 + ( t1 - t0 ) * 0.5;
   v = bezier( x0, x1, x2, x3, t );
   if ( Math.abs( time - v ) > .0001 ) {
      if ( v > time )
         t1 = t;
      else
         t0 = t;
      return bez2_time( x0, x1, x2, x3, time, t0, t1 );
   }
   else
      return t;
}


/*
======================================================================
bez2()

Interpolate the value of a BEZ2 curve.
====================================================================== */

function bez2( key0, key1, time )
{
   var x, y, t, t0 = 0, t1 = 1;

   if ( key0.getShape() == eKeyframeShape_Bezier2D )
      x = key0.getTime() + key0.getParams(2);
   else
      x = key0.getTime() + ( key1.getTime() - key0.getTime() ) / 3;

   t = bez2_time( key0.getTime(), x, key1.getTime() + key1.getParams(0), key1.getTime(),
      time, t0, t1 );

   if ( key0.getShape() == eKeyframeShape_Bezier2D )
      y = key0.getValue() + key0.getParams(3);
   else
      y = key0.getValue() + key0.getParams(1) / 3;

   return bezier( key0.getValue(), y, key1.getParams(1) + key1.getValue(), key1.getValue(), t );
}


/*
======================================================================
outgoing()

Return the outgoing tangent to the curve at key0.  The value returned
for the BEZ2 case is used when extrapolating a linear pre behavior and
when interpolating a non-BEZ2 span.
====================================================================== */

function outgoing( keys, key0, key1, first )
{
   var a, b, d, t, out;

   switch ( key0.getShape() )
   {
      case eKeyframeShape.TCB:
         a = ( 1 - key0.getParams(0) )
           * ( 1 + key0.getParams(1) )
           * ( 1 + key0.getParams(2) );
         b = ( 1 - key0.getParams(0) )
           * ( 1 - key0.getParams(1) )
           * ( 1 - key0.getParams(2) );
         d = key1.getValue() - key0.getValue();

         if ( key0 != first ) {
            t = ( key1.getTime() - key0.getTime() ) / ( key1.getTime() - (keys.prev(key0)).getTime() );
            out = t * ( a * ( key0.getValue() - (keys.prev(key0)).getValue() ) + b * d );
         }
         else
            out = b * d;
         break;

      case eKeyframeShape.Linear:
         d = key1.getValue() - key0.getValue();
         if ( key0 != first ) {
            t = ( key1.getTime() - key0.getTime() ) / ( key1.getTime() - (keys.prev(key0)).getTime() );
            out = t * ( key0.getValue() - (keys.prev(key0)).getValue() + d );
         }
         else
            out = d;
         break;

      case eKeyframeShape.Bezier1D:
         out = key0.getParams(1);
         if ( key0 != first )
            out *= ( key1.getTime() - key0.getTime() ) / ( key1.getTime() - (keys.prev(key0)).getTime() );
         break;

      case eKeyframeShape.Bezier2D:
         out = key0.getParams(3) * ( key1.getTime() - key0.getTime() );
         if ( Math.abs( key0.getParams(2) ) > 1e-5 )
            out /= key0.getParams(2);
         else
            out *= 1e5;
         break;

      case eKeyframeShape.Stepped:
      default:
         out = 0;
         break;
   }

   return out;
}


/*
======================================================================
incoming()

Return the incoming tangent to the curve at key1.  The value returned
for the BEZ2 case is used when extrapolating a linear post behavior.
====================================================================== */

function incoming( keys, key0, key1, last )
{
   var a, b, d, t, _in;

   switch ( key1.getShape() )
   {
      case eKeyframeShape.Linear:
         d = key1.getValue() - key0.getValue();
         if ( key1 != last ) {
            t = ( key1.getTime() - key0.getTime() ) / ( (keys.next(key1)).getTime() - key0.getTime() );
            _in = t * ( (keys.next(key1)).getValue() - key1.getValue() + d );
         }
         else
            _in = d;
         break;

      case eKeyframeShape.TCB:
         a = ( 1 - key1.getParams(0) )
           * ( 1 - key1.getParams(1) )
           * ( 1 + key1.getParams(2) );
         b = ( 1 - key1.getParams(0) )
           * ( 1 + key1.getParams(1) )
           * ( 1 - key1.getParams(2) );
         d = key1.getValue() - key0.getValue();

         if ( key1 != last ) {
            t = ( key1.getTime() - key0.getTime() ) / ( (keys.next(key1)).getTime() - key0.getTime() );
            _in = t * ( b * ( (keys.next(key1)).getValue() - key1.getValue() ) + a * d );
         }
         else
            _in = a * d;
         break;

      case eKeyframeShape.Bezier1D:
         _in = key1.getParams(0);
         if ( key1 != last )
            _in *= ( key1.getTime() - key0.getTime() ) / ( (keys.next(key1)).getTime() - key0.getTime() );
         break;
         return _in;

      case eKeyframeShape.Bezier2D:
         _in = key1.getParams(1) * ( key1.getTime() - key0.getTime() );
         if ( Math.abs( key1.getParams(0) ) > 1e-5 )
            _in /= key1.getParams(0);
         else
            _in *= 1e5;
         break;

      case eKeyframeShape.Stepped:
      default:
         _in = 0;
         break;
   }

   return _in;
}


/*
======================================================================
interpolate()

Given a list of keys and a time number, returns the interpolated 
value at that time.
====================================================================== */

function interpolate(time, keyframes, first, last, preBehavior, postBehavior)
{
    // if no keys, the value is 0
    if (keyframes.length == 0)
    {
        return 0;
    }

    // if only one key, the value is constant
    if (keyframes.length == 1)
    {
        return first.getValue();
    }

    var noff = 0;
    var _in = 0;
    var out = 0;
    var offset = 0;
    var result;

    // use pre-behavior if time is before first key time
    if (time < first.getTime())
    {
        switch (preBehavior)
        {
        case eEndBehavior.Reset:
            return 0;

        case eEndBehavior.Constant:
            return first.getValue();

        case eEndBehavior.Repeat:
            result = range(time, first.getTime(), last.getTime());
            time = result.value;
            break;

        case eEndBehavior.Oscillate:
            result = range(time, first.getTime(), last.getTime());
            time = result.value;
            noff = result.i;
            if (noff % 2)
            {
                time = last.getTime() - first.getTime() - time;
            }
            break;

        case eEndBehavior.OffsetRepeat:
            result = range(time, first.getTime(), last.getTime());
            time = result.value;
            noff = result.i;
            offset = noff * (last.getValue() - first.getValue());
            break;

        case eEndBehavior.Linear:
            out = outgoing(keyframes, first, keyframes.next(first), first) / ((keyframes.next(first)).getTime() - first.getTime());
            return out * (time - first.getTime()) + first.getValue();
        }
    }
    // use post-behavior if time is after last key time
    else if (time > last.getTime())
    {
        switch (postBehavior)
        {
        case eEndBehavior.Reset:
            return 0;

        case eEndBehavior.Constant:
            return last.getValue();

        case eEndBehavior.Repeat:
            result = range(time, first.getTime(), last.getTime());
            time = result.value;
            break;

        case eEndBehavior.Oscillate:
            result = range(time, first.getTime(), last.getTime());
            time = result.value;
            noff = result.i;
            if (noff % 2)
            {
                time = last.getTime() - first.getTime() - time;
            }
            break;

        case eEndBehavior.OffsetRepeat:
            result = range(time, first.getTime(), last.getTime());
            time = result.value;
            noff = result.i;
            offset = noff * (last.getValue() - first.getValue());
            break;

        case eEndBehavior.Linear:
            _in = incoming(keyframes, keyframes.prev(last), last, last) / (last.getTime() - (keyframes.prev(last)).getTime());
            return _in * (time - last.getTime()) + last.getValue();
        }
    }

    // get the endpoints of the interval being evaluated 
    var key0 = first;
    while (keyframes.next(key0) && 
           time > (keyframes.next(key0)).getTime())
    {
        key0 = keyframes.next(key0);
    }
    var key1 = keyframes.next(key0);

    // check for singularities first 
    if (time == (key0).getTime())
    {
       return (key0).getValue() + offset;
    }
    else if (time == (key1).getTime())
    {
       return (key1).getValue() + offset;
    }

    // get interval length, time in [0, 1] 
    var t = (time - (key0).getTime()) / ((key1).getTime() - (key0).getTime());

    // interpolate 
    switch ((key1).getShape())
    {
    case eKeyframeShape.TCB:
    case eKeyframeShape.Bezier1D:
        {
            out = outgoing(keyframes, key0, key1, first);
            _in = incoming(keyframes, key0, key1, last);
            var result = hermite(t);
            return result.h1 * (key0).getValue() + result.h2 * (key1).getValue() + result.h3 * out + result.h4 * _in + offset;
        }

    case eKeyframeShape.Bezier2D:
        return bez2(key0, key1, time) + offset;

    case eKeyframeShape.Linear:
        return (key0).getValue() + t * ((key1).getValue() - (key0).getValue()) + offset;

    case eKeyframeShape.Stepped:
        return (key0).getValue() + offset;

    default:
        return 0;
    }

}
function StateRec()
{
    this.material = null;
    this.renderStateRec = null;
    this.cullBackFace = false;
    this.textures = null;
    this.projectionTextures = null;
    this.globalIllumination = new Color();
}

function GetCurrentState(graphMgr)
{
    var rec = new StateRec();
	
    rec.material = graphMgr.getCurrentMaterial();
    rec.renderStateRec = graphMgr.renderState.getState(RENDERSTATE_ALL_BITS);
    rec.cullBackFace = graphMgr.renderContext.enabled(eRenderMode.CullBackFace);
    rec.textures = graphMgr.textureArrayStack.top();
    rec.projectionTextures = graphMgr.projectionTextureArrayStack.top();
    rec.globalIllumination.copy(graphMgr.renderContext.getGlobalIllumination());
    
    return rec;
}

function SetCurrentState(graphMgr, stateRec)
{
    graphMgr.setCurrentMaterial(stateRec.material);
    graphMgr.renderState.setState(RENDERSTATE_ALL_BITS, stateRec.renderStateRec);
    if (stateRec.cullBackFace)
    {
        graphMgr.renderContext.enable(eRenderMode.CullBackFace);
    }
    else
    {
        graphMgr.renderContext.disable(eRenderMode.CullBackFace);
    }
    graphMgr.textureArrayStack.load(stateRec.textures);
    graphMgr.projectionTextureArrayStack.load(stateRec.projectionTextures);
    graphMgr.renderContext.setGlobalIllumination(stateRec.globalIllumination);
}
function DistanceSortRec(distance,
                         geometry,
                         dissolve)
{
    this.distance = distance || 0;
    this.geometry = geometry || null;
    this.dissolve = dissolve || 0;
    this.stateRec = null;
}

DistanceSortAgent.prototype = new Agent();
DistanceSortAgent.prototype.constructor = DistanceSortAgent;

function DistanceSortAgent()
{
    Agent.call(this);
    this.className = "DistanceSortAgent";

    this.graphMgr = null;
    this.sortRecs = [];
}

DistanceSortAgent.prototype.setGraphMgr = function(graphMgr)
{
    this.graphMgr = graphMgr;
}

DistanceSortAgent.prototype.isEmpty = function()
{
    return this.sortRecs.length == 0;
}

DistanceSortAgent.prototype.addGeometry = function(geometry, min, max, dissolve)
{
    var rec = new DistanceSortRec();

    rec.geometry = geometry;
    rec.dissolve = dissolve;
    rec.stateRec = GetCurrentState(this.graphMgr);

    // calculate distance from camera
    var worldViewMatrix = new Matrix4x4();
    worldViewMatrix.loadMatrix(this.graphMgr.renderContext.modelViewMatrixStack.top());

    // initialize
    rec.distance = FLT_MAX;

    // take smallest z of worldView-transformed endpoints of the geometry's bbox as distance from camera
    var p;
    for (var i = 0; i < 8; i++)
    {
        switch (i)
        {
            case 0: p = new Vector3D(max.x, max.y, max.z); break;
            case 1: p = new Vector3D(max.x, max.y, min.z); break;
            case 2: p = new Vector3D(max.x, min.y, max.z); break;
            case 3: p = new Vector3D(max.x, min.y, min.z); break;
            case 4: p = new Vector3D(min.x, max.y, max.z); break;
            case 5: p = new Vector3D(min.x, max.y, min.z); break;
            case 6: p = new Vector3D(min.x, min.y, max.z); break;
            case 7: p = new Vector3D(min.x, min.y, min.z); break;
        }

        p = worldViewMatrix.transform(p.x, p.y, p.z, 1);

        rec.distance = Math.min(p.z, rec.distance);
    }

    // add to list
    this.sortRecs.push(rec);
    
}

DistanceSortAgent.prototype.clear = function()
{
    this.sortRecs.length = 0;
}

DistanceSortAgent.prototype.sort = function()
{
    this.sortRecs.sort(DistanceSortAgent_CompareSortRecs);
}

DistanceSortAgent.prototype.draw = function()
{
    if (this.sortRecs.length == 0)
    {
        return;
    }

    // push state
    var saveState = GetCurrentState(this.graphMgr);

    // disable writing to the depth buffer
    // technique described in the OpenGL Programming Guide, 2nd edition, pp. 222-223
    //this.graphMgr.renderContext.disable(eRenderMode.DepthBufferWrite);

    for (var i = 0; i < this.sortRecs.length; i++)
    {
        // set state according to sort rec
        SetCurrentState(this.graphMgr, this.sortRecs[i].stateRec);

        // draw
        this.sortRecs[i].geometry.draw(this.sortRecs[i].dissolve);

        // pop clip plane state
        // NOTE: D3D is having issues with clip plane states when more than 1 sort rec was present
        this.graphMgr.renderState.setState(RENDERSTATE_CLIP_PLANE_BIT, saveState.renderStateRec);
    }

    // restore depth buffer write state
    this.graphMgr.renderContext.enable(eRenderMode.DepthBufferWrite);

    // pop state
    SetCurrentState(this.graphMgr, saveState);
}

function DistanceSortAgent_CompareSortRecs(rec1, rec2)
{
    return rec2.distance - rec1.distance;
}
/// <b>Approximate</b> radius of Earth at the equator (in Km).
/// For a more precise value, use either the Ellipsoid corresponding to a
/// particular datum or calculate the radius for a given latitude using
/// Synder's Formula
/// @see
var EARTH_RADIUS_KM_EQ = 6378;

/// <b>Approximate</b> radius of Earth at the poles (in Km).
var EARTH_RADIUS_KM_P = 6377;

/// Maximum width of a UTM zone (taken to be at equator)
var UTM_ZONE_WIDTH_KM = 667.956; 

// EqualArc projection - Metric
var EQ_ARC_WIDTH_KM       = 40075.16;	// Earth circumference at Equator
var EQ_ARC_HEIGHT_KM      = 40008.0;    // Earth circumference from pole to pole
var EQ_ARC_ONE_DEG_LAT_KM = EQ_ARC_HEIGHT_KM / 360;
var EQ_ARC_ONE_DEG_LON_KM = EQ_ARC_WIDTH_KM / 360;

// EqualArc projection - English
var EQ_ARC_WIDTH_MI       = 24902.0;
var EQ_ARC_HEIGHT_MI      = 24900.0;
var EQ_ARC_ONE_DEG_LAT_MI = EQ_ARC_HEIGHT_MI / 360;
var EQ_ARC_ONE_DEG_LON_MI = EQ_ARC_WIDTH_MI / 360;

MapProjectionCalculator.prototype = new Evaluator();
MapProjectionCalculator.prototype.constructor = MapProjectionCalculator;

function MapProjectionCalculator()
{
    Evaluator.call(this);
    this.className = "MapProjectionCalculator";
    this.attrType = eAttrType.MapProjectionCalculator;

    this.unitsMultiplier = 1;
    this.positionCalculators = [];
    this.geoPositionCalculators = [];
    
    this.mapProjection = new StringAttr("equalArc");
    this.elevationModel = new StringAttr();
    this.center2D = new Vector2DAttr(0, 0);
    this.units = new StringAttr("kilometers");
    this.geoPosition = new Vector3DAttr(0, 0, 0);
    this.pointWorld = new Vector3DAttr();
    this.resultPosition = new Vector3DAttr();
    this.resultGeoPosition = new Vector3DAttr();

    this.units.addModifiedCB(MapProjectionCalculator_UnitsModifiedCB, this);
    this.pointWorld.addModifiedCB(MapProjectionCalculator_PointWorldModifiedCB, this);
    
    this.registerAttribute(this.mapProjection, "mapProjection");
    this.registerAttribute(this.elevationModel, "elevationModel");
    this.registerAttribute(this.center2D, "center2d");
    this.registerAttribute(this.units, "units");
    this.registerAttribute(this.geoPosition, "geoPosition");
    this.registerAttribute(this.geoPosition, "position"); // backward-compatibility
    this.registerAttribute(this.pointWorld, "pointWorld");
    this.registerAttribute(this.resultPosition, "resultPosition");
    this.registerAttribute(this.resultGeoPosition, "resultGeoPosition");
    this.registerAttribute(this.resultGeoPosition, "resultGeoLocation"); // backward-compatibility

    this.positionCalculators["equalArc"] = ComputeEqualArc3DPosition;
    this.geoPositionCalculators["equalArc"] = ComputeEqualArcGeoPosition;

    this.units.setValueDirect("meters"); // invoke modified cb
}

MapProjectionCalculator.prototype.evaluate = function()
{
    var geoPosition = this.geoPosition.getValueDirect();

    var resultPosition = this.computePosition(geoPosition.x, geoPosition.y, geoPosition.z);
    this.resultPosition.setValueDirect(resultPosition.x, resultPosition.y, resultPosition.z);

    var resultGeoPosition = this.computeGeoPosition(resultPosition.x, resultPosition.y, resultPosition.z);
    this.resultGeoPosition.setValueDirect(resultGeoPosition.x, resultGeoPosition.y, resultGeoPosition.z);
}

MapProjectionCalculator.prototype.computePosition = function(lon, alt, lat)
{
    var position = undefined;
    
    var mapProjection = this.mapProjection.getValueDirect().join("");
    var computeFunc = this.positionCalculators[mapProjection];
    if (computeFunc)
    {
        var center2D = this.center2D.getValueDirect();
        position = computeFunc(lon, alt, lat, center2D.x, center2D.y, this.unitsMultiplier);
    }

    return position;
}

MapProjectionCalculator.prototype.computeGeoPosition = function(x, y, z)
{
    var geoPosition = undefined;

    var mapProjection = this.mapProjection.getValueDirect().join("");
    var computeFunc = this.geoPositionCalculators[mapProjection];
    if (computeFunc)
    {
        var center2D = this.center2D.getValueDirect();
        geoPosition = computeFunc(x, y, z, center2D.x, center2D.y, this.unitsMultiplier);
    }

    return geoPosition;
}

function MapProjectionCalculator_UnitsModifiedCB(attribute, container)
{
    switch (attribute.getValueDirect().join(""))
    {
        case "kilometers":
            {
                container.unitsMultiplier = 1;
            }
            break;

        case "meters":
            {
                container.unitsMultiplier = 1000;
            }
            break;
    }
}

function MapProjectionCalculator_PointWorldModifiedCB(attribute, container)
{
    // TODO
}

function ComputeEqualArc3DPosition(lon, alt, lat, centerLon, centerLat, units)
{
    if (lat > 90  || lat < -90 ||
		lon > 180 || lon < -180)
	{
		return undefined;
	}
	
	var x = (lon - centerLon) * EQ_ARC_ONE_DEG_LON_KM * units;
	var y = alt;
	var z = (lat - centerLat) * EQ_ARC_ONE_DEG_LAT_KM * units;

	return { x: x, y: y, z: z }
}

function ComputeEqualArcGeoPosition(x, y, z, centerLon, centerLat, units)
{
	var lon = (x / units / EQ_ARC_ONE_DEG_LON_KM) + centerLon;
	var alt = y;
	var lat = (z / units / EQ_ARC_ONE_DEG_LAT_KM) + centerLat;   
    
    return { lon: lon, alt: alt, lat: lat }
}
NullObject.prototype = new ParentableMotionElement();
NullObject.prototype.constructor = NullObject;

function NullObject()
{
    ParentableMotionElement.call(this);
    this.className = "NullObject";
    this.attrType = eAttrType.NullObject;
}
Transform.prototype = new SGNode();
Transform.prototype.constructor = Transform;

/**
 * Defines a generic matrix transformation.
 *
 * @see GcSGNode
 */
function Transform()
{
    SGNode.call(this);
    this.className = "Transform";
    this.attrType = eAttrType.Transform;
    
    this.matrix = new Matrix4x4Attr
       (1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);
        
    this.matrixTransform = this.matrix.getValueDirect();
    this.updateMatrix = true;

    this.matrix.addModifiedCB(Transform_MatrixModifiedCB, this);

    this.registerAttribute(this.matrix, "matrix");
}

Transform.prototype.clone = function(src)
{
    this.matrix = src.matrix.clone();
    this.updateMatrix = src.updateMatrix;
}

Transform.prototype.update = function(params, visitChildren)
{
    if (this.updateMatrix)
    {
        this.updateMatrix = false;

        this.matrixTransform = this.matrix.getValueDirect();
    }
    
    // call base-class implementation
    SGNode.prototype.update.call(this, params, visitChildren);
}

Transform.prototype.apply = function(directive, params, visitChildren)
{
    if (!this.enabled.getValueDirect())
    {
        // call base class implementation
        SGNode.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }
    
    params.worldMatrix = params.worldMatrix.leftMultiply(this.matrixTransform);
            
    switch (directive)
    {
        case "render":
        {
            params.worldMatrix = this.matrixTransform.multiply(params.worldMatrix);
            this.applyTransform();
        }
        break;
         
        case "rayPick":
        case "bbox":
        case "collide":
        case "highlight":
        {
            params.worldMatrix = this.matrixTransform.multiply(params.worldMatrix);
        }
        break;
        
        default:
            break;
    }

    // call base class implementation
    SGNode.prototype.apply.call(this, directive, params, visitChildren);
}

Transform.prototype.applyTransform = function()
{
    // set transformation matrix
    this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
    this.graphMgr.renderContext.leftMultMatrix(this.matrixTransform);
    this.graphMgr.renderContext.applyModelViewTransform();
}

function Transform_MatrixModifiedCB(attribute, container)
{
    container.updateMatrix = true;
    container.incrementModificationCount();
}


QuaternionRotate.prototype = new Transform();
QuaternionRotate.prototype.constructor = QuaternionRotate;

function QuaternionRotate()
{
    Transform.call(this);
    this.className = "QuaternionRotate";
    this.attrType = eAttrType.QuaternionRotate;

    this.rotationQuat = new QuaternionAttr(1, 0, 0, 0);
    this.rotation = new Vector3DAttr(0, 0, 0);
    this.updateRotationQuat = true;

    this.rotationQuat.addModifiedCB(QuaternionRotate_RotationQuatModifiedCB, this);

    this.registerAttribute(this.rotationQuat, "rotationQuat");
    this.registerAttribute(this.rotation, "rotation");
}

QuaternionRotate.prototype.update = function(params, visitChildren)
{
    if (this.updateRotationQuat)
    {
        this.updateRotationQuat = false;

        var q = this.rotationQuat.getValueDirect();

        var matrix = q.getMatrix();
        this.matrix.setValueDirect(matrix);

        var rotation = matrix.getRotationAngles();
        this.rotation.setValueDirect(rotation.x, rotation.y, rotation.z);
        
        //console.debug("QuaternionRotate: rotation " + rotation.x + ", " + 
        //rotation.y + ", " + rotation.z);
    }

    // call base-class implementation
    Transform.prototype.update.call(this, params, visitChildren);
}

QuaternionRotate.prototype.apply = function(directive, params, visitChildren)
{
    if (!this.enabled.getValueDirect())
    {
        // call base-class implementation
        Transform.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    // call base-class implementation
    Transform.prototype.apply.call(this, directive, params, visitChildren);
}

function QuaternionRotate_RotationQuatModifiedCB(attribute, container)
{
    container.updateRotationQuat = true;
    container.incrementModificationCount();
}
Rotate.prototype = new Transform();
Rotate.prototype.constructor = Rotate;

function Rotate()
{
    Transform.call(this);
    this.className = "Rotate";
    this.attrType = eAttrType.Rotate;
    
    this.rotation = new Vector3DAttr(0, 0, 0);
    this.updateRotation = true;
    
    this.rotation.addModifiedCB(Rotate_RotationModifiedCB, this);
	
    this.registerAttribute(this.rotation, "rotation");
}

Rotate.prototype.update = function(params, visitChildren)
{
    if (this.updateRotation)
    {
        this.updateRotation = false;

        var r = this.rotation.getValueDirect();

        var matrix = new Matrix4x4()
        matrix.loadXYZAxisRotation(r.x, r.y, r.z);
        this.matrix.setValueDirect(matrix);
    }

    // call base-class implementation
    Transform.prototype.update.call(this, params, visitChildren);
}

Rotate.prototype.apply = function(directive, params, visitChildren)
{
    if (!this.enabled.getValueDirect())
    {
        // call base-class implementation
        Transform.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    // call base-class implementation
    Transform.prototype.apply.call(this, directive, params, visitChildren);
}

function Rotate_RotationModifiedCB(attribute, container)
{
    container.updateRotation = true;
    container.incrementModificationCount();
}
Scale.prototype = new Transform();
Scale.prototype.constructor = Scale;

function Scale()
{
    Transform.call(this);
    this.className = "Scale";
    this.attrType = eAttrType.Scale;
    
    this.scale = new Vector3DAttr(1, 1, 1);
    this.updateScale = true;
    
    this.scale.addModifiedCB(Scale_ScaleModifiedCB, this);
	
    this.registerAttribute(this.scale, "scale");
}

Scale.prototype.update = function(params, visitChildren)
{
    if (this.updateScale)
    {
        this.updateScale = false;

        var s = this.scale.getValueDirect();

        var matrix = new Matrix4x4();
        matrix.loadScale(s.x, s.y, s.z);
        this.matrix.setValueDirect(matrix);
    }

    // call base-class implementation
    Transform.prototype.update.call(this, params, visitChildren);
}

Scale.prototype.apply = function(directive, params, visitChildren)
{
    if (!this.enabled.getValueDirect())
    {
        // call base-class implementation
        Transform.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    // call base-class implementation
    Transform.prototype.apply.call(this, directive, params, visitChildren);
}

function Scale_ScaleModifiedCB(attribute, container)
{
    container.updateScale = true;
    container.incrementModificationCount();
}
Translate.prototype = new Transform();
Translate.prototype.constructor = Translate;

function Translate()
{
    Transform.call(this);
    this.className = "Translate";
    this.attrType = eAttrType.Translate;
    
    this.translation = new Vector3DAttr(0, 0, 0);
    this.updateTranslation = true;
    
    this.translation.addModifiedCB(Translate_TranslationModifiedCB, this);
	
    this.registerAttribute(this.translation, "translation");
}

Translate.prototype.update = function(params, visitChildren)
{
    if (this.updateTranslation)
    {
        this.updateTranslation = false;

        var t = this.translation.getValueDirect();

        var matrix = new Matrix4x4();
        matrix.loadTranslation(t.x, t.y, t.z);
        this.matrix.setValueDirect(matrix);
    }

    // call base-class implementation
    Transform.prototype.update.call(this, params, visitChildren);
}

Translate.prototype.apply = function(directive, params, visitChildren)
{
    if (!this.enabled.getValueDirect())
    {
        // call base-class implementation
        Transform.prototype.apply.call(this, directive, params, visitChildren);
        return;
    }

    // call base-class implementation
    Transform.prototype.apply.call(this, directive, params, visitChildren);
}

function Translate_TranslationModifiedCB(attribute, container)
{
    container.updateTranslation = true;
    container.incrementModificationCount();
}
MultiTargetObserver.prototype = new Evaluator();
MultiTargetObserver.prototype.constructor = MultiTargetObserver;

function MultiTargetObserver()
{
    Evaluator.call(this);
    this.className = "MultiTargetObserver";
    this.attrType = eAttrType.MultiTargetObserver;
    
    this.targetPosition = [];
    
    this.targets = new NumberAttr(0);
    this.position = new Vector3DAttr(0, 0, 0);
    this.distanceFromFirstTarget = new NumberAttr(0);
	this.affectPitch = new BooleanAttr(true);
	this.affectHeading = new BooleanAttr(true);
	this.resultPosition = new Vector3DAttr(0, 0, 0);
    this.resultPitch = new NumberAttr(0);
    this.resultHeading = new NumberAttr(0);

    this.registerAttribute(this.targets, "targets");
    this.registerAttribute(this.position, "position");
    this.registerAttribute(this.distanceFromFirstTarget, "distanceFromFirstTarget");
	this.registerAttribute(this.affectPitch, "affectPitch");
	this.registerAttribute(this.affectHeading, "affectHeading");
    this.registerAttribute(this.resultPosition, "resultPosition");
    this.registerAttribute(this.resultPitch, "resultPitch");
    this.registerAttribute(this.resultHeading, "resultHeading");
}

MultiTargetObserver.prototype.setNumberOfTargets = function(targets)
{
	// if targets are already registered, then unregister them
    var oldTargets = this.targets.getValueDirect();
	if (oldTargets > 0)
	{
		for (var i=0; i < oldTargets; i++)
        {
            this.unregisterAttribute(this.targetPosition[i]);
        }
	}

    this.targets.setValueDirect(targets);

    // allocate dynamic inputs
    if (targets > 0)
    {
        this.targetPosition.length = targets;
        
        for (var i=0; i < targets; i++)
        {
        	this.targetPosition[i] = new Vector3DAttr(0, 0, 0);
			this.registerAttribute(this.targetPosition[i], "targetPosition" + i);
        }
    }
}

MultiTargetObserver.prototype.evaluate = function()
{
    if (!(this.enabled.getValueDirect()))
	{
		return;
	}

    // if no targets, nothing to do
    if (this.targets.getValueDirect() == 0)
    {
        return;
    }

    // get input values

    // get observer and target positions
    var observerAndTarget = this.getObserverAndTargetPositions();
    var observer = observerAndTarget.observer;
    var target = observerAndTarget.target;

    // calculate target direction vector (vector from observer position to target position)
    var targetDirection = new Vector3D(target.x - observer.x,
                               		   target.y - observer.y,
                               		   target.z - observer.z);

    // get heading and pitch angles from target direction vector
    var targetDirHeading, targetDirPitch;
    var hp = XYZtoHP(targetDirection.x, targetDirection.y, targetDirection.z);
    var targetDirHeading = hp.heading;
    var targetDirPitch = hp.pitch;

    var pitch = 0;
	if (this.affectPitch.getValueDirect() == true)
	{
		pitch = -toDegrees(targetDirPitch);
	}

    var heading = 0;
	if (this.affectHeading.getValueDirect() == true)
	{
		heading = -toDegrees(targetDirHeading);
	}

    // output result
    var values = [observer.x, observer.y, observer.z];
    this.resultPosition.setValue(values);

    if (this.affectPitch.getValueDirect() == true)
    {
    	this.resultPitch.setValueDirect(pitch);
    }

    if (this.affectHeading.getValueDirect() == true)
    {
        this.resultHeading.setValueDirect(heading);
    }
}

MultiTargetObserver.prototype.getObserverAndTargetPositions = function()
{
	var observer, target;
	
    switch (this.targets.getValueDirect())
    {
    case 0:
        {
            observer = new Vector3D(0, 0, 0);
            target = new Vector3D(0, 0, 0);
        }
        break;

    case 1:
        {
            observer = this.position.getValueDirect();
            target = this.targetPosition[0].getValueDirect();
        }
        break;

    case 2:
        {
            var target1 = this.targetPosition[0].getValueDirect();
            var target2 = this.targetPosition[1].getValueDirect();

            var distance = this.distanceFromFirstTarget.getValueDirect();

            // get line direction from target2 to target1
            var lineDir = Normalize(target1 - target2);

            // calculate observer's position as target1's position + lineDir scaled by distance
            observer = lineDir * distance + target1;

            // if distance is 0, observer's position will equal target1's position,
            // so use target1 - lineDir as target's position
            if (distance == 0)
            {
                target = target1 - lineDir;
            }
            else
            {
                target = target1;
            }
        }
        break;

    default: // > 2 targets (currently unsupported)
        {
            observer = new Vector3D(0, 0, 0);
            target = Vector3D(0, 0, 0);
        }
        break;
    }
    
    return { observer: observer, target: target };
}
SerializeParams.prototype = new DirectiveParams();
SerializeParams.prototype.constructor = SerializeParams();

function SerializeParams()
{
    DirectiveParams.call(this);
    
    this.serialized = null;
}

SerializeDirective.prototype = new SGDirective();
SerializeDirective.prototype.constructor = SerializeDirective;

function SerializeDirective()
{
    SGDirective.call(this);
    
    this.className = "SerializeDirective";
    this.attrType = eAttrType.SerializeDirective;

    this.serialized = null;
}

SerializeDirective.prototype.execute = function(root)
{
    if (!root)
    {
		return;
	}

    // clear serialize string
    this.serialized = null;

    // setup serialize params structure
    var params = new SerializeParams();
    params.serialized = new String();

    // apply serialize directive
    root.apply("serialize", params, true);

	this.serialized = params.serialized;

    return;
}


CollideParams.prototype = new DirectiveParams();
CollideParams.prototype.constructor = CollideParams();

function CollideParams()
{
    DirectiveParams.call(this);

    this.viewSpace = false;
    this.viewMatrix = new Matrix4x4();
    this.worldMatrix = new Matrix4x4();
    this.detectCollisions = new Array();
}

function CollideRec(model, tree)
{
    this.model = model;
    this.tree = tree;    
}

CollideDirective.prototype = new SGDirective();
CollideDirective.prototype.constructor = CollideDirective;

function CollideDirective()
{
    SGDirective.call(this);
    this.className = "CollideDirective";
    this.attrType = eAttrType.CollideDirective;

    this.name.setValueDirect("CollideDirective");
}

CollideDirective.prototype.execute = function(root)
{
    root = root || this.rootNode.getValueDirect();

    // setup collision Detect params structure
    var params = new CollideParams();

    // get list of models for collision detection
    root.apply("collide", params, true);
    
    // detect collisions
    this.detectCollisions(params.detectCollisions);
}

CollideDirective.prototype.detectCollisions = function(collideRecs)
{
    var models = [];
    var trees = [];
    var collisions = [];
    
    for (var i in collideRecs)
    {
        models.push(collideRecs[i].model);
        trees.push(collideRecs[i].tree);
        collisions.push(false);

        collideRecs[i].model.getAttribute("collisionList").clear();        
    }
    
    for (var i = 0; i < trees.length; i++)
    {
        for (var j = i+1; j < trees.length; j++)
        {
            if (trees[i].collides(trees[j]))
            {
                models[i].getAttribute("collisionList").push_back(models[j]);                
                models[j].getAttribute("collisionList").push_back(models[i]);
                collisions[i] = collisions[j] = true;
            }
        }
    }
    
    for (var i = 0; i < collisions.length; i++)
    {
        models[i].getAttribute("collisionDetected").setValueDirect(collisions[i]);
    }
}
function HighlightTarget()
{
    this.projMatrix = new Matrix4x4();
    this.viewMatrix = new Matrix4x4();
    this.worldMatrix = new Matrix4x4();
    this.camera = null;
    this.viewport = new Viewport();
    this.geometries = new Array();
    this.center = new Vector3D();
    this.highlightColor_r = 0;
    this.highlightColor_g = 0;
    this.highlightColor_b = 0;
    this.highlightColor_a = 0;
    this.highlightWidth = 0;
};

HighlightParams.prototype = new DirectiveParams();
HighlightParams.prototype.constructor = HighlightParams();

function HighlightParams()
{
    DirectiveParams.call(this);

    this.projMatrix = new Matrix4x4();
    this.viewMatrix = new Matrix4x4();
    this.worldMatrix = new Matrix4x4();
    this.camera = null;
    this.viewport = new Viewport();
    this.targets = new Array();
}

HighlightDirective.prototype = new SGDirective();
HighlightDirective.prototype.constructor = HighlightDirective;

function HighlightDirective()
{
    SGDirective.call(this);
    this.className = "HighlightDirective";
    this.attrType = eAttrType.HighlightDirective;

    this.vertexBuffer = null;
    
    this.name.setValueDirect("HighlightDirective");
        
    this.highlightType = new NumberAttr(eHighlightType.None);
    this.highlightColor = new ColorAttr(1, 1, 0, 1);
    this.highlightWidth = new NumberAttr(5);
    
    this.highlightColor.addModifiedCB(HighlightDirective_HighlightColorModifiedCB, this);
    
    this.registerAttribute(this.highlightType, "highlightType");
    this.registerAttribute(this.highlightColor, "highlightColor");
    this.registerAttribute(this.highlightWidth, "highlightWidth");
}

HighlightDirective.prototype.setGraphMgr = function(graphMgr)
{
    // call base-class implementation
    SGDirective.prototype.setGraphMgr.call(this, graphMgr);
    
    this.initHighlightSquareVB();
}

HighlightDirective.prototype.execute = function(root)
{
    root = root || this.rootNode.getValueDirect();

    // setup collision Detect params structure
    var params = new HighlightParams();

    // get list of models for collision detection
    root.apply("highlight", params, true);
    
    // draw highlights
    this.drawHighlights(params);
}

HighlightDirective.prototype.drawHighlights = function(params)
{
    // if no targets, return
    if (params.targets.length == 0)
    {
        return;
    }

    // get render engine
    var renderContext = this.graphMgr.renderContext;
    if (!renderContext)
    {
        return;
    } 

    var highlightType = this.highlightType.getValueDirect();

    // for each target
    var up, right, forward;
    for (var i=0; i < params.targets.length; i++)
    {
        var target = params.targets[i];

        // get camera direction vectors
        var directions = target.camera.getDirectionVectors();
        up = directions.up;
        right = directions.right;
        forward = directions.forward;

        var wupp = this.getWorldUnitsPerPixel(target.center, target.worldMatrix, target.viewMatrix, target.camera, target.viewport);
        var highlightWidth = target.highlightWidth * wupp;

        // clear stencil buffer
        renderContext.clearStencil(0);
        renderContext.clear(RC_STENCIL_BUFFER_BIT);

        // increment stencil for geometry in delta positions
        var worldViewMatrix;
        for (var j=0; j < target.geometries.length; j++)
        {
            switch (highlightType)
            {
            case eHighlightType.FourPass:
                {
                    for (var pass=0; pass < 4; pass++)
                    {
                        worldViewMatrix = this.getWorldViewMatrix(highlightType, highlightWidth, pass, up, right,
                            forward, target.worldMatrix, target.viewMatrix);
                        this.configureStencil_Target(renderContext, target.geometries[j], target.projMatrix, 
                            worldViewMatrix, eStencilOp.Increment);
                    }
                }
                break;

            case eHighlightType.EightPass:
                {
                    for (var pass=0; pass < 8; pass++)
                    {
                        worldViewMatrix = this.getWorldViewMatrix(highlightType, highlightWidth, pass, up, right,
                            forward, target.worldMatrix, target.viewMatrix);
                        this.configureStencil_Target(renderContext, target.geometries[j], target.projMatrix,
                            worldViewMatrix, eStencilOp.Increment);
                    }
                }
                break;
            }
        }

        // zero stencil for geometry in original position
        worldViewMatrix = target.worldMatrix.multiply(target.viewMatrix);
        for (var j=0; j < target.geometries.length; j++)
        {
            this.configureStencil_Target(renderContext, target.geometries[j], target.projMatrix, worldViewMatrix, eStencilOp.Zero);
        }

        // update highlight color
        this.highlightColor.setValueDirect(target.highlightColor_r, target.highlightColor_g, target.highlightColor_b, target.highlightColor_a);

        // render highlight square
        this.renderHighlightSquare(params, renderContext);
    } 
}

HighlightDirective.prototype.getWorldUnitsPerPixel = function(point, worldMatrix, viewMatrix, camera, viewport)
{
    // get geometry's center in view space
    var worldViewMatrix = worldMatrix.multiply(viewMatrix);
    var centerPtCamSpace = worldViewMatrix.transform(point.x, point.y, point.z, 1);

    // determine the per-pixel width and height at geometry's center in view space
    var perPixel = new Vector2D();
    
    // get camera node type
    switch (camera.attrType)
    {
    case eAttrType.PerspectiveCamera:
        {
            // get zoom
            var zoom = camera.getAttribute("zoom").getValueDirect();
            perPixel = worldUnitsPerPixelPersp(viewport, zoom, centerPtCamSpace.z);
        }
        break;

    case eAttrType.OrthographicCamera:
        {
            // get width
            var width = camera.getAttribute("width").getValueDirect();
            perPixel = worldUnitsPerPixelOrtho(viewport, width);
        }
        break;
        
    default:
        break;
    }
    
    return Math.max(perPixel.x, perPixel.y); 
}

HighlightDirective.prototype.getWorldViewMatrix = function(highlightType, highlightWidth, pass,
                                                           cameraUp, cameraRight, cameraForward,
                                                           world, view)
{
    var degrees = 0;
    switch (highlightType)
    {
    case eHighlightType.FourPass:  degrees = 90; break;
    case eHighlightType.EightPass: degrees = 45; break;
    }

    var rotate = new Matrix4x4();
    rotate.loadZAxisRotation(degrees * pass);
    var delta = rotate.transform(1, 0, 0, 0);
    delta.x *= highlightWidth;
    delta.y *= highlightWidth;
    delta.z *= highlightWidth;

    var translate = new Matrix4x4();
    translate.loadTranslation(cameraRight.x * delta.x + cameraUp.x * delta.y,// + cameraForward.x * delta.z, 
                              cameraRight.y * delta.x + cameraUp.y * delta.y,// + cameraForward.y * delta.z,
                              cameraRight.z * delta.x + cameraUp.z * delta.y);// + cameraForward.z * delta.z);

    return translate.multiply(world.multiply(view));
}

HighlightDirective.prototype.configureStencil_Target = function(renderContext,
                                                               geometry,
                                                               projMatrix,
                                                               worldViewMatrix,
                                                               stencilOp)
{
    // get current render states
    var lastDepthBufferWrite = renderContext.enabled(eRenderMode.DepthBufferWrite);
    var lastStencilTest = renderContext.enabled(eRenderMode.StencilTest);
    var lastAlphaBlend = renderContext.enabled(eRenderMode.AlphaBlend);

    // disable z-buffer writes (note: z-testing still occurs), and enable the
    // stencil-buffer
    renderContext.setEnabled(eRenderMode.DepthBufferWrite, false);
    renderContext.setEnabled(eRenderMode.StencilTest, true);

    // set depth function
    renderContext.setDepthFunc(eDepthFunc.LessEqual);

    // disable smooth shading
    renderContext.setShadeModel(eShadeModel.Flat);

    // set up stencil compare fuction, reference value, and masks.
    // stencil test passes if ((ref & mask) cmpfn (stencil & mask)) is true.
    renderContext.setStencilFunc(eStencilFunc.Always, 0, 0xFF);
    renderContext.setStencilMask(0xFF);

    // if depth-test passes, increment stencil buffer value
    renderContext.setStencilOp(eStencilOp.Keep, stencilOp, stencilOp);

    // make sure that no pixels get drawn to the frame buffer
    renderContext.setEnabled(eRenderMode.AlphaBlend, true);
    renderContext.setBlendFactor(RC_ZERO, RC_ONE);

    // draw geometry in stencil only
    renderContext.setMatrixMode(RC_PROJECTION);
    renderContext.pushMatrix();
    renderContext.loadMatrix(projMatrix);
    renderContext.applyProjectionTransform();
    renderContext.setMatrixMode(RC_MODELVIEW);
    renderContext.pushMatrix();
    renderContext.loadMatrix(worldViewMatrix);
    renderContext.applyModelViewTransform();
    geometry.drawPrimitives();
    renderContext.setMatrixMode(RC_PROJECTION);
    renderContext.popMatrix();
    renderContext.setMatrixMode(RC_MODELVIEW);
    renderContext.popMatrix();

    // restore render states
    renderContext.setEnabled(eRenderMode.DepthBufferWrite, lastDepthBufferWrite);
    renderContext.setEnabled(eRenderMode.StencilTest, lastStencilTest);
    renderContext.setDepthFunc(eDepthFunc.LessEqual);
    renderContext.setShadeModel(eShadeModel.Gouraud);
    renderContext.setEnabled(eRenderMode.AlphaBlend, lastAlphaBlend);
}
     
HighlightDirective.prototype.renderHighlightSquare = function(params, renderContext)
{
    // get current render states
    var lastDepthTest = renderContext.enabled(eRenderMode.DepthTest);
    var lastStencilTest = renderContext.enabled(eRenderMode.StencilTest);
    var lastAlphaBlend = renderContext.enabled(eRenderMode.AlphaBlend);
    var lastLighting = renderContext.enabled(eRenderMode.Lighting);

    // set render states
    renderContext.setDepthFunc(eDepthFunc.LessEqual);
    renderContext.setEnabled(eRenderMode.DepthTest, false);
    renderContext.setEnabled(eRenderMode.StencilTest, true);
    renderContext.setEnabled(eRenderMode.AlphaBlend, true);
    renderContext.setEnabled(eRenderMode.Lighting, false);
    renderContext.setBlendFactor(RC_SRC_ALPHA, RC_ONE_MINUS_SRC_ALPHA);

    // only write where stencil val <= 1 (count indicates # of target fragments that
    // overlap that pixel)
    renderContext.setStencilFunc(eStencilFunc.LessEqual, 1, 0xFF);
    renderContext.setStencilOp(eStencilOp.Keep, eStencilOp.Keep, eStencilOp.Keep); 

    // draw the highlight square
    var m = new Matrix4x4();
    m.loadIdentity();
    renderContext.setMatrixMode(RC_PROJECTION);
    renderContext.pushMatrix();
    renderContext.loadMatrix(m);
    renderContext.applyProjectionTransform();
    renderContext.setMatrixMode(RC_MODELVIEW);
    renderContext.pushMatrix();
    renderContext.loadMatrix(m);
    renderContext.applyModelViewTransform();
    this.vertexBuffer.draw();
    renderContext.popMatrix();
    renderContext.setMatrixMode(RC_PROJECTION);
    renderContext.popMatrix();

    // restore render states
    renderContext.setDepthFunc(eDepthFunc.LessEqual);
    renderContext.setEnabled(eRenderMode.DepthTest, lastDepthTest);
    renderContext.setEnabled(eRenderMode.StencilTest, lastStencilTest);
    renderContext.setEnabled(eRenderMode.AlphaBlend, lastAlphaBlend);
    renderContext.setEnabled(eRenderMode.Lighting, lastLighting);
    renderContext.setMatrixMode(RC_MODELVIEW);
}
                                      
HighlightDirective.prototype.initHighlightSquareVB = function()
{
    this.vertexBuffer = this.graphMgr.renderContext.createVertexBuffer(3);
    this.vertexBuffer.setPrimitiveType(RC_TRIANGLE_STRIP);
    
    var vertices = [ -1, -1,  1,
                     -1,  1,  1,
                      1, -1,  1,
                      1,  1,  1 ];

    var normals = [ 0,  0, -1,
                    0,  0, -1,
                    0,  0, -1,
                    0,  0, -1 ];
             
    var color = this.highlightColor.getValueDirect();       
    var colors = [ color.r, color.g, color.b, color.a,
                   color.r, color.g, color.b, color.a,
                   color.r, color.g, color.b, color.a,
                   color.r, color.g, color.b, color.a ];
                    
    this.vertexBuffer.setVertices(vertices);
    this.vertexBuffer.setNormals(normals);
    this.vertexBuffer.setColors(colors);
}

HighlightDirective.prototype.highlightColorModified = function()
{
    if (this.vertexBuffer)
    {
        var color = this.highlightColor.getValueDirect();       
        var colors = [ color.r, color.g, color.b, color.a,
                       color.r, color.g, color.b, color.a,
                       color.r, color.g, color.b, color.a,
                       color.r, color.g, color.b, color.a ];

        this.vertexBuffer.setColors(colors);
    }
}

function HighlightDirective_HighlightColorModifiedCB(attribute, container)
{
    container.highlightColorModified();
}

var OBJECTMOTION_PAN_BIT		= 0x001;
var OBJECTMOTION_LINEAR_BIT     = 0x002;
var OBJECTMOTION_ANGULAR_BIT    = 0x004;
var OBJECTMOTION_SCALAR_BIT     = 0x008;
var OBJECTMOTION_ALL_BITS		= 0x00F;

function ObjectMotionDesc()
{
	this.validMembersMask = OBJECTMOTION_ALL_BITS;
	this.panVelocity = new Vector3D(0, 0, 0);
	this.linearVelocity = new Vector3D(0, 0, 0);
	this.angularVelocity = new Vector3D(0, 0, 0);
	this.scalarVelocity = new Vector3D(0, 0, 0);
	this.duration = 0; // seconds
	this.stopOnCollision = true;
	this.reverseOnCollision = false;
}

ObjectMover.prototype = new Evaluator();
ObjectMover.prototype.constructor = ObjectMover;

function ObjectMover()
{
    Evaluator.call(this);
    this.className = "ObjectMover";
    this.attrType = eAttrType.ObjectMover;

    this.targetObject = null;
    this.motionQueue = new Queue();
    this.activeDuration = 0;

    this.target = new StringAttr("");
    this.timeIncrement = new NumberAttr(0);
    this.linearSpeed = new NumberAttr(0); // meters/sec
    this.angularSpeed = new NumberAttr(0); // degrees/sec
    this.panVelocity = new Vector3DAttr();
    this.linearVelocity = new Vector3DAttr();
    this.angularVelocity = new Vector3DAttr();
    this.scalarVelocity = new Vector3DAttr();

    this.enabled.addModifiedCB(ObjectMover_EnabledModifiedCB, this);
    this.target.addModifiedCB(ObjectMover_TargetModifiedCB, this);

    this.registerAttribute(this.target, "target");
    this.registerAttribute(this.timeIncrement, "timeIncrement");
    this.registerAttribute(this.linearSpeed, "linearSpeed");
    this.registerAttribute(this.angularSpeed, "angularSpeed");
}

ObjectMover.prototype.onUnregister = function()
{
    this.motionQueue.clear();
    this.panVelocity.setValueDirect(0, 0, 0);
    this.linearVelocity.setValueDirect(0, 0, 0);
    this.angularVelocity.setValueDirect(0, 0, 0);
    this.scalarVelocity.setValueDirect(0, 0, 0);
}

ObjectMover.prototype.evaluate = function()
{
	// time
    var timeIncrement = this.timeIncrement.getValueDirect();
    
    this.updateActiveMotion(timeIncrement);

    this.setMotion(this.activeMotion);
}

ObjectMover.prototype.setMotion = function(motion)
{
    if (motion.validMembersMask & OBJECTMOTION_PAN_BIT)
    {
        this.panVelocity.setValueDirect(motion.panVelocity.x, 
                                        motion.panVelocity.y, 
                                        motion.panVelocity.z);
    }
    
    if (motion.validMembersMask & OBJECTMOTION_LINEAR_BIT)
    {                       
        this.linearVelocity.setValueDirect(motion.linearVelocity.x, 
                                           motion.linearVelocity.y, 
                                           motion.linearVelocity.z);
    }
        
    if (motion.validMembersMask & OBJECTMOTION_ANGULAR_BIT)
    {                              
        this.angularVelocity.setValueDirect(motion.angularVelocity.x, 
                                            motion.angularVelocity.y, 
                                            motion.angularVelocity.z);
    }
        
    if (motion.validMembersMask & OBJECTMOTION_SCALAR_BIT)
    {                               
        this.scalarVelocity.setValueDirect(motion.scalarVelocity.x, 
                                           motion.scalarVelocity.y, 
                                           motion.scalarVelocity.z);
    }
}

ObjectMover.prototype.updateActiveMotion = function(timeIncrement)
{
	if (!this.activeMotion ||
		 this.activeDuration >= this.activeMotion.duration)
    {
       	this.activeDuration = 0;
    	this.activeMotion = this.motionQueue.front() || new ObjectMotionDesc();
    	this.motionQueue.pop();
    }  
     
    this.activeDuration += timeIncrement;
}

ObjectMover.prototype.connectTarget = function(target)
{
	this.panVelocity.removeAllTargets();
	this.linearVelocity.removeAllTargets();
	this.angularVelocity.removeAllTargets();
	this.scalarVelocity.removeAllTargets();
	
	if (target)
	{
		this.panVelocity.addTarget(target.getAttribute("panVelocity"));
		this.linearVelocity.addTarget(target.getAttribute("linearVelocity"));
		this.angularVelocity.addTarget(target.getAttribute("angularVelocity"));
		this.scalarVelocity.addTarget(target.getAttribute("scalarVelocity"));	
		target.getAttribute("collisionDetected").addModifiedCB(ObjectMover_TargetCollisionDetectedModifiedCB, this);
	}
	
	this.targetObject = target;
}

ObjectMover.prototype.collisionDetected = function()
{
}

function ObjectMover_EnabledModifiedCB(attribute, container)
{
    var enabled = attribute.getValueDirect();
    if (!enabled)
    {
        container.motionQueue.clear();
        container.panVelocity.setValueDirect(0, 0, 0);
        container.linearVelocity.setValueDirect(0, 0, 0);
        container.angularVelocity.setValueDirect(0, 0, 0);
        container.scalarVelocity.setValueDirect(0, 0, 0);
    }
}

function ObjectMover_TargetModifiedCB(attribute, container)
{
	var target = attribute.getValueDirect().join("");
    var resource = container.registry.find(target);
    if (resource)
    {
    	container.connectTarget(resource);
    }
}

function ObjectMover_TargetCollisionDetectedModifiedCB(attribute, container)
{
    var collisionDetected = attribute.getValueDirect();
    if (collisionDetected)
    {
        container.collisionDetected(attribute.getContainer().getAttribute("collisionList"));
    }
}

var ANIMALMOVER_MAX_QUEUE_LENGTH	= 2;

AnimalMover.prototype = new ObjectMover();
AnimalMover.prototype.constructor = AnimalMover;

function AnimalMover()
{
    ObjectMover.call(this);
    this.className = "AnimalMover";
    this.attrType = eAttrType.AnimalMover;
}

AnimalMover.prototype.evaluate = function()
{
	if (this.motionQueue.length() < ANIMALMOVER_MAX_QUEUE_LENGTH)
	{
		var motion = new ObjectMotionDesc();
		motion.duration = FLT_MAX;
		motion.panVelocity = new Vector3D(0, 0, this.linearSpeed.getValueDirect());
		
		this.motionQueue.push(motion);
	}
	
	// call base-class implementation
	ObjectMover.prototype.evaluate.call(this);
}

AnimalMover.prototype.collisionDetected = function(collisionList)
{   
    this.activeMotion = null;
    this.motionQueue.clear();
    
    var turn = new ObjectMotionDesc();
    turn.duration = 1 / this.angularSpeed.getValueDirect();
    turn.angularVelocity = new Vector3D(0, this.angularSpeed.getValueDirect(), 0);
        
    this.motionQueue.push(turn);
      
    var walk = new ObjectMotionDesc();
    walk.duration = 1 / this.linearSpeed.getValueDirect();
    walk.panVelocity = new Vector3D(0, 0, this.linearSpeed.getValueDirect());
        
    this.motionQueue.push(walk);
}

Cube.prototype = new TriList();
Cube.prototype.constructor = Cube;

function Cube()
{
    TriList.call(this);
    this.className = "Cube";
    this.attrType = eAttrType.Cube;
    
    this.updateTriList = true; // update once
    
    this.transform = new Matrix4x4();
    this.updateTransform = false;
    
    this.materialNode = new Material();
    this.updateMaterial = false;
    
    this.color = new ColorAttr(1, 1, 1, 1);
    this.opacity = new NumberAttr(1);
    this.position = new Vector3DAttr(0, 0, 0);
    this.rotation = new Vector3DAttr(0, 0, 0);
    this.scale = new Vector3DAttr(1, 1, 1);
    
    this.color.addModifiedCB(Cube_MaterialModifiedCB, this);
    this.opacity.addModifiedCB(Cube_MaterialModifiedCB, this);
    this.position.addModifiedCB(Cube_PositionModifiedCB, this);
    this.rotation.addModifiedCB(Cube_RotationModifiedCB, this);
    this.scale.addModifiedCB(Cube_ScaleModifiedCB, this);
    
    this.registerAttribute(this.color, "color");
    this.registerAttribute(this.opacity, "opacity");
    this.registerAttribute(this.position, "position");
    this.registerAttribute(this.rotation, "rotation");
    this.registerAttribute(this.scale, "scale");
    
    var vertices = 
    [
        -0.25, -0.25, 0.25, -0.25, 0.25, 0.25, -0.25, 0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, 0.25, -0.25, 0.25, -0.25,
        0.25, -0.25, -0.25, 0.25, -0.25, 0.25, -0.25, -0.25, 0.25, -0.25, -0.25, -0.25, 0.25, -0.25, -0.25, -0.25, -0.25, 0.25,
        0.25, -0.25, -0.25, -0.25, 0.25, -0.25, 0.25, 0.25, -0.25, 0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, 0.25, -0.25,
        0.25, -0.25, 0.25, 0.25, 0.25, -0.25, 0.25, 0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, 0.25, -0.25, 0.25,
        0.25, 0.25, -0.25, -0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, -0.25, -0.25, 0.25, -0.25, -0.25, 0.25, 0.25,
        0.25, -0.25, 0.25, 0.25, 0.25, 0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, 0.25, -0.25, 0.25, 0.25
    ];
    
    var normals =
    [
        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
        0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
        0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
        1, -0, 0, 1, -0, 0, 1, -0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
        0, 1, -0, 0, 1, -0, 0, 1, -0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        0, -0, 1, 0, -0, 1, 0, -0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1
    ];
    
    this.vertices.setValue(vertices);
    this.normals.setValue(normals);
    
    this.color.addTarget(this.materialNode.getAttribute("color"));
    this.opacity.addTarget(this.materialNode.getAttribute("opacity"));
}

Cube.prototype.setGraphMgr = function(graphMgr)
{
    // call base-class implementation
    TriList.prototype.setGraphMgr.call(this, graphMgr);

    this.materialNode.setGraphMgr(graphMgr);
}
            
Cube.prototype.update = function(params, visitChildren)
{
    if (this.updateTransform)
    {
        this.updateTransform = false;
 
        var position = this.position.getValueDirect();
        var translationMatrix = new Matrix4x4();
        translationMatrix.loadTranslation(position.x, position.y, position.z);
        
        var rotation = this.rotation.getValueDirect();
        var rotationMatrix = new Matrix4x4();
        rotationMatrix.loadXYZAxisRotation(rotation.x, rotation.y, rotation.z);
        
        var scale = this.scale.getValueDirect();
        var scaleMatrix = new Matrix4x4();
        scaleMatrix.loadScale(scale.x, scale.y, scale.z);
        
        this.transform.loadMatrix(scaleMatrix.multiply(rotationMatrix.multiply(translationMatrix)));
    }
    
    if (this.updateMaterial)
    {
        this.updateMaterial = false;       
        this.materialNode.update(params, visitChildren);
    }

    if (this.updateTriList)
    {
        this.updateTriList = false;
        TriList.prototype.update.call(this, params, visitChildren);
    }
}

Cube.prototype.apply = function(directive, params, visitChildren)
{
    var show = this.show.getValueDirect();
    var enabled = this.enabled.getValueDirect();
    if (!show || !enabled)
    {
        return;
    }
    
    switch (directive)
    {
        case "render":
            {
                this.materialNode.apply(directive, params, visitChildren);
                this.draw(params.dissolve);
            }
            break;
    }
}

Cube.prototype.draw = function(dissolve)
{
    this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
    this.graphMgr.renderContext.pushMatrix();

    this.graphMgr.renderContext.leftMultMatrix(this.transform);
    this.graphMgr.renderContext.applyModelViewTransform();
    
    // draw primitives
    this.vertexBuffer.draw();
    
    this.graphMgr.renderContext.setMatrixMode(RC_MODELVIEW);
    this.graphMgr.renderContext.popMatrix();
    this.graphMgr.renderContext.applyModelViewTransform();
}

function Cube_PositionModifiedCB(attribute, container)
{
    container.updateTransform = true;
}

function Cube_RotationModifiedCB(attribute, container)
{
    container.updateTransform = true;
}

function Cube_ScaleModifiedCB(attribute, container)
{
    container.updateTransform = true;
}

function Cube_MaterialModifiedCB(attribute, container)
{
    container.updateMaterial = true;
}
var eEventType = {
    Unknown                     :-1,
    
    Render_First                :0,
    RenderBegin                 :1,
    RenderEnd                   :2,
    Render_End                  :9,
    
    Mouse_First                 :100,
    MouseMove                   :101,
    MouseDown                   :102,
    MouseLeftDown               :103,
    MouseMiddleDown             :104,
    MouseRightDown              :105,
    MouseAllDown                :106,
    MouseBothDown               :107,
    MouseWheelDown              :108,
    MouseUp                     :109,
    MouseLeftUp                 :110,
    MouseRightUp                :111,
    MouseMiddleUp               :112,
	MouseWheelUp                :113,
	MouseLeftClick              :114,
	MouseMiddleClick            :115,
	MouseRightClick             :116,
    MouseLeftDblClick           :117,
	MouseMiddleDblClick         :118,
    MouseRightDblClick          :119,
    MouseDrag                   :120,
    MouseWheelForward           :121,
    MouseWheelBackward          :122,
	MouseHover                  :123,
	MouseLeave                  :124,	// fires when the mouse leaves the client area of the window
	MouseOver                   :125,	// fires when the mouse is moved onto an element
	MouseOut                    :126,	// fires when the mouse is moved off an element
    Mouse_Last                  :199,

    Key_First                   :200,
    Key_Down                    :201,
    Key_Up                      :202,
    Key_Last                    :299,
    
    Element_First               :700,
    ElementSelected             :701,
    ElementUnselected           :702,
    ElementFocus                :703,
    ElementBlur                 :704,
    Element_Last                :799,
    
    UserDefined                 :2000
};

var eEventNameMap = {
    "MButton1"                  : eEventType.MouseLeftDown,
    "MButton1.Down"             : eEventType.MouseLeftDown,
    "MButton2"                  : eEventType.MouseMiddleDown,
    "MButton2.Down"             : eEventType.MouseMiddleDown,
    "MButton3"                  : eEventType.MouseRightDown,
    "MButton3.Down"             : eEventType.MouseRightDown,
    "MButton1+MButton2.Down"    : eEventType.MouseBothDown,
	"MButton2+MButton3.Down"    : eEventType.MouseBothDown,
	"MButton1+MButton3.Down"    : eEventType.MouseBothDown,
    "MButton1.Click"            : eEventType.MouseLeftClick,
	"MButton1.DoubleClick"      : eEventType.MouseLeftDblClick,
	"MButton1.Up"               : eEventType.MouseLeftUp,
    "MButton2.Click"            : eEventType.MouseMiddleClick,
	"MButton2.DoubleClick"      : eEventType.MouseMiddleDblClick,
	"MButton2.Up"               : eEventType.MouseMiddleUp,
	"MButton3.Click"            : eEventType.MouseRightClick,
	"MButton3.DoubleClick"      : eEventType.MouseRightDblClick,
	"MButton3.Up"               : eEventType.MouseRightUp,
    "MWheel"                    : eEventType.MouseWheelDown,
	"MWheel.Down"               : eEventType.MouseWheelDown,
    "MWheel.Click"              : eEventType.MouseWheelUp,
	"MWheel.Up"                 : eEventType.MouseWheelUp,
	"Mouse.Move"                : eEventType.MouseMove,
	"Mouse.Hover"               : eEventType.MouseHover,
	"Mouse.Leave"               : eEventType.MouseLeave,
	"Mouse.Over"                : eEventType.MouseOver,
	"Mouse.Out"                 : eEventType.MouseOut,
	"Element.Selected"          : eEventType.ElementSelected,
	"Element.Unselected"        : eEventType.ElementUnselected,
	"Element.Focus"             : eEventType.ElementFocus,
	"Element.Blur"              : eEventType.ElementBlur
};

function getEventTypeByName(name)
{
    var type = eEventNameMap[name];
    
    if (type == undefined)
    {
        // TODO  
        type = eEventType.Unknown;      
    }   
    
    return type;
}
Event.prototype = new AttributeContainer();
Event.prototype.constructor = Event;

function Event(type, time, userData)
{
    AttributeContainer.call(this);
    this.className = "Event";
    
    this.type = type || eEventType.Unknown;
    this.time = time || 0;
    this.userData = userData || null;
}

Event.prototype.synchronize = function(src)
{
    this.type = src.type;
    this.time = src.time;
    this.userData = src.userData;
}
InputEvent.prototype = new Event();
InputEvent.prototype.constructor = InputEvent;

function InputEvent(type, time, inputId, modifiers, state, userData)
{
    Event.call(this, type, time, userData);
    this.className = "InputEvent";
    
    this.inputId = inputId || 0;
    this.modifiers = modifiers || 0;
    this.state = state || 0;
}

InputEvent.prototype.synchronize = function(src)
{
	this.inputId = src.inputId;
	this.modifiers = src.modifiers;
	this.state = src.state;

	Event.prototype.synchronize.call(this, src);
}
var MOUSEEVENT_LEFT_BUTTON     = 0x0001;
var MOUSEEVENT_MIDDLE_BUTTON   = 0x0002;
var MOUSEEVENT_RIGHT_BUTTON    = 0x0004;

MouseEvent.prototype = new InputEvent();
MouseEvent.prototype.constructor = MouseEvent;

function MouseEvent(type, time, buttonId, modifiers, state, x, y, userData)
{
    InputEvent.call(this, type, time, buttonId, modifiers, state, userData);
    this.className = "MouseEvent";
    
    this.x = x || 0;
    this.y = y || 0;
}
function MouseEventState()
{
    this.leftButtonDown = false;
    this.middleButtonDown = false;
    this.rightButtonDown = false;
}

EventAdapter.prototype = new AttributeContainer();
EventAdapter.prototype.constructor = EventAdapter;

function EventAdapter()
{
    AttributeContainer.call(this);
    this.className = "EventAdapter";
    
    this.mouseState = new MouseEventState();
    
    this.name = new StringAttr("EventAdapter");
    
    this.registerAttribute(this.name, "name");
}

EventAdapter.prototype.createKeyboardEvent = function(event)
{
    var keyboardEvent = null;//new KeyboardEvent(type, time, buttonId, modifiers, state, x, y);
    return keyboardEvent;
}

EventAdapter.prototype.createMouseEvent = function(event)
{
    var date = new Date();
    
    var type = eEventType.Unknown;
    var time = date.getTime();
    var buttonId = 0;
    var modifiers = 0;  // TODO
    var state = 0;      // TODO
    
    var x = event.canvasX;
    var y = event.canvasY;

    switch (event.type)
    {
    case "click":
        {
            switch (event.button)
            {
            case 0: type = eEventType.MouseLeftClick; break;
            case 1: type = eEventType.MouseMiddleDown; break;
            case 2: type = eEventType.MouseRightClick; break;
            } 
        }
        break;

    case "dblclick":
        {
            switch (event.button)
            {
            case 0: type = eEventType.MouseLeftDblClick; break;
            case 1: type = eEventType.MouseMiddleDblClick; break;
            case 2: type = eEventType.MouseRightDblClick; break;
            }    
        }
        break;
        
    case "mousedown":
        {
            switch (event.button)
            {
            case 0:
                { 
                    if (this.mouseState.rightButtonDown)
                    {
                        type = eEventType.MouseBothDown;
                    }
                    else 
                    {
                        type = eEventType.MouseLeftDown;
                    }
                    this.mouseState.leftButtonDown = true;
                }
                break;
                
            case 1: 
                {
                    type = eEventType.MouseMiddleDown;
                    this.mouseState.middleButtonDown = true;
                }
                break;
                
            case 2: 
                {
                    if (this.mouseState.leftButtonDown)
                    {
                        type = eEventType.MouseBothDown;
                    }
                    else 
                    {
                        type = eEventType.MouseRightDown;
                    }
                    this.mouseState.rightButtonDown = true;
                }
                break;
            }
        }
        break;
      
    case "mouseup":
        {
            switch (event.button)
            {
            case 0:
                { 
                    type = eEventType.MouseLeftUp; 
                    this.mouseState.leftButtonDown = false;
                }
                break;
                
            case 1: 
                {
                    type = eEventType.MouseMiddleUp;
                    this.mouseState.middleButtonDown = false;
                }
                break;
                
            case 2: 
                {
                    type = eEventType.MouseRightUp;
                    this.mouseState.rightButtonDown = false;
                }
                break;
            }
        }
        break;
        
    case "mousemove":
        {
            type = eEventType.MouseMove;
        }
        break;
        
    default:
        {
            type = eEventType.UserDefined; // TEMPTEST (?)
        }
        break;
    }       
    
    // set which buttons are pressed to buttonId
    if (this.mouseState.leftButtonDown)     buttonId |= MOUSEEVENT_LEFT_BUTTON;
    if (this.mouseState.middleButtonDown)   buttonId |= MOUSEEVENT_MIDDLE_BUTTON;
    if (this.mouseState.rightButtonDown)    buttonId |= MOUSEEVENT_RIGHT_BUTTON;
    
    var mouseEvent = new MouseEvent(type, time, buttonId, modifiers, state, x, y);
    
    return mouseEvent;
}
EventListener.prototype = new Agent();
EventListener.prototype.constructor = EventListener;

function EventListener()
{
    Agent.call(this);
    this.className = "EventListener";
    
    this.events = [];
    
    this.listen = new BooleanAttr(true);
    this.trigger = new StringAttr("");
    this.numResponses = new NumberAttr(1);
    this.event = new StringAttr("");
    
    this.event.addModifiedCB(EventListener_EventModifiedCB, this);
    
    this.registerAttribute(this.listen, "listen");
    this.registerAttribute(this.trigger, "trigger");
    this.registerAttribute(this.numResponses, "numResponses");
    this.registerAttribute(this.event, "event");
}

EventListener.prototype.addEventType = function(type)
{
    this.events.push(type);
    
    // for serialization
    var name = this.event.getValueDirect().join("");
    var event = new StringAttr(name);
    event.flagDeserializedFromXML(); 
    this.events.push(event);
    this.registerAttribute(event, "event");
}

EventListener.prototype.getEventTypes = function()
{
    return this.events;
}

EventListener.prototype.eventPerformed = function(event)
{
    // decr numResponses
    var numResponses = this.numResponses.getValueDirect();
    if (numResponses > 0)
    {
        this.numResponses.setValueDirect(numResponses-1);
    }
}
EventListener.prototype.getTrigger = function()
{
        this.trigger;
}
EventListener.prototype.setTrigger = function(trigger)
{
    if(trigger)
    {
        this.trigger = trigger;
    }
}

function EventListener_EventModifiedCB(attribute, container)
{
    var type = getEventTypeByName(attribute.getValueDirect().join(""));
    // TODO -- restore the following line when all events are defined
    //if (type != eEventType.Unknown)
    {
        container.addEventType(type);
    }
}
EventMgr.prototype = new AttributeContainer();
EventMgr.prototype.constructor = EventMgr;

function EventMgr()
{
    AttributeContainer.call(this);
    this.className = "EventMgr";
    
    this.listeners = [];
    
    this.name = new StringAttr("EventMgr");
    
    this.registerAttribute(this.name, "name");
}

EventMgr.prototype.addListener = function(type, listener)
{
    if (this.listeners[type] == undefined)
    {
        this.listeners[type] = [];
    }
    
    // only add once
    if (this.listeners[type].indexOf(listener) == -1)
    {
        this.listeners[type].push(listener);
    }
}

EventMgr.prototype.removeListener = function(type, listener)
{
    if (this.listeners[type])
    {
        this.listeners[type].splice(this.listeners[type].indexOf(listener), 1);
    }    
}

EventMgr.prototype.processEvent = function(event)
{
    var type = event.type;
    var expired = [];
    
    // process event for registered listeners
    if (this.listeners[type])
    {
        for (var i=0; i < this.listeners[type].length; i++)
        {
            this.listeners[type][i].eventPerformed(event);
            
            // if listener has finished responding, add to expired list
            var numResponses = this.listeners[type][i].getAttribute("numResponses");
            if (numResponses && numResponses.getValueDirect() == 0)
            {
                expired.push(this.listeners[type][i]);
            }
        }
    }
    
    // remove expired listeners
    for (var i=0; i < expired.length; i++)
    {
        this.removeListener(type, expired[i]);
        this.registry.unregister(expired[i]);
    }
}
EventMgr.prototype.clearEvents = function()
{
/*
    this.bProcessingQs = false;
    this.bPendingRegistrations = false;

    while (!this.pendingAddsQ.empty())
    {
        var elp = m_pendingAddsQ.front();
        var elist = elp.second;
        this.elist.clear();
//        SAFE_DELETE(elist);
        this.pendingAddsQ.pop();
    }

    while (!this.userInputEventsQ.empty())
    {
        var pEvent = this.userInputEventsQ.front();
        this.userInputEventsQ.pop();
//        SAFE_RELEASE(pEvent);
    }

    while (!this.sceneOutputEventsQ.empty())
    {
        var pEvent = this.sceneOutputEventsQ.front();
        this.sceneOutputEventsQ.pop();
//        SAFE_RELEASE(pEvent);
    }

    this.removeAllListeners();
    */
    this.listeners.length = 0;
}
DeviceHandler.prototype = new EventListener();
DeviceHandler.prototype.constructor = DeviceHandler;

function DeviceHandler()
{
    EventListener.call(this);
    this.className = "DeviceHandler";
    this.attrType = eAttrType.DeviceHandler;
    
    this.inputMessage = new NumberAttr(0);
    this.inputId = new NumberAttr(0);
    this.inputModifier = new NumberAttr(0);
    this.inputState = new NumberAttr(0);
    this.prevInputState = new NumberAttr(0);
    this.output = new StringAttr("");
    
    this.registerAttribute(this.inputMessage, "inputMessage");
    this.registerAttribute(this.inputId, "inputId");
    this.registerAttribute(this.inputModifier, "inputModifier");
    this.registerAttribute(this.inputState, "inputState");
    this.registerAttribute(this.prevInputState, "prevInputState");
    this.registerAttribute(this.output, "output");
    
    // always respond to events
    this.numResponses.setValueDirect(-1);
}

DeviceHandler.prototype.eventPerformed = function(event)
{
    this.inputMessage.setValueDirect(event.type);
    this.inputId.setValueDirect(event.inputId);
    this.inputState.setValueDirect(event.state);
    this.inputModifier.setValueDirect(event.modifiers);
}
MouseHandler.prototype = new DeviceHandler();
MouseHandler.prototype.constructor = MouseHandler;

function MouseHandler()
{
    DeviceHandler.call(this);
    this.className = "MouseHandler";
    this.attrType = eAttrType.MouseHandler;
    
    this.name.setValueDirect("MouseHandler");
        
    this.lastX = 0;
    this.lastY = 0;
    
    this.x = new NumberAttr(0);
    this.y = new NumberAttr(0);
    this.deltaX = new NumberAttr(0);
    this.deltaY = new NumberAttr(0);
    this.delta = new Vector2DAttr(0, 0);
    
    this.registerAttribute(this.x, "deviceX");
    this.registerAttribute(this.y, "deviceY");
    this.registerAttribute(this.deltaX, "deltaX");
    this.registerAttribute(this.deltaY, "deltaY");
    this.registerAttribute(this.delta, "delta");
   
    this.addEventType(eEventType.MouseMove);
    this.addEventType(eEventType.MouseLeftDown);
}

MouseHandler.prototype.eventPerformed = function(event)
{
    var x = event.x;
    var y = event.y;

    switch (event.type)
    {
    	case eEventType.MouseMove:
    	{
			// do nothing
    	}
    	break;
    	
    	default:
    	{
    		this.lastX = x;
    		this.lastY = y;
    	}
    	break;
    }
   
    this.x.setValueDirect(x);
    this.y.setValueDirect(y);
    
    this.deltaX.setValueDirect(this.lastX-x);
    this.deltaY.setValueDirect(this.lastY-y);
    
    this.delta.setValueDirect(this.lastX-x, this.lastY-y);
    
    this.lastX = x;
    this.lastY = y;
    
    // call the base class to copy the rest of the InputEvent data
	DeviceHandler.prototype.eventPerformed.call(this, event);

	this.deltaX.setValueDirect(0);
	this.deltaY.setValueDirect(0);
	this.delta.setValueDirect(0, 0);
}
Command.prototype = new EventListener();
Command.prototype.constructor = Command;

function Command()
{
    EventListener.call(this);
    this.className = "Command";
    this.attrType = eAttrType.Command;
    
    this.borrowedAttributes = [];
    this.attributeValuePairs = [];
    this.attributeRefPairs = [];
    
    this.target = new StringAttr("");
    
    this.registerAttribute(this.target, "target");
}

Command.prototype.finalize = function()
{  
}

Command.prototype.eventPerformed = function(event)
{
    if (this.listen.getValueDirect() == true)
    {
        this.execute();
    }
    
    // call base-class implementation
    EventListener.prototype.eventPerformed.call(this, event);
}

Command.prototype.isBorrowed = function(attribute)
{
    for (var i=0; i < this.borrowedAttributes.length; i++)
    {
        if (attribute == this.borrowedAttributes[i])
        {
            return true;
        }
    }

    return false;
}

Command.prototype.isBorrowedAndValueModified = function(attribute)
{
    if (this.isBorrowed(attribute))
    {
        for (var i=0; i < this.attributeValuePairs.length; i++)
        {
            if (attribute == this.attributeValuePairs[i].first)
            {
                return { borrowed: true, value: this.attributeValuePairs[i].second };
            }
        }
    }

    return { borrowed: false, value: null };
}

Command.prototype.isBorrowedAndReferenceModified = function(attribute)
{
    if (this.isBorrowed(attribute))
    {
        for (var i=0; i < this.attributeRefPairs.length; i++)
        {
            if (attribute == this.attributeRefPairs[i].second)
            {
                return { borrowed: true, reference: this.attributeRefPairs[i].first };
            }
        }
    }

    return { borrowed: false, reference: null };
}


SetCommand.prototype = new Command();
SetCommand.prototype.constructor = SetCommand;

function SetCommand()
{
    Command.call(this);
    this.className = "Set";
    this.attrType = eAttrType.Set;
    
    this.target.addModifiedCB(SetCommand_TargetModifiedCB, this);
}

SetCommand.prototype.execute = function()
{
    // TODO: enabled (? - there is a commandEnabled attaribute in .cpp)
    
    this.applyAttributeValues();
}

SetCommand.prototype.applyAttributeValues = function()
{
    for (var i=0; i < this.attributeValuePairs.length; i++)
    {
        setAttributeValue(this.attributeValuePairs[i].first, this.attributeValuePairs[i].second);
    }
}

SetCommand.prototype.registerTargetAttributes = function(target, targetName)
{
    var sname;
    var myAttribute;
    var count = target.getAttributeCount();
    for (var i=0; i < count; i++)
    {
        var attribute = target.getAttributeAt(i);
        var attributeName = target.getAttributeNameAt(i);

        // if the target has an attribute of the same name as the
		// Set, register that same attribute using a relative path
		// expression, e.g., "Container_target"
		if ((myAttribute = this.getAttribute(attributeName)) != null)
		{
			// insert relative path expression
			sName = targetName + "_";	
			sName += attributeName;	
		}
		else	// attribute is not already registered
		{
			sName = attributeName;
		}
		
		this.registerAttribute(attribute, sName);
		this.borrowedAttributes.push(attribute);
    }    
}

function SetCommand_TargetModifiedCB(attribute, container)
{ 
    var target = attribute.getValueDirect().join("");
    var targets = target.split(",");
    
    container.targets.length = 0;
    for (var i=0; i < targets.length; i++)
    {
        var resource = container.registry.find(targets[i]);
        if (resource)
        {
            container.registerTargetAttributes(resource, targets[i]);
        }
    }
    
    setAttributeBin(container.attributeValuePairs);
}
function ConnectionDesc()
{
    this.sourceContainer = null;
    this.targetContainer = null;
    this.sourceAttribute = null;
    this.targetAttribute = null;
    this.sourceAttributeName = "";
    this.targetAttributeName = "";
    this.sourceIndex = -1;
    this.targetIndex = -1;
}

var gConnectionHelpers = [];

function registerConnectionHelper(type, connect, disconnect)
{
    gConnectionHelpers[type] = new Pair(connect, disconnect);
}

ConnectAttributesCommand.prototype = new Command();
ConnectAttributesCommand.prototype.constructor = ConnectAttributesCommand;

function ConnectAttributesCommand()
{
    Command.call(this);
    this.className = "ConnectAttributes";
    this.attrType = eAttrType.ConnectAttributes;
    
    this.connections = new Stack();
    this.connectionHelper = new Pair(null, null);
    
    this.sourceContainer = new StringAttr("");
    this.targetContainer = new StringAttr("");
    this.sourceAttribute = new StringAttr("");
    this.targetAttribute = new StringAttr("");
    this.source = new StringAttr("");
    this.negate = new BooleanAttr(false);   // if true, disconnect
    this.persist = new BooleanAttr(true);
    this.connectionType = new StringAttr("");
    
    this.source.addTarget(this.sourceAttribute);
    this.target.addTarget(this.targetAttribute);
    
    this.sourceContainer.addModifiedCB(ConnectAttributesCommand_SourceContainerModifiedCB, this);
    this.targetContainer.addModifiedCB(ConnectAttributesCommand_TargetContainerModifiedCB, this);
    this.sourceAttribute.addModifiedCB(ConnectAttributesCommand_SourceAttributeModifiedCB, this);
    this.targetAttribute.addModifiedCB(ConnectAttributesCommand_TargetAttributeModifiedCB, this);
    this.connectionType.addModifiedCB(ConnectAttributesCommand_ConnectionTypeModifiedCB, this);
    this.negate.addModifiedCB(ConnectAttributesCommand_NegateModifiedCB, this);
    
    this.registerAttribute(this.sourceContainer, "sourceContainer");
	this.registerAttribute(this.sourceContainer, "sourceEvaluator");
	this.registerAttribute(this.targetContainer, "targetContainer");
	this.registerAttribute(this.sourceAttribute, "sourceAttribute");
	this.registerAttribute(this.sourceAttribute, "sourceOutput");
	this.registerAttribute(this.targetAttribute, "targetAttribute");
	this.registerAttribute(this.source, "source");
	this.registerAttribute(this.negate, "negate");
	this.registerAttribute(this.persist, "persist");
	this.registerAttribute(this.connectionType, "connectionType");
}

ConnectAttributesCommand.prototype.finalize = function()
{
    // for serialization; register each sourceAttribute/targetAttribute pair
    for (var i=0; i < this.connections.length()-2; i++)
    {
        var connection = this.connections.getAt(i);
        if (connection.sourceAttribute && connection.targetAttribute)
        {
            var sourceAttribute = new StringAttr(connection.sourceAttributeName);
            sourceAttribute.flagDeserializedFromXML();
            this.registerAttribute(sourceAttribute, "sourceAttribute");
            
            var targetAttribute = new StringAttr(connection.targetAttributeName);
            targetAttribute.flagDeserializedFromXML();
            this.registerAttribute(targetAttribute, "targetAttribute"); 
        }    
    }
    
    // call base-class implementation
    Command.prototype.finalize.call(this);
}

ConnectAttributesCommand.prototype.eventPerformed = function(event)
{
    // TEMPTEST
    // call base-class implementation
    Command.prototype.eventPerformed.call(this, event);
}

ConnectAttributesCommand.prototype.execute = function()
{
    var desc = this.connections.top();
    var persist = this.persist.getValueDirect();
    
    var sourceEvaluator = null;
    if (desc.sourceContainer &&
        desc.sourceContainer.attrType >= eAttrType.Evaluator &&
        desc.sourceContainer.attrType <= eAttrType.Evaluator_End)
    {
        sourceEvaluator = desc.sourceContainer;
    }
    
    if (this.negate.getValueDirect() == false)
    {
        if (this.connectionHelper.first)
        {
            this.connectionHelper.first(desc.sourceContainer, desc.targetContainer)
            if (!persist && this.connectionHelper.second)
            {
                // if source is evaluator, evaluate
                if (sourceEvaluator) sourceEvaluator.evalute();
                
                this.connectionHelper.second(desc.sourceContainer, desc.targetContainer);
            }
        }
        else
        {
            this.addOrRemoveTargets(true);
            
            if (!persist)
            {
                // if source is evaluator, evaluate
                if (sourceEvaluator) sourceEvaluator.evalute();
                
                this.addOrRemoveTargets(false);
            }
        }
    }
    else // negate - disconnect
    {
        if (this.connectionHelper.second)
        {
            var desc = this.connections.top();
            this.connectionHelper.second(desc.sourceContainer, desc.targetContainer);
            
            // if source is evaluator, evaluate
            if (sourceEvaluator) sourceEvaluator.evalute();
        }
        else
        {
            this.addOrRemoveTargets(false);
            
            // if source is evaluator, evaluate
            if (sourceEvaluator) sourceEvaluator.evalute();
        }
    }
}

ConnectAttributesCommand.prototype.addOrRemoveTargets = function(add)
{
    for (var i=0; i < this.connections.length(); i++)
    {
        var desc = this.connections.getAt(i);
        if (desc.sourceAttribute && desc.targetAttribute)
        {
            // always remove first to ensure no duplicates
            desc.sourceAttribute.removeElementTarget(desc.targetAttribute, desc.sourceIndex, desc.targetIndex);
            if (add)
            {
                desc.sourceAttribute.addElementTarget(desc.targetAttribute, desc.sourceIndex, desc.targetIndex);
            }
            
            // detect connection of a screenPosition to anything and disable display lists
            var container = desc.sourceAttribute.getContainer();
            if (container)
            {   
                var screenPosition = container.getAttribute("screenPosition");
                if (screenPosition && screenPosition == desc.sourceAttribute)
                {
                    var autoDL = container.getAttribute("autoDisplayList");
                    if (autoDL)
                    {
                        autoDL.setValueDirect(false);    
                    }
                    
                    var enableDL = container.getAttribute("enableDisplayList");
                    if (enableDL)
                    {
                        enableDL.setValueDirect(false);    
                    }
                }
            }
        }
    }
}

function ConnectAttributesCommand_SourceContainerModifiedCB(attribute, container)
{
    if (container.connections.length() == 0)
    {
        container.connections.push(new ConnectionDesc());
    }
    var connection = container.connections.top();
    connection.sourceContainer = container.registry.find(attribute.getValueDirect().join(""));       
}

function ConnectAttributesCommand_TargetContainerModifiedCB(attribute, container)
{
    if (container.connections.length() == 0)
    {
        container.connections.push(new ConnectionDesc());
    }
    var connection = container.connections.top();     
    connection.targetContainer = container.registry.find(attribute.getValueDirect().join(""));       
}

function ConnectAttributesCommand_SourceAttributeModifiedCB(attribute, container)
{
    var source = null;
    var index = -1;
    
    if (container.connections.length() == 0)
    {
        container.connections.push(new ConnectionDesc());
    }

    var connection = container.connections.top();    
    if (connection.sourceContainer)
    {
        var sourceTokens = attribute.getValueDirect().join("").split(":");
        source = connection.sourceContainer.getAttribute(sourceTokens[0]);
        if (sourceTokens.length > 1)
        {
            index = sourceTokens[1];
        }              
    }
    else
    {
        source = container.registry.find(attribute.getValueDirect().join(""));
        if (source)
        {
            connection.sourceContainer = source.getContainer();
            if (!connection.sourceContainer) connection.sourceContainer = source;     
        }
    }
    
    connection.sourceAttribute = source;
    connection.sourceAttributeName = attribute.getValueDirect().join("");
    connection.sourceIndex = index;
    
    // if source and target attributes have both been set, push another connection desc for the next source/target pair
    if (connection.sourceAttribute && connection.targetAttribute)
    {
        container.connections.push(new ConnectionDesc());
        container.connections.top().sourceContainer = connection.sourceContainer;
        container.connections.top().targetContainer = connection.targetContainer;
    }
}

function ConnectAttributesCommand_TargetAttributeModifiedCB(attribute, container)
{
    var target = null;
    var index = -1;
    
    if (container.connections.length() == 0)
    {
        container.connections.push(new ConnectionDesc());
    }
    
    var connection = container.connections.top();    
    if (connection.targetContainer)
    {
        var targetTokens = attribute.getValueDirect().join("").split(":");
        target = connection.targetContainer.getAttribute(targetTokens[0]);
        if (targetTokens.length > 1)
        {
            index = targetTokens[1];
        }              
    }
    else
    {
        target = container.registry.find(attribute.getValueDirect().join(""));
        if (target)
        {
            connection.targetContainer = target.getContainer();
            if (!connection.targetContainer) connection.targetContainer = target;     
        }
    }
    
    connection.targetAttribute = target;
    connection.targetAttributeName = attribute.getValueDirect().join("");
    connection.targetIndex = index;
        
    // if source and target attributes have both been set, push another connection desc for the next source/target pair
    if (connection.sourceAttribute && connection.targetAttribute)
    {
        container.connections.push(new ConnectionDesc());
        container.connections.top().sourceContainer = connection.sourceContainer;
        container.connections.top().targetContainer = connection.targetContainer;
    }
}

function ConnectAttributesCommand_ConnectionTypeModifiedCB(attribute, container)
{
    var helpers = gConnectionHelpers[attribute.getValueDirect().join("")];
    if (helpers)
    {
        container.connectionHelper.first = helpers.first;
        container.connectionHelper.second = helpers.second;
    }
}

function ConnectAttributesCommand_NegateModifiedCB(attribute, container)
{
    var negate = attribute.getValueDirect();
    if (negate)
    {
        container.className = "DisconnectAttributes";
        container.attrType = eAttrType.DisconnectAttributes;
    }
    else // !negate
    {
        container.className = "ConnectAttributes";
        container.attrType = eAttrType.ConnectAttributes;       
    }
}
AutoInterpolateCommand.prototype = new Command();
AutoInterpolateCommand.prototype.constructor = AutoInterpolateCommand;

function AutoInterpolateCommand()
{
    Command.call(this);
    this.className = "AutoInterpolate";
    this.attrType = eAttrType.AutoInterpolate;

    this.kfi = null;
    this.numValueChannels = 0;
    this.numReferenceChannels = 0;
    this.numChannels = 0;
    
    this.shape = new NumberAttr(eKeyframeShape.Linear);
    this.duration = new NumberAttr(1);
    this.preBehavior = new NumberAttr(eEndBehavior.Constant);
    this.postBehavior = new NumberAttr(eEndBehavior.Constant);
    this.renderAndRelease = new BooleanAttr(true);

    this.target.addModifiedCB(AutoInterpolateCommand_TargetModifiedCB, this);

    this.registerAttribute(this.shape, "shape");
    this.registerAttribute(this.duration, "duration");
    this.registerAttribute(this.preBehavior, "preBehavior");
    this.registerAttribute(this.postBehavior, "postBehavior");
    this.registerAttribute(this.renderAndRelease, "renderAndRelease");
}

AutoInterpolateCommand.prototype.execute = function()
{
    // TODO: enabled (?)

    this.buildMotion();
    if (this.kfi)
    {
        this.kfi.getAttribute("time").setValueDirect(0);
        this.kfi.getAttribute("enabled").setValueDirect(true);
    }
}

AutoInterpolateCommand.prototype.buildMotion = function()
{
    var factory = this.registry.find("AttributeFactory");
    this.kfi = factory.create("KeyframeInterpolator");
    if (!this.kfi)
    {
        return;
    }
    this.kfi.getAttribute("enabled").setValueDirect(false);
    this.kfi.getAttribute("renderAndRelease").copyValue(this.renderAndRelease);
    
    // TODO: name the interpolator based on the target

    for (var i = 0; i < this.attributeValuePairs.length; i++)
    {
        this.numValueChannels += this.attributeValuePairs[i].first.getLength();
    }
    for (var i = 0; i < this.attributeRefPairs.length; i++)
    {
        this.numReferenceChannels += this.attributeRefPairs[i].first.getLength();
    }
    this.numChannels = this.numValueChannels + this.numReferenceChannels;
    this.kfi.setNumChannels(this.numChannels);

    var pre = this.preBehavior.getValueDirect();
    var post = this.postBehavior.getValueDirect();
    for (var i = 0; i < this.numChannels; i++)
    {
        this.kfi.getAttribute("preBehaviors").getAt(i).setValueDirect(pre);
        this.kfi.getAttribute("postBehaviors").getAt(i).setValueDirect(post);
    }

    // apply the parsed values to the kfi
    this.applyAttributeValues();
    this.applyAttributeRefs();
}

AutoInterpolateCommand.prototype.applyAttributeValues = function()
{
    // i = channel counter, advanced by j elements each pass
    // j = element of an Attribute, always 0 for primitive Attrs or 0-length-1 for complex
    // k = index in attribute values map
    var i, j, k;
    for (i = 0, k = 0; k < this.attributeValuePairs.length; k++)
    {
        var attr = this.attributeValuePairs[k].first;
        var value = this.attributeValuePairs[k].second;

        // for each channel:
        // 1. create a starting keyframe from target's current value for each attribute
        // 2. create an ending keyframe from the value contained in the map for each attribute
        for (j = 0; j < attr.getLength(); j++)
        {
            var keyframes = this.kfi.getAttribute("channels").getAt(i + j);

            var start = new KeyframeAttr();
            var end = new KeyframeAttr();

            start.getAttribute("time").setValueDirect(0);
            end.getAttribute("time").setValueDirect(this.duration.getValueDirect());

            start.getAttribute("shape").setValueDirect(this.shape.getValueDirect());
            end.getAttribute("shape").setValueDirect(this.shape.getValueDirect());

            // ensure numerical value with parseFloat()
            var startVal = parseFloat(attr.getElement(j));
            var endVal = parseFloat(attr.getLength() > 1 ? value[j] : value);

            // if the attribute is rotational (determined by "rotation" or "angle" as the attribute name), 
            // ensure motion will be the shortest path (eliminate the spin caused by 360's)
            if (this.isAttributeRotational(attr))
            {
                var shortestPath = this.shortestPath(startVal, endVal);
                startVal = shortestPath.start;
                endVal = shortestPath.end;
            }

            start.getAttribute("value").setValueDirect(startVal);
            end.getAttribute("value").setValueDirect(endVal);

            keyframes.push_back(start);
            keyframes.push_back(end);

            // connect the interpolator's output to the attribute
            this.kfi.getAttribute("resultValues").getAt(i + j).addElementTarget(attr, 0, j)
        }

        i += j;
    }
}

AutoInterpolateCommand.prototype.applyAttributeRefs = function()
{
    // i = channel counter, advanced by j elements each pass
    // j = element of an Attribute, always 0 for primitive Attrs or 0-length-1 for complex
    // k = index in attribute values map
    var i, j, k;
    for (i = 0, k = 0; k < this.attributeRefPairs.length; k++)
    {
        var ref = this.attributeRefPairs[k].first;
        var attr = this.attributeRefPairs[k].second;

        // for each channel:
        // 1. create a starting keyframe from target's current value for each attribute
        // 2. create an ending keyframe from the value contained in the map for each attribute
        for (j = 0; j < attr.getLength(); j++)
        {
            var keyframes = this.kfi.getAttribute("channels").getAt(i + j);

            var start = new KeyframeAttr();
            var end = new KeyframeAttr();

            start.getAttribute("time").setValueDirect(0);
            end.getAttribute("time").setValueDirect(this.duration.getValueDirect());

            start.getAttribute("shape").setValueDirect(this.shape.getValueDirect());
            end.getAttribute("shape").setValueDirect(this.shape.getValueDirect());

            // ensure numerical value with parseFloat()
            var startVal = parseFloat(attr.getElement(j));
            var endVal = parseFloat(ref.getElement(j));

            // if the attribute is rotational (determined by "rotation" or "angle" as the attribute name), 
            // ensure motion will be the shortest path (eliminate the spin caused by 360's)
            if (this.isAttributeRotational(attr))
            {
                var shortestPath = this.shortestPath(startVal, endVal);
                startVal = shortestPath.start;
                endVal = shortestPath.end;
            }

            start.getAttribute("value").setValueDirect(startVal);
            end.getAttribute("value").setValueDirect(endVal);

            keyframes.push_back(start);
            keyframes.push_back(end);

            // connect the interpolator's output to the attribute
            this.kfi.getAttribute("resultValues").getAt(i + j).addElementTarget(attr, 0, j)
        }

        i += j;
    }
}

AutoInterpolateCommand.prototype.registerTargetAttributes = function(target, targetName)
{
    var sname;
    var myAttribute;
    var count = target.getAttributeCount();
    for (var i = 0; i < count; i++)
    {
        var attribute = target.getAttributeAt(i);
        var attributeName = target.getAttributeNameAt(i);

        // if the target has an attribute of the same name as the
        // Set, register that same attribute using a relative path
        // expression, e.g., "Container_target"
        if ((myAttribute = this.getAttribute(attributeName)) != null)
        {
            // insert relative path expression
            sName = targetName + "_";
            sName += attributeName;
        }
        else	// attribute is not already registered
        {
            sName = attributeName;
        }

        this.registerAttribute(attribute, sName);
        this.borrowedAttributes.push(attribute);
    }
}

AutoInterpolateCommand.prototype.isAttributeRotational = function(attr)
{
    var container = attr.getContainer();
    if (container)
    {
        var name = container.getAttributeName(attr);
        if (name)
        {
            if (name == "rotation" ||
                name == "angle")
            {
                return true;
            }
        }
    }

    return false;
}

AutoInterpolateCommand.prototype.shortestPath = function(start, end)
{
    // normalize start to [0, 360)
    var nstart = degreeNormalize(start);

    // normalize end to [0, 360]
    var nend = degreeNormalize(end);

    // calculate direct path
    var directPath = nend - nstart;
    if (directPath <= 180 && directPath >= -180) 
    {
        return { start: start, end: end }; // direct path is shortest path, no changes necessary
    }

    // if direct path > 180 or < -180, a shorter path exists
    var shortestPath = 0;
    if (directPath > 180)
    {
        shortestPath = 360 - directPath;
    }
    else //if (directPath < -180)
    {
        shortestPath = 360 + directPath;
    }

    // update start/end so that shortest path is traversed
    start = nstart;
    if (nend > nstart)
    {       
        end = nstart - shortestPath;
    }
    else
    {
        end = nstart + shortestPath;
    }
    
    return { start: start, end: end };
}

function AutoInterpolateCommand_TargetModifiedCB(attribute, container)
{
    var target = attribute.getValueDirect().join("");
    var targets = target.split(",");

    container.targets.length = 0;
    for (var i = 0; i < targets.length; i++)
    {
        var resource = container.registry.find(targets[i]);
        if (resource)
        {
            container.registerTargetAttributes(resource, targets[i]);
        }
    }

    setAttributeBin(container.attributeValuePairs);
    setAttributePairs(container.attributeRefPairs);
}
MotionInterpolateCommand.prototype = new AutoInterpolateCommand();
MotionInterpolateCommand.prototype.constructor = MotionInterpolateCommand;

function MotionInterpolateCommand()
{
    AutoInterpolateCommand.call(this);
    this.className = "MotionInterpolateCommand";

    this.startPosition = new Vector3DAttr();
    this.endPosition = new Vector3DAttr();
    this.resultPosition = new Vector3DAttr();
    this.positionControl = new Vector3DAttr();
    this.easeIn = new BooleanAttr(true);
    this.easeOut = new BooleanAttr(true);
    this.midPosition = new Vector3DAttr();

    //this.resultPosition.addModifiedCB(MotionInterpolateCommand_ResultPositionModifiedCB, this);
    
    this.registerAttribute(this.startPosition, "startPosition");
    this.registerAttribute(this.endPosition, "endPosition");
    this.registerAttribute(this.resultPosition, "resultPosition");
    this.registerAttribute(this.positionControl, "positionControl");
    this.registerAttribute(this.easeIn, "easeIn");
    this.registerAttribute(this.easeOut, "easeOut");
}

MotionInterpolateCommand.prototype.execute = function()
{
    // call base-class implementation
    AutoInterpolateCommand.prototype.execute.call(this);
}

MotionInterpolateCommand.prototype.buildMotion = function()
{
    var factory = this.registry.find("AttributeFactory");
    this.kfi = factory.create("KeyframeInterpolator");
    if (!this.kfi)
    {
        return;
    }
    this.kfi.getAttribute("enabled").setValueDirect(false);
    this.kfi.getAttribute("renderAndRelease").copyValue(this.renderAndRelease);

    this.numChannels = 3;
    this.kfi.setNumChannels(this.numChannels);

    var pre = this.preBehavior.getValueDirect();
    var post = this.postBehavior.getValueDirect();
    for (var i = 0; i < this.numChannels; i++)
    {
        this.kfi.getAttribute("preBehaviors").getAt(i).setValueDirect(pre);
        this.kfi.getAttribute("postBehaviors").getAt(i).setValueDirect(post);
    }

    // set the keyframes
    this.setKeyframes();
}

MotionInterpolateCommand.prototype.setKeyframes = function()
{
    // get start position
    var startPosition = this.startPosition.getValueDirect();

    // get end position
    var endPosition = this.endPosition.getValueDirect();

    // get distance between start/end
    var positionDelta = distanceBetween(startPosition, endPosition);

    // get position control vector
    var positionControl = new Vector3D(); 
    positionControl.copy(this.positionControl.getValueDirect());
    positionControl.normalize();

    // get mid position
    var midPosition = new Vector3D(
        ((startPosition.x + endPosition.x) / 2) + (positionControl.x * (positionDelta / 2)),
        ((startPosition.y + endPosition.y) / 2) + (positionControl.y * (positionDelta / 2)),
        ((startPosition.z + endPosition.z) / 2) + (positionControl.z * (positionDelta / 2)));
    this.midPosition.setValueDirect(midPosition.x, midPosition.y, midPosition.z);

    // get ease-in, ease-out settings
    var easeIn = this.easeIn.getValueDirect();
    var easeOut = this.easeOut.getValueDirect();

    // get shape
    var shape = this.shape.getValueDirect();

    // get duration
    var duration = this.duration.getValueDirect();

    // for each channel...
    for (var channel = 0; channel < this.numChannels; channel++)
    {
        var keyframes = this.kfi.getAttribute("channels").getAt(channel);

        var start = new KeyframeAttr();
        var mid = new KeyframeAttr();
        var end = new KeyframeAttr();

        start.getAttribute("time").setValueDirect(0);
        mid.getAttribute("time").setValueDirect(duration * 0.5);
        end.getAttribute("time").setValueDirect(duration);

        start.getAttribute("shape").setValueDirect(shape);
        mid.getAttribute("shape").setValueDirect(shape);
        end.getAttribute("shape").setValueDirect(shape);

        start.getAttribute("value").setValueDirect(this.startPosition.getElement(channel));
        mid.getAttribute("value").setValueDirect(this.midPosition.getElement(channel));
        end.getAttribute("value").setValueDirect(this.endPosition.getElement(channel));

        keyframes.push_back(start);
        keyframes.push_back(mid);
        keyframes.push_back(end);

        this.kfi.getAttribute("resultValues").getAt(channel).addElementTarget(this.resultPosition, 0, channel);
    }
}

function MotionInterpolateCommand_ResultPositionModifiedCB(attribute, container)
{
    var value = attribute.getValueDirect();

    OutputDebugMsg("x: " + value.x + " y: " + value.y + " z: " + value.z + "\n");
}
LocateCommand.prototype = new Command();
LocateCommand.prototype.constructor = LocateCommand;

function LocateCommand()
{
    Command.call(this);
    this.className = "LocateCommand";
    this.attrType = eAttrType.Locate;

    this.targetNode = null;
    this.directive = new BBoxDirective();
    this.locator = new BBoxLocator();
    this.inspector = null;
    
	this.duration = new NumberAttr(1);
	this.transition = new BooleanAttr(true);
	this.updateClipPlanes = new BooleanAttr(false);
	this.shape = new NumberAttr(eKeyframeShape.TCB);
	this.easeIn = new BooleanAttr(true);
	this.easeOut = new BooleanAttr(true);
	this.resultPosition = new Vector3DAttr();
	this.resultFarDistance = new NumberAttr();
	this.resultWidth = new NumberAttr();
    
    this.target.addModifiedCB(LocateCommand_TargetModifiedCB, this);
    
	this.registerAttribute(this.duration, "duration");
	this.registerAttribute(this.transition, "transition");
	this.registerAttribute(this.updateClipPlanes, "updateClipPlanes");
	this.registerAttribute(this.shape, "shape");
	this.registerAttribute(this.easeIn, "easeIn");
	this.registerAttribute(this.easeOut, "easeOut");
	this.registerAttribute(this.resultPosition, "resultPosition");
	this.registerAttribute(this.resultFarDistance, "resultFarDistance");
	this.registerAttribute(this.resultWidth, "resultWidth");

    this.registerAttribute(this.locator.getAttribute("closeness"), "closeness");
    this.registerAttribute(this.locator.getAttribute("resultPivotDistance"), "resultPivotDistance");
}

LocateCommand.prototype.execute = function()
{
    if (this.targetNode)
    {
        this.locate();
    }
}

LocateCommand.prototype.locate = function()
{
    var selector = this.registry.find("Selector");
    var viewportMgr = this.registry.find("ViewportMgr");

    // get camera at last select point (if no selection has been made, gets camera at (0, 0))
    var clickPoint = selector.getAttribute("clickPoint").getValueDirect();
    var vp = viewportMgr.getViewportAtScreenXY(clickPoint.x, clickPoint.y);
    var camera = vp.camera;
    var viewport = vp.viewport;

    // get world-space bbox
    this.directive.execute(this.targetNode);
    var bounds = this.directive.getBounds();
    this.locator.getAttribute("bbox").setValueDirect(bounds.min, bounds.max);

    // get view-space bbox
    var view = vp.camera.getTransform();
    view.invert();
    this.directive.getAttribute("viewTransform").setValueDirect(view);
    this.directive.getAttribute("viewSpace").setValueDirect(true);
    this.directive.execute(this.targetNode);
    bounds = this.directive.getBounds();
    this.locator.getAttribute("bboxView").setValueDirect(bounds.min, bounds.max);

    // copy current viewport to the locator's viewport attribute
    this.locator.getAttribute("viewport").setValueDirect(viewport.x, viewport.y, viewport.width, viewport.height);

    // inputs
    var locatorNear = this.locator.getAttribute("nearDistance");
    var locatorVolume = this.locator.getAttribute("viewVolume");
    var locatorViewPosition = this.locator.getAttribute("viewPosition");
    var locatorTransform = this.locator.getAttribute("viewTransform");

    // outputs
    var locatorResultPosition = this.locator.getAttribute("resultPosition");
    var locatorResultWidth = this.locator.getAttribute("resultWidth");
    var locatorResultFarDistance = this.locator.getAttribute("resultFarDistance");
    var resultPivotDistance = this.locator.getAttribute("resultPivotDistance");

    // output targets (others determined later)
    var targetPivotDistance = null;
    var updateClipPlanes = this.updateClipPlanes.getValueDirect();
    var transition = this.transition.getValueDirect();

    if (this.inspector)
    {
        targetPivotDistance = this.inspector.getAttribute("pivotDistance");
    }

    if (resultPivotDistance && targetPivotDistance)
    {
        resultPivotDistance.addTarget(targetPivotDistance);
    }

    cameraNear = camera.getAttribute("nearDistance");
    cameraFar = camera.getAttribute("farDistance");
    cameraWidth = camera.getAttribute("width");
    cameraVolume = camera.getAttribute("viewVolume");
    cameraPosition = camera.getAttribute("sectorPosition");
    cameraWorldPosition = camera.getAttribute("sectorWorldPosition");
    cameraWorldTransform = camera.getAttribute("sectorWorldTransform");

    cameraNear.addTarget(locatorNear);
    cameraVolume.addTarget(locatorVolume);
    cameraWorldPosition.addTarget(locatorViewPosition);
    cameraWorldTransform.addTarget(locatorTransform);

    // if NOT transitioning, apply the result directly back to the camera
    if (transition == false)
    {
        locatorResultPosition.addTarget(cameraPosition);
        locatorResultWidth.addTarget(cameraWidth);

        if (updateClipPlanes)
        {
            locatorResultFarDistance.addTarget(cameraFar);
        }

        this.locator.evaluate();

        locatorResultPosition.removeTarget(cameraPosition);

        // removing null or non-targets is harmless, 
        // so no need to check, just call remove
        locatorResultWidth.removeTarget(cameraWidth);
        locatorResultFarDistance.removeTarget(cameraFar);
    }
    else
    {
        locatorResultPosition.addTarget(this.resultPosition);
        locatorResultWidth.addTarget(this.resultWidth);

        if (updateClipPlanes)
        {
            locatorResultFarDistance.addTarget(this.resultFarDistance);
        }

        this.locator.evaluate();

        locatorResultPosition.removeTarget(this.resultPosition);

        // removing null or non-targets is harmless, 
        // so no need to check, just call remove
        locatorResultWidth.removeTarget(this.resultWidth);
        locatorResultFarDistance.removeTarget(this.resultFarDistance);

        // based upon shape value, create either a normal auto-interpolator (linear), or a
        // motion-interpolator (non-linear)
        switch (this.shape.getValueDirect())
        {
            case eKeyframeShape.Stepped:
            case eKeyframeShape.TCB:
            case eKeyframeShape.Bezier1D:
            case eKeyframeShape.Bezier2D:
                {
                    var factory = this.registry.find("AttributeFactory");
                    var autoInterpolate = factory.create("MotionInterpolate");

                    autoInterpolate.getAttribute("shape").copyValue(this.shape);
                    autoInterpolate.getAttribute("easeIn").copyValue(this.easeIn);
                    autoInterpolate.getAttribute("easeOut").copyValue(this.easeOut);
                    autoInterpolate.getAttribute("startPosition").copyValue(cameraPosition);
                    autoInterpolate.getAttribute("endPosition").copyValue(this.resultPosition);
                    autoInterpolate.getAttribute("resultPosition").addTarget(cameraPosition,
                        eAttrSetOp.Replace, null, false);

                    // get camera direction vectors
                    var dirs = camera.getDirectionVectors();

                    // set the inverse camera fwd vector to the interpolator's position control
                    autoInterpolate.getAttribute("positionControl").setValueDirect(-dirs.forward.x,
					    -dirs.forward.y, -dirs.forward.z);
                }
                break;

            case eKeyframeShape.Linear:
            default:
                {
                    var factory = this.registry.find("AttributeFactory");
                    var autoInterpolate = factory.create("AutoInterpolate");

                    autoInterpolate.attributeRefPairs.push(new Pair(this.resultPosition, cameraPosition));
                }
                break;
        }

        if (updateClipPlanes)
        {
            if (cameraWidth) autoInterpolate.attributeRefPairs.push(new Pair(this.resultWidth, cameraWidth));
            if (cameraFar) autoInterpolate.attributeRefPairs.push(new Pair(this.resultFarDistance, cameraFar));
        }

        autoInterpolate.target = camera;
        autoInterpolate.getAttribute("duration").copyValue(this.duration);
        autoInterpolate.execute();
        this.registry.unregister(autoInterpolate);
    }

    if (resultPivotDistance && targetPivotDistance)
    {
        resultPivotDistance.removeTarget(targetPivotDistance);
    }
}

function LocateCommand_TargetModifiedCB(attribute, container)
{
    var target = attribute.getValueDirect().join("");
    var resource = container.registry.find(target);
    if (resource)
    {
        container.targetNode = resource;
        
        // try and locate a scene inspector for updating pivotDistance
        container.inspector = container.registry.find("SceneInspector");
    }
    else
    {
        console.debug("TODO: " + arguments.callee.name);
        // TODO: target not found
        //_snprintf(msg, sizeof(msg), "LocateBBox: target=\"%s\" not found\n", name.c_str());
        // TODO: Locate a point on an object and/or in the world
    }
}

PlayCommand.prototype = new Command();
PlayCommand.prototype.constructor = PlayCommand;

function PlayCommand()
{
    Command.call(this);
    this.className = "Play";
    this.attrType = eAttrType.Play;

    this.evaluators = [];
    this.negate = new BooleanAttr(false);   // if true, Pause
    
    this.registerAttribute(this.negate, "negate");
    
    this.target.addModifiedCB(PlayCommand_TargetModifiedCB, this);
    this.negate.addModifiedCB(PlayCommand_NegateModifiedCB, this);
}

PlayCommand.prototype.execute = function()
{
    // TODO: enabled (?)
	var renderAgent = this.registry.find("RenderAgent");
	if (renderAgent)
	{
        // SetEvaluatorPlayState not implemented by RenderAgent
        // ePlayState_* is not implemented by RenderAgent
        if (this.evaluators.length < 1)
        {
			if (this.negate.getValueDirect() == false)
			{
				renderAgent.setEvaluatorsPlayState(ePlayState.Play);
			}
			else
			{
				renderAgent.setEvaluatorsPlayState(ePlayState.Pause);
			}
        }
        else
        {
            for (var i = 0; i < this.evaluators.length; i++)
            {
         
    			if (this.negate.getValueDirect() == false)
    			{
    				renderAgent.setEvaluatorPlayState(evaluators[i], ePlayState.Play);
    			}
    			else
    			{
    				renderAgent.setEvaluatorPlayState(evaluators[i], ePlayState.Pause);
    			}
            
            }   
        }
	}
}

function PlayCommand_TargetModifiedCB(attribute, container)
{
    var target = attribute.getValueDirect().join("");
    var targets = target.split(",");

    // find one or more evaluator to play
    container.targets.length = 0;   // copied this from Set. What does it do?
    for (var i = 0; i < targets.length; i++)
    {
        var evaluator = container.registry.find(targets[i]);
        if (evaluator)
        {
            container.evaluators[i] = evaluator;
        }
    }
}

function PlayCommand_NegateModifiedCB(attribute, container)
{
    var negate = attribute.getValueDirect();
    if (negate)
    {
        container.className = "Pause";
        container.attrType = eAttrType.Pause;
    }
    else // !negate
    {
        container.className = "Play";
        container.attrType = eAttrType.Play;       
    }
}
RemoveCommand.prototype = new Command();
RemoveCommand.prototype.constructor = RemoveCommand;

function RemoveCommand()
{
    Command.call(this);
    this.className = "RemoveCommand";
    this.attrType = eAttrType.Remove;

    this.targetAttribute = null;
    
    this.target.addModifiedCB(RemoveCommand_TargetModifiedCB, this);
}

RemoveCommand.prototype.execute = function()
{
    if (this.targetAttribute)
    {
        // if node, remove from tree, and remove/unregister all children
        if (this.targetAttribute.isNode())
        {
            var i = 0;
            var parent = null;
            while ((parent = this.targetAttribute.getParent(i++)))
            {
                parent.removeChild(this.targetAttribute);
            }

            this.removeChildren(this.targetAttribute);
        }

        // remove from registry
        this.registry.unregister(this.targetAttribute);
        
        // delete
        this.targetAttribute.destroy();
    }
}

RemoveCommand.prototype.removeChildren = function(root)
{
    var child = null;
	while ((child = root.getChild(0))) // get child 0 each time because we are removing the front child
	{
		// recurse on child
		this.removeChildren(child);

		// remove from registry
		this.registry.unregister(child);

		// remove from root node
		root.removeChild(child);
	}
}

function RemoveCommand_TargetModifiedCB(attribute, container)
{
    var target = attribute.getValueDirect().join("");
    container.targetAttribute = container.registry.find(target);
}

StopCommand.prototype = new Command();
StopCommand.prototype.constructor = StopCommand;

function StopCommand()
{
    Command.call(this);
    this.className = "Stop";
    this.attrType = eAttrType.Stop;

    this.evaluators = [];
    
    this.target.addModifiedCB(StopCommand_TargetModifiedCB, this);

}

StopCommand.prototype.execute = function()
{
    // TODO: enabled (?)
	var renderAgent = this.registry.find("RenderAgent");
	if (renderAgent)
	{
        // SetEvaluatorStopState not implemented by RenderAgent
        // eStopState_* is not implemented by RenderAgent
        if (this.evaluators.length < 1)
        {
			renderAgent.setEvaluatorsPlayState(ePlayState.Stop);
        }
        else
        {
            for (var i = 0; i < this.evaluators.length; i++)
            {
         
    			renderAgent.setEvaluatorPlayState(evaluators[i], ePlayState.Stop);
            }   
        }
	}
}

function StopCommand_TargetModifiedCB(attribute, container)
{
    var target = attribute.getValueDirect().join("");
    var targets = target.split(",");

    // find one or more evaluator to play
    container.targets.length = 0;   // copied this from Set. What does it do?
    for (var i = 0; i < targets.length; i++)
    {
        var evaluator = container.registry.find(targets[i]);
        if (evaluator)
        {
            container.evaluators[i] = evaluator;
        }
    }
}
CommandSequence.prototype = new Command();
CommandSequence.prototype.constructor = CommandSequence;

function CommandSequence()
{
    Command.call(this);
    this.className = "CommandSequence";
    this.attrType = eAttrType.CommandSequence;
    
    this.sequence = [];
}

CommandSequence.prototype.execute = function()
{
    for (var i=0; i < this.sequence.length; i++)
    {
        this.sequence[i].execute();
    }
}

CommandSequence.prototype.addCommand = function(command)
{
    this.sequence.push(command);
    
    // register command for serialization
    var num = this.sequence.length - 1;
    var name = "Command(" + num.toString() + ")";
    this.registerAttribute(command, name);
}
CommandMgr.prototype = new AttributeContainer();
CommandMgr.prototype.constructor = CommandMgr;

function CommandMgr()
{
    AttributeContainer.call(this);
    this.className = "CommandMgr";
    
    this.commandSeqStack = new Stack();
    
    this.name = new StringAttr("CommandMgr");
    
    this.registerAttribute(this.name, "name");
}

CommandMgr.prototype.pushCommandSequence = function(sequence)
{
    this.commandSeqStack.push(sequence);
}

CommandMgr.prototype.popCommandSequence = function()
{
    this.commandSeqStack.pop();
}

CommandMgr.prototype.clearCommandSequenceStack = function()
{
    this.commandSeqStack.clear();
}

CommandMgr.prototype.addCommand = function(command)
{
    setAttributeBin(null);
    setAttributePairs(null);
    
    if (this.commandSeqStack.length() > 0)
    {
        this.commandSeqStack.top().addCommand(command);
        this.registry.unregister(command); // unregister here so command will not be serialized separately
        return;
    }
    
    // execute the command or register it for events.  If the command
    // was NOT configured for events, then Execute it and get rid of it             
    var events = command.getEventTypes();
    var trigger = command.getAttribute("trigger");
    if (events.length > 0)
    {
        var eventMgr = this.registry.find("EventMgr");
        if (eventMgr)
        {
            for (var i=0; i < events.length; i++)
            {
                eventMgr.addListener(events[i], command);
            }
        }   
    }
    else if (trigger.getLength() > 0)
    {
		trigger.addModifiedCB(CommandMgr_CommandTriggerModifiedCB, this);
		this.createCommandTrigger(command, trigger);
    }
    else // no events -- execute and remove
    {
        command.execute();
        this.registry.unregister(command);
    }
}

CommandMgr.prototype.createCommandTrigger = function(command, trigger) 
 {

 	// TODO: Support Commands that Execute from Events AND Triggers

 	// trigger syntax based on Attributes:
 	// ObjectName/Attribute=value
 	// ObjectName/Attribute[item]=value
 	// ObjectName/Attribute=value,value,value,...,value
 	// Where "ObjectName" may be an XPath-like expression
 	var attrNdx = 0;
    var valueNdx = 0;
    var rangeNdx = 0;
    var itemNdx = 0;

    var triggerString = "";
    triggerString = trigger.getValueDirect().join("");
 	attrNdx = triggerString.lastIndexOf('/');

 	if (attrNdx != -1)
 	{
 		var objectName = triggerString.substring(0, attrNdx);
 		var resource = bridgeworks.registry.find(objectName);
 		if(resource)
 		{
 			var not = false;

            var attrName = "";
            var itemString = "";
            var valueString = "";
            var rangeString = "";
            
 			valueNdx = triggerString.lastIndexOf('!');
 			if (valueNdx > 0)
 			{
 			    triggerString.replace("!", ""); // erase the '!' for subsequent processing
 			    not = true;
 			}

 			valueNdx = triggerString.lastIndexOf('=');

 			if(valueNdx > 0) 
 			{
 				itemNdx = triggerString.lastIndexOf('[');
 				if(itemNdx > 0) 
 				{
 					var itemNdx2 = triggerString.lastIndexOf(']', itemNdx); 
 					itemString = triggerString.substring(itemNdx+1, itemNdx2 - itemNdx - 1); 
 				}

 				var range = FLT_MAX; 
 				var rangeNdx = triggerString.lastIndexOf(',');
 				if(rangeNdx > 0)
 				{
 					var rangeString = triggerString.substring(rangeNdx+1, trigger.length()-rangeNdx-1);
 					range = rangeString.parseFloat(); 
 				}
 				rangeNdx = rangeNdx == -1 ? triggerString.length : rangeNdx;
 				// value is the string between '=' && (',' || end of string)
 				valueString = triggerString.substring(valueNdx+1, valueNdx+(rangeNdx-valueNdx));

 			}
 			else //TEMPEST
 			{
 				itemNdx = triggerString.lastIndexOf('[');
 				if(itemNdx > 0) 
 				{
 					var itemNdx2 = triggerString.lastIndexOf(']', itemNdx);
 					itemString = triggerString.substring(itemNdx+1, itemNdx2-itemNdx-1);
 				}
 			}
 			valueNdx = itemNdx == -1 ? (valueNdx == -1 ? triggerString.length() : valueNdx) : itemNdx;
 			attrName = triggerString.substring(attrNdx+1, valueNdx);

 			var input = resource.getAttribute(attrName);

 			var attr = this.createAttribute(input, valueString);

 			if(attr)
 			{
 				var item = -1; 
 				if(itemString != "")
 				{
 					item = parseInt(itemString);
 				}

 				var numExecutions = command.numResponses;
 				var newTrigger = new AttributeTrigger(input, attr, command, item, not, numExecutions);

 				command.setTrigger(newTrigger);
 			}
 			triggerString = objectName + "/" + attrName;

 			console.debug(trigger);
 			console.debug("\n");
 		}		
 	}
 }

CommandMgr.prototype.createAttribute = function(attribute, value)
{
	var newAttribute = null;
	if(attribute)
	{
        //console.debug(attribute);
		var etype = attribute.attrType;
		var len = attribute.getLength();
        //console.debug(etype);
//			switch (etype)
//			{
//
//			case eAttrType.BooleanAttr:
//				{
//					newAttribute = new NumberAttr();
//		            newAttribute.setValueDirect(parseInt(value));
//				}
//				break;
//            case eAttrType.NumberAttr:
//
//				{
					newAttribute = new NumberAttr();
		            newAttribute.setValueDirect(parseFloat(value));
//				}
//				break;
//
//            case eAttrType.StringAttr:
//				{
//					newAttribute = new StringAttr();
//                    newAttribute.setValueDirect(value);
//				}
//				break;
//
//			default:
//				newAttribute = null;
//				break;
//			}
		  }
        //console.debug(newAttribute);
		return newAttribute; 
}

function CommandMgr_CommandTriggerModifiedCB(attribute, container)
{
	this.createCommandTrigger(attribute, container);
}

AttributeTrigger.prototype = new Command();
AttributeTrigger.prototype.constructor = AttributeTrigger;


function AttributeTrigger(input, trigger, target, item, _not, _executionCount)
{
    this.input = input;
    this.trigger = trigger;
    this.target = target;

    this.lastValues = [];

	this.input.getValue(this.lastValues);
    this.attrType = eAttrType.AttributeTrigger;
	
    this.item = item;
    
    this.not = _not;


    this.executionCount = _executionCount;

	this.input.addModifiedCB(AttributeTrigger_InputModifiedCB, this);

	var len = this.input.getLength();

	if (len == 1)
	{
		this.item = 0;
	}
}


AttributeTrigger.prototype.execute = function()
{
	if (this.target)
	{
        var type = this.trigger.attrType;

        switch (type)
        {

        case eAttrType.StringAttr:
            {
                var vIn = [];
                var vTrig = [];
            
                this.input.getValue(vIn);
                this.trigger.getValue(vTrig);

                var pass = vIn[0] == vTrig[0] ? true : false;
                pass = this.not ? !pass : pass;
                if (pass)
                {
                    var count = this.executionCount.getValueDirect() - 1;
                    this.executionCount.setValueDirect(count);
                }

                if (this.executionCount == 0)
		        {
			        this.target = null;
		        }
            }
            break;

        default:
            {
                var vIn = [];
                var vTrig = [];

		        this.input.getValue(vIn);
		        this.trigger.getValue(vTrig);

		        // match single-item Attribute OR single item of a multi-item Attribute
		        if (this.item != -1)
		        {
			        // if equal OR descending past OR ascending past
                    var pass = ((vIn[this.item] == vTrig[0]) ||
			                     (this.lastValues[this.item] > vIn[this.item] && vIn[this.item] < vTrig[0]) ||
			                     (this.lastValues[this.item] < vIn[this.item] && vIn[this.item] > vTrig[0]));
                    pass = this.not ? !pass : pass;
                    if (pass)
			        {
						this.target.execute();
                        var count = this.executionCount.getValueDirect() - 1;
				        this.executionCount.setValueDirect(count);
			        }
		        }
		        else	// match every item in a multi-item Attribute
		        {
			        var len = this.input.getLength();
			        var matches = 0;
			        for (var i = 0; i < len; ++i)
			        {
				        // if equal OR descending past OR ascending past
				        var pass = ((vIn[i] == vTrig[i]) ||
				                     (this.lastValues[i] > vIn[i] && vIn[i] < vTrig[i]) ||
				                     (this.lastValues[i] < vIn[i] && vIn[i] > vTrig[i]));
                        pass = this.not ? !pass : pass;
                        if (pass)
				        {
					        ++matches;
				        }
			        }

			        // if every item matches simultaneously
			        if (matches = len)
			        {
						err = this.target.execute();
						this.executionCount.setValueDirect(--this.executionCount);
			        }
		        }

		        if (this.executionCount.getValueDirect() == 0)
		        {
			        this.target = null;
                    this.input.removeModifiedCB(AttributeTrigger_InputModifiedCB,this);
		        }
		        else
		        {
			        this.lastValues = vIn;
		        }
            }
            break;
        }
	}

	return;
}

function AttributeTrigger_InputModifiedCB(attribute, container)
{
	container.execute();

	// TODO:  Expand to also support EventListener::EventPerformed
}
/*
void AttributeTrigger_InputModifiedTaskProc(void* data, const bool & run)
{
	TAttributeTrigger* pTrigger = static_cast<TAttributeTrigger*>(data);
	pTrigger.Execute();
}
*/
BwRegistry.prototype = new AttributeRegistry();
BwRegistry.prototype.constructor = BwRegistry;

function BwRegistry()
{
    AttributeRegistry.call(this);
    this.className = "BwRegistry";
    this.attrType = eAttrType.AttributeRegistry;
    
    this.rootPtr = new ReferenceAttr(null);
    this.subtreePtr = new ReferenceAttr(null);
    this.sgPointer = new StringAttr("");
    this.maxAnimationTimeInSecs = new NumberAttr(0);

    this.rootPtr.addModifiedCB(BwRegistry_RootPtrModifiedCB, this);
    this.sgPointer.addModifiedCB(BwRegistry_SgPointerModifiedCB, this);
    
    this.registerAttribute(this.rootPtr, "rootPtr");
    this.registerAttribute(this.subtreePtr, "subtreePtr");
    this.registerAttribute(this.sgPointer, "sgPointer");
    this.registerAttribute(this.maxAnimationTimeInSecs, "maxAnimationTimeInSecs");
    
    this.registerByName(this, "NodeMgr");      // backward-compatibility
    this.registerByName(this, "EvaluatorMgr"); // backward-compatibility
}

BwRegistry.prototype.find = function(name)
{
    if (!name) return null;
    
    // tokenize name path
    var tokens = [];
    var index = 0;
    while ((index = name.indexOf('/')) > -1)
    {
        tokens.push(name.substring(0, index));
        name = name.substring(index+1, name.length);
    }
    tokens.push(name);
    
    // call get() on first token
    var resource = this.getByName(tokens[0]);
    if (resource) resource = resource[0];
    
    // call getAttribute() on subsequent tokens
    for (var i=1; i < tokens.length && resource; i++)
    {
        resource = resource.getAttribute(tokens[i]);
    }
    
    return resource;
}

BwRegistry.prototype.findContext = function(name, context)
{
    // TODO
}

BwRegistry.prototype.registerResource = function(container)
{
    // setup parent relationship for nodes (not all containers passed to this method will be nodes)
    if (container.isNode() && container.getAttribute("orphan").getValueDirect() == false)
    {
        this.updateTree(container);
    }
}

BwRegistry.prototype.finalizeResource = function(container)
{
    if (container.isNode() && container.getParentCount() > 0)
    {
        this.subtreePtr.setValueDirect(container.getParent(0));
    }
}

BwRegistry.prototype.register = function(container)
{
    // call base-class implementation
    AttributeRegistry.prototype.register.call(this, container);
    
    // TODO
}

BwRegistry.prototype.unregister = function(container)
{
    // call base-class implementation
    AttributeRegistry.prototype.unregister.call(this, container);
    
    // TODO
}

BwRegistry.prototype.clear = function()
{
    this.rootPtr.setValueDirect(null);
    this.subtreePtr.setValueDirect(null);
    this.sgPointer.setValueDirect(null);
    
    // call base-class implementation
    AttributeRegistry.prototype.clear.call(this);    
}

BwRegistry.prototype.updateTree = function(node)
{
    var root = this.rootPtr.getValueDirect();
    var subtree = this.subtreePtr.getValueDirect();
  
    // by default, first node is the root
    if (root == null)
    {
        root = subtree = node;
    }
    else
    {
        if (subtree)
        {
            subtree.addChild(node);
        }
        else
        {
            root.addChild(node);
        }
        
        subtree = node;
    }
    
    this.rootPtr.setValueDirect(root);
    this.subtreePtr.setValueDirect(subtree);
}

BwRegistry.prototype.updateMaxAnimationTime = function()
{
    // TODO
}

BwRegistry.prototype.formatContext = function(attribute, name)
{
    // TODO
}

BwRegistry.prototype.sgPointerModified = function()
{
    var resource = this.find(this.sgPointer.getValueDirect().join(""));
    if (resource)
    {
        this.subtreePtr.setValueDirect(resource);
    }
}

function BwRegistry_RootPtrModifiedCB(attribute, container)
{
    var resource = attribute.getValueDirect();
}

function BwRegistry_SgPointerModifiedCB(attribute, container)
{
    container.sgPointerModified();
}
BwSceneInspector.prototype = new SceneInspector();
BwSceneInspector.prototype.constructor = BwSceneInspector;

function BwSceneInspector()
{
    SceneInspector.call(this);
    this.className = "BwSceneInspector";
    this.attrType = eAttrType.SceneInspector;
    
    this.camera = null;
    this.viewport = new Viewport();
    this.worldUnitsPerPixel = new Vector2D();
    this.clickPosWorld = new Vector3D();
    this.last_d3 = 0;
    
    this.translationSensitivity = new Vector3DAttr(1, 1, 1);
    this.panSensitivity = new Vector3DAttr(1, 1, 1);
    this.trackSensitivity = new Vector3DAttr(1, 1, 1);
    this.rotationSensitivity = new Vector3DAttr(1, 1, 1);
    this.zoomSensitivity = new NumberAttr(1);
    this.invertedTranslationDelta = new Vector3DAttr(0, 0, 0);
    this.invertedPanDelta = new Vector3DAttr(0, 0, 0);
    this.invertedTrackDelta = new Vector3DAttr(0, 0, 0);
    this.invertedRotationDelta = new Vector3DAttr(0, 0, 0);
    this.zoomDelta = new NumberAttr(0);
    this.invertedZoomDelta = new NumberAttr(0);
    this.selectionOccurred = new BooleanAttr(false);
    this.viewRelativeTranslationDelta = new Vector3DAttr(0, 0, 0);
    
    this.translationDelta.addModifiedCB(BwSceneInspector_TranslationDeltaModifiedCB, this);
    this.panDelta.addModifiedCB(BwSceneInspector_PanDeltaModifiedCB, this);
    this.trackDelta.addModifiedCB(BwSceneInspector_TrackDeltaModifiedCB, this);
    this.rotationDelta.addModifiedCB(BwSceneInspector_RotationDeltaModifiedCB, this);
    this.invertedTranslationDelta.addModifiedCB(BwSceneInspector_InvertedTranslationDeltaModifiedCB, this);
    this.invertedPanDelta.addModifiedCB(BwSceneInspector_InvertedPanDeltaModifiedCB, this);
    this.invertedTrackDelta.addModifiedCB(BwSceneInspector_InvertedTrackDeltaModifiedCB, this);
    this.invertedRotationDelta.addModifiedCB(BwSceneInspector_InvertedRotationDeltaModifiedCB, this);
    this.zoomDelta.addModifiedCB(BwSceneInspector_ZoomDeltaModifiedCB, this);
    this.invertedZoomDelta.addModifiedCB(BwSceneInspector_InvertedZoomDeltaModifiedCB, this);
    this.selectionOccurred.addModifiedCB(BwSceneInspector_SelectionOccurredCB, this);
    this.viewRelativeTranslationDelta.addModifiedCB(BwSceneInspector_TrackDeltaModifiedCB, this);
    
    this.registerAttribute(this.translationSensitivity, "translationSensitivity");
    this.registerAttribute(this.panSensitivity, "panSensitivity");
    this.registerAttribute(this.trackSensitivity, "trackSensitivity");
    this.registerAttribute(this.rotationSensitivity, "rotationSensitivity");
    this.registerAttribute(this.zoomSensitivity, "zoomSensitivity");
    this.registerAttribute(this.invertedTranslationDelta, "invertedTranslationDelta");
    this.registerAttribute(this.invertedPanDelta, "invertedPanDelta");
    this.registerAttribute(this.invertedTrackDelta, "invertedTrackDelta");
    this.registerAttribute(this.invertedRotationDelta, "invertedRotationDelta");
    this.registerAttribute(this.zoomDelta, "zoomDelta");
    this.registerAttribute(this.invertedZoomDelta, "invertedZoomDelta");
    this.registerAttribute(this.selectionOccurred, "selectionOccurred");
    this.registerAttribute(this.viewRelativeTranslationDelta, "viewRelativeTranslationDelta");
    
    // set orphan so that evaluator will not be added to scene graph
	this.orphan.setValueDirect(true);
	
	this.enabled.addModifiedCB(BwSceneInspector_EnabledModifiedCB, this);
}

BwSceneInspector.prototype.evaluate = function()
{
    // call base-class implementation
    SceneInspector.prototype.evaluate.call(this);
}

BwSceneInspector.prototype.translate = function(delta)
{
    if (delta.x == 0 && delta.y == 0 && delta.z == 0)
    {
        // no effect
        return;
    }
    
    // get sensitivity
    var sensitivity = this.translationSensitivity.getValueDirect();

    // calculate deltas (scale by sensitivity)
    delta.x *= sensitivity.x;
    delta.y *= sensitivity.y;
    delta.z *= sensitivity.z;

    // set deltas
    var values = [delta.x, delta.y, delta.z];
    var params = new AttributeSetParams(-1, -1, 0, true, false);
	this.translationDelta.setValue(values, params);
	
    // evaluate scene inspector
	this.evaluate();

    // clear deltas
    var zeroes = [0, 0, 0];
    this.translationDelta.setValue(zeroes, params);
    this.invertedTranslationDelta.setValue(zeroes, params);
}

BwSceneInspector.prototype.pan = function(delta)
{
    if (delta.x == 0 && delta.y == 0 && delta.z == 0)
    {
        // no effect
        return;
    }
    
    // if worldUnitsPerPixel hasn't been set, use pivot distance as default
    if (this.worldUnitsPerPixel.x == 0 && this.worldUnitsPerPixel.y == 0)
    {
        var wupp = this.getWorldUnitsPerPixel(this.pivotDistance.getValueDirect());
        this.worldUnitsPerPixel.x = wupp.x;
        this.worldUnitsPerPixel.y = wupp.y;
    }
    
    // get sensitivity
    var sensitivity = this.panSensitivity.getValueDirect();

    // calculate deltas (scale by sensitivity & worldUnitsPerPixel)
    delta.x *= sensitivity.x * this.worldUnitsPerPixel.x;
    delta.y *= sensitivity.y * this.worldUnitsPerPixel.y;
    delta.z *= sensitivity.z * this.worldUnitsPerPixel.y; // use y for z
    
    // set deltas
    var values = [delta.x, delta.y, delta.z];
    var params = new AttributeSetParams(-1, -1, 0, true, false);
	this.panDelta.setValue(values, params);
	
	// update pivot distance if panning in z-direction
	if (delta.z != 0)
	{
	    var pivotDistance = this.pivotDistance.getValueDirect();
	    pivotDistance -= delta.z;
	    this.pivotDistance.setValueDirect(pivotDistance);
	}
	
    // evaluate scene inspector
	this.evaluate();

    // clear deltas
    var zeroes = [0, 0, 0];
    this.panDelta.setValue(zeroes, params);
    this.invertedPanDelta.setValue(zeroes, params);
}

BwSceneInspector.prototype.track = function(delta)
{   
    if (delta.x == 0 && delta.y == 0 && delta.z == 0)
    {
        // no effect
        return;
    }

    // not supported for orthographic cameras
    if (this.camera == null || this.camera.attrType == eAttrType.OrthographicCamera)
    {
        return;
    }

	// check for valid viewport
	if (this.viewport.width <= 0 || this.viewport.height <= 0)
	{
		return;
	}

    // if worldUnitsPerPixel hasn't been set, use pivot distance as default
    if (this.worldUnitsPerPixel.x == 0 && this.worldUnitsPerPixel.y == 0)
    {
        var wupp = this.getWorldUnitsPerPixel(this.pivotDistance.getValueDirect());
        this.worldUnitsPerPixel.x = wupp.x;
        this.worldUnitsPerPixel.y = wupp.y;
    }

    // get sensitivity
    var sensitivity = this.trackSensitivity.getValueDirect();

    // calculate x and y deltas (scale by sensitivity & worldUnitsPerPixel)
    // calculate deltas (scale by sensitivity & worldUnitsPerPixel)
    delta.x *= sensitivity.x * this.worldUnitsPerPixel.x;
    delta.y *= sensitivity.y * this.worldUnitsPerPixel.y;
    
    // calculate z delta (scale by sensitivity)
    if (delta.z != 0)
    {
        // Let cameraPos be the sector position of the camera
		var cameraPos = this.camera.getAttribute("position").getValueDirect();

        // Let cameraRot be the world-space rotation of the camera
        var cameraRot = this.camera.getAttribute("rotation").getValueDirect();
    
        // Let cameraHeight be the delta between the clickPosWorld.y and cameraPos.y
        var cameraHeight = cameraPos.y - this.clickPosWorld.y;
        
        // STEP 2: define d1 as the distance between cameraPos and clickPosWorld
        var d1 = distanceBetween(cameraPos, this.clickPosWorld);

        // STEP 3: using the pythagorean theorem, a^2 + b^2 = c^2, where a = cameraHeight, 
        //         b = unknown, and c = d1, find the length b1 of side b
        var b1 = Math.sqrt((d1 * d1) - (cameraHeight * cameraHeight));

        // calculate distance between camera and new point
        var zoom = this.camera.getAttribute("zoom").getValueDirect();
        var fovy = 2 * Math.atan2(1, zoom);
        var radsPerPixel = fovy / this.viewport.height;
        var angleB_Radians = Math.acos(cameraHeight / d1);
        var angleA_Radians = angleB_Radians + (delta.z * radsPerPixel);
        var b2 = Math.tan(angleA_Radians) * cameraHeight;

        // STEP 7: define d3 as b2 - b1
        var d3 = b2 - b1;

        // as angle B approaches 90, use last calculated d3 (algorithm produces exponential results otherwise) 
        if (angleB_Radians >= toRadians(88) && angleB_Radians <= toRadians(92))
        {
            if (d3 < 0)
            {
                d3 = -(Math.abs(this.last_d3));
            }
            else
            {
                d3 = Math.abs(this.last_d3);
            }
        }

        var viewRotation = cameraRot;
        var fabs_bank = Math.abs(cameraRot.z);
        var flipIt = false;
        if (fabs_bank >= 90 && fabs_bank <= 270)
        {
            if (cameraRot.x > -45 && cameraRot.x < 45)
            {
                flipIt = true;
            }
        }
        if (flipIt)
        {
            d3 = -d3;
        }

        this.last_d3 = d3;

        // STEP 8: translate camera by d3 units
		delta.z = d3 * sensitivity.z * (cameraHeight < 0 ? -1 : 1);

        //var mat = new Matrix4x4();
        //mat.loadYAxisRotation(cameraRot.y);
        //var v = mat.transform(0, 0, 1, 0);
        //v.normalize();
        
        var directions = this.camera.getDirectionVectors();
        v = new Vector3D(directions.forward.x, directions.forward.y, directions.forward.z);
        v.y = 0;
        v.normalize();

        // method 1 for retrieval of angle C
        var camToClick = subtract3D(this.clickPosWorld, cameraPos);
        camToClick.y = 0;
        camToClick.normalize();
        var cosAngleBetweenCameraDirectionAndCamToClick = cosineAngleBetween(camToClick, v);
        var headingRads = Math.acos(cosAngleBetweenCameraDirectionAndCamToClick);
    
        // method 2 for retrieval of angle C
        var fovx = 2 * Math.atan(this.viewport.width / this.viewport.height * Math.tan(fovy / 2));
        var radsPerPixelX = fovx / this.viewport.width;
        var clickPoint;
        var selector = this.registry.find("Selector");
        if (selector)
        {
            clickPoint = selector.getAttribute("clickPoint").getValueDirect();
        }
        var angleC_Radians = Math.abs(this.viewport.width / 2 - clickPoint.x) * radsPerPixelX;
        headingRads = angleC_Radians;
    
        var xTrans = Math.tan(headingRads) * d3;

        var plane = new Plane(cameraPos, directions.right);
        if (pointOnNegativeSideOfPlane(this.clickPosWorld, plane))
        {
            xTrans *= -1;
        }
        if (flipIt)
        {
            xTrans *= -1;
        }

        delta.x += -xTrans;
    }
    
    // set deltas
    var values = [delta.x, delta.y, delta.z];
    var params = new AttributeSetParams(-1, -1, 0, true, false);
	this.trackDelta.setValue(values, params);
	
	// evaluate scene inspector
	this.evaluate();

    // clear deltas
    var zeroes = [0, 0, 0];
    this.trackDelta.setValue(zeroes, params);
    this.invertedTrackDelta.setValue(zeroes, params);
}

BwSceneInspector.prototype.rotate = function(delta)
{
    if (delta.x == 0 && delta.y == 0 && delta.z == 0)
    {
        // no effect
        return;
    }

    // get sensitivity
    var sensitivity = this.rotationSensitivity.getValueDirect();

    // calculate deltas (scale by sensitivity)
    delta.x *= sensitivity.x;
    delta.y *= sensitivity.y;
    delta.z *= sensitivity.z;

    // set deltas
    var values = [delta.x, delta.y, delta.z];
    var params = new AttributeSetParams(-1, -1, 0, true, false);
	this.rotationDelta.setValue(values, params);
	
    // evaluate scene inspector
	this.evaluate();

    // clear deltas
    var zeroes = [0, 0, 0];
    this.rotationDelta.setValue(zeroes, params);
    this.invertedRotationDelta.setValue(zeroes, params);
}

BwSceneInspector.prototype.zoom = function(delta)
{
    if (delta == 0)
    {
        // no effect
        return;
    }
    
    if (!this.camera)
    {
        return;
    }
    
    switch (this.camera.className)
    {
    case "PerspectiveCamera":
        {
            var zoom = this.camera.getAttribute("zoom").getValueDirect();
            zoom += delta * this.zoomSensitivity.getValueDirect();
            if (zoom < 0) zoom = 0.05; // don't go < 0
            this.camera.getAttribute("zoom").setValueDirect(zoom);
        }
        break;
        
    case "OrthographicCamera":
        {
            var width = this.camera.getAttribute("width").getValueDirect();
            width += delta * this.zoomSensitivity.getValueDirect();
            if (width < 0) width = 0; // don't go < 0
            this.camera.getAttribute("width").setValueDirect(width);
        }
        break;
    }
}

BwSceneInspector.prototype.setCamera = function(camera)
{
    this.camera = camera;
}

BwSceneInspector.prototype.getCamera = function()
{
    return this.camera;
}

BwSceneInspector.prototype.getWorldUnitsPerPixel = function(viewSpace_Z)
{
    var x = 0;
    var y = 0;
    
    // get current viewport
    var selector = this.registry.find("Selector");
    if (selector)
    {
        var vp = selector.selections.viewports[selector.selections.viewports.length-1];
        
        if (this.camera)
        {
            switch (this.camera.attrType)
            {
            case eAttrType.PerspectiveCamera:
                {
                    // get zoom
				    var zoom = this.camera.getAttribute("zoom").getValueDirect();

				    // determine the per-pixel width and height at viewSpace_Z
				    var result = worldUnitsPerPixelPersp(vp, zoom, viewSpace_Z);
				    x = result.x;
				    y = result.y;    
                }
                break;
                
            case eAttrType.OrthographicCamera:
                {
                    // get width
				    var width = this.camera.getAttribute("width").getValueDirect();

				    // determine the per-pixel width and height
				    var result = worldUnitsPerPixelOrtho(vp, width);
				    x = result.x;
				    y = result.y;
                }
                break;
            }
        }
    }
    
    return { x: x, y: y };
}

function BwSceneInspector_TranslationDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.translate(attribute.getValueDirect());
    }
}
    
function BwSceneInspector_PanDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.pan(attribute.getValueDirect());
    }
}

function BwSceneInspector_TrackDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.track(attribute.getValueDirect());
    }
}

function BwSceneInspector_RotationDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.rotate(attribute.getValueDirect());
    }
}

function BwSceneInspector_InvertedTranslationDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        var deltas = attribute.getValueDirect();
        deltas.x *= -1;
        deltas.y *= -1;
        deltas.z *= -1;
        container.translate(deltas);
        
        if (deltas.x != 0 || deltas.y != 0 || deltas.z != 0) alert("rotate");
    }
}
 
function BwSceneInspector_InvertedPanDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        var deltas = attribute.getValueDirect();
        deltas.x *= -1;
        deltas.y *= -1;
        deltas.z *= -1;
        container.pan(deltas);
    }
}

function BwSceneInspector_InvertedTrackDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        var deltas = attribute.getValueDirect();
        deltas.x *= -1;
        deltas.y *= -1;
        deltas.z *= -1;
        container.track(deltas);
    }
}

function BwSceneInspector_InvertedRotationDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        var deltas = attribute.getValueDirect();
        deltas.x *= -1;
        deltas.y *= -1;
        deltas.z *= -1;
        container.rotate(deltas);
    }
}

function BwSceneInspector_ZoomDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.zoom(attribute.getValueDirect());
    }
}

function BwSceneInspector_InvertedZoomDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.zoom(attribute.getValueDirect() * -1);
    }
}

function BwSceneInspector_SelectionOccurredCB(attribute, container)
{
    var selector = container.registry.find("Selector");
    if (selector)
    {
        // get viewport
        if (selector.selections.viewports.length > 0)
        {
            container.viewport.loadViewport(selector.selections.viewports[0]);
        }
        
        // get click point in world-space
        container.clickPosWorld.copy(selector.getAttribute("pointWorld").getValueDirect());
        
        // get click point in view-space
        var clickPosView = selector.getAttribute("pointView").getValueDirect();
        
        // get world units per-pixel at click point z
        container.getWorldUnitsPerPixel(clickPosView.z);
    }
}

function BwSceneInspector_EnabledModifiedCB(attribute, container)
{
    var enabled = attribute.getValueDirect();
}


ObjectInspector.prototype = new ArcballInspector();
ObjectInspector.prototype.constructor = ObjectInspector;

function ObjectInspector()
{
    ArcballInspector.call(this);
    this.className = "ObjectInspector";
    this.attrType = eAttrType.ObjectInspector;
    
    this.camera = null;
    this.selectedObjects = [];
    this.pointView = new Vector3DAttr(1, 1, 1);
    this.translationDelta = new Vector3DAttr(0, 0, 0);
    this.rotationDelta = new Vector3DAttr(0, 0, 0);
    this.translationNow = new Vector3DAttr(0, 0, 0);
    this.rotationNow = new Vector3DAttr(0, 0, 0);
    this.selectionOccurred = new BooleanAttr(false);
    this.selectionCleared = new BooleanAttr(false);
    
    this.translationDelta.addModifiedCB(ObjectInspector_TranslationDeltaModifiedCB, this);
    this.rotationDelta.addModifiedCB(ObjectInspector_RotationDeltaModifiedCB, this);
    this.translationNow.addModifiedCB(ObjectInspector_TranslationNowModifiedCB, this);
    this.rotationNow.addModifiedCB(ObjectInspector_RotationNowModifiedCB, this);
    this.selectionOccurred.addModifiedCB(ObjectInspector_SelectionOccurredCB, this);
    this.selectionCleared.addModifiedCB(ObjectInspector_SelectionClearedCB, this);
    
    this.registerAttribute(this.pointView, "pointView");
    this.registerAttribute(this.translationDelta, "translationDelta");
    this.registerAttribute(this.rotationDelta, "rotationDelta");    
    this.registerAttribute(this.translationNow, "translationNow");    
    this.registerAttribute(this.rotationNow, "rotationNow");    
    this.registerAttribute(this.selectionOccurred, "selectionOccurred");
    this.registerAttribute(this.selectionCleared, "selectionCleared");
    
    // set orphan so that evaluator will not be added to scene graph
    this.orphan.setValueDirect(true);   
    
    this.enabled.addModifiedCB(ObjectInspector_EnabledModifiedCB, this)   
}

ObjectInspector.prototype.applyCameraRelativeRotation = function(selected)
{
    var i;
	
    // vectors
    var pivot  = null;
    var screen = null;
	
    // matrices
    var camXform  = null;
    var proj  = null;
    var world = null;
    
    // viewport
    var vp = this.viewport;

    // convenience
    var cam = this.camera;

    // sphere center (use world position of selected node)
    pivot = selected.worldCenter.getValueDirect();

    camXform = cam.getTransform();
    camXform.invert(); // put in view-space
    
    projection = cam.projectionMatrix;

    screen = toScreenSpace(pivot, camXform, projection, vp);
	
    this.sphereCenter.setValueDirect(screen.x, screen.y, 0);

    // sphere radius
    this.sphereRadius.setValueDirect(0.75);

    // world transform
    world = selected.getTransform();
    
    this.worldTransform.setValueDirect(world);

    // view transform
    camXform = cam.getTransform();
	
    this.viewTransform.setValueDirect(camXform);
    
    //var sPos = this.viewTransform.getValueDirect();
    //console.debug("ObjectInspector.viewTransform: " + sPos._11 + ", " + 
    //    sPos._12 + ", " + sPos._13);
}

ObjectInspector.prototype.applyCameraRelativeTranslation = function(selected)
{
    var cam = this.camera;

    // get translation delta values
    var delta = this.translationDelta.getValueDirect();
	
    if (delta.x == 0 && delta.y == 0 && delta.z == 0) 
    {
        return;
    }

    // get sector view matrix
    var camSectorXform = cam.getSectorTransform();
    camSectorXform.invert(); // put in view-space

    // get node, camera world positions
    var nodePos = selected.sectorWorldCenter.getValueDirect();
    var camPos  = cam.sectorWorldPosition.getValueDirect();

    // calculate forward vector as vector from camera world position to node world position
    var fwd = new Vector3D(nodePos.x - camPos.x, 
                           nodePos.y - camPos.y,
                           nodePos.z - camPos.z);
    fwd.normalize();

    // get viewport dimensions
    var vp = this.viewport;

    // get click point in camera space
    var v = this.pointView.getValueDirect();
    var clickPtCamSpace = new Vector3D(v.x, v.y, v.z);

    var transDelta = null;
    
    var xTransCamSpace = new Vector3D(1, 0, 0);
    var yTransCamSpace = new Vector3D(0, 1, 0);
    var zTransWorldSpace = new Vector3D(fwd.x, fwd.y, fwd.z);
    
    var destCamSpace = new Vector3D(v.x, v.y, v.z);
    
    var parent = selected.motionParent;
    var mParent = null;
    if (parent) 
    {
        mParent = parent.getTransform();
        mParent.invert();
    }
    
    var perPixelWidth = -1;
    var zoom_or_width = -1;
    
    switch (cam.attrType)
    {
        case eAttrType.PerspectiveCamera:
        {
            // get zoom
            zoom_or_width = cam.zoom.getValueDirect();

            // determine the per-pixel width and height at clickPtCamSpace.z
            perPixelWidth = worldUnitsPerPixelPersp(vp, zoom_or_width, clickPtCamSpace.z);
        }
        break;

        case eAttrType.OrthographicCamera:
        {
            // get width
            zoom_or_width = cam.width.getValueDirect();

            // determine the per-pixel width and height
            perPixelWidth = worldUnitsPerPixelOrtho(vp, zoom_or_width);

        }
        break;

        default:
            break;
    }
    
    // multiply the per-pixel width by delta.x and use this to scale the
    // camera-space vector (1, 0, 0)
    xTransCamSpace.multiplyScalar(perPixelWidth.x);
    xTransCamSpace.multiplyScalar(-delta.x);

    // multiply the per-pixel height by delta.y and use this to scale the
    // camera-space vector (0, 1, 0)
    yTransCamSpace.multiplyScalar(perPixelWidth.y);
    yTransCamSpace.multiplyScalar(delta.y);

    // multiply the per-pixel height by delta.z and use this to scale the
    // world-space forward vector
    zTransWorldSpace.multiplyScalar(perPixelWidth.y);
    zTransWorldSpace.multiplyScalar(delta.z);

    // calculate camera-space destination point as camera-space click point
    // plus xTransCamSpace and yTransCamSpace
    destCamSpace.addVector(xTransCamSpace);
    destCamSpace.addVector(yTransCamSpace);

    // convert clickPtCamSpace and destCamSpace to world space
    camSectorXform.invert();
    // if parented, multipy view with parent's inverse
    if (mParent)
    {
        camSectorXform = camSectorXform.multiply(mParent);
        zTransWorldSpace = mParent.transform(zTransWorldSpace.x, zTransWorldSpace.y, zTransWorldSpace.z, 0);
    }
    clickPtCamSpace = camSectorXform.transform(clickPtCamSpace.x, clickPtCamSpace.y, clickPtCamSpace.z, 1);
    destCamSpace = camSectorXform.transform(destCamSpace.x, destCamSpace.y, destCamSpace.z, 1);
    
    // calculate the translation delta as destCamSpace - clickPtCamSpace + zTransWorldSpace
    transDelta = new Vector3D(destCamSpace.x, destCamSpace.y, destCamSpace.z);
    transDelta.subtractVector(clickPtCamSpace);
    transDelta.addVector(zTransWorldSpace);

    // add scaled direction vectors to current node position
    var attrSetParams = new AttributeSetParams(-1, -1, eAttrSetOp.Add, true, true);
    var attrSetVals = [transDelta.x, transDelta.y, transDelta.z];
    selected.sectorPosition.setValue(attrSetVals, attrSetParams);

    var sPos = selected.sectorPosition.getValueDirect();
    console.debug("selected.sectorPosition: " + sPos.x + ", " + 
        sPos.y + ", " + sPos.z);
}

ObjectInspector.prototype.translationDeltaModified = function()
{
    var pme = null;
    for (var i=0; i < this.selectedObjects.length; i++)
    {
        pme = this.selectedObjects[i];
        if (!pme)
        {
            continue;
        }

        var moveable = pme.getAttribute("moveable").getValueDirect();
        if (!moveable)
        {
            continue;
        }

        this.applyCameraRelativeTranslation(pme);
    }

    var zeroes = [0, 0, 0];
    var params = new AttributeSetParams(0,0,0, true, false);

    this.translationDelta.setValue(zeroes, params);  
}

ObjectInspector.prototype.rotationDeltaModified = function()
{
    var pme = null;
    for (var i=0; i < this.selectedObjects.length; i++)
    {
        pme = this.selectedObjects[i];
        if (!pme)
        {
            continue;
        }

        var moveable = pme.moveable.getValueDirect();
        if (!moveable)
        {
            continue;
        }

        this.applyCameraRelativeRotation(pme);

        var mNow = this.mouseNow.getValueDirect();
        var rDelta = this.rotationDelta.getValueDirect();

        mNow.x -= rDelta.x;
        mNow.y -= rDelta.y;

        // mouse now (formulate so that mouse coords match windows standard
        // of (0, 0) at top-left, and (width, height) at bottom-right)
        this.mouseNow.setValueDirect(mNow.y, mNow.x);

        this.evaluate();
    }
}

ObjectInspector.prototype.rotationNowModified = function()
{
    if (this.selectedObjects == null ||
        this.selectedObjects == undefined)
        return;
    
    var pme = null;
    for (var i=0; i < this.selectedObjects.length; i++)
    {
        pme = this.selectedObjects[i];
		
        var moveable = pme.moveable.getValueDirect();
        if (moveable)
        {

            this.applyCameraRelativeRotation(pme);
            
            var rNow = this.rotationNow.getValueDirect();
            
            // mouse now (formulate so that mouse coords match windows standard
            // of (0, 0) at top-left, and (width, height) at bottom-right)
            this.mouseNow.setValueDirect(rNow.y, rNow.x);
            
            //console.debug("mouseNow: " + rNow.x + ", " + 
            //    rNow.y);
    
            this.evaluate();
        }
    }
}

ObjectInspector.prototype.runSelectionOccurred = function()
{
    var selector =  this.registry.find("Selector");
    var vpMgr = this.registry.find("ViewportMgr");

    //this.registryThreadLock.Unlock();
    if (!selector || !vpMgr)
    {
        return;
    }

    // get selector click point
    // must use getAttribute here b/c it's not a native attribute to Selector
    var clickPoint = selector.getAttribute("clickPoint").getValueDirect();

    // get viewport and camera into view object
    var view = vpMgr.getViewportAtScreenXY(clickPoint.x, clickPoint.y);
    this.viewport = view.viewport;
    this.camera = view.camera;
	
    // get selected movable objects
    // TODO: don't assume models?
    this.selectedObjects = selector.selections.models.slice();

    var pResultQuat = this.resultQuat;
    var pQuatAtMouseDown = this.quatAtMouseDown;
    var pMouseDown = this.mouseDown;
    var pMouseNow = this.mouseNow;
    
    var pSelected = null;
    var pIso = null;	// TODO: support more than just Isolators
    var pChildZero = null;
    var pRotGroup = null;
    var pQuat = null;
    var pTransOut = null;
    var pTransBack = null;
    var pRotQuatAttr = null;
    var pBox = null;
    var center = 0;
    var centerNeg = 0;
	
    for (var i=0; i < this.selectedObjects.length; i++)
    {
        pResultQuat.removeAllTargets();

        pMouseDown.setValueDirect(clickPoint.x, clickPoint.y);
        pMouseNow.setValueDirect(clickPoint.x, clickPoint.y);

        // for each selected moveable, attach it's Quat to the Inspector
        for (var j=0; j < this.selectedObjects.length; j++)
        {
            pSelected = this.selectedObjects[j];

            pRotGroup = getInspectionGroup(pSelected);
            //setInspectionGroupActivationState(pSelected, this.enabled.getValueDirect())
            if (pRotGroup && (pQuat = pRotGroup.getChild(2)))
            {
                // see notes in BwObjectInspector.cpp
                var values = [true];
                var params = new AttributeSetParams(-1, -1, eAttrSetOp.Replace, true, true);
                // it would seem easier to setValueDirect(true) here given params are
                // created with all default values but params are reused throughout this
                // function and setting the intended params values, per the notes in .cpp,
                // triggers a bug elsewhere. 
                pQuat.enabled.setValue(values, params);

                pRotQuatAttr = pQuat.rotationQuat;

                pResultQuat.addTarget(pRotQuatAttr);
				
                var prq = pRotQuatAttr.getValueDirect();
                pQuatAtMouseDown.setValueDirect(prq);

                var box = pSelected.bbox;
                var min = box.min.getValueDirect();
                var max = box.max.getValueDirect();
                center = new Vector3D(min.x, min.y, min.z);
                center.addVector(max);
                center.multiplyScalar(0.5);
	
                var pivot = pSelected.pivot.getValueDirect();
                if (pSelected.pivotAboutGeometricCenter.getValueDirect())
                {
                    pivot = center;
                }				
                var pivotNeg = new Vector3D(pivot.x, pivot.y, pivot.z);
                pivotNeg.multiplyScalar(-1);

                // translate to pivot before applying quaternion rotation
                // don't alert modified sinks here because this will cause antialiasing to reset
                values = [pivot.x, pivot.y, pivot.z];
                pRotGroup.getChild(0).translation.setValue(values, params);

                // don't alert modified sinks here because this will cause antialiasing to reset
                var scale = pSelected.worldScale.getValueDirect();
                var scaleInv = new Vector3D(1 / scale.x,
                    1 / scale.y,
                    1 / scale.z);
                values[0] = scaleInv.x;
                values[1] = scaleInv.y;
                values[2] = scaleInv.z;
                pRotGroup.getChild(1).scale.setValue(values, params);
                
                values[0] = scale.x;
                values[1] = scale.y;
                values[2] = scale.z;
                pRotGroup.getChild(3).scale.setValue(values, params);
            
                // translate back from pivot after applying quaternion rotation
                // don't alert modified sinks here because this will cause antialiasing to reset
                values[0] = pivotNeg.x;
                values[1] = pivotNeg.y;
                values[2] = pivotNeg.z;
                pRotGroup.getChild(4).translation.setValue(values, params);
            }
        }
    }   
}

ObjectInspector.prototype.runSelectionCleared = function()
{
    this.selectedObjects = [];
}

function ObjectInspector_TranslationDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.translationDeltaModified();
    }
}

function ObjectInspector_RotationDeltaModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.rotationDeltaModified();
    }
}

function ObjectInspector_TranslationNowModifiedCB(attribute, container)
{
// deprecated
}

function ObjectInspector_RotationNowModifiedCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.rotationNowModified();
    }
}

function ObjectInspector_SelectionOccurredCB(attribute, container)
{
    var enabled = container.enabled.getValueDirect();
    if (enabled)
    {
        container.runSelectionOccurred();
    }
}

function ObjectInspector_SelectionClearedCB(attribute, container)
{
    container.runSelectionCleared();
}

function ObjectInspector_EnabledModifiedCB(attribute, container)
{
    console.debug("ObjectInspector.enable modified: " + container.enabled.getValueDirect().toString())
}


ConnectionMgr.prototype = new AttributeContainer();
ConnectionMgr.prototype.constructor = ConnectionMgr;

function ConnectionMgr()
{
    AttributeContainer.call(this);
    this.className = "ConnectionMgr";
    
    this.name = new StringAttr("ConnectionMgr");
    
    this.registerAttribute(this.name, "name");
    
    // TODO: finish adding connection helpers
    //registerConnectionHelper("DisconnectAllSources", null, ConnectionMgr.prototype.disconnectAllSources);
    registerConnectionHelper("DisconnectAllTargets", null, ConnectionMgr.prototype.disconnectAllTargets);
    registerConnectionHelper("dissolve", ConnectionMgr.prototype.connectDissolve, ConnectionMgr.prototype.disconnectDissolve);
}

ConnectionMgr.prototype.connectSceneInspection = function(inspector, camera)
{
    if (!inspector || !camera) return;
    
    var lastCamera = inspector.getCamera();
    if (lastCamera == camera)
    {
        // already connected
        return;
    }
    else if (lastCamera)
    {
        this.disconnectSceneInspection(inspector, lastCamera);
    }

    camera.getAttribute("sectorPosition").addTarget(inspector.getAttribute("viewPosition"), eAttrSetOp.Replace, null, true);
    camera.getAttribute("rotation").addTarget(inspector.getAttribute("viewRotation"), eAttrSetOp.Replace, null, true);

    inspector.getAttribute("resultPosition").addTarget(camera.getAttribute("sectorPosition"), eAttrSetOp.Replace, null, false);
    inspector.getAttribute("resultRotation").addTarget(camera.getAttribute("rotation"), eAttrSetOp.Replace, null, false);
    
    inspector.setCamera(camera);
}

ConnectionMgr.prototype.disconnectAllTargets = function(source, target)
{
    if (source)
    {
        var count = source.getAttributeCount();
        for (var i=0; i < count; i++)
        {
            var attribute = source.getAttributeAt(i);
            if (attribute)
            {
                attribute.removeAllTargets();
            }
        }
    }
}

ConnectionMgr.prototype.disconnectSceneInspection = function(inspector, camera)
{
    if (!inspector || !camera) return;
    
    camera.getAttribute("sectorPosition").removeTarget(inspector.getAttribute("viewPosition"));
    camera.getAttribute("rotation").removeTarget(inspector.getAttribute("viewRotation"));
    
    inspector.getAttribute("resultPosition").removeTarget(camera.getAttribute("sectorPosition"));
    inspector.getAttribute("resultRotation").removeTarget(camera.getAttribute("rotation"));
    
    inspector.setCamera(null);
}

ConnectionMgr.prototype.connectMapProjectionCalculator = function(mpc, pme)
{
    if (!mpc || !pme) return;

    mpc.getAttribute("resultPosition").addTarget(pme.getAttribute("position"));

    mpc.evaluate();
}

ConnectionMgr.prototype.disconnectMapProjectionCalculator = function(mpc, pme)
{
    if (!mpc || !pme) return;

    mpc.getAttribute("resultPosition").removeTarget(pme.getAttribute("position"));
}

ConnectionMgr.prototype.connectDissolve = function(evaluator, target)
{
    if (!evaluator || !target) return;
    
    var dissolve = target.getAttribute("dissolve");
    if (dissolve)
    {
        var resultValues = evaluator.getAttribute("resultValues");
        if (resultValues)
        {
            var resultValue = resultValues.getAt(0);
            if (resultValue)
            {
                resultValue.addTarget(dissolve);
            }
        }
    }
}

ConnectionMgr.prototype.disconnectDissolve = function(evaluator, target)
{
    if (!evaluator || !target) return;
    
    var dissolve = target.getAttribute("dissolve");
    if (dissolve)
    {
        var resultValues = evaluator.getAttribute("resultValues");
        if (resultValues)
        {
            var resultValue = resultValues.getAt(0);
            if (resultValue)
            {
                resultValue.removeTarget(dissolve);
            }
        }
    }
}

RenderAgent.prototype = new Agent();
RenderAgent.prototype.constructor = RenderAgent;

var ePlayState = {
    Unknown:    -1,
    
    Play:       0,
    Pause:      1,
    Stop:       2,
}

function RenderAgent(bridgeworks)
{
    Agent.call(this);
    this.className = "RenderAgent";
    
    this.bridgeworks = bridgeworks;
    
    this.name.setValueDirect("RenderAgent");
    this.timer = new Timer();
    
    this.frameRate = new NumberAttr(0);
    this.desiredFrameRate = new NumberAttr(30);
    this.timeIncrement = new NumberAttr(0);
    this.globalTimeInSecs = new NumberAttr(0);
    this.elapsedTimeInSecs = new NumberAttr(0);

    this.desiredFrameRate.addModifiedCB(RenderAgent_DesiredFrameRateModified, this);
    this.globalTimeInSecs.addModifiedCB(RenderAgent_GlobalTimeInSecsModified, this);
    
    this.registerAttribute(this.frameRate, "frameRate");
    this.registerAttribute(this.desiredFrameRate, "desiredFrameRate");
    this.registerAttribute(this.timeIncrement, "timeIncrement");
    this.registerAttribute(this.globalTimeInSecs, "globalTimeInSecs");
    this.registerAttribute(this.elapsedTimeInSecs, "elapsedTimeInSecs");
}

RenderAgent.prototype.render = function()
{
    this.timer.stop();
    var increment = this.timer.getTime();
    this.timer.start();
    this.timeIncrement.setValueDirect(increment);
    
    var elapsedTime = this.elapsedTimeInSecs.getValueDirect() + increment;
    this.elapsedTimeInSecs.setValueDirect(elapsedTime);
    // update frame rate
    this.frameRate.setValueDirect(1.0 / increment);
    //alert(this.desiredFrameRate.getValueDirect());
    this.animateEvaluators(increment);
    this.executeRenderDirectives();
}

RenderAgent.prototype.animateEvaluators = function(timeIncrement)
{
    var evaluators = this.registry.getByType(eAttrType.Evaluator);
    for (var i=0; i < evaluators.length; i++)
    {
        this.animateEvaluator(evaluators[i], timeIncrement);
    }
}

RenderAgent.prototype.animateEvaluator = function(evaluator, timeIncrement)
{
    var enabled = evaluator.getAttribute("enabled").getValueDirect();
    var expired = evaluator.getAttribute("expired").getValueDirect();

    var orphan = evaluator.getAttribute("orphan").getValueDirect();

    if (enabled && !expired)
    {
        switch (evaluator.className)
        {
            case "KeyframeInterpolator":
            {
                var params = new AttributeSetParams(-1, -1, eAttrSetOp.Add, true, true);
                evaluator.getAttribute("time").setValue(timeIncrement, params);
            }
            break;
            
            case "ObjectMover":
            case "AnimalMover":
            {
            	evaluator.getAttribute("timeIncrement").setValueDirect(timeIncrement);
            }
        }

        // don't evaluate scene/object inspection here, or any other evaluator not in the scene graph
        if (!orphan) evaluator.evaluate();
    }

    // if evaluator has expired, and it's set to "renderAndRelease", release it
    if (expired && evaluator.getAttribute("renderAndRelease").getValueDirect())
    {
        this.registry.unregister(evaluator);
    }
}

RenderAgent.prototype.executeRenderDirectives = function()
{
    var directives = this.registry.getByType(eAttrType.RenderDirective);
    if (directives)
    {
        this.bridgeworks.viewportMgr.layoutDirectives(directives);
        for (var i=0; i < directives.length; i++)
        {
        	directives[i].getAttribute("timeIncrement").setValueDirect(this.timeIncrement.getValueDirect());
            directives[i].execute();    
        }
    }   
}

// never executes
RenderAgent.prototype.globalTimeInSecsModified = function()
{
    var globalTime = this.globalTimeInSecs.getValueDirect();

    // synchronize elapsed time
    this.elapsedTimeInSecs.setValueDirect(globalTime);

    // get all evaluators and set their time to globalTimeInSecs
    if (this.registry)
    {
        var evaluators = this.registry.getByType(eAttrType.Evaluator);
        if (evaluators)
        {
            for (var i=0; i < evaluators.length; i++)
            {
                var evaluator = evaluators[i];
                if (evaluator)
                {
                    var time = evaluator.getAttribute("time");
                    if (time)
                    {
                        var globalTimeSyncEnabled = evaluator.getAttribute("globalTimeSyncEnabled");
                        if ((globalTimeSyncEnabled && globalTimeSyncEnabled.getValueDirect()) ||
                            !globalTimeSyncEnabled)
                        {
                            time.setValueDirect(globalTime);
                        }
                    }
                    
                    evaluator.evaluate(); // calling Evaluate() will reset "expired" flag based upon global time
                }
            }
        }

        // disable the rotation inspection group for the models in the scene;
        // this is required b/c user may have rotated models during
        // object inspection and Object Inspection uses transformation
        // nodes that will still be affecting the target
        var models = this.registry.getByType(eAttrType.Model);
        if (models)
        {
            for (var i=0; i < models.length; i++)
            {
                setInspectionGroupActivationState(models[i], false);
            }
        }
    }
}

RenderAgent.prototype.setEvaluatorPlayState = function(evaluator, state)
{
    if (!evaluator)
    {
        return this.setEvaluatorPlayState(state);
    }
    
    // perform state-specific processing
    var en = evaluator.getAttribute("enabled");
    switch (state)
    {
    case ePlayState.Play:
        {
            en.setValueDirect(true);
        }
        break;

    case ePlayState.Pause:
        {
            en.setValueDirect(false);
        }
        break;

    case ePlayState.Stop:
        {
            en.setValueDirect(false);

            // if kfi, set time to 0 and evaluate once to reset outputs to time 0
            switch (evaluator.className)
            {
            case "KeyframeInterpolator":
                {
                    evaluator.getAttribute("time").setValueDirect(0);
                    evaluator.evaluate();
                }
            }
        }
        break;
    }
    
    clearObjectPositionMap();
}

RenderAgent.prototype.setEvaluatorsPlayState = function(state)
{
    if (this.registry)
    {
        var evaluators = this.registry.getByType(eAttrType.Evaluator);
        if (evaluators)
        {
            for (i=0; i < evaluators.length; i++)
            {
                var evaluator = evaluators[i];
                
                var type = evaluator.attrType;

                // don't set play state for inspectors or any evaluators not in scenegraph
                var orphan = evaluator.getAttribute("orphan").getValueDirect();
                if (!orphan)
                {
                    this.setEvaluatorPlayState(evaluator, state)
                }

            }
        }
    }
}

RenderAgent.prototype.setDesiredFrameRate = function(rate)
{
    this.desiredFrameRate.setValueDirect(rate);
}

function RenderAgent_DesiredFrameRateModified(attribute, container)
{
}

function RenderAgent_GlobalTimeInSecsModified(attribute, container)
{
    var renderAgent = container.registry.find("RenderAgent");
    renderAgent.globalTimeInSecsModified();
}
var FRAME_RATE_DEFAULT = 30;
var FRAME_RATE_MAX = FRAME_RATE_DEFAULT * 32;
var FRAME_RATE_MIN = FRAME_RATE_DEFAULT * -32;

RenderController.prototype = new AttributeContainer();
RenderController.prototype.constructor = RenderController;

function RenderController(bridgeworks)
{
    AttributeContainer.call(this);
    this.className = "RenderController";
    
    this.playState = ePlayState.Pause;
    
    this.renderAgent = bridgeworks.renderAgent;
}

RenderController.prototype.fastForward = function()
{
    this.play();
    var rate = this.renderAgent.frameRate.getValueDirect();
    if (rate < 0)
    {
        this.renderAgent.desiredFrameRate.setValueDirect(FRAME_RATE_DEFAULT);
    }
    
    if (rate < FRAME_RATE_MAX)
	{
		this.renderAgent.desiredFrameRate.setValueDirect(Math.abs(this.renderAgent.frameRate) * 2);
	}
	else
	{
		// clamp to max fast forward speed
		this.renderAgent.desiredFrameRate.setValueDirect(FRAME_RATE_MAX);
	}
}

RenderController.prototype.pause = function()
{
    this.renderAgent.desiredFrameRate.setValueDirect(FRAME_RATE_DEFAULT);
    this.renderAgent.setEvaluatorsPlayState(ePlayState.Pause);
}

RenderController.prototype.play = function()
{
    this.renderAgent.desiredFrameRate.setValueDirect(FRAME_RATE_DEFAULT);
    this.renderAgent.setEvaluatorsPlayState(ePlayState.Play);    
}

RenderController.prototype.rewind = function()
{
    this.play();
    var rate = this.renderAgent.frameRate.getValueDirect();
    if (rate > 0)
    {
        this.renderAgent.desiredFrameRate.setValueDirect(FRAME_RATE_DEFAULT);
    }
    if (rate > FRAME_RATE_MIN)
    {
        this.renderAgent.desiredFrameRate.setValueDirect(Math.abs(this.renderAgent.frameRate) * -2);
    }
    else
    {
        this.renderAgent.desiredFrameRate.setValueDirect(FRAME_RATE_MIN);    
    }
}

RenderController.prototype.stop = function()
{
    this.renderAgent.setEvaluatorsPlayState(ePlayState.Stop);
    this.renderAgent.desiredFrameRate.setValueDirect(1);
}


/**
 *	Reverses the frame rate and updates a status label with the
 *	current playback speed.  Rewind is a negative frame rate
 *  that doubles with each push of the button until 
 *  BridgeworksObject.FRAME_RATE_MIN is reached
 *	
 *	@param void
 *	@return void
	
function DVD_Rewind()
{
    bridgeworks.updateScene("<Play/>");
    

    if (bridgeworks.renderAgent.frameRate > 0)
    {
        bridgeworks.renderAgent.setDesiredFrameRate(FRAME_RATE_DEFAULT);
    }
    
    if (bridgeworks.renderAgent.frameRate > FRAME_RATE_MIN)	// if fast forwarding or playing
	{
		bridgeworks.renderAgent.setDesiredFrameRate(Math.abs(bridgeworks.renderAgent.frameRate) * -2);
	}
	else	// max rewind value reached
	{
		// clamp to max rewind speed
		bridgeworks.renderAgent.setDesiredFrameRate(FRAME_RATE_MIN);
	}
    
    g_paused = false;

}
 */

/**
 *	Fast forwards the frame rate and updates a status label with the
 *	current playback speed.  Fast forward is a positive frame rate
 *  that doubles with each push of the button until
 *  BridgeworksObject.FRAME_RATE_MAX is reached
 *	
 *	@param void
 *	@return void

function DVD_FastForward()
{
    bridgeworks.updateScene("<Play/>");
    
    if (bridgeworks.renderAgent.frameRate < 0)
    {
        bridgeworks.renderAgent.setDesiredFrameRate(FRAME_RATE_DEFAULT);
    }
    
    if (bridgeworks.renderAgent.frameRate < FRAME_RATE_MAX)
	{
		bridgeworks.renderAgent.setDesiredFrameRate(Math.abs(bridgeworks.renderAgent.frameRate) * 2);
	}
	else
	{
		// clamp to max fast forward speed
		bridgeworks.renderAgent.setDesiredFrameRate(FRAME_RATE_MAX);
	}
    
    g_paused = false;

}
 */	

function Selections()
{
    this.viewports = [];
    this.cameras = [];
    this.lights = [];
    this.models = [];
    this.surfaces = [];
    this.labels = [];
    
    this.clear = function()
    {
        this.viewports = [];
        this.cameras = [];
        this.lights = [];
        this.models = [];
        this.surfaces = [];
        this.labels = [];
    }
}

SelectionListener.prototype = new EventListener();
SelectionListener.prototype.constructor = SelectionListener;

function SelectionListener()
{
    EventListener.call(this);
    this.className = "SelectionListener";

    this.name.setValueDirect("Selector");

    this.rayPick = null;
    this.selections = new Selections();
    this.selected = null;
    
    this.selectionOccurred = new PulseAttr();
    this.selectionCleared = new PulseAttr();
    this.pointView = new Vector3DAttr();
    this.pointWorld = new Vector3DAttr();
    this.pointObject = new Vector3DAttr();
    this.pointGeo = new Vector3DAttr();
    this.triIndex = new NumberAttr();
    this.distance = new NumberAttr();
    this.distanceFromScreenCenter = new NumberAttr();
    this.computePivotDistance = new BooleanAttr(true);
    this.selectedName = new StringAttr();
    this.selectedElement = new NumberAttr(-1);	// this.registered when the selection has a selected element
    this.lastSelectedName = new StringAttr();

    this.pointWorld.addModifiedCB(SelectionListener_PointWorldModifiedCB, this);

    this.registerAttribute(this.selectionOccurred, "selectionOccurred");
    this.registerAttribute(this.selectionCleared, "selectionCleared");
    this.registerAttribute(this.pointView, "pointView");
    this.registerAttribute(this.pointWorld, "pointWorld");
    this.registerAttribute(this.pointObject, "pointObject");
    this.registerAttribute(this.pointGeo, "pointGeo");
    this.registerAttribute(this.triIndex, "triIndex");
    this.registerAttribute(this.distance, "distance");
    this.registerAttribute(this.distanceFromScreenCenter, "distanceFromScreenCenter");
    this.registerAttribute(this.computePivotDistance, "computePivotDistance");
    this.registerAttribute(this.selectedName, "selectedName");
    this.registerAttribute(this.lastSelectedName, "lastSelectedName");
    
    this.numResponses.setValueDirect(-1);
}

SelectionListener.prototype.setRayPick = function(rayPick)
{
    this.rayPick = rayPick;
    
    var clickPoint = this.rayPick.getAttribute("clickPoint");
    this.registerAttribute(clickPoint, "clickPoint");
    clickPoint.addModifiedCB(SelectionListener_ClickPointModifiedCB, this);
}

SelectionListener.prototype.eventPerformed = function(event)
{
    // if mouse-move event, don't process if any other mouse button is pressed (this affects object inspection)
    switch (event.type)
    {
        case eEventType.MouseMove:
        {
            if (event.inputId & MOUSEEVENT_LEFT_BUTTON ||
                event.inputId & MOUSEEVENT_MIDDLE_BUTTON ||
                event.inputId & MOUSEEVENT_RIGHT_BUTTON)
                return;        
        }
        break;
    }
    
    // TODO: allow for multi-select (clear if Ctrl is not pressed)
    this.clearSelections();
    
    this.getAttribute("clickPoint").setValueDirect(event.x, event.y);
}

SelectionListener.prototype.registerSelection = function(node, element)
{
    // only register first item
    if (this.selected) return;
    
    this.selected = node;
    
    // registering an attribute that has a NULL container (Get/SetContainer()) will set
    // the calling object as the container; don't want this behavior here
    var lastContainer = this.selected.getContainer();
    this.registerAttribute(this.selected, "Selected");	// unregistered in clearSelections()
    this.selected.setContainer(lastContainer);
	
    var name = node.getAttribute("name").getValueDirect().join("");
    //OutputDebugMsg("Selected: " + name);

    this.selectedName.setValueDirect(name);
    
    if (element >= 0)
    {
        this.selectedElement.setValueDirect(element);
        this.selected.registerAttribute(this.selectedElement, "selectedElement");
    }
}

SelectionListener.prototype.clearSelections = function()
{
    this.selections.clear();
   
    this.selectedElement.setValueDirect(-1);
    if (this.selected)
    {
    	if (this.selected.getAttribute("selectedElement"))
    	{
        	this.selected.unregisterAttribute(this.selectedElement);
        }
        
        this.selectedName.setValueDirect("");
    	this.unregisterAttribute(this.selected);
    	this.selected = null;
    }
    
    this.selectionCleared.pulse();
}

SelectionListener.prototype.processPick = function(pick)
{
    for (var i=0; i < pick.path.length; i++)
    {
        var node = pick.path[i];
        
        // if selectable or show is false, or polygons are flipped, skip
        var selectable = node.getAttribute("selectable");
        var show = node.getAttribute("show");
        var flipPolygons = node.getAttribute("flipPolygons");
        if ((selectable && selectable.getValueDirect() == false) ||
            (show && show.getValueDirect() == false) ||
            (flipPolygons && flipPolygons.getValueDirect() == true))
            {
            continue;
        }      
        
        var element = -1;
        switch (node.attrType)
        {
            case eAttrType.PerspectiveCamera:
            case eAttrType.OrthographicCamera:
            {
                this.selections.cameras.push(node);
            }
            break;
		    
            case eAttrType.DirectionalLight:
            case eAttrType.PointLight:
            case eAttrType.SpotLight:
            {
                this.selections.lights.push(node);
            }
            break;
		    
            case eAttrType.Model:
            {
                this.selections.models.push(node);
                this.registerSelection(node, element);
            }
            break;
            
            case eAttrType.Surface:
            {
                this.selections.surfaces.push(node);
            }
            break;

            case eAttrType.Label:
            {
                this.selections.labels.push(node);
                this.registerRasterComponentSelection(node, element);
            }
        }
    }
    
    if (this.selected)
    {
        this.pointObject.setValueDirect(pick.intersectRecord.pointModel.x, pick.intersectRecord.pointModel.y, pick.intersectRecord.pointModel.z);
        this.pointWorld.setValueDirect(pick.intersectRecord.pointWorld.x, pick.intersectRecord.pointWorld.y, pick.intersectRecord.pointWorld.z);
        this.pointView.setValueDirect(pick.intersectRecord.pointView.x, pick.intersectRecord.pointView.y, pick.intersectRecord.pointView.z);
        this.triIndex.setValueDirect(pick.intersectRecord.triIndex);
        this.distance.setValueDirect(pick.intersectRecord.distance);
    }
    
    return (this.selected ? true : false);
}

SelectionListener.prototype.processPicks = function(picks)
{
    for (var i=0; i < picks.length; i++)
    {
        if (this.processPick(picks[i]) == true)
        {
            return true;
        }
    }   
    
    return false;
}

SelectionListener.prototype.registerRasterComponentSelection = function(rc,element)
{
    // if a GUI has already been selected, replace if node paramter has a greater renderedSlot value
    if (this.selected)
    {
        var selected = this.selected;
        if (selected)
        {
            var renderedSlotSelection = rc.renderedSlot.getValueDirect();
            var renderedSlotSelected = selected.renderedSlot.getValueDirect();

            if (renderedSlotSelection > renderedSlotSelected)
            {
                return this.registerSelection(rc, element, true);
            }
        }
    }
    else // no previous selection, register
    {
        this.registerSelection(rc, element);
    }

}
SelectionListener.prototype.clickPointModified = function()
{
    var point = this.getAttribute("clickPoint").getValueDirect();
    var vpMgr = this.registry.find("ViewportMgr");
    var vp = vpMgr.getViewportAtScreenXY(point.x, point.y);
    this.selections.viewports.push(vp.viewport);
    this.rayPick.getAttribute("viewport").setValueDirect(vp.viewport.x, vp.viewport.y, vp.viewport.width, vp.viewport.height);
    this.rayPick.getAttribute("camera").setValueDirect(vp.camera);
    var root = this.registry.getAttribute("rootPtr").getValueDirect();
    this.rayPick.execute(root);
    if (this.rayPick.picked.length > 0)
    {
        this.processPicks(this.rayPick.picked);
        this.selectionOccurred.pulse();
    }
    // update distance from screen center
    this.updateDistanceFromScreenCenter(root);
    // update scene inspector with selected camera
    this.updateSceneInspectionCamera(vp.camera);
}

SelectionListener.prototype.updateDistanceFromScreenCenter = function(root)
{
    if (this.computePivotDistance.getValueDirect() == false)
    {
        return;
    }

    // get window center and set to ray pick's click point
    var bworks = this.registry.find("Bridgeworks");
    if (!bworks) return;
    var x = bworks.canvas.width / 2;
    var y = bworks.canvas.height / 2;
    var lastClickPoint = this.rayPick.getAttribute("clickPoint").getValueDirect();
    var params = new AttributeSetParams(-1, -1, 0, false, false);   
    this.rayPick.getAttribute("clickPoint").setValueDirect(x, y, params);
    
    // execute
    this.rayPick.execute(root);
    
    // cycle through picked list and skip labels and poly lines
    // NOTE: we may eventually want the convenience of pivoting about a label because labels are sometimes easier 
    // to intersect (i.e., when the model is too small to intersect)
    var found = false;
    for (var i=0; i < this.rayPick.picked.length && !found; i++)
    {
        if (this.rayPick.picked[i].intersectRecord.distance != 0) // labels and poly lines have a distance of 0
        {
            // found selected geometry, update distance from screen center
            this.distanceFromScreenCenter.setValueDirect(this.rayPick.picked[i].intersectRecord.distance);
            found = true;
            break;
        }
    }

    // restore previous click point
    this.rayPick.getAttribute("clickPoint").setValueDirect(lastClickPoint.x, lastClickPoint.y, params);   
}

SelectionListener.prototype.updateSceneInspectionCamera = function(camera)
{
    var si = this.registry.find("SceneInspector");
    if (si)
    {
        if (si.getCamera() == camera) return; // already connected
        
        // disconnect old camera, connect new one
        var connectionMgr = this.registry.find("ConnectionMgr");
        if (connectionMgr)
        {
            connectionMgr.disconnectSceneInspection(si, si.getCamera());
            connectionMgr.connectSceneInspection(si, camera);
        }
    }
}

function SelectionListener_ClickPointModifiedCB(attribute, container)
{
    container.clickPointModified();
}

function SelectionListener_PointWorldModifiedCB(attribute, container)
{
}
ViewportLayout.prototype = new AttributeContainer();
ViewportLayout.prototype.constructor = ViewportLayout;

function ViewportLayout()
{
    AttributeContainer.call(this);
    this.className = "ViewportLayout";
    
    this.name = new StringAttr("ViewportLayout");
    this.width = new NumberAttr(0);
    this.height = new NumberAttr(0);
    
    this.registerAttribute(this.name, "name");
    this.registerAttribute(this.width, "width");
    this.registerAttribute(this.height, "height");
}

ViewportLayout.prototype.initialize = function()
{
}

ViewportLayout.prototype.layoutDirectives = function(directives)
{
}

GridLayout.prototype = new ViewportLayout();
GridLayout.prototype.constructor = GridLayout;

function GridLayout()
{
    ViewportLayout.call(this);
    this.className = "GridLayout";
    
    this.name.setValueDirect("GridLayout");
    
    this.rows = new NumberAttr(1);
    this.cols = new NumberAttr(1);
    
    this.registerAttribute(this.rows, "rows");
    this.registerAttribute(this.cols, "cols");
}

GridLayout.prototype.initialize = function()
{
    this.rows.setValueDirect(1);
    this.cols.setValueDirect(1);
    
    // call base-class implementation
    ViewportLayout.prototype.initialize.call(this);
}

GridLayout.prototype.layoutDirectives = function(directives)
{
	if (!directives)
	{
		return;
	}

    var width = this.width.getValueDirect();
    var height = this.height.getValueDirect();
    var rows = this.rows.getValueDirect();
    var cols = this.cols.getValueDirect();
    if (width <= 0 || height <= 0 || rows <= 0 || cols <= 0)
    {
        return;
    }
    
    var vpX = 0;
    var vpY = 0;
    var vpWidth = width / cols;
	var vpHeight = height / rows;
	var values = new Array(4);

	var nDirectives = directives.length;
	for (var i=0, n=0; i < rows && n < nDirectives; i++)
	{
		for (var j=0; j < cols && n < nDirectives; j++, n++)
		{
			values[0] = vpX;
			values[1] = vpY;
			values[2] = vpWidth;
			values[3] = vpHeight;

			directives[n].getAttribute("viewport").setValue(values);

			vpX += vpWidth;
		}

		vpX = 0;
		vpY += vpHeight;
	}
}
ViewportMgr.prototype = new AttributeContainer();
ViewportMgr.prototype.constructor = ViewportMgr;

function ViewportMgr()
{
    AttributeContainer.call(this);
    this.className = "ViewportMgr";
    
    this.name = new StringAttr("ViewportMgr");
    this.cursor = new StringAttr("Arrow");
    this.width = new NumberAttr(0);
    this.height = new NumberAttr(0);
    this.layout = new ReferenceAttr(null);
    
    this.cursor.addModifiedCB(ViewportMgr_CursorModifiedCB, this);
    this.width.addModifiedCB(ViewportMgr_WidthModifiedCB, this);
    this.height.addModifiedCB(ViewportMgr_HeightModifiedCB, this);
    this.layout.addModifiedCB(ViewportMgr_LayoutModifiedCB, this);
    
    this.registerAttribute(this.name, "name");
    this.registerAttribute(this.cursor, "cursor");
    this.registerAttribute(this.width, "width");
    this.registerAttribute(this.height, "height");
    this.registerAttribute(this.layout, "layout");
}

ViewportMgr.prototype.initLayout = function()
{
    var layout = this.layout.getValueDirect();
    if (layout)
    {
        layout.initialize();
    }
}

ViewportMgr.prototype.layoutDirectives = function(directives)
{
    var layout = this.layout.getValueDirect();
    if (layout)
    {
        layout.layoutDirectives(directives);   
    }
}

ViewportMgr.prototype.getViewportAtScreenXY = function(x, y)
{
    var width = this.width.getValueDirect();
    var height = this.height.getValueDirect();
    
    // make sure x, y fall between [0, viewport width/height]
    x = clamp(x, 0, width);
    y = clamp(y, 0, height);
    
    // get cameras
    var cameras = this.registry.getByType(eAttrType.Camera);
    
    // get smallest viewport containing screen x, y (necessary for picture-in-picture)
    var minWidth = width;
    var minHeight = height;
    var camera, viewport;
    for (var i=0; i < cameras.length; i++)
    {
        if (cameras[i].viewport.containsPoint(x, y) &&
            cameras[i].viewport.width <= minWidth &&
            cameras[i].viewport.height <= minHeight)
        {
            camera = cameras[i];
            viewport = cameras[i].viewport;
            minWidth = cameras[i].viewport.width;
            minHeight = cameras[i].viewport.height
        }
    }
    
    return { viewport: viewport, camera: camera };
}

function ViewportMgr_CursorModifiedCB(attribute, container)
{
    // TODO
}

function ViewportMgr_WidthModifiedCB(attribute, container)
{
    var layout = container.layout.getValueDirect();
    if (layout)
    {
        layout.getAttribute("width").setValueDirect(attribute.getValueDirect());
    }
}

function ViewportMgr_HeightModifiedCB(attribute, container)
{
    var layout = container.layout.getValueDirect();
    if (layout)
    {
        layout.getAttribute("height").setValueDirect(attribute.getValueDirect());
    }
}

function ViewportMgr_LayoutModifiedCB(attribute, container)
{
    var layout = attribute.getValueDirect();
    if (layout)
    {
        layout.getAttribute("width").setValueDirect(container.width.getValueDirect());
        layout.getAttribute("height").setValueDirect(container.height.getValueDirect());
    }
}
RasterComponentEventListener.prototype = new EventListener();
RasterComponentEventListener.prototype.constructor = Command;

function RasterComponentEventListener()
{
    EventListener.call(this);
    this.className = "RasterComponentEventListener";

    this.rcs = [];
    this.rcsSelectionState = [];
    this.rcListenMap = [];
    this.rcEventMap = [];
    this.styleMgr = null;
    
    this.selectionEvent = new InputEvent(eEventType.Unknown, 0, 0xffffffff, 0, eEventType.Key_Up);

	this.name.setValueDirect("RasterComponentEventListener");
	this.numResponses.setValueDirect(-1);
}

RasterComponentEventListener.prototype.eventPerformed = function(event)
{
    var enabled = this.enabled.getValueDirect();
    if (!enabled)
    {
        return;
    }
    
    var currSelectionState, lastSelectionState, selectionEventSelectionState;
	for (var i=0; i < this.rcs.length; i++)
	{
		if (!this.isListening(this.rcs[i]))
		{
			continue;
		}

		lastSelectionState = this.rcsSelectionState[i];
		currSelectionState = this.rcs[i].eventPerformed(event);
		
		if (this.styleMgr)
	    {
		    if (currSelectionState)
			{
				this.styleMgr.eventPerformed(event, this.rcs[i]);

				// send selected/focus/mouseover event depending upon event type and whether 
				// component doesn't have focus/didn't have selection
				switch (event.type)
				{
				case eEventType.MouseLeftClick:
					{
						// send element focus event (once)
						if (this.isListeningEvent(this.rcs[i], eEventType.ElementFocus) &&
							this.rcs[i].hasFocus.getValueDirect() <= 0)
						{
							this.selectionEvent.synchronize(event);
							this.selectionEvent.type = eEventType.ElementFocus;
							
							selectionEventSelectionState = m_rcs[i].eventPerformed(this.selectionEvent);
							this.styleMgr.eventPerformed(this.selectionEvent, this.rcs[i]);

							this.rcs[i].hasFocus.setValueDirect(1);
					    }
					}
					break;

				case eEventType.MouseMove:
					{
						// send element selected event (once)
						if (this.isListeningEvent(this.rcs[i], eEventType.ElementSelected) &&
							this.rcs[i].selected.getValueDirect() <= 0)
						{
							this.selectionEvent.synchronize(event);
							this.selectionEvent.type = eEventType.ElementSelected;
							
							selectionEventSelectionState = this.rcs[i].eventPerformed(this.selectionEvent);
							this.styleMgr.eventPerformed(this.selectionEvent, this.rcs[i]);
							this.rcs[i].selected.setValueDirect(1);
						}

						if (!lastSelectionState &&
							this.isListeningEvent(this.rcs[i], eEventType.MouseOver))
						{
							this.selectionEvent.synchronize(event);
							this.selectionEvent.type = eEventType.MouseOver;

							selectionEventSelectionState = this.rcs[i].eventPerformed(this.selectionEvent);
							this.styleMgr.eventPerformed(this.selectionEvent, this.rcs[i]);
						}
					}
					break;
				}
			}
			else // !currSelectionState
			{
				// send unselected/blur/mouseout event depending upon event type and whether 
				// component has focus/had selection
				switch (event.type)
				{
				case eEventType.MouseLeftDown:
				case eEventType.MouseLeftClick:
				case eEventType.MouseLeftDblClick:
				case eEventType.MouseMiddleDown:
				case eEventType.MouseMiddleClick:
				case eEventType.MouseMiddleDblClick:
				case eEventType.MouseRightDown:
				case eEventType.MouseRightClick:
				case eEventType.MouseRightDblClick:
				case eEventType.MouseWheelDown:
				case eEventType.MouseBothDown:
					{
						// send element blur event (once)
						if (this.isListeningEvent(this.rcs[i], eEventType.ElementBlur) &&
							this.rcs[i].hasFocus.getValueDirect() > 0)
						{
							this.selectionEvent.synchronize(event);
							this.selectionEvent.type = eEventType.ElementBlur;
							
							selectionEventSelectionState = this.rcs[i].eventPerformed(this.selectionEvent);
							this.styleMgr.eventPerformed(this.selectionEvent, this.rcs[i]);

							this.rcs[i].hasFocus.setValueDirect(-1);
						}
					}
					break;

				case eEventType.MouseMove:
					{
						// send element unselected event (once)
						if (this.isListeningEvent(this.rcs[i], eEventType.ElementUnselected) &&
							this.rcs[i].selected.getValueDirect() > 0)
						{
							this.selectionEvent.synchronize(event);
							this.selectionEvent.type = eEventType.ElementUnselected;
							
							selectionEventSelectionState = this.rcs[i].eventPerformed(this.selectionEvent);
							this.styleMgr.eventPerformed(this.selectionEvent, this.rcs[i]);
							this.rcs[i].selected.setValueDirect(-1);
						}

						if (lastSelectionState &&
							this.isListeningEvent(this.rcs[i], eEventType.MouseOut))
						{
							this.selectionEvent.synchronize(event);
							this.selectionEvent.type = eEventType.MouseOut;

							selectionEventSelectionState = this.rcs[i].eventPerformed(this.selectionEvent);
							this.styleMgr.eventPerformed(this.selectionEvent, this.rcs[i]);
						}
					}
					break;
				}
			}
		}

		this.rcsSelectionState[i] = currSelectionState;
	}
}

RasterComponentEventListener.prototype.registerComponent = function(rc, before)
{
    if (rc)
    {
        if (before)
        {
            var i = this.rcs.indexOf(before);
            if (i < 0) i = this.rcs.length;
            
            this.rcs.splice(i, 0, rc);
            this.rcsSelectionState.splice(i, 0, rc);
        }
        else
        {
            this.rcs.push(rc);
            this.rcsSelectionState.push(rc);
        }
    }
}

RasterComponentEventListener.prototype.unregisterComponent = function(rc)
{
    if (rc)
    {
        this.rcs.splice(this.rcs.indexOf(rc), 1);
    }
}

RasterComponentEventListener.prototype.Listen = function(rc)
{
    if (rc)
    {
        this.rcListenMap[rc] = true;
    }
}

RasterComponentEventListener.prototype.Ignore = function(rc)
{
    if (rc)
    {
        this.rcListenMap[rc] = false;
    }
}

RasterComponentEventListener.prototype.listenEvent = function(rc, eventType)
{
    if (rc)
    {
        if (this.rcEventMap[rc] == undefined)
        {
            this.rcEventMap[rc] = new Array();
        }

        this.rcEventMap[rc].push(eventType);
    }
}

RasterComponentEventListener.prototype.ignoreEvent = function(rc, eventType)
{
    if (rc)
    {
        if (this.rcEventMap[rc])
        {
            this.rcEventMap[rc].splice(this.rcEventMap[rc].indexOf(eventType), 1);
        }
    }
}

RasterComponentEventListener.prototype.setStyleMgr = function(styleMgr)
{
    this.styleMgr = styleMgr;
}

RasterComponentEventListener.prototype.setSelectionState = function(rc, selected)
{
    this.rcsSelectionState[rc] = selected;
}

RasterComponentEventListener.prototype.getComponent = function(n)
{
    if (n < this.rcs.length)
    {
        return this.rcs[n];
    }

    return null;
}

RasterComponentEventListener.prototype.isListening = function(rc)
{
    if (rc)
    {
        if (this.rcListenMap[rc])
        {
            return this.rcListenMap[rc];
        }
    }

    return false;
}

RasterComponentEventListener.prototype.isListeningEvent = function(rc, eventType)
{
    if (rc)
    {
        if (this.rcEventMap[rc])
        {
            if (this.rcEventMap[rc].indexOf(eventType) >= 0)
                return true;
        }
    }

    return false;
}




var g_objPosMap = {};

function addInspectionGroup(node, factory)
{

    // ensure that rotation group has not already been added
	var rotGroup = getInspectionGroup(node);
	
    if (rotGroup) return;
		
	var pGrp        = new Group();
    pGrp.setGraphMgr(factory.graphMgr);
    var pTranslate  = new Translate();
    pTranslate.setGraphMgr(factory.graphMgr);
    var pScaleInv   = new Scale();
    pScaleInv.setGraphMgr(factory.graphMgr);
    var pQuat       = new QuaternionRotate();
    pQuat.setGraphMgr(factory.graphMgr);
    var pTransBack  = new Translate();
    pTransBack.setGraphMgr(factory.graphMgr);
    var pScale      = new Scale();
    pScale.setGraphMgr(factory.graphMgr);
    
    pQuat.addModifiedCB(Util_InspectionGroup_RotationQuatModifiedCB, null);

    pGrp.name.setValueDirect("InspectionGroup");
	pTranslate.name.setValueDirect("Translate");
    pScaleInv.name.setValueDirect("ScaleInverse");
	pQuat.name.setValueDirect("Quaternion");
	pTransBack.name.setValueDirect("TranslateBack");			
    pScale.name.setValueDirect("Scale");

	pGrp.addChild(pTranslate); // child 0
    pGrp.addChild(pScaleInv);  // child 1
	pGrp.addChild(pQuat);      // child 2
    pGrp.addChild(pScale);     // child 3
	pGrp.addChild(pTransBack); // child 4

	var pChildZero = node.getChild(0);
	if (pChildZero)
	{
		pChildZero.insertChild(pGrp, 0);
	}

    node.registerAttribute(pTranslate.translation, "inspectionGroup_translate");
    node.registerAttribute(pScaleInv.scale, "inspectionGroup_scaleInverse");
    node.registerAttribute(pQuat.rotationQuat, "inspectionGroup_rotationQuat");
    node.registerAttribute(pQuat.enabled, "inspectionGroup_rotationEnabled");
    node.registerAttribute(pScale.scale, "inspectionGroup_scale");
    node.registerAttribute(pTransBack.translation, "inspectionGroup_translateBack");

    pTranslate.translation.setContainer(node);
    pScaleInv.scale.setContainer(node);
    pQuat.rotationQuat.setContainer(node);
    pQuat.enabled.setContainer(node);
    pScale.scale.setContainer(node);
    pTransBack.translation.setContainer(node);

	return;
}

function deleteInspectionGroup(node)
{
	var rotGroup = getInspectionGroup(node);
	if (rotGroup)
	{
        rotGroup.getChild(0).getAttribute("translation").setContainer(rotGroup.getChild(0));
        rotGroup.getChild(1).getAttribute("scale").setContainer(rotGroup.getChild(1));
        rotGroup.getChild(2).getAttribute("rotationQuat").setContainer(rotGroup.getChild(2));
        rotGroup.getChild(2).getAttribute("enabled").setContainer(rotGroup.getChild(2));
        rotGroup.getChild(3).getAttribute("scale").setContainer(rotGroup.getChild(3));
        rotGroup.getChild(4).getAttribute("translation").setContainer(rotGroup.getChild(4));

        node.unregisterAttribute(node.getAttribute("inspectionGroup_translate"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_scaleInverse"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_rotationQuat"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_rotationEnabled"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_scale"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_translateBack"));

        node.removeChild(rotGroup);

	}

	return;
}

function getInspectionGroup(moveableNode)
{
    var group = null;
    
	var childZero = moveableNode.getChild(0);
	if (childZero)
	{
		group = childZero.getNamedChild("InspectionGroup")
	}

	return group;
}

function setInspectionGroupActivationState(node, enable)
{
	var pRotGroup = getInspectionGroup(node);
	if (pRotGroup)
	{	
		var pQuat = pRotGroup.getChild(2);
		if (pQuat)
		{
			pQuat.enabled.setValueDirect(enable);

			if (!enable)
			{
				var quat = new Quaternion();
				quat.loadIdentity();

				var quatAttr = pQuat.rotationQuat;
				quatAttr.setValueDirect(quat);
			}
		}
		
		var pPos = node.getAttribute("position");
		if (enable)
		{
			if (!(node in g_objPosMap))
			{
				g_objPosMap[node] = pPos.getValueDirect();
			}
		}
		else // !enable
		{
			var pos = g_objPosMap[node];
			pPos.setValueDirect(pos);
		}
		
	}

	return;
}

function setInspectionGroupContainer(node)
{

	var pRotGroup = getInspectionGroup(node);
	if (pRotGroup)
	{	
        node.unregisterAttribute(node.getAttribute("inspectionGroup_translate"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_scaleInverse"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_rotationQuat"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_rotationEnabled"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_scale"));
        node.unregisterAttribute(node.getAttribute("inspectionGroup_translateBack"));

        node.registerAttribute(pRotGroup.getChild(0).getAttribute("translation"), "inspectionGroup_translate");
        node.registerAttribute(pRotGroup.getChild(1).getAttribute("scale"), "inspectionGroup_scaleInverse");
        node.registerAttribute(pRotGroup.getChild(2).getAttribute("rotationQuat"), "inspectionGroup_rotationQuat");
        node.registerAttribute(pRotGroup.getChild(2).getAttribute("enabled"), "inspectionGroup_rotationEnabled");
        node.registerAttribute(pRotGroup.getChild(3).getAttribute("scale"), "inspectionGroup_scale");
        node.registerAttribute(pRotGroup.getChild(4).getAttribute("translation"), "inspectionGroup_translateBack");

        pRotGroup.getChild(0).getAttribute("translation").setContainer(node);
        pRotGroup.getChild(1).getAttribute("scale").setContainer(node);
        pRotGroup.getChild(2).getAttribute("rotationQuat").setContainer(node);
        pRotGroup.getChild(2).getAttribute("enabled").setContainer(node);
        pRotGroup.getChild(3).getAttribute("scale").setContainer(node);
        pRotGroup.getChild(4).getAttribute("translation").setContainer(node);

    }

    return;
}


// Isn't called. Commented out in RenderAgent.cpp
function zeroInspectionGroup(node)
{
   var pRotGroup = getInspectionGroup(node);
	if (pRotGroup)
	{	
		var pQuat = pRotGroup.getChild(2);
		if (pQuat)
		{
			var quat = new Quaternion();
			quat.loadIdentity();

			var quatAttr = pQuat.rotationQuat;
			quatAttr.setValueDirect(quat);
		}
    }

    return;
}

function clearObjectPositionMap()
{
	g_objPosMap = {};

	return;
}

// Doesn't do anything.
function Util_InspectionGroup_RotationQuatModifiedCB(attribute, container)
{
    /* 
    CQuaternionf q;
	CQuaternionFloatAttr quat = dynamic_cast<CQuaternionFloatAttr>(attr);
	if (quat)
	{
		quat.getValueDirect(q);
	}
    */
}
SerializeCommand.prototype = new Command();
SerializeCommand.prototype.constructor = SerializeCommand;

function SerializeCommand()
{
    Command.call(this);
    this.className = "Serialize";
    this.attrType = eAttrType.Serialize;

    this.targetAttribute = null;
    this.target.addModifiedCB(SerializeCommand_TargetModifiedCB, this);
    this.directive = null;
    this.serialized = "";
}

SerializeCommand.prototype.execute = function()
{
    if (this.directive)
    {
//        if (this.target && this.directive)
//        {
//            if (this.directive.execute(this.target === 0))
//            {
//                this.serialized = this.directive.getSerialized();
//            }
//        }
//        else // !this.target
//        {
            this.serializeScene();
//        }
    }
}

SerializeCommand.prototype.serializeScene = function()
{
    var i;
    var container = null;
    var node = null;
    var context = new Context();
    var xstr;

    // root element open tag
    this.serialized = '<?xml version="1.0" encoding="UTF-8"?><?bw onload="initialize"?><Session broadcast="false">';

    //var attrContainerRegistry = this.registry.getAttributeContainerRegistry();
    var attrContainerRegistry = bridgeworks.registry;
    if (attrContainerRegistry)
    {
        var factory = this.registry.find("AttributeFactory");
        var serializer = factory.create("Serializer");
        var xmlSerializer = new XMLSerializer(); 
        // set minimum flag so that only the minimum required for recreation is serialized
        serializer.serializeMinimum.setValueDirect(true);

        var count = attrContainerRegistry.getObjectCount();

        // serialize
        var i;
        for (i = 0; i < count; i++)
        {
            container = attrContainerRegistry.getObject(i);
            if (!container) continue;
            
            // device handlers
            if (container.attrType > eAttrType.DeviceHandler && 
                container.attrType < eAttrType.DeviceHandler_End)
            {
                context.attribute = container;

                // serialize
                serializer.serialize(context.attribute, context.item, context.attributeName, context.container);
                var serialized = xmlSerializer.serializeToString(serializer.DOM);
                if (serialized == "<__InitialRoot/>") continue;
                this.serialized += serialized;
            }
            // root nodes (nodes without parents)
            else if (container.attrType > eAttrType.Node && 
                	 container.attrType < eAttrType.Node_End)
            {
            	if (container.getParentCount() == 0)
            	{
                	this.directive.execute(container);
                	this.serialized += this.directive.serialized;
                }
            }
            // directives
            else if (container.attrType > eAttrType.Directive &&
            		 container.attrType < eAttrType.Directive_End)
            {
            	context.attribute = container;

                // serialize
                serializer.serialize(context.attribute, context.item, context.attributeName, context.container);
                var serialized = xmlSerializer.serializeToString(serializer.DOM);
                if (serialized == "<__InitialRoot/>") continue;
                this.serialized += serialized;
            }
            // SelectionListener
            else if (container.className == "SelectionListener")
            {
                var computePivotDistance = container.getAttribute("computePivotDistance").getValueDirect();

                this.serialized += "<Set target=\"Selector\" computePivotDistance=\"";
                this.serialized += (computePivotDistance ? "true" : "false");
                this.serialized += "\"/>";
            }
            // remaining attributes not fitting other criteria and not a command (commands serialized below)
            /*else if (container.attrType < eAttrType.Command || 
                	 container.attrType > eAttrType.Command_End)
            {
                context.attribute = container;

                // serialize
                serializer.serialize(context.attribute, context.item, context.attributeName, context.container);
                this.serialized += xmlSerializer.serializeToString(serializer.DOM);
            }*/
        }

		// commands

		// DisconnectAttributes commands (must come before ConnectAttributes in DefaultPreferences.xml)
		for (i = 0; i < count; i++)
        {
            container = attrContainerRegistry.getObject(i);
            if (!container) continue;
            
   			if (container.className == "DisconnectAttributes")
            {
                context.attribute = container;

                // serialize
                serializer.serialize(context.attribute, context.item, context.attributeName, context.container);
                var serialized = xmlSerializer.serializeToString(serializer.DOM);
                if (serialized == "<__InitialRoot/>") continue;
                this.serialized += serialized;
            }
        }
        
        // other commands
        for (i = 0; i < count; i++)
        {
            container = attrContainerRegistry.getObject(i);
            if (!container) continue;
            
   			if (container.attrType > eAttrType.Command && 
                container.attrType < eAttrType.Command_End &&
                container.className != "DisconnectAttributes")
            {
                context.attribute = container;

                // serialize
                serializer.serialize(context.attribute, context.item, context.attributeName, context.container);
                var serialized = xmlSerializer.serializeToString(serializer.DOM);
                if (serialized == "<__InitialRoot/>") continue;
                this.serialized += serialized;
            }
        }
            		
        /*
         // updateSectorOrigin
         const char* substr = NULL;
         std.prototype.string name = "";
         if ((substr = strstr(this.serialized.c_str(), "PerspectiveCamera")) ||
         (substr = strstr(this.serialized.c_str(), "OrthographicCamera")))
         {
         if (substr = strstr(substr, "<name>"))
         {
         substr += 6; // skip "<name>"
         while (*substr != '<')
         {
         name += *substr++;
         }

         this.serialized += ".set target=\"";
         this.serialized += name;
         this.serialized += "\" updateSectorOrigin=\"true\"/>";
         }
         }
         */
        // TODO: pivotCone
    }

    // root element close tag
    this.serialized += "</Session>";
    serializedScene += this.serialized;
    console.log(this.serialized);

    return;
}

SerializeCommand.prototype.undo = function()
{

}

SerializeCommand.prototype.setRegistry = function(registry)
{
    // create serialize directive
    var factory = bridgeworks.registry.find("AttributeFactory");
    this.directive = factory.create("SerializeDirective");

    // call base-class implementation
    Command.prototype.setRegistry.call(this, registry);
}

SerializeCommand.prototype.getSerialized = function()
{
    return this.serialized;
}

function SerializeCommand_TargetModifiedCB(attribute, container)
{
    var target = attribute.getValueDirect().join("");
    container.targetAttribute = container.registry.find(target);
}
ScreenCaptureCommand.prototype = new Command();
ScreenCaptureCommand.prototype.constructor = ScreenCaptureCommand;

function ScreenCaptureCommand()
{
    Command.call(this);
    this.className = "ScreenCapture";
    this.attrType = eAttrType.ScreenCapture;

    this.canvasId = new StringAttr();
    
    this.registerAttribute(this.canvasId, "canvasId");
    
    this.numResponses.setValueDirect(0);
}

ScreenCaptureCommand.prototype.execute = function()
{
    var bworks = this.registry.find("Bridgeworks");
    bworks.eventMgr.addListener(eEventType.RenderEnd, this);
}

ScreenCaptureCommand.prototype.screenCapture = function(canvasId)
{
    var canvas = document.getElementById(canvasId);
    cimageData = canvas.toDataURL('image/png');
    var imageData = cimageData;

//    window.open(imageData);

    //Decode the base64 data into 8bit array. Used Specifically for 3Scape
    var cnt = imageData.lastIndexOf(',') + 1;
    imageData = imageData.substr(cnt);
    imgeData = Base64Binary.decode(imageData);
    
    // copy to clipboard
    // TODO: investigate method described at: https://forums.mozilla.org/addons/viewtopic.php?t=9736&p=21119
    
    // open in new window

    // download
    //var imageDataStream = imageData.replace("image/png", "image/octet-stream");
    //window.location.href = imageDataStream;
}

ScreenCaptureCommand.prototype.eventPerformed = function(event)
{
    // if mouse-move event, don't process if any other mouse button is pressed (this affects object inspection)
    switch (event.type)
    {
        case eEventType.RenderEnd:
        {
            this.screenCapture(this.canvasId.getValueDirect().join(""));
            return;        
        }
        break;
    }
}

// TODO
var eLWObjectTokens = 
{
    COLR    : 1129270354,
    DIFF    : 1145652806,
    LUMI    : 1280658761,
    SPEC    : 1397769539,
    TRAN    : 1414676814
};

function LWO2BlockData()
{
    this.type = "";
    this.ordinal = "";
    this.channel = 0;
    this.enable = 1;
    this.opacityType = 7;
    this.opacity = 1;
    this.opacityEnvelope = 0;
    this.negative = 0;
    this.center = new Vector3D();
    this.size = new Vector3D();
    this.coordSys = 0;
    this.projMode = 0;
    this.axis = 0;
    this.imageIndex = 0;
    this.widthWrap = 1;
    this.heightWrap = 1;
    this.widthWrapAmt = 0;
    this.heightWrapAmt = 0;
    this.uvMapName = "";
}

function LWO2SurfaceData()
{
    this.name = "";
    this.source = "";
    this.color = new Vector3D();
    this.diffuseLevel = 1;
    this.specularLevel = 0;
    this.luminosityLevel = 0;
    this.transparencyLevel = 0;
    this.glossiness = 0.4;
    this.doubleSided = false;
    this.smoothingAngle = 0;  
    this.blocks = [];
    this.addBlock = function()
    {
        this.blocks.push(new LWO2BlockData());
    }
    this.currentBlock = function()
    {
        return this.blocks.length > 0 ? this.blocks[this.blocks.length-1] : null;
    }
}

function LWO2ClipData()
{
    this.type = 0;
    this.negative = 0;
    
    var filename = "";
    var platformNeutralFilename = "";
    this.setPlatformNeutralFilename = function(_filename)
    {
        platformNeutralFilename = _filename;
        filename = _filename;
        if (filename.indexOf(':') >= 0)
        {
            var split = new Array();
            split = filename.split(':');
            filename = split[0] + ':' + '/' + split[1];
        }
    }
    this.setFilename = function(_filename)
    {
        filename = _filename;
        platformNeutralFilename = _filename;
        // check that filename is not in platform neutral format
        var pos = filename.indexOf(':');
        if (pos >= 0)
        {
            if (filename.charAt(pos+1) != '/' && filename.charAt(pos+1) != '\\')
            {
                var split = new Array();
                split = filename.split(':');
                filename = split[0] + ':' + '/' + split[1];
            }
        }
        // check that platform neutral filename is in platform neutral format
        pos = platformNeutralFilename.indexOf(':');
        if (pos >= 0)
        {
            if (platformNeutralFilename.charAt(pos+1) == '/' || platformNeutralFilename.charAt(pos+1) == '\\')
            {
                var split = new Array();
                split = platformNeutralFilename.split(':');
                platformNeutralFilename = split[0] + ':' + split[1].substr(1, split[1].length);
            }
        }
        this.getPlatformNeutralFilename = function()
        {
            return platformNeutralFilename;
        }
        this.getFilename = function()
        {
            return filename;
        }
    }
}

function LWO2EnvelopeData()
{
    this.userFormat = 0;
    this.type = 0;
    this.preBehavior = 0;
    this.postBehavior = 0;
    this.keyframes = [];
    
    this.currentKyframe = function()
    {
        return this.keyframes.length > 0 ? this.keyframes[this.keyframes.length-1] : null;
    }
}

function LWO2VMAPData()
{
    this.vertex = 0;
    this.u = 0;
    this.v = 0;
}

function LWO2VMADData()
{
    this.poly = 0;
    this.vertex = 0;
    this.u = 0;
    this.v = 0;
}

function LWO2PTAGData()
{
    this.poly = 0;
    this.tag = 0;
}

function LWO2LayerData()
{
    this.number = 0;
    this.name = "";
    this.pnts = [];
    this.pols = [];
    this.ptagsSURF = [];
    this.vmapsTXUV = [];
    this.vmadsTXUV = [];
    this.ptagsSURFMaxIndex = 0;
    this.pivot = new Vector3D();
    
    this.getVmap = function(type, name)
    {
        switch (type)
        {
            case 'TXUV':
                return this.vmapsTXUV[name];
                break;
            
            default: 
                return null;
        }
    }
    
    this.putVmap = function(type, name, vmap)
    {
        switch (type)
        {
            case 'TXUV':
                if (this.vmapsTXUV[name] == undefined) 
                    this.vmapsTXUV[name] = []
                this.vmapsTXUV[name].push(vmap);
                break;
        }
    }
    
    this.getVmad = function(type, name)
    {
        switch (type)
        {
            case 'TXUV':
                return this.vmadsTXUV[name];
                break;
            
            default: 
                return null;
        }
    }
    
    this.putVmad = function(type, name, vmad)
    {
        switch (type)
        {
            case 'TXUV':
                if (this.vmadsTXUV[name] == undefined) 
                    this.vmadsTXUV[name] = []
                this.vmadsTXUV[name].push(vmad);
                break;
        }
    }
    
    this.putPtag = function(ptag)
    {
        this.ptagsSURF.push(ptag);
    }
}

function LWO2Data()
{
    this.name = "";
    this.contentDir = "";
    this.layers = [];
    this.tags = [];
    this.surfaces = [];
    this.clips = [];
    this.envelopes = [];
    this.subChunkContext = "";
    this.evaluators = [];
    
    var currentClip = null;
    var currentEnvelope = null;
    var currentLayer = null;
    this.addLayer = function(number)
    {
        var layer = new LWO2LayerData();
        layer.number = number;
        if (this.layers.length <= number)
        {
            this.layers.length = number + 1;
        }
        this.layers[number] = layer;
        currentLayer = layer;
    }
    this.currentLayer = function()
    {
        return currentLayer;
    }
    this.addSurface = function(name, source)
    {
        var surface = new LWO2SurfaceData();
        surface.name = name;
        surface.source = source;
        this.surfaces.push(surface);
    }
    this.currentSurface = function()
    {
        return this.surfaces.length > 0 ? this.surfaces[this.surfaces.length-1] : null;
    }
    this.getSurface = function(name)
    {
        for (var i=0; i < this.surfaces.length; i++)
        {
            if (this.surfaces[i].name == name)
            {
                return this.surfaces[i];
            }
        }
        return null;
    }
    this.addClip = function(index)
    {
        var clip = new LWO2ClipData();
        if (this.clips.length <= index)
        {
            this.clips.length = index + 1;
        }
        this.clips[index] = clip;
        currentClip = clip;
    }
    this.currentClip = function()
    {
        return currentClip;
    }
    this.addEnvelope = function(index)
    {
        var envelope = new LWO2EnvelopeData();
        this.envelopes[index] = envelope;
        currentEnvelope = envelope;
    }
    this.currentEnvelope = function()
    {
        return currentEnvelope;
    }
}

LWObjectHandler.prototype = new ContentHandler();
LWObjectHandler.prototype.constructor = LWObjectHandler;

function LWObjectHandler()
{
    ContentHandler.call(this);
    this.className = "LWObjectHandler";
    
    this.lwo2DataHandlers = [];
    this.lwo2DataHandlersData = [];
}

LWObjectHandler.prototype.addObjectHandler = function(handler, data)
{
    this.lwo2DataHandlers.push(handler);
    this.lwo2DataHandlersData.push(data);
}

LWObjectHandler.prototype.parseFileStream = function(url)
{
    var filename = formFullPath(url, this.contentDirectory.getValueDirect().join(""));
    var filestream = loadBinaryResource(filename);
    if (filestream == null)
    {
        return -2;
    }

    var parser = new BinaryParser(filestream, true);

    // read file tag (must be 'FORM')
    if (parser.readUInt8() != 70 || // 'F'
    parser.readUInt8() != 79 || // 'O'
    parser.readUInt8() != 82 || // 'R'
    parser.readUInt8() != 77)   // 'M'
    {
        return -1;
    }

    // read file size
    var fileSize = parser.readUInt32();

    // read file type (must be 'LWO2')
    if (parser.readUInt8() != 76 || // 'L'
    parser.readUInt8() != 87 || // 'W'
    parser.readUInt8() != 79 || // 'O'
    parser.readUInt8() != 50)   // '2'
    {
        return -1;
    }
    fileSize -= 4; // subtract these 4 bytes from the file size

    var data = new LWO2Data();
    data.contentDir = this.contentDirectory.getValueDirect().join("");

    // set the model name (filename w/o extension)
    // TODO

    // read file chunks into LWOData
    while (fileSize > 0)
    {
        fileSize -= this.parseChunk(parser, data);
    }

    // pass data to consumer(s)
    for (var i = 0; i < this.lwo2DataHandlers.length; i++)
    {
        this.lwo2DataHandlers[i](data, this.lwo2DataHandlersData[i]);
    }

    return 0;
}

LWObjectHandler.prototype.parseChunk = function(parser, data)
{
    var bytesRead = 0;
    
    // ASSUMPTION MADE:  file stream pointer is currently sitting at a tag
    // i.e., has been advanced past header.

    // read chunk tag
    var tag = parser.readUInt32(); // bytesRead accounted for at end of method
    //alert("tag: " + tag);
    
    // read chunk size
    var chunkSize = parser.readUInt32(); // bytesRead accounted for at end of method
    //alert("chunkSize: " + chunkSize);
    
    // read chunk size bytes
    switch (tag)
    {
        case 1279351122: // 'LAYR'
            {
                var number = parser.readUInt16(); bytesRead += 2;
            
                var flags = parser.readUInt16(); bytesRead += 2;

                var x = parser.readFloat32(); bytesRead += 4;
                var y = parser.readFloat32(); bytesRead += 4;
                var z = parser.readFloat32(); bytesRead += 4;
            
                var name = this.readString(parser); bytesRead += name.bytesRead;
            
                if (chunkSize > bytesRead)
                {
                    var parent = parser.readUInt16(); bytesRead += 2;
                }

                data.addLayer(number);
                data.currentLayer().name = name.string;
                data.currentLayer().pivot.x = x;
                data.currentLayer().pivot.y = y;
                data.currentLayer().pivot.z = z;
            }
            break;
    
        case 1347310675: // 'PNTS'
            {
                var numPnts = chunkSize / 12;

                for (var i=0; i < numPnts; i++)
                {
                    var x = parser.readFloat32(); bytesRead += 4;
                    var y = parser.readFloat32(); bytesRead += 4;
                    var z = parser.readFloat32(); bytesRead += 4; 
            
                    data.currentLayer().pnts[i] = new Vector3D();
                    data.currentLayer().pnts[i].x = x;
                    data.currentLayer().pnts[i].y = y; 
                    data.currentLayer().pnts[i].z = z;                
                }
            }
            break;
    
        case 1347374163: // 'POLS'
            {
                var type = parser.readUInt32(); bytesRead += 4;
            
                var flags, numVerts;
                while (chunkSize > bytesRead)
                {
                    var poly = [];
                
                    flags = parser.readUInt16(); bytesRead += 2;
                    numVerts = flags & 0x03ff;
                    for (var i=0; i < numVerts; i++)
                    {
                        var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                    
                        poly.push(index.index);
                    }
                
                    data.currentLayer().pols.push(poly);
                }
            }
            break;
        
        case 1413564243: // 'TAGS'
            {
                while (chunkSize > bytesRead)
                {
                    var tags = this.readString(parser); bytesRead += tags.bytesRead;
                    data.tags.push(tags.string);
                }
            }
            break;
      		
        case 1347699015: // 'PTAG'
            {
                var type = parser.readUInt32(); bytesRead += 4;
            
                while (chunkSize > bytesRead)
                {
                    var ptag = new LWO2PTAGData();
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                    ptag.poly = index.index;
                    ptag.tag = parser.readUInt16(); bytesRead += 2;
                
                    switch (type)
                    {
                        case 1398100550: // 'SURF'
                            {
                                data.currentLayer().putPtag(ptag);
                                data.currentLayer().ptagsSURFMaxIndex = Math.max(ptag.tag, data.currentLayer().ptagsSURFMaxIndex);
                            }
                            break;
                    }
                }
            }
            break;
    
        case 1447903568: // 'VMAP'
            {
                var type = parser.readUInt32(); bytesRead += 4;
                var dimension = parser.readUInt16(); bytesRead += 2;
                var name = this.readString(parser); bytesRead += name.bytesRead;
            
                var u, v, value;
                while (chunkSize > bytesRead)
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead; 
                
                    switch (type)
                    {
                        case 1415075158: // 'TXUV'
                            {
                                u = parser.readFloat32(); bytesRead += 4;
                                v = parser.readFloat32(); bytesRead += 4;
                        
                                var vmapData = new LWO2VMAPData();
                                vmapData.vertex = index.index;
                                vmapData.u = u;
                                vmapData.v = v;
                                data.currentLayer().putVmap('TXUV', name.string, vmapData);
                            }
                            break;
                    
                        default:
                            {
                                for (var i=0; i < dimension; i++)
                                {
                                    value = parser.readFloat32(); bytesRead += 4;       
                                }
                            }
                            break;    
                    }
                }
            }
            break;
        
        case 1447903556: // 'VMAD'
            {
                var type = parser.readUInt32(); bytesRead += 4;
                var dimension = parser.readUInt16(); bytesRead += 2;
                var name = this.readString(parser); bytesRead += name.bytesRead;
            
                var u, v, value;
                while (chunkSize > bytesRead)
                {
                    var vertIndex = this.readVariableLengthIndex(parser); bytesRead += vertIndex.bytesRead;
                    var polyIndex = this.readVariableLengthIndex(parser); bytesRead += polyIndex.bytesRead;
                
                    switch (type)
                    {
                        case 1415075158: // 'TXUV'
                            {
                                u = parser.readFloat32(); bytesRead += 4;
                                v = parser.readFloat32(); bytesRead += 4;
                        
                                var vmadData = new LWO2VMADData();
                                vmadData.vertex = vertIndex.index;
                                vmadData.poly = polyIndex.index;
                                vmadData.u = u;
                                vmadData.v = v;
                                data.currentLayer().putVmad('TXUV', name.string, vmadData);
                            }
                            break;
                    
                        default:
                            {
                                for (var i=0; i < dimension; i++)
                                {
                                    value = parser.readFloat32(); bytesRead += 4;       
                                }
                            }
                            break;    
                    }       
                }
            }
            break;
        
        case 1398100550: // 'SURF'
            {
                var name = this.readString(parser); bytesRead += name.bytesRead;
                var source = this.readString(parser); bytesRead += source.bytesRead;

                data.addSurface(name.string, source.string);
            
                // parse surface subchunks
                while (chunkSize > bytesRead)
                {
                    bytesRead += this.parseSubChunk(parser, data);
                }
            }
            break;
        
        case 1129072976: // 'CLIP'
            {
                var index = parser.readUInt32(); bytesRead += 4;
            
                data.addClip(index);
                data.subChunkContext = tag;
            
                // parse clip subchunks
                while (chunkSize > bytesRead)
                {
                    bytesRead += this.parseSubChunk(parser, data);
                }
            }
            break;
        
        case 1162761804: // 'ENVL'
            {
                var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
            
                data.addEnvelope(index.index);
            
                // parse envelope subchunks
                while (chunkSize > bytesRead)
                {
                    bytesRead += this.parseSubChunk(parser, data);
                }
            }
            break;
          
        default:
            {
                // unrecognized tag - seek to end of chunk
                while (chunkSize > bytesRead)
                {
                    parser.readUInt8(); bytesRead++;
                }
            }
            break;
    }
    
    // read pad byte if chunk size is odd
    if (chunkSize & 0x1)
    {
        parser.readUInt8(); bytesRead++;
    }
    
    // account for tag/chunk size (read at beginning of method)
    bytesRead += 8;
    //alert("bytesRead: " + bytesRead);
    
    return bytesRead;    
}

LWObjectHandler.prototype.parseSubChunk = function(parser, data)
{
    var bytesRead = 0;

    // read subchunk tag
    var tag = parser.readUInt32(); bytesRead += 4;

    // read subchunk size
    var subChunkSize = parser.readUInt16(); bytesRead += 2;

    // read subchunk size bytes
    switch (tag)
    {
        case 1129270354: // 'COLR'
            {
                data.currentSurface().color.x = parser.readFloat32(); bytesRead += 4;
                data.currentSurface().color.y = parser.readFloat32(); bytesRead += 4;
                data.currentSurface().color.z = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }    
            }
            break;
        
        case 1145652806: // 'DIFF'
            {
                data.currentSurface().diffuseLevel = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                } 
            }
            break;
    
        case 1280658761: // 'LUMI'  
            {
                data.currentSurface().luminosityLevel = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1397769539: // 'SPEC'
            {
                data.currentSurface().specularLevel = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1414676814: // 'TRAN'
            {
                data.currentSurface().transparencyLevel = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1196183379: // 'GLOS'
            {
                data.currentSurface().glossiness = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1397310533: // 'SIDE'
            {
                data.currentSurface().doubleSided = (parser.readUInt16() == 3 ? true : false); bytesRead += 2;            
            }
            break;
        
        case 1397571918: // 'SMAN'
            {
                data.currentSurface().smoothingAngle = parser.readFloat32(); bytesRead += 4;
            }
            break;
        
        case 1398032716: // 'STIL'
        case 1095649613: // 'ANIM'
        case 1230194001: // 'ISEQ'
            {
                var filename = this.readString(parser); bytesRead += filename.bytesRead;
            
                // skip subsequent chunk data
                while (subChunkSize > (bytesRead - 6))
                {
                    parser.readUInt8(); bytesRead += 1;
                }
            
                data.currentClip().type = tag;
                data.currentClip().setFilename(filename.string);
            }
            break;
        
        case 1313163073: // 'NEGA'
            {
                var negative = parser.readUInt16(); bytesRead += 2;
            
                if (data.subChunkContext == 'IMAP')
                {
                    data.currentSurface().currentBlock().negative = negative;
                }
                else if (data.subChunkContext == 'CLIP')
                {
                    data.currentClip().negative = negative;
                }
            }
            break;
        
        case 1112297291: // 'BLOK'
            {
                data.currentSurface().addBlock();
            }
            break;
        
        case 1229799760: // 'IMAP'
            {
                var ordinal = this.readString(parser); bytesRead += ordinal.bytesRead;
            
                data.currentSurface().currentBlock().type = 'IMAP';
                data.currentSurface().currentBlock().ordinal = ordinal.string;
                data.subChunkContext = 'IMAP';
            }
            break;
        
        case 1128808782: // 'CHAN'
            {
                var channel = parser.readUInt32(); bytesRead += 4;
            
                if (data.subChunkContext == 'IMAP')
                {
                    data.currentSurface().currentBlock().channel = channel;
                }
            }
            break;
        
        case 1162756418: // 'ENAB'
            {
                data.currentSurface().currentBlock().enable = parser.readUInt16(); bytesRead += 2;
            }
            break;
        
        case 1330659651: // 'OPAC'
            {
                data.currentSurface().currentBlock().opacityType = parser.readUInt16(); bytesRead += 2;
                data.currentSurface().currentBlock().opacity = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var envelope = this.readVariableLengthIndex(parser); bytesRead += envelope.bytesRead;
                
                    data.currentSurface().currentBlock().opacityEnvelope = envelope.index;
                }
            }
            break;
        
        case 1414349136: // 'TMAP'
            {
            }
            break;
         
        case 1129206866: // 'CNTR'
            {
                data.currentSurface().currentBlock().center.x = parser.readFloat32(); bytesRead += 4;
                data.currentSurface().currentBlock().center.y = parser.readFloat32(); bytesRead += 4;
                data.currentSurface().currentBlock().center.z = parser.readFloat32(); bytesRead += 4;
            
                while (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1397316165: // 'SIZE'
            {
                data.currentSurface().currentBlock().size.x = parser.readFloat32(); bytesRead += 4;
                data.currentSurface().currentBlock().size.y = parser.readFloat32(); bytesRead += 4;
                data.currentSurface().currentBlock().size.z = parser.readFloat32(); bytesRead += 4;
            
                while (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1129535827: // 'CSYS'
            {
                data.currentSurface().currentBlock().coordSys = parser.readUInt16(); bytesRead += 2;
            }
            break;
        
        case 1347571530: // 'PROJ'
            {
                data.currentSurface().currentBlock().projMode = parser.readUInt16(); bytesRead += 2;
            }
            break;
        
        case 1096304979: // 'AXIS'
            {
                var axis = parser.readUInt16(); bytesRead += 2;
            
                if (data.subChunkContext == 'IMAP')
                {
                    data.currentSurface().currentBlock().axis = axis;
                }
            }
            break;
        
        case 1229799751: // 'IMAG'
            {
                var image = this.readVariableLengthIndex(parser); bytesRead += image.bytesRead;
            
                data.currentSurface().currentBlock().imageIndex = image.index;
            }
            break;
        
        case 1465008464: // 'WRAP'
            {
                data.currentSurface().currentBlock().widthWrap = parser.readUInt16(); bytesRead += 2;
                data.currentSurface().currentBlock().heightWrap = parser.readUInt16(); bytesRead += 2;
            }
            break;
        
        case 1465012311: // 'WRPW'
            {
                data.currentSurface().currentBlock().widthWrapAmt = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1465012296: // 'WRPH'
            {
                data.currentSurface().currentBlock().heightWrapAmt = parser.readFloat32(); bytesRead += 4;
            
                if (subChunkSize > (bytesRead - 6))
                {
                    var index = this.readVariableLengthIndex(parser); bytesRead += index.bytesRead;
                }
            }
            break;
        
        case 1447903568: // 'VMAP'
            {
                var name = this.readString(parser); bytesRead += name.bytesRead;
            
                data.currentSurface().currentBlock().uvMapName = name.string; 
            }
            break;
        
        case 1415139397: // 'TYPE'
            {
                data.currentEnvelope().userFormat = parser.readUInt8(); bytesRead += 1;
                data.currentEnvelope().type = parser.readUInt8(); bytesRead += 1;
            }
            break;
        
        case 1347568928: // 'PRE '
            {
                data.currentEnvelope().preBehavior = parser.readUInt16(); bytesRead += 2;
            }
            break;
        
            //case 1262836000: // 'KEY '
            {
                // TODO        
            }
            break;
       
            //case 1397768526: // 'SPAN'
            {
                // TODO
                //case 1413693984: // 'TCB '
                //case 1212502605: // 'HERM'
                //case 1111841353: // 'BEZI'
                //case 1111841330: // 'BEZ2'
                //case 1398031696: // 'STEP'
                //case 1279872581: // 'LINE'
            }
            break;
        
        case 1347375956: // 'POST'
            {
                data.currentEnvelope().postBehavior = parser.readUInt16(); bytesRead += 2;
            }
            break;

        default:
            {
                // unrecognized tag - seek to end of chunk
                while (subChunkSize > (bytesRead - 6))
                {
                    parser.readUInt8(); bytesRead += 1;
                }
            }
            break;
    }
    
    // read pad byte if subchunk size is odd
    if (subChunkSize & 0x1)
    {
        parser.readUInt8(); bytesRead += 1;
    }
    
    return bytesRead;
}

LWObjectHandler.prototype.readString = function(parser)
{
    var s = "";
    var c = 0;
    var count = 0;
    do
    {
        c = parser.readUInt8(); count++;
        s += String.fromCharCode(c);
        
    } while (c);
    
    // read pad byte if length is odd
    if (count & 0x1)
    {
        parser.readUInt8(); count++;   
    }
    
    return { string: s, bytesRead: count };
}

LWObjectHandler.prototype.readVariableLengthIndex = function(parser)
{
    var i = 0;
    var c = new Array(4);
    var count = 0;
    
    c[0] = parser.readUInt8(); count++;
    c[1] = parser.readUInt8(); count++;
    
    if (c[0] < 0xff00) // 2-byte form
    {
        i = c[0] << 8 | c[1];
    }
    else // 4-byte form
    {
        c[2] = parser.readUInt8(); count++;
        c[3] = parser.readUInt8(); count++;
        
        i = c[1] << 16 | c[2] << 8 | c[3];
    }

    return { index: i, bytesRead: count };
}

LWObjectHandler.prototype.matchesType = function(type)
{
    return (type == "lwo");
}
LWObjectBuilder.prototype = new ContentBuilder();
LWObjectBuilder.prototype.constructor = LWObjectBuilder;

function LWObjectBuilder()
{
    ContentBuilder.call(this);
    this.className = "LWObjectBuilder";
    
    this.graphMgr = null;
    
    this.indexGeometry = new BooleanAttr(true);
    
    this.registerAttribute(this.indexGeometry, "indexGeometry");
}

LWObjectBuilder.prototype.visitHandler = function(handler)
{
    handler.addObjectHandler(LWObjectBuilder_ObjectHandler, this);
}

LWObjectBuilder.prototype.finalize = function()
{
}

LWObjectBuilder.prototype.matchesType = function(type)
{
    return (type == "lwo");
}

LWObjectBuilder.prototype.allocateModel = function(data)
{
    var model = null;
    var layer = this.layer;
    if (layer == 0)
    {
        for (var i=0; i < data.layers.length; i++)
        {
            // allocate model if necessary (otherwise use the model passed to the builder)
            if (!this.models[0])
            {
                var factory = this.registry.find("AttributeFactory");
                model = factory.create("Model");
                this.models.push(model);
            }
            else model = this.models[0];

            // TODO: matching model/replace model surfaces

            // define model attributes
            this.describeModel(data, data.layers[i], model);
        }
    }
    else if (layer <= data.layers.length) // layer > 0
    {
        // allocate model if necessary (otherwise use the model passed to the builder)
        if (!this.models[0])
        {
            var factory = this.registry.find("AttributeFactory");
            model = factory.create("Model");
            this.models.push(model);
        }
        else model = this.models[0];
        
        // TODO: matching model/replace model surfaces

        // define model attributes
        this.describeModel(data, data.layers[layer-1], model);
    }
}

LWObjectBuilder.prototype.describeModel = function(data, layer, model)
{
    var factory = this.registry.find("AttributeFactory");
    
    // set pivot if not already set by scene
    var pivot = model.getAttribute("pivot");
    if (model.getAttributeModificationCount(pivot) == 0)
    {
        pivot.setValue(layer.pivot.v());
    }

    // build list of tri, line, and point poly indices indexed by surface number
    var numSurfaces = layer.ptagsSURFMaxIndex + 1;
    var triPolys = new Array(numSurfaces);
    var linePolys = new Array(numSurfaces);
    var pointPolys = new Array(numSurfaces);
    var NPolys = new Array(numSurfaces);
    for (var i = 0; i < numSurfaces; i++)
    {
        triPolys[i] = [];
        linePolys[i] = [];
        pointPolys[i] = [];
        NPolys[i] = [];
    }

    var polyIndex, surfIndex;
    var numPtagsSURF = layer.ptagsSURF.length;
    for (var ptag = 0; ptag < numPtagsSURF; ptag++)
    {
        polyIndex = layer.ptagsSURF[ptag].poly;
        surfIndex = layer.ptagsSURF[ptag].tag;

        switch (layer.pols[polyIndex].length)
        {
            case 3: triPolys[surfIndex].push(polyIndex); break;
            case 2: linePolys[surfIndex].push(polyIndex); break;
            case 1: pointPolys[surfIndex].push(polyIndex); break;
            default: NPolys[surfIndex].push(polyIndex); break;
        }
    }

    // create surfaces for geometry
    var surfaces = new Array(numSurfaces);
    for (var surfIndex = 0; surfIndex < numSurfaces; surfIndex++)
    {
        surfaces[surfIndex] = this.allocateSurface(data, layer, surfIndex);

        // add surface to model (model will target surface and set its color to the surface)
        model.addSurface(surfaces[surfIndex]);
    }

    // set layer vertices to model
    var layerVertices = new Array(layer.pnts.length * 3);
    for (var layerVertex = 0; layerVertex < layer.pnts.length; layerVertex++)
    {
        layerVertices[layerVertex * 3] = layer.pnts[layerVertex].x;
        layerVertices[layerVertex * 3 + 1] = layer.pnts[layerVertex].y;
        layerVertices[layerVertex * 3 + 2] = layer.pnts[layerVertex].z;
    }
    model.getAttribute("vertices").setValue(layerVertices);

    // create geometry (calculate polygon normals for tris)
    var vertexPolyNormals = [];
    var vertexNormals = [];
    var vertexOrder = [];
    var vertexMinMax = [];
    var polyOrder = [];
    var triLists = [];
    var triVertices = [];
    var triPolyNormals = [];
    var leg1 = new Vector3D();
    var leg2 = new Vector3D();
        
    vertexPolyNormals.length = layer.pnts.length;
    for (var i = 0; i < vertexPolyNormals.length; i++)
    {
        vertexPolyNormals[i] = [];
    }
    vertexNormals.length = numSurfaces;
    vertexOrder.length = numSurfaces;
    vertexMinMax.length = numSurfaces;
    polyOrder.length = numSurfaces;
    triLists.length = numSurfaces;
    triVertices.length = numSurfaces;
    triPolyNormals.length = numSurfaces;

    for (var surfIndex = 0; surfIndex < surfaces.length; surfIndex++)
    {
        var vertices = [];
        var normals = [];
        vertexNormals[surfIndex] = []
        vertexOrder[surfIndex] = [];
        vertexMinMax[surfIndex] = new Pair();
        vertexMinMax[surfIndex].first = vertexMinMax[surfIndex].second = 0;
        polyOrder[surfIndex] = [];
        triPolyNormals[surfIndex] = [];

        // N-polys (triangulate then add to tris list)
        var polys = NPolys[surfIndex];
        var numPolys = polys.length;
        for (var polyIndex = 0; polyIndex < numPolys; polyIndex++)
        {
            var jsmPolygon = new JSM.Polygon();
            var poly = layer.pols[polys[polyIndex]];
            for (var vertex = 0; vertex < poly.length; vertex++)
            {
                var point = layer.pnts[poly[vertex]];
                vertices.push([point.x, point.y, point.z]);

                jsmPolygon.AddVertex(point.x, point.y, point.z);
            }
           
            var triangles = JSM.PolygonTriangulate(jsmPolygon);
            for (var i=0; i < triangles.length; i++)
            {
                var triPoly = [];
                triPoly.push(poly[triangles[i][0]]);
                triPoly.push(poly[triangles[i][1]]);
                triPoly.push(poly[triangles[i][2]]);
                
                layer.pols.push(triPoly);
                triPolys[surfIndex].push(layer.pols.length-1);
            }
        }

        // tris   
        vertices = [];
        polys = triPolys[surfIndex];
        numPolys = polys.length;
        for (var polyIndex = 0; polyIndex < numPolys; polyIndex++)
        {
            var poly = layer.pols[polys[polyIndex]];
            for (var vertex = 0; vertex < 3; vertex++)
            {
                var point = layer.pnts[poly[vertex]];
                vertices.push(point.x);
                vertices.push(point.y);
                vertices.push(point.z);

                vertexOrder[surfIndex].push(poly[vertex]);
                vertexMinMax[surfIndex].first = Math.min(poly[vertex], vertexMinMax[surfIndex].first);
                vertexMinMax[surfIndex].second = Math.min(poly[vertex], vertexMinMax[surfIndex].second);
                polyOrder[surfIndex].push(polys[polyIndex]);
            }

            // get vertex indices
            var vertIndex0 = poly[0];
            var vertIndex1 = poly[1];
            var vertIndex2 = poly[2];

            // calculate polygon normal
            var point0 = layer.pnts[vertIndex0];
            var point1 = layer.pnts[vertIndex1];
            var point2 = layer.pnts[vertIndex2];

            leg1.load(point1.x - point0.x,
                      point1.y - point0.y,
                      point1.z - point0.z);

            leg2.load(point2.x - point0.x,
                      point2.y - point0.y,
                      point2.z - point0.z);

            var cross = crossProduct(leg1, leg2);
            cross.normalize();

            normals.push(cross.x)
            normals.push(cross.y);
            normals.push(cross.z);

            normals.push(cross.x)
            normals.push(cross.y);
            normals.push(cross.z);

            normals.push(cross.x)
            normals.push(cross.y);
            normals.push(cross.z);

            vertexNormals[surfIndex].push(new Pair(vertIndex0, cross));
            vertexNormals[surfIndex].push(new Pair(vertIndex1, cross));
            vertexNormals[surfIndex].push(new Pair(vertIndex2, cross));

            vertexPolyNormals[vertIndex0].push(cross);
            vertexPolyNormals[vertIndex1].push(cross);
            vertexPolyNormals[vertIndex2].push(cross);

            triPolyNormals[surfIndex].push(cross);
            triPolyNormals[surfIndex].push(cross);
            triPolyNormals[surfIndex].push(cross);
        }

        if (vertices.length)
        {
            var triList = factory.create("TriList");

            model.addGeometry(triList, surfaces[surfIndex]); // TODO: call method that accepts indices

            triList.getAttribute("vertices").setValue(vertices);
            triList.getAttribute("normals").setValue(normals);

            triLists[surfIndex] = triList;
            triVertices[surfIndex] = vertices;
        }

        // lines
        vertices = [];
        polys = linePolys[surfIndex];
        numPolys = polys.length;
        
        for (var polyIndex = 0; polyIndex < numPolys; polyIndex++)
        {
            var poly = layer.pols[polyIndex];
            if (poly.length < 2) continue;
            
            for (var vertex = 0; vertex < 2; vertex++)
            {
                var point = layer.pnts[poly[vertex]];
                
                vertices.push(point.x);
                vertices.push(point.y);
                vertices.push(point.z);
                
            }
        }
        
        if (vertices.length)
        {
            var lineList = factory.create("LineList");

            model.addGeometry(lineList, surfaces[surfIndex]); // TODO: call method that accepts indices   
            
            lineList.getAttribute("vertices").setValue(vertices);
        }
        
        // points
        vertices = [];
        polys = pointPolys[surfIndex];
        numPolys = polys.length;
        
        for (var polyIndex = 0; polyIndex < numPolys; polyIndex++)
        {
            var poly = layer.pols[polyIndex];
            
            var point = layer.pnts[poly[0]];
            
            vertices.push(point.x);
            vertices.push(point.y);
            vertices.push(point.z);
                
        }
        
        if (vertices.length)
        {
            var pointList = factory.create("PointList");

            model.addGeometry(pointList, surfaces[surfIndex]); // TODO: call method that accepts indices   
            
            pointList.getAttribute("vertices").setValue(vertices);
        }
    }

    // calculate smooth normals for tris
    var smoothNormals = [];
    for (var surfIndex = 0; surfIndex < surfaces.length; surfIndex++)
    {
        if (!triLists[surfIndex]) continue;

        var surface = data.getSurface(data.tags[surfIndex]);
        if (!surface) continue;
        
        var smoothingAngle = surface.smoothingAngle;
        if (smoothingAngle <= 0) continue;

        var cosSmoothingAngle = Math.cos(smoothingAngle);

        smoothNormals.length = vertexNormals[surfIndex].length;
        for (var i = 0; i < smoothNormals.length; i++)
        {
            smoothNormals[i] = new Vector3D();
        }

        // for each vertex normal...
        for (var vn = 0; vn < vertexNormals[surfIndex].length; vn++)
        {
            var vertexIndex = vertexNormals[surfIndex][vn].first;
            var vertexNormal = vertexNormals[surfIndex][vn].second;

            // for each polygon normal...
            for (var vpn = 0; vpn < vertexPolyNormals[vertexIndex].length; vpn++)
            {
                var polyNormal = vertexPolyNormals[vertexIndex][vpn];
                var angle = cosineAngleBetween(vertexNormal, polyNormal);
                if (Math.acos(angle) <= smoothingAngle)
                {
                    smoothNormals[vn].x += polyNormal.x;
                    smoothNormals[vn].y += polyNormal.y;
                    smoothNormals[vn].z += polyNormal.z;
                }
            }

            smoothNormals[vn].normalize();
        }

        // arrange smooth normals in array
        var smoothedNormals = [];
        for (var i = 0; i < smoothNormals.length; i++)
        {
            smoothedNormals.push(smoothNormals[i].x);
            smoothedNormals.push(smoothNormals[i].y);
            smoothedNormals.push(smoothNormals[i].z);
        }
        smoothNormals.length = 0;

        triLists[surfIndex].getAttribute("normals").setValue(smoothedNormals);
    }

    // load textures
    for (var surfIndex = 0; surfIndex < surfaces.length; surfIndex++)
    {
        var surfaceData = data.getSurface(surfaces[surfIndex].getAttribute("name").getValueDirect().join(""));
        if (surfaceData)
        {
            var textures = this.loadTextures(data, layer, surfaceData, surfaces[surfIndex]);

            // calculate texture coordinates
            for (var i = 0; i < textures.length; i++)
            {
                var uvCoords = this.calculateTextureCoords(data, layer, textures[i].second, triVertices[surfIndex],
                                                       triPolyNormals[surfIndex], vertexOrder[surfIndex],
                                                       polyOrder[surfIndex]);
                if (uvCoords)
                {
                    triLists[surfIndex].getUVCoords(textures[i].first).setValueDirect(uvCoords);
                }
            }
        }
    }

    // TODO: index vertices if requested
}

LWObjectBuilder.prototype.allocateSurface = function(data, layer, surfaceNumber)
{
     var factory = this.registry.find("AttributeFactory");
     surface = factory.create("Surface");
     
     var name = data.tags[surfaceNumber];
     surface.getAttribute("name").setValueDirect(name);
     
     this.describeSurface(data.getSurface(name), surface);
     
     return surface;
}

LWObjectBuilder.prototype.describeSurface = function(data, surface)
{
    // TEMPTEST
    if (!data) return;
    
    // color
    var values = [];
    values.push(data.color.x);
    values.push(data.color.y);
    values.push(data.color.z);
    values.push(1);
    surface.getAttribute("color").setValue(values);
    
    // ambient level (use diffuse since ambient level is not specified
    surface.getAttribute("ambientLevel").setValueDirect(data.diffuseLevel);
    
    // diffuse level
    surface.getAttribute("diffuseLevel").setValueDirect(data.diffuseLevel);
    
    // specular level
    surface.getAttribute("specularLevel").setValueDirect(data.specularLevel);
    
    // emissive level
    surface.getAttribute("emissiveLevel").setValueDirect(data.luminosityLevel);
    
    // glossiness
    surface.getAttribute("glossiness").setValueDirect(data.glossiness);
    
    // opacity
    surface.getAttribute("opacity").setValueDirect(1 - data.transparencyLevel);
    
    // double-sidedness
    surface.getAttribute("doubleSided").setValueDirect(data.doubleSided ? true : false);
}

LWObjectBuilder.prototype.loadTextures = function(data, layer, surfaceData, surface)
{
    var textures = [];

    // arrange blocks into ordered lists indexed by channel
    var channelBlocks = [];
    for (var i = 0; i < surfaceData.blocks.length; i++)
    {
        var block = surfaceData.blocks[i];
        if (block.type != 'IMAP') continue;

        if (!channelBlocks[block.channel])
        {
            channelBlocks[block.channel] = []
        }
        channelBlocks[block.channel].push(block);
    }

    // allocate textures for supported channel types

    // color
    if (channelBlocks[eLWObjectTokens.COLR])
    {
        this.allocateTextures(eTextureType.Color, data, layer, channelBlocks[eLWObjectTokens.COLR], surface, textures);
    }

    // diffuse
    if (channelBlocks[eLWObjectTokens.DIFF])
    {
        this.allocateTextures(eTextureType.Diffuse, data, layer, channelBlocks[eLWObjectTokens.DIFF], surface, textures);
    }

    // luminosity
    if (channelBlocks[eLWObjectTokens.LUMI])
    {
        this.allocateTextures(eTextureType.Luminosity, data, layer, channelBlocks[eLWObjectTokens.LUMI], surface, textures);
    }

    // specular
    if (channelBlocks[eLWObjectTokens.SPEC])
    {
        this.allocateTextures(eTextureType.Specular, data, layer, channelBlocks[eLWObjectTokens.SPEC], surface, textures);
    }

    // transparency
    if (channelBlocks[eLWObjectTokens.TRAN])
    {
        this.allocateTextures(eTextureType.Transparency, data, layer, channelBlocks[eLWObjectTokens.TRAN], surface, textures);
    }

    return textures;
}

LWObjectBuilder.prototype.allocateTextures = function(type, data, layer, blocks, surface, textures)
{  
    // create a media texture object for each normal or additive texture layer; if subsequent
    // layer is alpha, add as texture alpha channel
    for (var i=0; i < blocks.length; i++)
    {
        var block = blocks[i];
        if (block.opacityType != 0 && 
            block.opacityType != 7)
            continue;
            
        var imageClip = data.clips[block.imageIndex];
        if (!imageClip)
            continue;
            
        var alphaClip = null;
        if (i+1 < blocks.length)
        {
            if (blocks[i+1].opacityType == 5)
            {
                alphaClip = data.clips[blocks[i+1].imageIndex];
            }    
        } 
        
        var widthWrap, heightWrap;
        switch (block.widthWrap)
        {
        case 0: widthWrap = eTextureWrap.None; break;
        case 1: widthWrap = eTextureWrap.Repeat; break; 
        case 2: widthWrap = eTextureWrap.Mirror; break;
        case 3: widthWrap = eTextureWrap.Clamp; break;
        } 
        switch (block.heightWrap)
        {
        case 0: heightWrap = eTextureWrap.None; break;
        case 1: heightWrap = eTextureWrap.Repeat; break; 
        case 2: heightWrap = eTextureWrap.Mirror; break;
        case 3: heightWrap = eTextureWrap.Clamp; break;
        }     
        
        var filename = imageClip.getFilename();
        
        // strip any local paths saved by the modeler
        var ndx = filename.lastIndexOf('/');
        
        filename = ndx === -1 ? filename : filename.substring(ndx+1);
         
        var clipFilename = data.contentDir + "images/" + filename;
        
        // setup negate image flag based upon whether or not the graphics card uses
        // inverted alpha values, and if this is a transparency, diffuse, luminosity,
        // or specularity texture
        var negateImage = block.negative ? true : false;
        if (this.invertAlpha && 
           (type == eTextureType.Transparency ||
            type == eTextureType.Diffuse ||
            type == eTextureType.Luminosity ||
            type == eTextureType.Specularity))
        {
            negateImage = !negateImage;
        }

        // setup negate alpha flag based upon existance of an alpha clip and 
        // whether or not the graphics card uses inverted alpha values
        var negateAlpha = false;
        if (alphaClip)
        {
            negateAlpha = blocks[i+1].negative ? true : false;
            if (this.invertAlpha)
            {
                negateAlpha = !negateAlpha;
            }
        }
        
        // TODO: check if texture with same attributes has already been created;
        // if not, or if an opacity envelope is being used, allocate new one
        var mediaTexture = null;
        
        var factory = this.registry.find("AttributeFactory");
        mediaTexture = factory.create("MediaTexture");
           
        mediaTexture.getAttribute("name").setValueDirect(""); // TODO
        mediaTexture.getAttribute("textureType").setValueDirect(type);
        mediaTexture.getAttribute("opacity").setValueDirect(block.opacity);
        mediaTexture.getAttribute("widthWrap").setValueDirect(widthWrap);
        mediaTexture.getAttribute("heightWrap").setValueDirect(heightWrap);
        mediaTexture.getAttribute("mipmappingEnabled").setValueDirect(false);
        mediaTexture.getAttribute("imageFilename").setValueDirect(clipFilename);
        mediaTexture.getAttribute("negateImage").setValueDirect(negateImage);
        mediaTexture.getAttribute("negateAlpha").setValueDirect(negateAlpha);
        if (alphaClip)
        {
            mediaTexture.getAttribute("alphaFilename").setValueDirect(data.contentDir + alphaClip.getFilename());
        }
        
        // TODO: if opacity is an envelope, create a KeyframeInterpolator and attach to texture opacity attr

        textures.push(new Pair(mediaTexture, block));
        surface.addTexture(mediaTexture);
    }       
}

LWObjectBuilder.prototype.calculateTextureCoords = function(data, layer, blockData, vertices, polyNormals,
                                                            vertIndices, polyIndices)
{
    if (!data ||
        !layer ||
        !blockData ||
        !vertices ||
        !polyNormals ||
        !vertIndices ||
        !polyIndices)
    {
        return null;
    }

    var uvCoords = []
    var numVertices = vertices.length / 3;

    switch (blockData.projMode)
    {
        case 0: // planar
        case 1: // cylindrical
        case 2: // spherical
            {
                var i, vertex, uv;
                for (i = 0, vertex = 0, uv = 0; i < numVertices; i++, vertex += 3, uv += 2)
                {
                    uv = this.mapXYZtoUV(vertices[vertex], vertices[vertex + 1], vertices[vertex + 2],
                                     blockData.center, blockData.size, blockData.projMode, blockData.axis,
                                     blockData.widthWrapAmt, blockData.heightWrapAmt);
                    uvCoords.push(uv.u);
                    uvCoords.push(uv.v);
                }
            }
            break;

        case 3: // cubic
            {
                var i, vertex, uv;
                for (i = 0, vertex = 0, uv = 0; i < numVertices; i++, vertex += 3, uv += 2)
                {
                    polyNormal = polyNormals[i];

                    if (Math.acos(cosineAngleBetween(polyNormal, new Vector3D(1, 0, 0))) <= QUARTERPI ||
                    Math.acos(cosineAngleBetween(polyNormal, new Vector3D(-1, 0, 0))) <= QUARTERPI)
                    {
                        axis = 0; // x
                    }
                    else if (Math.acos(cosineAngleBetween(polyNormal, new Vector3D(0, 1, 0))) <= QUARTERPI ||
                         Math.acos(cosineAngleBetween(polyNormal, new Vector3D(0, -1, 0))) <= QUARTERPI)
                    {
                        axis = 1; // y
                    }
                    else
                    {
                        axis = 2; // z
                    }

                    uv = this.mapXYZtoUV(vertices[vertex], vertices[vertex + 1], vertices[vertex + 2],
                                     blockData.center, blockData.size, 0, axis,
                                     blockData.widthWrapAmt, blockData.heightWrapAmt);
                    uvCoords.push(uv.u);
                    uvCoords.push(uv.v);
                }
            }
            break;

        case 5: // UV
            {
                var vmap = layer.getVmap('TXUV', blockData.uvMapName);
                //if (vmap) quick_sort(vmap, LWObjectBuilder_CompareVmapEntries);

                var vmad = layer.getVmad('TXUV', blockData.uvMapName);
                //if (vmad) quick_sort(vmad, LWObjectBuilder_CompareVmadEntries);

                var i, vertIndex, polyIndex, uv, uvSet;
                for (i = 0, uv = 0; i < numVertices; i++, uv += 2)
                {
                    vertIndex = vertIndices[i];
                    polyIndex = polyIndices[i];
                    uvSet = false;

                    // check for vmad entry (overrides vmap entry)
                    if (vmad && vmad.length)
                    {
                        for (var vmad_entries = 0; vmad_entries < vmad.length; vmad_entries++)
                        {
                            if (vmad[vmad_entries].poly > polyIndex)
                            {
                                break;
                            }

                            if (vmad[vmad_entries].poly == polyIndex)
                            {
                                if (vmad[vmad_entries].vertex == vertIndex)
                                {
                                    uvCoords[uv] = vmad[vmad_entries].u;
                                    uvCoords[uv + 1] = vmad[vmad_entries].v;
                                    uvSet = true;
                                    break;
                                }
                            }
                        }

                        if (uvSet)
                        {
                            // don't retrieve from vmap
                            continue;
                        }
                    }

                    // check for vmap entry
                    if (vmap && vmap.length)
                    {
                        for (var vmap_entries = 0; vmap_entries < vmap.length; vmap_entries++)
                        {
                            if (vmap[vmap_entries].vertex > vertIndex)
                            {
                                break;
                            }

                            if (vmap[vmap_entries].vertex == vertIndex)
                            {
                                uvCoords[uv] = vmap[vmap_entries].u;
                                uvCoords[uv + 1] = vmap[vmap_entries].v;
                                uvSet = true;
                                break;
                            }
                        }
                    }

                    if (!uvSet)
                    {
                        uvCoords[uv] = 0;
                        uvCoords[uv + 1] = 0;
                    }
                }
            }
            break;

        default:
            {
                //alert(blockData.projMode);
            }
            break;
    }

    return uvCoords;
}

LWObjectBuilder.prototype.mapXYZtoUV = function(x, y, z, textureCenter, textureSize, projMode, axis, widthWrapAmt, heightWrapAmt)
{
    var lon, lat;
    var integerPart;

    var u = 0;
    var v = 0;

    switch(projMode)
    {
    case 0: // planar
        switch(axis)
        {
        case 0: // x
            u = (z - textureCenter.z) / textureSize.z + 0.5;
            v = (y - textureCenter.y) / textureSize.y + 0.5;
            break;

        case 1: // y
            u = (x - textureCenter.x) / textureSize.x + 0.5;
            v = (z - textureCenter.z) / textureSize.z + 0.5;
            break;

        case 2: // z
        default:
            u = (x - textureCenter.x) / textureSize.x + 0.5;
            v = (y - textureCenter.y) / textureSize.y + 0.5;
            break;
        }
        break;

   case 1: // cylindrical
        x -= textureCenter.x;
        y -= textureCenter.y;
        z -= textureCenter.z;
        
        switch(axis)
        {
        case 0: // x
            lon = XYZtoH(z, x, y);
            u = lon / (TWOPI * widthWrapAmt);
            v = x / textureSize.x + 0.5;
            break;

        case 1: // y
            lon = XYZtoH(x, y, z);
            u = lon / (TWOPI * widthWrapAmt);
            v = y / textureSize.y + 0.5;
            break;

        case 2: // z
        default:
            lon = XYZtoH(-x, z, -y);
            u = lon / (TWOPI * widthWrapAmt);
            v = -z / textureSize.z + 0.5;
            break;
        }

        // clamp u coordinate to range [0, 1)
        u = modf(u).fractionalPart;
        if (u < 0) u += 1;
        break;

   case 2: // spherical
        x -= textureCenter.x;
        y -= textureCenter.y;
        z -= textureCenter.z;

        switch (axis)
        {
        case 0: // x
            var hp = XYZtoHP(z, x, -y);
            lon = hp.heading;
            lat = hp.pitch;
            break;

        case 1: // y
            var hp = XYZtoHP(-x, y, z);
            lon = hp.heading;
            lat = hp.pitch;
            break;

        case 2: // z
        default:
            var hp = XYZtoHP(-x, z, -y);
            lon = hp.heading;
            lat = hp.pitch;
            break;
        }

        u = modf(1 - (lon / TWOPI * widthWrapAmt)).fractionalPart;
        v = 1 - modf(0.5 - (lat / Math.PI * heightWrapAmt)).fractionalPart;

        break;
    }
 
    return { u: u, v: v };   
}

function LWObjectBuilder_ObjectHandler(data, builder)
{
    builder.allocateModel(data);
}

function LWObjectBuilder_CompareVmapEntries(elem1, elem2)
{
    if (elem1.vertex < elem2.vertex) return -1;
    if (elem1.vertex > elem2.vertex) return 1;
    return 0;
}

function LWObjectBuilder_CompareVmadEntries(elem1, elem2)
{
    if (elem1.poly < elem2.poly) return -1;
    if (elem1.poly > elem2.poly) return 1;
    return 0;
}
LWSceneHandler.prototype = new ContentHandler();
LWSceneHandler.prototype.constructor = LWSceneHandler;

function LWSceneHandler()
{
    ContentHandler.call(this);
    this.className = "LWSceneHandler";
    
    this.tokenHandlers = [];
    this.tokenHandlersData = [];
}

LWSceneHandler.prototype.addTokenHandler = function(handler, data)
{
    this.tokenHandlers.push(handler);
    this.tokenHandlersData.push(data);
}

LWSceneHandler.prototype.parseFileStream = function(url)
{
    var filename = formFullPath(url, this.contentDirectory.getValueDirect().join(""));
    var filestream = loadTextResource(filename);
    if (filestream == null)
    {
        return -2;
    }
    
    var parser = new TextParser(filestream);
    
    var tokens;
    while (tokens = parser.readLineTokens())
    {
        // pass tokens to consumer(s)
        for (var i=0; i < this.tokenHandlers.length; i++)
        {
            this.tokenHandlers[i](tokens, this.tokenHandlersData[i]);    
        }    
    }
}
LWSceneBuilder.prototype = new ContentBuilder();
LWSceneBuilder.prototype.constructor = LWSceneBuilder;

function LWSceneBuilder()
{
    ContentBuilder.call(this);
    this.className = "LWSceneBuilder";
    
    this.graphMgr = null;
    this.currChannel = 0;   // motions
    
    this.indexGeometry = new BooleanAttr(true);
    
    this.registerAttribute(this.indexGeometry, "indexGeometry");
}

LWSceneBuilder.prototype.visitHandler = function(handler)
{
    handler.addTokenHandler(LWSceneBuilder_TokenHandler, this);
}

LWSceneBuilder.prototype.finalize = function()
{
    }

LWSceneBuilder.prototype.matchesType = function(type)
{
    return (type == "lws" ||
            type == "mot");
}

LWSceneBuilder.prototype.allocateSceneElement = function(tokens)
{
    
    
    switch (tokens[0])
    {
        case "LoadObjectLayer":
        {
            
        }
        break;
        case "NumChannels":
        {
            var numChannels = parseInt(tokens[1], 10);
            
            var eval = this.evaluators[this.evaluators.length-1];
            
            eval.setNumChannels(numChannels);
            
            // attach to target (if specified)
            switch (numChannels)
            {
                case 1:
                    this.attachDissolveInterpolator(this.evaluators[this.evaluators.length-1], 
                        this.registry.find(this.evaluators[this.evaluators.length-1].getAttribute("target").getValueDirect().join("")));
                    break;
                   
                default:
                    this.attachKeyframeInterpolator(this.evaluators[this.evaluators.length-1], 
                        this.registry.find(this.evaluators[this.evaluators.length-1].getAttribute("target").getValueDirect().join("")));
                    break;
            }
        }
        break;
        
        case "Channel":
        {
            this.currChannel = parseInt(tokens[1], 10);
        }
        break;
        
        case "Key":
        {
            if (this.evaluators.length <= 0) break;
            
            var keyframes = this.evaluators[this.evaluators.length-1].getAttribute("channels").getAt(this.currChannel);
            if (!keyframes) break;
            
            var keyframe = new KeyframeAttr();
            for (var i=1; i < tokens.length; i++)
            {
                switch (i)
                {
                    // value
                    case 1:
                    {
                        var f = parseFloat(tokens[i]);

                        // if channel 3, 4, or 5, convert value to degrees
                        if (this.currChannel == 3 || this.currChannel == 4 || this.currChannel == 5)
                        {
                            f = toDegrees(f);
                        }

                        keyframe.getAttribute("value").setValueDirect(f);
                    }
                    break;
                    // time
                    case 2:
                        keyframe.getAttribute("time").setValueDirect(parseFloat(tokens[i]));
                        break;
                    case 3:
                    {
                        var shape = parseInt(tokens[i]);
                        switch (shape)
                        {
                            case 0:
                                keyframe.getAttribute("shape").setValueDirect(eKeyframeShape.TCB);
                                break;
                            case 1:
                                //keyframe.getAttribute("shape").setValueDirect();	// TODO: Hermite Spline
                                break;
                            case 2:
                                keyframe.getAttribute("shape").setValueDirect(eKeyframeShape.Bezier1D);
                                break;
                            case 3:
                                keyframe.getAttribute("shape").setValueDirect(eKeyframeShape.Linear);
                                break;
                            case 4:
                                keyframe.getAttribute("shape").setValueDirect(eKeyframeShape.Stepped);
                                break;
                            case 5:
                                keyframe.getAttribute("shape").setValueDirect(eKeyframeShape.Bezier2D);
                                break;
                            default:
                                keyframe.getAttribute("shape").setValueDirect(eKeyframeShape.Linear);
                                break;
                        }
                    }
                    break;
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        keyframe.getAttribute("params").getAt(i-3-1).setValueDirect(parseFloat(tokens[i]));
                        break;
                    default:
                        break;
                }
            }
			
            // set to keyframe interpolator
            keyframes.push_back(keyframe);
        }
        break;
        
        case "Behaviors":
        {
            if (this.evaluators.length <= 0) break;
            
            var preBehaviors = this.evaluators[this.evaluators.length-1].getAttribute("preBehaviors").getAt(this.currChannel);
            var postBehaviors = this.evaluators[this.evaluators.length-1].getAttribute("postBehaviors").getAt(this.currChannel);
            if (!preBehaviors || !postBehaviors) break;
            
            var pre = parseInt(tokens[1], 10);
            var post = parseInt(tokens[2], 10);
            
            preBehaviors.setValueDirect(pre);
            postBehaviors.setValueDirect(post);            
        }
        break;
    }
}

LWSceneBuilder.prototype.attachKeyframeInterpolator = function(kfi, target)
{
    if (!kfi || !target) return;
    
    var numChannels = kfi.getAttribute("channels").vector.length;
    
    for (var channel=0; channel < numChannels; channel++)
    {
        var resultValue = kfi.getAttribute("resultValues").getAt(channel);
        
        switch (channel)
        {
            case 0: // x pos
                resultValue.addElementTarget(target.getAttribute("position"), 0, 0);
                break;

            case 1: // y pos
                resultValue.addElementTarget(target.getAttribute("position"), 0, 1);
                break;

            case 2: // z pos
                resultValue.addElementTarget(target.getAttribute("position"), 0, 2);
                break;

            case 3: // heading (y rot)
                resultValue.addElementTarget(target.getAttribute("rotation"), 0, 1);
                break;

            case 4: // pitch (x rot)
                resultValue.addElementTarget(target.getAttribute("rotation"), 0, 0);
                break;

            case 5: // bank (z rot)
                resultValue.addElementTarget(target.getAttribute("rotation"), 0, 2);
                break;

            case 6: // x scale
                resultValue.addElementTarget(target.getAttribute("scale"), 0, 0);
                break;

            case 7: // y scale
                resultValue.addElementTarget(target.getAttribute("scale"), 0, 1);
                break;

            case 8: // z scale
                resultValue.addElementTarget(target.getAttribute("scale"), 0, 2);
                break;
        }   
    }
    
    kfi.getAttribute("time").setValueDirect(0);
}

LWSceneBuilder.prototype.attachDissolveInterpolator = function(kfi, target)
{
    if (!kfi || !target) return;
    
    var resultValue = kfi.getAttribute("resultValues").getAt(0);
    
    resultValue.addElementTarget(target.getAttribute("dissolve"), 0, 0);
}

function LWSceneBuilder_TokenHandler(tokens, builder)
{
    builder.allocateSceneElement(tokens);
}
AttributeFactory.prototype = new AttributeContainer();
AttributeFactory.prototype.constructor = AttributeFactory;

function AttributeFactory()
{
    AttributeContainer.call(this);
    this.className = "AttributeFactory";
    this.attrType = eAttrType.AttributeFactory;
    
    this.newResourceProcs = [];
    this.configureProcs = [];
    this.finalizeProcs = [];
    this.registry = null;
    this.graphMgr = null;
    
    this.name = new StringAttr("AttributeFactory");
    
    this.registerAttribute(this.name, "name");
    
    this.initializeNewResourceMap();
    this.initializeConfigureMap();
    this.initializeFinalizeMap();
}

AttributeFactory.prototype.create = function(name)
{
    var resource = null;
    
    // invoke new resource proc
    var newResourceProc = this.newResourceProcs[name];
    if (newResourceProc)
    {
        resource = newResourceProc(name, this);
    }
    if (!resource) return null;
    
    // invoke configuration proc (if specified)
    var configureProc = this.configureProcs[name];
    if (configureProc)
    {
        configureProc(resource, this);
    }
    
    // if resource is a container, register name and userData if not already registered
	if (resource.isContainer())
	{
	    if (!resource.getAttribute("name")) resource.registerAttribute(new StringAttr(""), "name");
	    if (!resource.getAttribute("userData")) resource.registerAttribute(new StringAttr(""), "userData");
	}
	
	// register resource
	if (this.registry)
	{
	    this.registry.register(resource);
	    resource.setRegistry(this.registry);   
	}
	
	// invoke post-register proc (if specified)
	
	return resource;
}

AttributeFactory.prototype.finalize = function(name, attribute)
{
    // invoke finalize proc
    var finalizeProc = this.finalizeProcs[name];
    if (finalizeProc)
    {
        finalizeProc(attribute, this);
    }
}

AttributeFactory.prototype.initializeNewResourceMap = function()
{
    // attributes
    this.newResourceProcs["Styles"] = newAttribute;
    this.newResourceProcs["StyleMap"] = newAttribute;
    this.newResourceProcs["StylesMap"] = newAttribute;
    this.newResourceProcs["LabelStyle"] = newAttribute;
    this.newResourceProcs["IconStyle"] = newAttribute;
    this.newResourceProcs["FontStyle"] = newAttribute;
    this.newResourceProcs["HTMLLabelStyle"] = newAttribute;
    this.newResourceProcs["BalloonTipLabelStyle"] = newAttribute;
    this.newResourceProcs["RenderableElementStyle"] = newAttribute;
    this.newResourceProcs["Serializer"] = newAttribute;

    // nodes
    this.newResourceProcs["DirectionalLight"] = newSGNode;
    this.newResourceProcs["GlobalIllumination"] = newSGNode;
    this.newResourceProcs["Group"] = newSGNode;
    this.newResourceProcs["Isolator"] = newSGNode;
    this.newResourceProcs["Label"] = newSGNode;
    this.newResourceProcs["HTMLLabel"] = newSGNode;
    this.newResourceProcs["BalloonTipLabel"] = newSGNode;
    this.newResourceProcs["LineList"] = newSGNode;
    this.newResourceProcs["MediaTexture"] = newSGNode;
    this.newResourceProcs["Model"] = newModel;
    this.newResourceProcs["OrthographicCamera"] = newSGNode;
    this.newResourceProcs["PerspectiveCamera"] = newSGNode;
    this.newResourceProcs["PointLight"] = newSGNode;
    this.newResourceProcs["PointList"] = newSGNode;
    this.newResourceProcs["QuaternionRotate"] = newSGNode;
    this.newResourceProcs["Rotate"] = newSGNode;
    this.newResourceProcs["Scale"] = newSGNode;
    this.newResourceProcs["Surface"] = newSGNode;
    this.newResourceProcs["Translate"] = newSGNode;
    this.newResourceProcs["TriList"] = newSGNode;
    this.newResourceProcs["NullObject"] = newSGNode;
    this.newResourceProcs["Material"] = newSGNode;
    this.newResourceProcs["Cube"] = newSGNode;

    // directives
    this.newResourceProcs["BBoxDirective"] = newSGDirective;
    this.newResourceProcs["RayPickDirective"] = newSGDirective;
    this.newResourceProcs["RenderDirective"] = newSGDirective;
    this.newResourceProcs["SerializeDirective"] = newSGDirective;
    this.newResourceProcs["UpdateDirective"] = newSGDirective;
    this.newResourceProcs["CollideDirective"] = newSGDirective;
    this.newResourceProcs["HighlightDirective"] = newSGDirective;
    
    // evaluators
    this.newResourceProcs["BBoxLocator"] = newBBoxLocator;
    this.newResourceProcs["KeyframeInterpolator"] = newKeyframeInterpolator;
    this.newResourceProcs["MapProjectionCalculator"] = newMapProjectionCalculator;
    this.newResourceProcs["ObjectInspector"] = newObjectInspector;
    this.newResourceProcs["SceneInspector"] = newSceneInspector;
    this.newResourceProcs["TargetObserver"] = newTargetObserver;
    this.newResourceProcs["AnimalMover"] = newAnimalMover;

    // commands
    this.newResourceProcs["AppendNode"] = newCommand;
    this.newResourceProcs["AutoInterpolate"] = newCommand;
    this.newResourceProcs["CommandSequence"] = newCommand;
    this.newResourceProcs["ConnectAttributes"] = newCommand;
    this.newResourceProcs["ConnectOutputs"] = newCommand;
    this.newResourceProcs["DisconnectAttributes"] = newCommand;
    this.newResourceProcs["DisconnectOutputs"] = newCommand;
    this.newResourceProcs["Locate"] = newCommand;
    this.newResourceProcs["MotionInterpolate"] = newCommand;
    this.newResourceProcs["Pause"] = newCommand;
    this.newResourceProcs["Play"] = newCommand;
    this.newResourceProcs["Remove"] = newCommand;
    this.newResourceProcs["ScreenCapture"] = newCommand;
    this.newResourceProcs["Serialize"] = newCommand;
    this.newResourceProcs["Set"] = newCommand;
    this.newResourceProcs["Stop"] = newCommand;

    // device handlers
    this.newResourceProcs["MouseHandler"] = newDeviceHandler;
}

AttributeFactory.prototype.initializeConfigureMap = function()
{
    // nodes
    this.configureProcs["Model"] = configureModel;

    // directives
    this.configureProcs["BBoxDirective"] = configureDirective;
    this.configureProcs["RayPickDirective"] = configureDirective;
    this.configureProcs["RenderDirective"] = configureDirective;
    this.configureProcs["SerializeDirective"] = configureDirective;
    this.configureProcs["UpdateDirective"] = configureDirective;
    this.configureProcs["CollideDirective"] = configureDirective;
    this.configureProcs["HighlightDirective"] = configureDirective;
}

AttributeFactory.prototype.initializeFinalizeMap = function()
{
    // nodes
    this.finalizeProcs["Model"] = finalizeModel;

    // directives
    this.finalizeProcs["BBoxDirective"] = finalizeDirective;
    this.finalizeProcs["RayPickDirective"] = finalizeDirective;
    this.finalizeProcs["RenderDirective"] = finalizeDirective;
    this.finalizeProcs["SerializeDirective"] = finalizeDirective;
    this.finalizeProcs["UpdateDirective"] = finalizeDirective;
    this.finalizeProcs["CollideDirective"] = finalizeDirective;
    this.finalizeProcs["HighlightDirective"] = finalizeDirective;

    // evaluators 
    this.finalizeProcs["KeyframeInterpolator"] = finalizeEvaluator;

    // commands
    this.finalizeProcs["AppendNode"] = finalizeCommand;
    this.finalizeProcs["AutoInterpolate"] = finalizeCommand;
    this.finalizeProcs["CommandSequence"] = finalizeCommand;
    this.finalizeProcs["ConnectAttributes"] = finalizeCommand;
    this.finalizeProcs["ConnectOutputs"] = finalizeCommand;
    this.finalizeProcs["DisconnectAttributes"] = finalizeCommand;
    this.finalizeProcs["DisconnectOutputs"] = finalizeCommand;
    this.finalizeProcs["Locate"] = finalizeCommand;
    this.finalizeProcs["MotionInterpolate"] = finalizeCommand;
    this.finalizeProcs["Pause"] = finalizeCommand;
    this.finalizeProcs["Play"] = finalizeCommand;
    this.finalizeProcs["Remove"] = finalizeCommand;
    this.finalizeProcs["ScreenCapture"] = finalizeCommand;
    this.finalizeProcs["Serialize"] = finalizeCommand;
    this.finalizeProcs["Set"] = finalizeCommand;
    this.finalizeProcs["Stop"] = finalizeCommand;

    // device handlers
    this.finalizeProcs["MouseHandler"] = finalizeDeviceHandler;
}

AttributeFactory.prototype.setRegistry = function(registry)
{
    this.registry = registry;
}

AttributeFactory.prototype.setGraphMgr = function(graphMgr)
{
    this.graphMgr = graphMgr;
}

function newAttribute(name, factory)
{
    var resource = null;
    
    switch (name)
    {
    case "BalloonTipLabelStyleAttr":    resource = new BalloonTipLabelStyleAttr(); break;
    case "BBoxAttr":                    resource = new BBoxAttr(); break;
    case "BooleanAttr":                 resource = new BooleanAttr(); break;
    case "ColorAttr":                   resource = new ColorAttr(); break;
    case "FontStyleAttr":               resource = new FontStyleAttr(); break;
    case "IconStyleAttr":               resource = new IconStyleAttr(); break;
    case "ImageAttr":                   resource = new ImageAttr(); break;
    case "KeyframeAttr":                resource = new KeyframeAttr(); break;
    case "KeyframesAttr":               resource = new KeyframesAttr(); break;
    case "LabelStyleAttr":              resource = new LabelStyleAttr(); break;
    case "HTMLLabelStyleAttr":          resource = new HTMLLabelStyleAttr(); break;
    case "NumberArrayAttr":             resource = new NumberArrayAttr(); break;
    case "NumberAttr":                  resource = new NumberAttr(); break;
    case "Matrix4x4Attr":               resource = new Matrix4x4Attr(); break;
    case "PlaneAttr":                   resource = new PlaneAttr(); break;
    case "PulseAttr":                   resource = new PulseAttr(); break;
    case "QuaternionAttr":              resource = new QuaternionAttr(); break;
    case "RectAttr":                    resource = new RectAttr(); break;
    case "ReferenceAttr":               resource = new ReferenceAttr(); break;
    case "StringAttr":                  resource = new StringAttr(); break;
    case "StyleAttr":                   resource = new StyleAttr(); break;
    case "StylesAttr":                  resource = new StylesAttr(); break;
    case "StyleMapAttr":                resource = new StyleMapAttr(); break;
    case "StylesMapAttr":               resource = new StylesMapAttr(); break;
    case "Vector2DAttr":                resource = new Vector2DAttr(); break;
    case "Vector3DAttr":                resource = new Vector3DAttr(); break;
    case "ViewportAttr":                resource = new ViewportAttr(); break;
    case "ViewVolumeAttr":              resource = new ViewVolumeAttr(); break;
    case "RenderableElementStyleAttr":  resource = new RenderableElementStyleAttr(); break;
    case "Serializer":                  resource = new Serializer(); break;
    }
    
    return resource;
}

function newSGNode(name, factory)
{
    var resource = null;
    
    switch (name)
    {
    case "DirectionalLight":    resource = new DirectionalLight(); registerParentableAttributes(resource, factory); break;
    case "GlobalIllumination":  resource = new GlobalIllumination(); break;
    case "Group":               resource = new Group(); break;
    case "Isolator":            resource = new Isolator(); break;
    case "Label":               resource = new Label(); break;
    case "HTMLLabel":           resource = new HTMLLabel(); break;
    case "BalloonTipLabel":     resource = new BalloonTipLabel(); break;
    case "LineList":            resource = new LineList(); break;
    case "MediaTexture":        resource = new MediaTexture(); break;
    case "OrthographicCamera":  resource = new OrthographicCamera(); registerParentableAttributes(resource, factory); break;
    case "PerspectiveCamera":   resource = new PerspectiveCamera(); registerParentableAttributes(resource, factory); break;
    case "PointLight":          resource = new PointLight(); registerParentableAttributes(resource, factory); break;
    case "PointList":           resource = new PointList(); break;
    case "QuaternionRotate":    resource = new QuaternionRotate(); break;
    case "Rotate":              resource = new Rotate(); break;
    case "Scale":               resource = new Scale(); break;
    case "Surface":             resource = new Surface(); break;
    case "Transform":           resource = new Transform(); break;
    case "Translate":           resource = new Translate(); break;
    case "TriList":             resource = new TriList(); break;
    case "NullObject":          resource = new NullObject(); registerParentableAttributes(resource, factory);  break;
    case "Cube":                resource = new Cube(); break;
    case "Material":            resource = new Material(); break;
    }
    
    if (resource)
    {
        resource.setGraphMgr(factory.graphMgr);
    }
    
    return resource;
}

function newSGDirective(name, factory)
{
    var resource = null;
    
    switch (name)
    {
    case "BBoxDirective":               resource = new BBoxDirective(); break;
    case "RayPickDirective":            resource = new RayPickDirective(); break;
    case "RenderDirective":             resource = new RenderDirective(); break;  
    case "SerializeDirective":          resource = new SerializeDirective(); break;
    case "UpdateDirective":             resource = new UpdateDirective(); break;
    case "CollideDirective":            resource = new CollideDirective(); break;
    case "HighlightDirective":          resource = new HighlightDirective(); break;
    }
    
    if (resource)
    {
        resource.setGraphMgr(factory.graphMgr);
    }
    
    return resource;
}

function newModel(name, factory)
{
    var resource = new Model();
    resource.setGraphMgr(factory.graphMgr);
    registerParentableAttributes(resource, factory);
    return resource;
}

function newBBoxLocator(name, factory)
{
    var resource = new BBoxLocator();

    registerEvaluatorAttributes(resource, factory);

    return resource;
}

function newKeyframeInterpolator(name, factory)
{
    var resource = new KeyframeInterpolator();
    
    registerEvaluatorAttributes(resource, factory);
    
    return resource;
}

function newMapProjectionCalculator(name, factory)
{
    var resource = new MapProjectionCalculator();

    registerEvaluatorAttributes(resource, factory);

    return resource;
}

function newObjectInspector(name, factory)
{
    var resource = new ObjectInspector();
    
    registerEvaluatorAttributes(resource, factory);
    
    // target the Inspector's selection flag with the selector's clickPoint
    var selector = factory.registry.find("Selector");
    if (selector)
    {
        selector.getAttribute("selectionOccurred").addTarget(
            resource.getAttribute("selectionOccurred"), eAttrSetOp.Replace, null, false);
            
        selector.getAttribute("selectionCleared").addTarget(
            resource.getAttribute("selectionCleared"), eAttrSetOp.Replace, null, false);
            
        selector.getAttribute("pointView").addTarget(
            resource.getAttribute("pointView"), eAttrSetOp.Replace, null, false);
    }
    
    return resource;
}

function newSceneInspector(name, factory)
{
    var resource = new BwSceneInspector();
    
    registerEvaluatorAttributes(resource, factory);
   
    // target the Inspector's selection flag with the selector's clickPoint
    // target the Inspector's pivotDistance with the selector's distanceFromScreenCenter
    var selector = factory.registry.find("Selector");
    if (selector)
    {
        selector.getAttribute("selectionOccurred").addTarget(
            resource.getAttribute("selectionOccurred"), eAttrSetOp.Replace, null, false);
            
        selector.getAttribute("distanceFromScreenCenter").addTarget(
            resource.getAttribute("pivotDistance"), eAttrSetOp.Replace, null, false);
    }
     
    return resource;
}

function newTargetObserver(name, factory)
{
	var resource = new BwTargetObserver();
    
    registerEvaluatorAttributes(resource, factory);
   
   	return resource;	
}

function newAnimalMover(name, factory)
{
	var resource = new AnimalMover();
	
	resource.setGraphMgr(factory.graphMgr);
	registerEvaluatorAttributes(resource, factory);
	
	return resource;	
}

function newCommand(name, factory)
{
    var resource = null;
    
    switch (name)
    {
    case "AppendNode":     	    resource = new AppendNodeCommand(); break;
    case "AutoInterpolate":     resource = new AutoInterpolateCommand(); break;
    case "CommandSequence":     resource = new CommandSequence(); break;
    case "ConnectAttributes":   resource = new ConnectAttributesCommand(); break;
    case "ConnectOutputs":      resource = new ConnectAttributesCommand(); break;    
    case "DisconnectAttributes":resource = new ConnectAttributesCommand(); resource.getAttribute("negate").setValueDirect(true); break;
    case "DisconnectOutputs":   resource = new ConnectAttributesCommand(); resource.getAttribute("negate").setValueDirect(true); break;
    case "Locate":              resource = new LocateCommand(); break;
    case "MotionInterpolate":   resource = new MotionInterpolateCommand(); break;
    case "Pause":               resource = new PlayCommand(); resource.getAttribute("negate").setValueDirect(true); break;
    case "Play":                resource = new PlayCommand(); break;
    case "Remove":              resource = new RemoveCommand(); break;
    case "ScreenCapture":       resource = new ScreenCaptureCommand(); break;
    case "Serialize":           resource = new SerializeCommand(); break;
    case "Set":                 resource = new SetCommand(); break;
    case "Stop":                resource = new StopCommand(); break;
    }

	// if command sequence, set to command mgr
	if (name == "CommandSequence")
	{
	    var commandMgr = factory.registry.find("CommandMgr");
	    if (commandMgr)
	    {
	        commandMgr.pushCommandSequence(resource);
	    }    
	}
	
	return resource;
}

function newDeviceHandler(name, factory)
{
    var resource = null;
    
    switch (name)
    {
    case "MouseHandler":        resource = new MouseHandler(); break;
    }
	
	return resource;
}

function configureModel(model, factory)
{
    // TODO
    console.debug("TODO: " + arguments.callee.name);
}

function configureDirective(directive, factory)
{
    var root = new StringAttr("");
    root.addModifiedCB(AttributeFactory_DirectiveRootModifiedCB, factory);
    directive.registerAttribute(root, "root");
    
    var rootNode = factory.registry.getAttribute("rootPtr").getValueDirect();
    if (rootNode)
    {
        root.setValueDirect(rootNode.getAttribute("name").getValueDirect().join(""));
    }
}

function finalizeModel(model, factory)
{
    // TODO
    console.debug("TODO: remove LWO assumption");
    
    var url = model.getAttribute("url").getValueDirect();
    if (url) {
        
        url = url.join("");
        
        var pathInfo = formatPath(url);
        console.debug("path: " + pathInfo[0]);
        console.debug("content dir: " + pathInfo[1]);
        
        var contentHandler = new LWObjectHandler();
        contentHandler.getAttribute("contentDirectory").setValueDirect(pathInfo[1]);

        var contentBuilder = new LWObjectBuilder(); 
        contentBuilder.setRegistry(factory.registry);
        contentBuilder.models.push(model);
        contentBuilder.layer = model.getAttribute("layer").getValueDirect();
        contentBuilder.visitHandler(contentHandler);
        
        contentHandler.parseFileStream(pathInfo[0]);  
    }
    
    addInspectionGroup(model, factory);
}

function finalizeDirective(directive, factory)
{
}

function finalizeCommand(command, factory)
{
    command.finalize();
    
    var commandMgr = factory.registry.find("CommandMgr");
    if (commandMgr)
    {
        // if command sequence, clear from command mgr
        if (command.className == "CommandSequence")
        {
            commandMgr.popCommandSequence();
        }
        
        commandMgr.addCommand(command);
    }
}

function finalizeDeviceHandler(handler, factory)
{
    var eventMgr = factory.registry.find("EventMgr");
    if (eventMgr)
    {
        var events = handler.getEventTypes();
        for (var i=0; i < events.length; i++)
        {
            eventMgr.addListener(events[i], handler);
        }
    }
}

function finalizeEvaluator(evaluator, factory)
{
    // TODO
    console.debug("TODO: " + arguments.callee.name);
    
    switch (evaluator.className)
    {
    case "KeyframeInterpolator":
        
        var url = evaluator.getAttribute("url").getValueDirect();
        if (url) {
        
            url = url.join("");
            
            var pathInfo = formatPath(url);
            
            var contentHandler = new LWSceneHandler();
            contentHandler.getAttribute("contentDirectory").setValueDirect(pathInfo[1]);
            
            var contentBuilder = new LWSceneBuilder(); 
            contentBuilder.setRegistry(factory.registry);
            contentBuilder.evaluators.push(evaluator);
            contentBuilder.visitHandler(contentHandler);
            
            contentHandler.parseFileStream(pathInfo[0]); 
        }
        AttributeFactory_EvaluatorTargetConnectionTypeModifiedCB(evaluator.getAttribute("targetConnectionType"), factory);
        break;
    }
}

function registerEvaluatorAttributes(evaluator, factory)
{
    // url
    if (!evaluator.getAttribute("url"))
    {
    	var url = new StringAttr("");
    	evaluator.registerAttribute(url, "url");
	}
	
    // target
    if (!evaluator.getAttribute("target"))
    {
    	var target = new StringAttr("");
    	evaluator.registerAttribute(target, "target");
	}
	
    // renderAndRelease
    if (!evaluator.getAttribute("renderAndRelease"))
    {
    	var renderAndRelease = new BooleanAttr(false);
    	evaluator.registerAttribute(renderAndRelease, "renderAndRelease");
	}
	
    // targetConnectionType
    if (!evaluator.getAttribute("targetConnectionType"))
    {
    	var targetConnectionType = new StringAttr("transform");
    	targetConnectionType.addModifiedCB(AttributeFactory_EvaluatorTargetConnectionTypeModifiedCB, factory);
    	evaluator.registerAttribute(targetConnectionType, "targetConnectionType");
    }
}

function registerParentableAttributes(pme, factory)
{
    // label
    if (!pme.getAttribute("label"))
    {
		var label = new StringAttr("");
		pme.registerAttribute(label, "label");
		label.addModifiedCB(AttributeFactory_ParentableLabelModifiedCB, factory);
	}
	
	// geoPosition
	if (!pme.getAttribute("geoPosition"))
	{
		var geoPosition = new Vector3DAttr();
		pme.registerAttribute(geoPosition, "geoPosition");
		geoPosition.addModifiedCB(AttributeFactory_ParentableGeoPositionModifiedCB, factory);
	}

	// altitude
	if (!pme.getAttribute("altitude"))
	{
		var altitude = new NumberAttr();
		pme.registerAttribute(altitude, "altitude");
	}
	
	// latitude
	if (!pme.getAttribute("latitude"))
	{
		var latitude = new NumberAttr();
		pme.registerAttribute(latitude, "latitude");
	}
	
	// longitude
	if (!pme.getAttribute("longitude"))
	{
		var longitude = new NumberAttr();
		pme.registerAttribute(longitude, "longitude");
	}
	
	// misc modified callbacks
	pme.getAttribute("worldCenter").addModifiedCB(AttributeFactory_ParentableWorldPositionModifiedCB, factory);
}

function getSceneGraph()
{
    return this.sceneGraph;
}

function AttributeFactory_DirectiveRootModifiedCB(root, factory)
{
    var directive = root.getContainer();
    var resources = factory.registry.getByName(root.getValueDirect().join(""));
    if (resources)
    {
        directive.getAttribute("rootNode").setValueDirect(resources[0]);
    }
}

function AttributeFactory_ParentableLabelModifiedCB(attribute, container)
{
    console.debug("TODO: " + arguments.callee.name);
}

function AttributeFactory_ParentableGeoPositionModifiedCB(attribute, container)
{
    var pme = attribute.getContainer();
    if (pme)
    {
        var cms = container.registry.getByName("ConnectionMgr");
        if (cms && cms.length)
        {
            var cm = cms[0];
            
            var mpcs = container.registry.getByType(eAttrType.MapProjectionCalculator);
            if (mpcs && mpcs.length)
            {
                var mpc = mpcs[0];

                mpc.getAttribute("geoPosition").copyValue(attribute);

                cm.connectMapProjectionCalculator(mpc, pme);
                cm.disconnectMapProjectionCalculator(mpc, pme);
            }
        }
    }
}

function AttributeFactory_ParentableWorldPositionModifiedCB(attribute, container)
{
    // TODO
    //console.debug("TODO: " + arguments.callee.name);
}

function AttributeFactory_EvaluatorTargetConnectionTypeModifiedCB(attribute, container)
{  
    var evaluator = attribute.getContainer();
    if (evaluator)
    {
        var connect = new ConnectAttributesCommand();
        connect.setRegistry(container.registry);
        connect.getAttribute("sourceContainer").copyValue(evaluator.getAttribute("name"));
        connect.getAttribute("targetContainer").copyValue(evaluator.getAttribute("target"));
        connect.getAttribute("connectionType").copyValue(attribute);
        connect.execute();
    }
}
Bridgeworks.prototype = new AttributeContainer();
Bridgeworks.prototype.constructor = Bridgeworks;

function Bridgeworks(canvas, bgImage, contentDir)
{
    AttributeContainer.call(this);
    this.className = "Bridgeworks";
    
    this.renderContext =  newRenderContext("webgl", canvas, bgImage);
    if (!this.renderContext) return;

    contentDir = contentDir == null? "BwContent" : contentDir;

    this.canvas = canvas;
    this.contentDir = contentDir;
    
    // allocate objects
    //this.renderContext = null;
    this.graphMgr = new GraphMgr();
    this.graphMgr.setRenderContext(this.renderContext)
    
    this.styleMgr = new StyleMgr();
    this.registry = new BwRegistry();
    this.factory = new AttributeFactory();
    this.parser = new XMLParser(this.factory, this.registry, this.contentDir);
    this.eventAdapter = new EventAdapter();
    this.eventMgr = new EventMgr();
    this.commandMgr = new CommandMgr();
    this.connectionMgr = new ConnectionMgr();
    this.viewportMgr = new ViewportMgr();
    this.selector = new SelectionListener();
    this.rayPick = new RayPickDirective();
    this.renderAgent = new RenderAgent(this);
    this.renderController = new RenderController(this);
    this.layout = new GridLayout();
    this.mapProjectionCalculator = new MapProjectionCalculator();
    this.rasterComponentEventListener = new RasterComponentEventListener();
     
    // set registry to allocated objects
    this.graphMgr.setRegistry(this.registry);
    this.factory.setRegistry(this.registry);
    this.eventAdapter.setRegistry(this.registry);
    this.eventMgr.setRegistry(this.registry);
    this.commandMgr.setRegistry(this.registry);
    this.connectionMgr.setRegistry(this.registry);
    this.viewportMgr.setRegistry(this.registry);
    this.selector.setRegistry(this.registry);
    this.renderAgent.setRegistry(this.registry);
    this.layout.setRegistry(this.registry);
    this.mapProjectionCalculator.setRegistry(this.registry);
    this.rasterComponentEventListener.setRegistry(this.registry);
    
    // configure dependencies
    this.factory.setGraphMgr(this.graphMgr);
    this.selector.setRayPick(this.rayPick);
    this.rasterComponentEventListener.setStyleMgr(this.styleMgr);
    this.rasterComponents = null;
    
    this.name = new StringAttr("Bridgeworks");
    this.onLoad = new StringAttr();
    
    this.onLoad.addModifiedCB(Bridgeworks_OnLoadModifiedCB, this);
    
    this.registerAttribute(this.name, "name");
    this.registerAttribute(this.onLoad, "onLoad");
    
    this.viewportMgr.getAttribute("width").setValueDirect(this.canvas.width);
    this.viewportMgr.getAttribute("height").setValueDirect(this.canvas.height);    
    this.viewportMgr.getAttribute("layout").setValueDirect(this.layout);
    
    enumerateAttributeTypes();
    enumerateAttributeElementTypes();
    
    // TODO: remove the following when onLoadModified is defined
    console.debug("TODO: " + arguments.callee.name);
    this.initRegistry();
    this.initEventListeners();
    this.viewportMgr.initLayout();
}

Bridgeworks.prototype.handleEvent = function(event)
{
    var bwEvent = null;

    switch (getObjectClassName(event))
    {
        case "MouseEvent":
            {
                var absPos = getElementAbsolutePos(this.canvas);            
                event.canvasX = event.clientX - absPos.x;
                event.canvasY = event.clientY - absPos.y;
                bwEvent = this.eventAdapter.createMouseEvent(event);
            }
            break;
        case "KeyboardEvent":
            {
                bwEvent = this.eventAdapter.createKeyboardEvent(event);
            }
            break;
    }

    if (bwEvent)
    {
        this.eventMgr.processEvent(bwEvent);
    }
}

Bridgeworks.prototype.initRegistry = function()
{
    // register allocated objects
    this.registry.register(this);
    this.registry.register(this.graphMgr);
    this.registry.register(this.factory);
    this.registry.register(this.eventAdapter);
    this.registry.register(this.eventMgr);
    this.registry.register(this.commandMgr);
    this.registry.register(this.connectionMgr);
    this.registry.register(this.viewportMgr);
    this.registry.register(this.selector);
    this.registry.register(this.renderAgent);
    this.registry.register(this.layout);
    this.registry.register(this.mapProjectionCalculator);

    // backward compatibility
    this.registry.registerByName(this.renderAgent, "AnimationAgent");
}

Bridgeworks.prototype.initEventListeners = function()
{
    // selector
    this.eventMgr.addListener(eEventType.MouseLeftDown, this.selector);
    this.eventMgr.addListener(eEventType.MouseMiddleDown, this.selector);
    this.eventMgr.addListener(eEventType.MouseRightDown, this.selector);
    this.eventMgr.addListener(eEventType.MouseBothDown, this.selector);
    this.eventMgr.addListener(eEventType.MouseHover, this.selector);
    //this.eventMgr.addListener(eMOUSE_MOVE, this.selector);

    // raster component event listener
    this.eventMgr.addListener(eEventType.MouseLeftDown, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseLeftUp, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseLeftClick, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseLeftDblClick, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseMiddleDown, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseMiddleUp, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseMiddleClick, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseMiddleDblClick, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseRightDown, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseRightUp, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseRightClick, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseRightDblClick, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseWheelDown, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseWheelUp, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseBothDown, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseHover, this.rasterComponentEventListener);
    this.eventMgr.addListener(eEventType.MouseMove, this.rasterComponentEventListener);    
}

Bridgeworks.prototype.onLoadModified = function()
{
    this.renderAgent.stop();
    //this.iscetAgent.stop(); There is no isectAgent in javascript version
    this.selector.stop();
    this.rasterComponentEventListener.stop();

    this.commandMgr.clearCommandSequenceStack();
    this.eventMgr.clearEvents();
    $('#RasterComponents').empty();
    //this.resouceMgr.clear(); There is no resourceMgr in javascript version
    this.selector.clearSelections();
    this.selector.getAttribute("lastSelectedName").setValueDirect("");
    this.viewportMgr.initLayout();
/*    std::map<std::string, std::pair<CAttribute*, CAttribute*> >::const_iterator it;
 for (it = m_messageSinks.begin(); it != m_messageSinks.end(); it++)
 {
 it->second.first->AddRef();
 it->second.second->AddRef();
 }*/

    this.registry.clear();
    this.initEventListeners();
    this.initRegistry();

    /*	for (it = m_messageSinks.begin(); it != m_messageSinks.end(); it++)
     {
     std::string data_name(it->first.c_str());
     data_name += "_data";

     dynamic_cast<AttributeRegistry*>(registry)->Register(it->second.first, it->first.c_str());
     it->second.first->Release();
     dynamic_cast<AttributeRegistry*>(registry)->Register(it->second.second, data_name.c_str());
     it->second.second->Release();
     }*/

    this.renderAgent.getAttribute("globalTimeInSecs").setValueDirect(0);

    this.graphMgr.reset();

    this.renderAgent.start();
    //this.iscetAgent.start(); There is no isectAgent in javascript version
    this.selector.start();
    this.rasterComponentEventListener.start();


    // TODO
    console.debug("TODO: " + arguments.callee.name);
}

Bridgeworks.prototype.resize = function(width, height)
{
    this.canvas.width = width;
    this.canvas.height = height;
    this.renderContext.setViewport(this.canvas.offsetLeft, this.canvas.offsetTop, width, height);

    this.viewportMgr.getAttribute("width").setValueDirect(width);
    this.viewportMgr.getAttribute("height").setValueDirect(height);
}

Bridgeworks.prototype.render = function()
{
    this.eventMgr.processEvent(new Event(eEventType.RenderBegin));
    
    this.renderContext.clear();
    this.renderAgent.render();
    
    this.eventMgr.processEvent(new Event(eEventType.RenderEnd));
}

Bridgeworks.prototype.setRenderContext = function(rc)
{
    this.renderContext = rc;
    this.graphMgr.setRenderContext(rc);
}

Bridgeworks.prototype.updateScene = function(xml)
{
    var xmlString = new String(xml);
    var extension = xmlString.substr(xmlString.length - 3, 3);
    if (extension == "xml")
    {
        xml = loadXMLResource(this.contentDir + "/" + xml);
    }

    this.parser.parse(xml);
}

function Bridgeworks_OnLoadModifiedCB(attribute, container)
{
    container.onLoadModified();
}
/*
 * jQuery JavaScript Library v1.3.2
 * http://jquery.com/
 *
 * Copyright (c) 2009 John Resig
 * Dual licensed under the MIT and GPL licenses.
 * http://docs.jquery.com/License
 *
 * Date: 2009-02-19 17:34:21 -0500 (Thu, 19 Feb 2009)
 * Revision: 6246
 */
(function(){var l=this,g,y=l.jQuery,p=l.$,o=l.jQuery=l.$=function(E,F){return new o.fn.init(E,F)},D=/^[^<]*(<(.|\s)+>)[^>]*$|^#([\w-]+)$/,f=/^.[^:#\[\.,]*$/;o.fn=o.prototype={init:function(E,H){E=E||document;if(E.nodeType){this[0]=E;this.length=1;this.context=E;return this}if(typeof E==="string"){var G=D.exec(E);if(G&&(G[1]||!H)){if(G[1]){E=o.clean([G[1]],H)}else{var I=document.getElementById(G[3]);if(I&&I.id!=G[3]){return o().find(E)}var F=o(I||[]);F.context=document;F.selector=E;return F}}else{return o(H).find(E)}}else{if(o.isFunction(E)){return o(document).ready(E)}}if(E.selector&&E.context){this.selector=E.selector;this.context=E.context}return this.setArray(o.isArray(E)?E:o.makeArray(E))},selector:"",jquery:"1.3.2",size:function(){return this.length},get:function(E){return E===g?Array.prototype.slice.call(this):this[E]},pushStack:function(F,H,E){var G=o(F);G.prevObject=this;G.context=this.context;if(H==="find"){G.selector=this.selector+(this.selector?" ":"")+E}else{if(H){G.selector=this.selector+"."+H+"("+E+")"}}return G},setArray:function(E){this.length=0;Array.prototype.push.apply(this,E);return this},each:function(F,E){return o.each(this,F,E)},index:function(E){return o.inArray(E&&E.jquery?E[0]:E,this)},attr:function(F,H,G){var E=F;if(typeof F==="string"){if(H===g){return this[0]&&o[G||"attr"](this[0],F)}else{E={};E[F]=H}}return this.each(function(I){for(F in E){o.attr(G?this.style:this,F,o.prop(this,E[F],G,I,F))}})},css:function(E,F){if((E=="width"||E=="height")&&parseFloat(F)<0){F=g}return this.attr(E,F,"curCSS")},text:function(F){if(typeof F!=="object"&&F!=null){return this.empty().append((this[0]&&this[0].ownerDocument||document).createTextNode(F))}var E="";o.each(F||this,function(){o.each(this.childNodes,function(){if(this.nodeType!=8){E+=this.nodeType!=1?this.nodeValue:o.fn.text([this])}})});return E},wrapAll:function(E){if(this[0]){var F=o(E,this[0].ownerDocument).clone();if(this[0].parentNode){F.insertBefore(this[0])}F.map(function(){var G=this;while(G.firstChild){G=G.firstChild}return G}).append(this)}return this},wrapInner:function(E){return this.each(function(){o(this).contents().wrapAll(E)})},wrap:function(E){return this.each(function(){o(this).wrapAll(E)})},append:function(){return this.domManip(arguments,true,function(E){if(this.nodeType==1){this.appendChild(E)}})},prepend:function(){return this.domManip(arguments,true,function(E){if(this.nodeType==1){this.insertBefore(E,this.firstChild)}})},before:function(){return this.domManip(arguments,false,function(E){this.parentNode.insertBefore(E,this)})},after:function(){return this.domManip(arguments,false,function(E){this.parentNode.insertBefore(E,this.nextSibling)})},end:function(){return this.prevObject||o([])},push:[].push,sort:[].sort,splice:[].splice,find:function(E){if(this.length===1){var F=this.pushStack([],"find",E);F.length=0;o.find(E,this[0],F);return F}else{return this.pushStack(o.unique(o.map(this,function(G){return o.find(E,G)})),"find",E)}},clone:function(G){var E=this.map(function(){if(!o.support.noCloneEvent&&!o.isXMLDoc(this)){var I=this.outerHTML;if(!I){var J=this.ownerDocument.createElement("div");J.appendChild(this.cloneNode(true));I=J.innerHTML}return o.clean([I.replace(/ jQuery\d+="(?:\d+|null)"/g,"").replace(/^\s*/,"")])[0]}else{return this.cloneNode(true)}});if(G===true){var H=this.find("*").andSelf(),F=0;E.find("*").andSelf().each(function(){if(this.nodeName!==H[F].nodeName){return}var I=o.data(H[F],"events");for(var K in I){for(var J in I[K]){o.event.add(this,K,I[K][J],I[K][J].data)}}F++})}return E},filter:function(E){return this.pushStack(o.isFunction(E)&&o.grep(this,function(G,F){return E.call(G,F)})||o.multiFilter(E,o.grep(this,function(F){return F.nodeType===1})),"filter",E)},closest:function(E){var G=o.expr.match.POS.test(E)?o(E):null,F=0;return this.map(function(){var H=this;while(H&&H.ownerDocument){if(G?G.index(H)>-1:o(H).is(E)){o.data(H,"closest",F);return H}H=H.parentNode;F++}})},not:function(E){if(typeof E==="string"){if(f.test(E)){return this.pushStack(o.multiFilter(E,this,true),"not",E)}else{E=o.multiFilter(E,this)}}var F=E.length&&E[E.length-1]!==g&&!E.nodeType;return this.filter(function(){return F?o.inArray(this,E)<0:this!=E})},add:function(E){return this.pushStack(o.unique(o.merge(this.get(),typeof E==="string"?o(E):o.makeArray(E))))},is:function(E){return !!E&&o.multiFilter(E,this).length>0},hasClass:function(E){return !!E&&this.is("."+E)},val:function(K){if(K===g){var E=this[0];if(E){if(o.nodeName(E,"option")){return(E.attributes.value||{}).specified?E.value:E.text}if(o.nodeName(E,"select")){var I=E.selectedIndex,L=[],M=E.options,H=E.type=="select-one";if(I<0){return null}for(var F=H?I:0,J=H?I+1:M.length;F<J;F++){var G=M[F];if(G.selected){K=o(G).val();if(H){return K}L.push(K)}}return L}return(E.value||"").replace(/\r/g,"")}return g}if(typeof K==="number"){K+=""}return this.each(function(){if(this.nodeType!=1){return}if(o.isArray(K)&&/radio|checkbox/.test(this.type)){this.checked=(o.inArray(this.value,K)>=0||o.inArray(this.name,K)>=0)}else{if(o.nodeName(this,"select")){var N=o.makeArray(K);o("option",this).each(function(){this.selected=(o.inArray(this.value,N)>=0||o.inArray(this.text,N)>=0)});if(!N.length){this.selectedIndex=-1}}else{this.value=K}}})},html:function(E){return E===g?(this[0]?this[0].innerHTML.replace(/ jQuery\d+="(?:\d+|null)"/g,""):null):this.empty().append(E)},replaceWith:function(E){return this.after(E).remove()},eq:function(E){return this.slice(E,+E+1)},slice:function(){return this.pushStack(Array.prototype.slice.apply(this,arguments),"slice",Array.prototype.slice.call(arguments).join(","))},map:function(E){return this.pushStack(o.map(this,function(G,F){return E.call(G,F,G)}))},andSelf:function(){return this.add(this.prevObject)},domManip:function(J,M,L){if(this[0]){var I=(this[0].ownerDocument||this[0]).createDocumentFragment(),F=o.clean(J,(this[0].ownerDocument||this[0]),I),H=I.firstChild;if(H){for(var G=0,E=this.length;G<E;G++){L.call(K(this[G],H),this.length>1||G>0?I.cloneNode(true):I)}}if(F){o.each(F,z)}}return this;function K(N,O){return M&&o.nodeName(N,"table")&&o.nodeName(O,"tr")?(N.getElementsByTagName("tbody")[0]||N.appendChild(N.ownerDocument.createElement("tbody"))):N}}};o.fn.init.prototype=o.fn;function z(E,F){if(F.src){o.ajax({url:F.src,async:false,dataType:"script"})}else{o.globalEval(F.text||F.textContent||F.innerHTML||"")}if(F.parentNode){F.parentNode.removeChild(F)}}function e(){return +new Date}o.extend=o.fn.extend=function(){var J=arguments[0]||{},H=1,I=arguments.length,E=false,G;if(typeof J==="boolean"){E=J;J=arguments[1]||{};H=2}if(typeof J!=="object"&&!o.isFunction(J)){J={}}if(I==H){J=this;--H}for(;H<I;H++){if((G=arguments[H])!=null){for(var F in G){var K=J[F],L=G[F];if(J===L){continue}if(E&&L&&typeof L==="object"&&!L.nodeType){J[F]=o.extend(E,K||(L.length!=null?[]:{}),L)}else{if(L!==g){J[F]=L}}}}}return J};var b=/z-?index|font-?weight|opacity|zoom|line-?height/i,q=document.defaultView||{},s=Object.prototype.toString;o.extend({noConflict:function(E){l.$=p;if(E){l.jQuery=y}return o},isFunction:function(E){return s.call(E)==="[object Function]"},isArray:function(E){return s.call(E)==="[object Array]"},isXMLDoc:function(E){return E.nodeType===9&&E.documentElement.nodeName!=="HTML"||!!E.ownerDocument&&o.isXMLDoc(E.ownerDocument)},globalEval:function(G){if(G&&/\S/.test(G)){var F=document.getElementsByTagName("head")[0]||document.documentElement,E=document.createElement("script");E.type="text/javascript";if(o.support.scriptEval){E.appendChild(document.createTextNode(G))}else{E.text=G}F.insertBefore(E,F.firstChild);F.removeChild(E)}},nodeName:function(F,E){return F.nodeName&&F.nodeName.toUpperCase()==E.toUpperCase()},each:function(G,K,F){var E,H=0,I=G.length;if(F){if(I===g){for(E in G){if(K.apply(G[E],F)===false){break}}}else{for(;H<I;){if(K.apply(G[H++],F)===false){break}}}}else{if(I===g){for(E in G){if(K.call(G[E],E,G[E])===false){break}}}else{for(var J=G[0];H<I&&K.call(J,H,J)!==false;J=G[++H]){}}}return G},prop:function(H,I,G,F,E){if(o.isFunction(I)){I=I.call(H,F)}return typeof I==="number"&&G=="curCSS"&&!b.test(E)?I+"px":I},className:{add:function(E,F){o.each((F||"").split(/\s+/),function(G,H){if(E.nodeType==1&&!o.className.has(E.className,H)){E.className+=(E.className?" ":"")+H}})},remove:function(E,F){if(E.nodeType==1){E.className=F!==g?o.grep(E.className.split(/\s+/),function(G){return !o.className.has(F,G)}).join(" "):""}},has:function(F,E){return F&&o.inArray(E,(F.className||F).toString().split(/\s+/))>-1}},swap:function(H,G,I){var E={};for(var F in G){E[F]=H.style[F];H.style[F]=G[F]}I.call(H);for(var F in G){H.style[F]=E[F]}},css:function(H,F,J,E){if(F=="width"||F=="height"){var L,G={position:"absolute",visibility:"hidden",display:"block"},K=F=="width"?["Left","Right"]:["Top","Bottom"];function I(){L=F=="width"?H.offsetWidth:H.offsetHeight;if(E==="border"){return}o.each(K,function(){if(!E){L-=parseFloat(o.curCSS(H,"padding"+this,true))||0}if(E==="margin"){L+=parseFloat(o.curCSS(H,"margin"+this,true))||0}else{L-=parseFloat(o.curCSS(H,"border"+this+"Width",true))||0}})}if(H.offsetWidth!==0){I()}else{o.swap(H,G,I)}return Math.max(0,Math.round(L))}return o.curCSS(H,F,J)},curCSS:function(I,F,G){var L,E=I.style;if(F=="opacity"&&!o.support.opacity){L=o.attr(E,"opacity");return L==""?"1":L}if(F.match(/float/i)){F=w}if(!G&&E&&E[F]){L=E[F]}else{if(q.getComputedStyle){if(F.match(/float/i)){F="float"}F=F.replace(/([A-Z])/g,"-$1").toLowerCase();var M=q.getComputedStyle(I,null);if(M){L=M.getPropertyValue(F)}if(F=="opacity"&&L==""){L="1"}}else{if(I.currentStyle){var J=F.replace(/\-(\w)/g,function(N,O){return O.toUpperCase()});L=I.currentStyle[F]||I.currentStyle[J];if(!/^\d+(px)?$/i.test(L)&&/^\d/.test(L)){var H=E.left,K=I.runtimeStyle.left;I.runtimeStyle.left=I.currentStyle.left;E.left=L||0;L=E.pixelLeft+"px";E.left=H;I.runtimeStyle.left=K}}}}return L},clean:function(F,K,I){K=K||document;if(typeof K.createElement==="undefined"){K=K.ownerDocument||K[0]&&K[0].ownerDocument||document}if(!I&&F.length===1&&typeof F[0]==="string"){var H=/^<(\w+)\s*\/?>$/.exec(F[0]);if(H){return[K.createElement(H[1])]}}var G=[],E=[],L=K.createElement("div");o.each(F,function(P,S){if(typeof S==="number"){S+=""}if(!S){return}if(typeof S==="string"){S=S.replace(/(<(\w+)[^>]*?)\/>/g,function(U,V,T){return T.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i)?U:V+"></"+T+">"});var O=S.replace(/^\s+/,"").substring(0,10).toLowerCase();var Q=!O.indexOf("<opt")&&[1,"<select multiple='multiple'>","</select>"]||!O.indexOf("<leg")&&[1,"<fieldset>","</fieldset>"]||O.match(/^<(thead|tbody|tfoot|colg|cap)/)&&[1,"<table>","</table>"]||!O.indexOf("<tr")&&[2,"<table><tbody>","</tbody></table>"]||(!O.indexOf("<td")||!O.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||!O.indexOf("<col")&&[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"]||!o.support.htmlSerialize&&[1,"div<div>","</div>"]||[0,"",""];L.innerHTML=Q[1]+S+Q[2];while(Q[0]--){L=L.lastChild}if(!o.support.tbody){var R=/<tbody/i.test(S),N=!O.indexOf("<table")&&!R?L.firstChild&&L.firstChild.childNodes:Q[1]=="<table>"&&!R?L.childNodes:[];for(var M=N.length-1;M>=0;--M){if(o.nodeName(N[M],"tbody")&&!N[M].childNodes.length){N[M].parentNode.removeChild(N[M])}}}if(!o.support.leadingWhitespace&&/^\s/.test(S)){L.insertBefore(K.createTextNode(S.match(/^\s*/)[0]),L.firstChild)}S=o.makeArray(L.childNodes)}if(S.nodeType){G.push(S)}else{G=o.merge(G,S)}});if(I){for(var J=0;G[J];J++){if(o.nodeName(G[J],"script")&&(!G[J].type||G[J].type.toLowerCase()==="text/javascript")){E.push(G[J].parentNode?G[J].parentNode.removeChild(G[J]):G[J])}else{if(G[J].nodeType===1){G.splice.apply(G,[J+1,0].concat(o.makeArray(G[J].getElementsByTagName("script"))))}I.appendChild(G[J])}}return E}return G},attr:function(J,G,K){if(!J||J.nodeType==3||J.nodeType==8){return g}var H=!o.isXMLDoc(J),L=K!==g;G=H&&o.props[G]||G;if(J.tagName){var F=/href|src|style/.test(G);if(G=="selected"&&J.parentNode){J.parentNode.selectedIndex}if(G in J&&H&&!F){if(L){if(G=="type"&&o.nodeName(J,"input")&&J.parentNode){throw"type property can't be changed"}J[G]=K}if(o.nodeName(J,"form")&&J.getAttributeNode(G)){return J.getAttributeNode(G).nodeValue}if(G=="tabIndex"){var I=J.getAttributeNode("tabIndex");return I&&I.specified?I.value:J.nodeName.match(/(button|input|object|select|textarea)/i)?0:J.nodeName.match(/^(a|area)$/i)&&J.href?0:g}return J[G]}if(!o.support.style&&H&&G=="style"){return o.attr(J.style,"cssText",K)}if(L){J.setAttribute(G,""+K)}var E=!o.support.hrefNormalized&&H&&F?J.getAttribute(G,2):J.getAttribute(G);return E===null?g:E}if(!o.support.opacity&&G=="opacity"){if(L){J.zoom=1;J.filter=(J.filter||"").replace(/alpha\([^)]*\)/,"")+(parseInt(K)+""=="NaN"?"":"alpha(opacity="+K*100+")")}return J.filter&&J.filter.indexOf("opacity=")>=0?(parseFloat(J.filter.match(/opacity=([^)]*)/)[1])/100)+"":""}G=G.replace(/-([a-z])/ig,function(M,N){return N.toUpperCase()});if(L){J[G]=K}return J[G]},trim:function(E){return(E||"").replace(/^\s+|\s+$/g,"")},makeArray:function(G){var E=[];if(G!=null){var F=G.length;if(F==null||typeof G==="string"||o.isFunction(G)||G.setInterval){E[0]=G}else{while(F){E[--F]=G[F]}}}return E},inArray:function(G,H){for(var E=0,F=H.length;E<F;E++){if(H[E]===G){return E}}return -1},merge:function(H,E){var F=0,G,I=H.length;if(!o.support.getAll){while((G=E[F++])!=null){if(G.nodeType!=8){H[I++]=G}}}else{while((G=E[F++])!=null){H[I++]=G}}return H},unique:function(K){var F=[],E={};try{for(var G=0,H=K.length;G<H;G++){var J=o.data(K[G]);if(!E[J]){E[J]=true;F.push(K[G])}}}catch(I){F=K}return F},grep:function(F,J,E){var G=[];for(var H=0,I=F.length;H<I;H++){if(!E!=!J(F[H],H)){G.push(F[H])}}return G},map:function(E,J){var F=[];for(var G=0,H=E.length;G<H;G++){var I=J(E[G],G);if(I!=null){F[F.length]=I}}return F.concat.apply([],F)}});var C=navigator.userAgent.toLowerCase();o.browser={version:(C.match(/.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/)||[0,"0"])[1],safari:/webkit/.test(C),opera:/opera/.test(C),msie:/msie/.test(C)&&!/opera/.test(C),mozilla:/mozilla/.test(C)&&!/(compatible|webkit)/.test(C)};o.each({parent:function(E){return E.parentNode},parents:function(E){return o.dir(E,"parentNode")},next:function(E){return o.nth(E,2,"nextSibling")},prev:function(E){return o.nth(E,2,"previousSibling")},nextAll:function(E){return o.dir(E,"nextSibling")},prevAll:function(E){return o.dir(E,"previousSibling")},siblings:function(E){return o.sibling(E.parentNode.firstChild,E)},children:function(E){return o.sibling(E.firstChild)},contents:function(E){return o.nodeName(E,"iframe")?E.contentDocument||E.contentWindow.document:o.makeArray(E.childNodes)}},function(E,F){o.fn[E]=function(G){var H=o.map(this,F);if(G&&typeof G=="string"){H=o.multiFilter(G,H)}return this.pushStack(o.unique(H),E,G)}});o.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(E,F){o.fn[E]=function(G){var J=[],L=o(G);for(var K=0,H=L.length;K<H;K++){var I=(K>0?this.clone(true):this).get();o.fn[F].apply(o(L[K]),I);J=J.concat(I)}return this.pushStack(J,E,G)}});o.each({removeAttr:function(E){o.attr(this,E,"");if(this.nodeType==1){this.removeAttribute(E)}},addClass:function(E){o.className.add(this,E)},removeClass:function(E){o.className.remove(this,E)},toggleClass:function(F,E){if(typeof E!=="boolean"){E=!o.className.has(this,F)}o.className[E?"add":"remove"](this,F)},remove:function(E){if(!E||o.filter(E,[this]).length){o("*",this).add([this]).each(function(){o.event.remove(this);o.removeData(this)});if(this.parentNode){this.parentNode.removeChild(this)}}},empty:function(){o(this).children().remove();while(this.firstChild){this.removeChild(this.firstChild)}}},function(E,F){o.fn[E]=function(){return this.each(F,arguments)}});function j(E,F){return E[0]&&parseInt(o.curCSS(E[0],F,true),10)||0}var h="jQuery"+e(),v=0,A={};o.extend({cache:{},data:function(F,E,G){F=F==l?A:F;var H=F[h];if(!H){H=F[h]=++v}if(E&&!o.cache[H]){o.cache[H]={}}if(G!==g){o.cache[H][E]=G}return E?o.cache[H][E]:H},removeData:function(F,E){F=F==l?A:F;var H=F[h];if(E){if(o.cache[H]){delete o.cache[H][E];E="";for(E in o.cache[H]){break}if(!E){o.removeData(F)}}}else{try{delete F[h]}catch(G){if(F.removeAttribute){F.removeAttribute(h)}}delete o.cache[H]}},queue:function(F,E,H){if(F){E=(E||"fx")+"queue";var G=o.data(F,E);if(!G||o.isArray(H)){G=o.data(F,E,o.makeArray(H))}else{if(H){G.push(H)}}}return G},dequeue:function(H,G){var E=o.queue(H,G),F=E.shift();if(!G||G==="fx"){F=E[0]}if(F!==g){F.call(H)}}});o.fn.extend({data:function(E,G){var H=E.split(".");H[1]=H[1]?"."+H[1]:"";if(G===g){var F=this.triggerHandler("getData"+H[1]+"!",[H[0]]);if(F===g&&this.length){F=o.data(this[0],E)}return F===g&&H[1]?this.data(H[0]):F}else{return this.trigger("setData"+H[1]+"!",[H[0],G]).each(function(){o.data(this,E,G)})}},removeData:function(E){return this.each(function(){o.removeData(this,E)})},queue:function(E,F){if(typeof E!=="string"){F=E;E="fx"}if(F===g){return o.queue(this[0],E)}return this.each(function(){var G=o.queue(this,E,F);if(E=="fx"&&G.length==1){G[0].call(this)}})},dequeue:function(E){return this.each(function(){o.dequeue(this,E)})}});
/*
 * Sizzle CSS Selector Engine - v0.9.3
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){var R=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?/g,L=0,H=Object.prototype.toString;var F=function(Y,U,ab,ac){ab=ab||[];U=U||document;if(U.nodeType!==1&&U.nodeType!==9){return[]}if(!Y||typeof Y!=="string"){return ab}var Z=[],W,af,ai,T,ad,V,X=true;R.lastIndex=0;while((W=R.exec(Y))!==null){Z.push(W[1]);if(W[2]){V=RegExp.rightContext;break}}if(Z.length>1&&M.exec(Y)){if(Z.length===2&&I.relative[Z[0]]){af=J(Z[0]+Z[1],U)}else{af=I.relative[Z[0]]?[U]:F(Z.shift(),U);while(Z.length){Y=Z.shift();if(I.relative[Y]){Y+=Z.shift()}af=J(Y,af)}}}else{var ae=ac?{expr:Z.pop(),set:E(ac)}:F.find(Z.pop(),Z.length===1&&U.parentNode?U.parentNode:U,Q(U));af=F.filter(ae.expr,ae.set);if(Z.length>0){ai=E(af)}else{X=false}while(Z.length){var ah=Z.pop(),ag=ah;if(!I.relative[ah]){ah=""}else{ag=Z.pop()}if(ag==null){ag=U}I.relative[ah](ai,ag,Q(U))}}if(!ai){ai=af}if(!ai){throw"Syntax error, unrecognized expression: "+(ah||Y)}if(H.call(ai)==="[object Array]"){if(!X){ab.push.apply(ab,ai)}else{if(U.nodeType===1){for(var aa=0;ai[aa]!=null;aa++){if(ai[aa]&&(ai[aa]===true||ai[aa].nodeType===1&&K(U,ai[aa]))){ab.push(af[aa])}}}else{for(var aa=0;ai[aa]!=null;aa++){if(ai[aa]&&ai[aa].nodeType===1){ab.push(af[aa])}}}}}else{E(ai,ab)}if(V){F(V,U,ab,ac);if(G){hasDuplicate=false;ab.sort(G);if(hasDuplicate){for(var aa=1;aa<ab.length;aa++){if(ab[aa]===ab[aa-1]){ab.splice(aa--,1)}}}}}return ab};F.matches=function(T,U){return F(T,null,null,U)};F.find=function(aa,T,ab){var Z,X;if(!aa){return[]}for(var W=0,V=I.order.length;W<V;W++){var Y=I.order[W],X;if((X=I.match[Y].exec(aa))){var U=RegExp.leftContext;if(U.substr(U.length-1)!=="\\"){X[1]=(X[1]||"").replace(/\\/g,"");Z=I.find[Y](X,T,ab);if(Z!=null){aa=aa.replace(I.match[Y],"");break}}}}if(!Z){Z=T.getElementsByTagName("*")}return{set:Z,expr:aa}};F.filter=function(ad,ac,ag,W){var V=ad,ai=[],aa=ac,Y,T,Z=ac&&ac[0]&&Q(ac[0]);while(ad&&ac.length){for(var ab in I.filter){if((Y=I.match[ab].exec(ad))!=null){var U=I.filter[ab],ah,af;T=false;if(aa==ai){ai=[]}if(I.preFilter[ab]){Y=I.preFilter[ab](Y,aa,ag,ai,W,Z);if(!Y){T=ah=true}else{if(Y===true){continue}}}if(Y){for(var X=0;(af=aa[X])!=null;X++){if(af){ah=U(af,Y,X,aa);var ae=W^!!ah;if(ag&&ah!=null){if(ae){T=true}else{aa[X]=false}}else{if(ae){ai.push(af);T=true}}}}}if(ah!==g){if(!ag){aa=ai}ad=ad.replace(I.match[ab],"");if(!T){return[]}break}}}if(ad==V){if(T==null){throw"Syntax error, unrecognized expression: "+ad}else{break}}V=ad}return aa};var I=F.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF_-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF_-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF_-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF_-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*_-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF_-]|\\.)+)(?:\((['"]*)((?:\([^\)]+\)|[^\2\(\)]*)+)\2\))?/},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(T){return T.getAttribute("href")}},relative:{"+":function(aa,T,Z){var X=typeof T==="string",ab=X&&!/\W/.test(T),Y=X&&!ab;if(ab&&!Z){T=T.toUpperCase()}for(var W=0,V=aa.length,U;W<V;W++){if((U=aa[W])){while((U=U.previousSibling)&&U.nodeType!==1){}aa[W]=Y||U&&U.nodeName===T?U||false:U===T}}if(Y){F.filter(T,aa,true)}},">":function(Z,U,aa){var X=typeof U==="string";if(X&&!/\W/.test(U)){U=aa?U:U.toUpperCase();for(var V=0,T=Z.length;V<T;V++){var Y=Z[V];if(Y){var W=Y.parentNode;Z[V]=W.nodeName===U?W:false}}}else{for(var V=0,T=Z.length;V<T;V++){var Y=Z[V];if(Y){Z[V]=X?Y.parentNode:Y.parentNode===U}}if(X){F.filter(U,Z,true)}}},"":function(W,U,Y){var V=L++,T=S;if(!U.match(/\W/)){var X=U=Y?U:U.toUpperCase();T=P}T("parentNode",U,V,W,X,Y)},"~":function(W,U,Y){var V=L++,T=S;if(typeof U==="string"&&!U.match(/\W/)){var X=U=Y?U:U.toUpperCase();T=P}T("previousSibling",U,V,W,X,Y)}},find:{ID:function(U,V,W){if(typeof V.getElementById!=="undefined"&&!W){var T=V.getElementById(U[1]);return T?[T]:[]}},NAME:function(V,Y,Z){if(typeof Y.getElementsByName!=="undefined"){var U=[],X=Y.getElementsByName(V[1]);for(var W=0,T=X.length;W<T;W++){if(X[W].getAttribute("name")===V[1]){U.push(X[W])}}return U.length===0?null:U}},TAG:function(T,U){return U.getElementsByTagName(T[1])}},preFilter:{CLASS:function(W,U,V,T,Z,aa){W=" "+W[1].replace(/\\/g,"")+" ";if(aa){return W}for(var X=0,Y;(Y=U[X])!=null;X++){if(Y){if(Z^(Y.className&&(" "+Y.className+" ").indexOf(W)>=0)){if(!V){T.push(Y)}}else{if(V){U[X]=false}}}}return false},ID:function(T){return T[1].replace(/\\/g,"")},TAG:function(U,T){for(var V=0;T[V]===false;V++){}return T[V]&&Q(T[V])?U[1]:U[1].toUpperCase()},CHILD:function(T){if(T[1]=="nth"){var U=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(T[2]=="even"&&"2n"||T[2]=="odd"&&"2n+1"||!/\D/.test(T[2])&&"0n+"+T[2]||T[2]);T[2]=(U[1]+(U[2]||1))-0;T[3]=U[3]-0}T[0]=L++;return T},ATTR:function(X,U,V,T,Y,Z){var W=X[1].replace(/\\/g,"");if(!Z&&I.attrMap[W]){X[1]=I.attrMap[W]}if(X[2]==="~="){X[4]=" "+X[4]+" "}return X},PSEUDO:function(X,U,V,T,Y){if(X[1]==="not"){if(X[3].match(R).length>1||/^\w/.test(X[3])){X[3]=F(X[3],null,null,U)}else{var W=F.filter(X[3],U,V,true^Y);if(!V){T.push.apply(T,W)}return false}}else{if(I.match.POS.test(X[0])||I.match.CHILD.test(X[0])){return true}}return X},POS:function(T){T.unshift(true);return T}},filters:{enabled:function(T){return T.disabled===false&&T.type!=="hidden"},disabled:function(T){return T.disabled===true},checked:function(T){return T.checked===true},selected:function(T){T.parentNode.selectedIndex;return T.selected===true},parent:function(T){return !!T.firstChild},empty:function(T){return !T.firstChild},has:function(V,U,T){return !!F(T[3],V).length},header:function(T){return/h\d/i.test(T.nodeName)},text:function(T){return"text"===T.type},radio:function(T){return"radio"===T.type},checkbox:function(T){return"checkbox"===T.type},file:function(T){return"file"===T.type},password:function(T){return"password"===T.type},submit:function(T){return"submit"===T.type},image:function(T){return"image"===T.type},reset:function(T){return"reset"===T.type},button:function(T){return"button"===T.type||T.nodeName.toUpperCase()==="BUTTON"},input:function(T){return/input|select|textarea|button/i.test(T.nodeName)}},setFilters:{first:function(U,T){return T===0},last:function(V,U,T,W){return U===W.length-1},even:function(U,T){return T%2===0},odd:function(U,T){return T%2===1},lt:function(V,U,T){return U<T[3]-0},gt:function(V,U,T){return U>T[3]-0},nth:function(V,U,T){return T[3]-0==U},eq:function(V,U,T){return T[3]-0==U}},filter:{PSEUDO:function(Z,V,W,aa){var U=V[1],X=I.filters[U];if(X){return X(Z,W,V,aa)}else{if(U==="contains"){return(Z.textContent||Z.innerText||"").indexOf(V[3])>=0}else{if(U==="not"){var Y=V[3];for(var W=0,T=Y.length;W<T;W++){if(Y[W]===Z){return false}}return true}}}},CHILD:function(T,W){var Z=W[1],U=T;switch(Z){case"only":case"first":while(U=U.previousSibling){if(U.nodeType===1){return false}}if(Z=="first"){return true}U=T;case"last":while(U=U.nextSibling){if(U.nodeType===1){return false}}return true;case"nth":var V=W[2],ac=W[3];if(V==1&&ac==0){return true}var Y=W[0],ab=T.parentNode;if(ab&&(ab.sizcache!==Y||!T.nodeIndex)){var X=0;for(U=ab.firstChild;U;U=U.nextSibling){if(U.nodeType===1){U.nodeIndex=++X}}ab.sizcache=Y}var aa=T.nodeIndex-ac;if(V==0){return aa==0}else{return(aa%V==0&&aa/V>=0)}}},ID:function(U,T){return U.nodeType===1&&U.getAttribute("id")===T},TAG:function(U,T){return(T==="*"&&U.nodeType===1)||U.nodeName===T},CLASS:function(U,T){return(" "+(U.className||U.getAttribute("class"))+" ").indexOf(T)>-1},ATTR:function(Y,W){var V=W[1],T=I.attrHandle[V]?I.attrHandle[V](Y):Y[V]!=null?Y[V]:Y.getAttribute(V),Z=T+"",X=W[2],U=W[4];return T==null?X==="!=":X==="="?Z===U:X==="*="?Z.indexOf(U)>=0:X==="~="?(" "+Z+" ").indexOf(U)>=0:!U?Z&&T!==false:X==="!="?Z!=U:X==="^="?Z.indexOf(U)===0:X==="$="?Z.substr(Z.length-U.length)===U:X==="|="?Z===U||Z.substr(0,U.length+1)===U+"-":false},POS:function(X,U,V,Y){var T=U[2],W=I.setFilters[T];if(W){return W(X,V,U,Y)}}}};var M=I.match.POS;for(var O in I.match){I.match[O]=RegExp(I.match[O].source+/(?![^\[]*\])(?![^\(]*\))/.source)}var E=function(U,T){U=Array.prototype.slice.call(U);if(T){T.push.apply(T,U);return T}return U};try{Array.prototype.slice.call(document.documentElement.childNodes)}catch(N){E=function(X,W){var U=W||[];if(H.call(X)==="[object Array]"){Array.prototype.push.apply(U,X)}else{if(typeof X.length==="number"){for(var V=0,T=X.length;V<T;V++){U.push(X[V])}}else{for(var V=0;X[V];V++){U.push(X[V])}}}return U}}var G;if(document.documentElement.compareDocumentPosition){G=function(U,T){var V=U.compareDocumentPosition(T)&4?-1:U===T?0:1;if(V===0){hasDuplicate=true}return V}}else{if("sourceIndex" in document.documentElement){G=function(U,T){var V=U.sourceIndex-T.sourceIndex;if(V===0){hasDuplicate=true}return V}}else{if(document.createRange){G=function(W,U){var V=W.ownerDocument.createRange(),T=U.ownerDocument.createRange();V.selectNode(W);V.collapse(true);T.selectNode(U);T.collapse(true);var X=V.compareBoundaryPoints(Range.START_TO_END,T);if(X===0){hasDuplicate=true}return X}}}}(function(){var U=document.createElement("form"),V="script"+(new Date).getTime();U.innerHTML="<input name='"+V+"'/>";var T=document.documentElement;T.insertBefore(U,T.firstChild);if(!!document.getElementById(V)){I.find.ID=function(X,Y,Z){if(typeof Y.getElementById!=="undefined"&&!Z){var W=Y.getElementById(X[1]);return W?W.id===X[1]||typeof W.getAttributeNode!=="undefined"&&W.getAttributeNode("id").nodeValue===X[1]?[W]:g:[]}};I.filter.ID=function(Y,W){var X=typeof Y.getAttributeNode!=="undefined"&&Y.getAttributeNode("id");return Y.nodeType===1&&X&&X.nodeValue===W}}T.removeChild(U)})();(function(){var T=document.createElement("div");T.appendChild(document.createComment(""));if(T.getElementsByTagName("*").length>0){I.find.TAG=function(U,Y){var X=Y.getElementsByTagName(U[1]);if(U[1]==="*"){var W=[];for(var V=0;X[V];V++){if(X[V].nodeType===1){W.push(X[V])}}X=W}return X}}T.innerHTML="<a href='#'></a>";if(T.firstChild&&typeof T.firstChild.getAttribute!=="undefined"&&T.firstChild.getAttribute("href")!=="#"){I.attrHandle.href=function(U){return U.getAttribute("href",2)}}})();if(document.querySelectorAll){(function(){var T=F,U=document.createElement("div");U.innerHTML="<p class='TEST'></p>";if(U.querySelectorAll&&U.querySelectorAll(".TEST").length===0){return}F=function(Y,X,V,W){X=X||document;if(!W&&X.nodeType===9&&!Q(X)){try{return E(X.querySelectorAll(Y),V)}catch(Z){}}return T(Y,X,V,W)};F.find=T.find;F.filter=T.filter;F.selectors=T.selectors;F.matches=T.matches})()}if(document.getElementsByClassName&&document.documentElement.getElementsByClassName){(function(){var T=document.createElement("div");T.innerHTML="<div class='test e'></div><div class='test'></div>";if(T.getElementsByClassName("e").length===0){return}T.lastChild.className="e";if(T.getElementsByClassName("e").length===1){return}I.order.splice(1,0,"CLASS");I.find.CLASS=function(U,V,W){if(typeof V.getElementsByClassName!=="undefined"&&!W){return V.getElementsByClassName(U[1])}}})()}function P(U,Z,Y,ad,aa,ac){var ab=U=="previousSibling"&&!ac;for(var W=0,V=ad.length;W<V;W++){var T=ad[W];if(T){if(ab&&T.nodeType===1){T.sizcache=Y;T.sizset=W}T=T[U];var X=false;while(T){if(T.sizcache===Y){X=ad[T.sizset];break}if(T.nodeType===1&&!ac){T.sizcache=Y;T.sizset=W}if(T.nodeName===Z){X=T;break}T=T[U]}ad[W]=X}}}function S(U,Z,Y,ad,aa,ac){var ab=U=="previousSibling"&&!ac;for(var W=0,V=ad.length;W<V;W++){var T=ad[W];if(T){if(ab&&T.nodeType===1){T.sizcache=Y;T.sizset=W}T=T[U];var X=false;while(T){if(T.sizcache===Y){X=ad[T.sizset];break}if(T.nodeType===1){if(!ac){T.sizcache=Y;T.sizset=W}if(typeof Z!=="string"){if(T===Z){X=true;break}}else{if(F.filter(Z,[T]).length>0){X=T;break}}}T=T[U]}ad[W]=X}}}var K=document.compareDocumentPosition?function(U,T){return U.compareDocumentPosition(T)&16}:function(U,T){return U!==T&&(U.contains?U.contains(T):true)};var Q=function(T){return T.nodeType===9&&T.documentElement.nodeName!=="HTML"||!!T.ownerDocument&&Q(T.ownerDocument)};var J=function(T,aa){var W=[],X="",Y,V=aa.nodeType?[aa]:aa;while((Y=I.match.PSEUDO.exec(T))){X+=Y[0];T=T.replace(I.match.PSEUDO,"")}T=I.relative[T]?T+"*":T;for(var Z=0,U=V.length;Z<U;Z++){F(T,V[Z],W)}return F.filter(X,W)};o.find=F;o.filter=F.filter;o.expr=F.selectors;o.expr[":"]=o.expr.filters;F.selectors.filters.hidden=function(T){return T.offsetWidth===0||T.offsetHeight===0};F.selectors.filters.visible=function(T){return T.offsetWidth>0||T.offsetHeight>0};F.selectors.filters.animated=function(T){return o.grep(o.timers,function(U){return T===U.elem}).length};o.multiFilter=function(V,T,U){if(U){V=":not("+V+")"}return F.matches(V,T)};o.dir=function(V,U){var T=[],W=V[U];while(W&&W!=document){if(W.nodeType==1){T.push(W)}W=W[U]}return T};o.nth=function(X,T,V,W){T=T||1;var U=0;for(;X;X=X[V]){if(X.nodeType==1&&++U==T){break}}return X};o.sibling=function(V,U){var T=[];for(;V;V=V.nextSibling){if(V.nodeType==1&&V!=U){T.push(V)}}return T};return;l.Sizzle=F})();o.event={add:function(I,F,H,K){if(I.nodeType==3||I.nodeType==8){return}if(I.setInterval&&I!=l){I=l}if(!H.guid){H.guid=this.guid++}if(K!==g){var G=H;H=this.proxy(G);H.data=K}var E=o.data(I,"events")||o.data(I,"events",{}),J=o.data(I,"handle")||o.data(I,"handle",function(){return typeof o!=="undefined"&&!o.event.triggered?o.event.handle.apply(arguments.callee.elem,arguments):g});J.elem=I;o.each(F.split(/\s+/),function(M,N){var O=N.split(".");N=O.shift();H.type=O.slice().sort().join(".");var L=E[N];if(o.event.specialAll[N]){o.event.specialAll[N].setup.call(I,K,O)}if(!L){L=E[N]={};if(!o.event.special[N]||o.event.special[N].setup.call(I,K,O)===false){if(I.addEventListener){I.addEventListener(N,J,false)}else{if(I.attachEvent){I.attachEvent("on"+N,J)}}}}L[H.guid]=H;o.event.global[N]=true});I=null},guid:1,global:{},remove:function(K,H,J){if(K.nodeType==3||K.nodeType==8){return}var G=o.data(K,"events"),F,E;if(G){if(H===g||(typeof H==="string"&&H.charAt(0)==".")){for(var I in G){this.remove(K,I+(H||""))}}else{if(H.type){J=H.handler;H=H.type}o.each(H.split(/\s+/),function(M,O){var Q=O.split(".");O=Q.shift();var N=RegExp("(^|\\.)"+Q.slice().sort().join(".*\\.")+"(\\.|$)");if(G[O]){if(J){delete G[O][J.guid]}else{for(var P in G[O]){if(N.test(G[O][P].type)){delete G[O][P]}}}if(o.event.specialAll[O]){o.event.specialAll[O].teardown.call(K,Q)}for(F in G[O]){break}if(!F){if(!o.event.special[O]||o.event.special[O].teardown.call(K,Q)===false){if(K.removeEventListener){K.removeEventListener(O,o.data(K,"handle"),false)}else{if(K.detachEvent){K.detachEvent("on"+O,o.data(K,"handle"))}}}F=null;delete G[O]}}})}for(F in G){break}if(!F){var L=o.data(K,"handle");if(L){L.elem=null}o.removeData(K,"events");o.removeData(K,"handle")}}},trigger:function(I,K,H,E){var G=I.type||I;if(!E){I=typeof I==="object"?I[h]?I:o.extend(o.Event(G),I):o.Event(G);if(G.indexOf("!")>=0){I.type=G=G.slice(0,-1);I.exclusive=true}if(!H){I.stopPropagation();if(this.global[G]){o.each(o.cache,function(){if(this.events&&this.events[G]){o.event.trigger(I,K,this.handle.elem)}})}}if(!H||H.nodeType==3||H.nodeType==8){return g}I.result=g;I.target=H;K=o.makeArray(K);K.unshift(I)}I.currentTarget=H;var J=o.data(H,"handle");if(J){J.apply(H,K)}if((!H[G]||(o.nodeName(H,"a")&&G=="click"))&&H["on"+G]&&H["on"+G].apply(H,K)===false){I.result=false}if(!E&&H[G]&&!I.isDefaultPrevented()&&!(o.nodeName(H,"a")&&G=="click")){this.triggered=true;try{H[G]()}catch(L){}}this.triggered=false;if(!I.isPropagationStopped()){var F=H.parentNode||H.ownerDocument;if(F){o.event.trigger(I,K,F,true)}}},handle:function(K){var J,E;K=arguments[0]=o.event.fix(K||l.event);K.currentTarget=this;var L=K.type.split(".");K.type=L.shift();J=!L.length&&!K.exclusive;var I=RegExp("(^|\\.)"+L.slice().sort().join(".*\\.")+"(\\.|$)");E=(o.data(this,"events")||{})[K.type];for(var G in E){var H=E[G];if(J||I.test(H.type)){K.handler=H;K.data=H.data;var F=H.apply(this,arguments);if(F!==g){K.result=F;if(F===false){K.preventDefault();K.stopPropagation()}}if(K.isImmediatePropagationStopped()){break}}}},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode metaKey newValue originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),fix:function(H){if(H[h]){return H}var F=H;H=o.Event(F);for(var G=this.props.length,J;G;){J=this.props[--G];H[J]=F[J]}if(!H.target){H.target=H.srcElement||document}if(H.target.nodeType==3){H.target=H.target.parentNode}if(!H.relatedTarget&&H.fromElement){H.relatedTarget=H.fromElement==H.target?H.toElement:H.fromElement}if(H.pageX==null&&H.clientX!=null){var I=document.documentElement,E=document.body;H.pageX=H.clientX+(I&&I.scrollLeft||E&&E.scrollLeft||0)-(I.clientLeft||0);H.pageY=H.clientY+(I&&I.scrollTop||E&&E.scrollTop||0)-(I.clientTop||0)}if(!H.which&&((H.charCode||H.charCode===0)?H.charCode:H.keyCode)){H.which=H.charCode||H.keyCode}if(!H.metaKey&&H.ctrlKey){H.metaKey=H.ctrlKey}if(!H.which&&H.button){H.which=(H.button&1?1:(H.button&2?3:(H.button&4?2:0)))}return H},proxy:function(F,E){E=E||function(){return F.apply(this,arguments)};E.guid=F.guid=F.guid||E.guid||this.guid++;return E},special:{ready:{setup:B,teardown:function(){}}},specialAll:{live:{setup:function(E,F){o.event.add(this,F[0],c)},teardown:function(G){if(G.length){var E=0,F=RegExp("(^|\\.)"+G[0]+"(\\.|$)");o.each((o.data(this,"events").live||{}),function(){if(F.test(this.type)){E++}});if(E<1){o.event.remove(this,G[0],c)}}}}}};o.Event=function(E){if(!this.preventDefault){return new o.Event(E)}if(E&&E.type){this.originalEvent=E;this.type=E.type}else{this.type=E}this.timeStamp=e();this[h]=true};function k(){return false}function u(){return true}o.Event.prototype={preventDefault:function(){this.isDefaultPrevented=u;var E=this.originalEvent;if(!E){return}if(E.preventDefault){E.preventDefault()}E.returnValue=false},stopPropagation:function(){this.isPropagationStopped=u;var E=this.originalEvent;if(!E){return}if(E.stopPropagation){E.stopPropagation()}E.cancelBubble=true},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=u;this.stopPropagation()},isDefaultPrevented:k,isPropagationStopped:k,isImmediatePropagationStopped:k};var a=function(F){var E=F.relatedTarget;while(E&&E!=this){try{E=E.parentNode}catch(G){E=this}}if(E!=this){F.type=F.data;o.event.handle.apply(this,arguments)}};o.each({mouseover:"mouseenter",mouseout:"mouseleave"},function(F,E){o.event.special[E]={setup:function(){o.event.add(this,F,a,E)},teardown:function(){o.event.remove(this,F,a)}}});o.fn.extend({bind:function(F,G,E){return F=="unload"?this.one(F,G,E):this.each(function(){o.event.add(this,F,E||G,E&&G)})},one:function(G,H,F){var E=o.event.proxy(F||H,function(I){o(this).unbind(I,E);return(F||H).apply(this,arguments)});return this.each(function(){o.event.add(this,G,E,F&&H)})},unbind:function(F,E){return this.each(function(){o.event.remove(this,F,E)})},trigger:function(E,F){return this.each(function(){o.event.trigger(E,F,this)})},triggerHandler:function(E,G){if(this[0]){var F=o.Event(E);F.preventDefault();F.stopPropagation();o.event.trigger(F,G,this[0]);return F.result}},toggle:function(G){var E=arguments,F=1;while(F<E.length){o.event.proxy(G,E[F++])}return this.click(o.event.proxy(G,function(H){this.lastToggle=(this.lastToggle||0)%F;H.preventDefault();return E[this.lastToggle++].apply(this,arguments)||false}))},hover:function(E,F){return this.mouseenter(E).mouseleave(F)},ready:function(E){B();if(o.isReady){E.call(document,o)}else{o.readyList.push(E)}return this},live:function(G,F){var E=o.event.proxy(F);E.guid+=this.selector+G;o(document).bind(i(G,this.selector),this.selector,E);return this},die:function(F,E){o(document).unbind(i(F,this.selector),E?{guid:E.guid+this.selector+F}:null);return this}});function c(H){var E=RegExp("(^|\\.)"+H.type+"(\\.|$)"),G=true,F=[];o.each(o.data(this,"events").live||[],function(I,J){if(E.test(J.type)){var K=o(H.target).closest(J.data)[0];if(K){F.push({elem:K,fn:J})}}});F.sort(function(J,I){return o.data(J.elem,"closest")-o.data(I.elem,"closest")});o.each(F,function(){if(this.fn.call(this.elem,H,this.fn.data)===false){return(G=false)}});return G}function i(F,E){return["live",F,E.replace(/\./g,"`").replace(/ /g,"|")].join(".")}o.extend({isReady:false,readyList:[],ready:function(){if(!o.isReady){o.isReady=true;if(o.readyList){o.each(o.readyList,function(){this.call(document,o)});o.readyList=null}o(document).triggerHandler("ready")}}});var x=false;function B(){if(x){return}x=true;if(document.addEventListener){document.addEventListener("DOMContentLoaded",function(){document.removeEventListener("DOMContentLoaded",arguments.callee,false);o.ready()},false)}else{if(document.attachEvent){document.attachEvent("onreadystatechange",function(){if(document.readyState==="complete"){document.detachEvent("onreadystatechange",arguments.callee);o.ready()}});if(document.documentElement.doScroll&&l==l.top){(function(){if(o.isReady){return}try{document.documentElement.doScroll("left")}catch(E){setTimeout(arguments.callee,0);return}o.ready()})()}}}o.event.add(l,"load",o.ready)}o.each(("blur,focus,load,resize,scroll,unload,click,dblclick,mousedown,mouseup,mousemove,mouseover,mouseout,mouseenter,mouseleave,change,select,submit,keydown,keypress,keyup,error").split(","),function(F,E){o.fn[E]=function(G){return G?this.bind(E,G):this.trigger(E)}});o(l).bind("unload",function(){for(var E in o.cache){if(E!=1&&o.cache[E].handle){o.event.remove(o.cache[E].handle.elem)}}});(function(){o.support={};var F=document.documentElement,G=document.createElement("script"),K=document.createElement("div"),J="script"+(new Date).getTime();K.style.display="none";K.innerHTML='   <link/><table></table><a href="/a" style="color:red;float:left;opacity:.5;">a</a><select><option>text</option></select><object><param/></object>';var H=K.getElementsByTagName("*"),E=K.getElementsByTagName("a")[0];if(!H||!H.length||!E){return}o.support={leadingWhitespace:K.firstChild.nodeType==3,tbody:!K.getElementsByTagName("tbody").length,objectAll:!!K.getElementsByTagName("object")[0].getElementsByTagName("*").length,htmlSerialize:!!K.getElementsByTagName("link").length,style:/red/.test(E.getAttribute("style")),hrefNormalized:E.getAttribute("href")==="/a",opacity:E.style.opacity==="0.5",cssFloat:!!E.style.cssFloat,scriptEval:false,noCloneEvent:true,boxModel:null};G.type="text/javascript";try{G.appendChild(document.createTextNode("window."+J+"=1;"))}catch(I){}F.insertBefore(G,F.firstChild);if(l[J]){o.support.scriptEval=true;delete l[J]}F.removeChild(G);if(K.attachEvent&&K.fireEvent){K.attachEvent("onclick",function(){o.support.noCloneEvent=false;K.detachEvent("onclick",arguments.callee)});K.cloneNode(true).fireEvent("onclick")}o(function(){var L=document.createElement("div");L.style.width=L.style.paddingLeft="1px";document.body.appendChild(L);o.boxModel=o.support.boxModel=L.offsetWidth===2;document.body.removeChild(L).style.display="none"})})();var w=o.support.cssFloat?"cssFloat":"styleFloat";o.props={"for":"htmlFor","class":"className","float":w,cssFloat:w,styleFloat:w,readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",tabindex:"tabIndex"};o.fn.extend({_load:o.fn.load,load:function(G,J,K){if(typeof G!=="string"){return this._load(G)}var I=G.indexOf(" ");if(I>=0){var E=G.slice(I,G.length);G=G.slice(0,I)}var H="GET";if(J){if(o.isFunction(J)){K=J;J=null}else{if(typeof J==="object"){J=o.param(J);H="POST"}}}var F=this;o.ajax({url:G,type:H,dataType:"html",data:J,complete:function(M,L){if(L=="success"||L=="notmodified"){F.html(E?o("<div/>").append(M.responseText.replace(/<script(.|\s)*?\/script>/g,"")).find(E):M.responseText)}if(K){F.each(K,[M.responseText,L,M])}}});return this},serialize:function(){return o.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?o.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||/select|textarea/i.test(this.nodeName)||/text|hidden|password|search/i.test(this.type))}).map(function(E,F){var G=o(this).val();return G==null?null:o.isArray(G)?o.map(G,function(I,H){return{name:F.name,value:I}}):{name:F.name,value:G}}).get()}});o.each("ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend".split(","),function(E,F){o.fn[F]=function(G){return this.bind(F,G)}});var r=e();o.extend({get:function(E,G,H,F){if(o.isFunction(G)){H=G;G=null}return o.ajax({type:"GET",url:E,data:G,success:H,dataType:F})},getScript:function(E,F){return o.get(E,null,F,"script")},getJSON:function(E,F,G){return o.get(E,F,G,"json")},post:function(E,G,H,F){if(o.isFunction(G)){H=G;G={}}return o.ajax({type:"POST",url:E,data:G,success:H,dataType:F})},ajaxSetup:function(E){o.extend(o.ajaxSettings,E)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return l.ActiveXObject?new ActiveXObject("Microsoft.XMLHTTP"):new XMLHttpRequest()},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},ajax:function(M){M=o.extend(true,M,o.extend(true,{},o.ajaxSettings,M));var W,F=/=\?(&|$)/g,R,V,G=M.type.toUpperCase();if(M.data&&M.processData&&typeof M.data!=="string"){M.data=o.param(M.data)}if(M.dataType=="jsonp"){if(G=="GET"){if(!M.url.match(F)){M.url+=(M.url.match(/\?/)?"&":"?")+(M.jsonp||"callback")+"=?"}}else{if(!M.data||!M.data.match(F)){M.data=(M.data?M.data+"&":"")+(M.jsonp||"callback")+"=?"}}M.dataType="json"}if(M.dataType=="json"&&(M.data&&M.data.match(F)||M.url.match(F))){W="jsonp"+r++;if(M.data){M.data=(M.data+"").replace(F,"="+W+"$1")}M.url=M.url.replace(F,"="+W+"$1");M.dataType="script";l[W]=function(X){V=X;I();L();l[W]=g;try{delete l[W]}catch(Y){}if(H){H.removeChild(T)}}}if(M.dataType=="script"&&M.cache==null){M.cache=false}if(M.cache===false&&G=="GET"){var E=e();var U=M.url.replace(/(\?|&)_=.*?(&|$)/,"$1_="+E+"$2");M.url=U+((U==M.url)?(M.url.match(/\?/)?"&":"?")+"_="+E:"")}if(M.data&&G=="GET"){M.url+=(M.url.match(/\?/)?"&":"?")+M.data;M.data=null}if(M.global&&!o.active++){o.event.trigger("ajaxStart")}var Q=/^(\w+:)?\/\/([^\/?#]+)/.exec(M.url);if(M.dataType=="script"&&G=="GET"&&Q&&(Q[1]&&Q[1]!=location.protocol||Q[2]!=location.host)){var H=document.getElementsByTagName("head")[0];var T=document.createElement("script");T.src=M.url;if(M.scriptCharset){T.charset=M.scriptCharset}if(!W){var O=false;T.onload=T.onreadystatechange=function(){if(!O&&(!this.readyState||this.readyState=="loaded"||this.readyState=="complete")){O=true;I();L();T.onload=T.onreadystatechange=null;H.removeChild(T)}}}H.appendChild(T);return g}var K=false;var J=M.xhr();if(M.username){J.open(G,M.url,M.async,M.username,M.password)}else{J.open(G,M.url,M.async)}try{if(M.data){J.setRequestHeader("Content-Type",M.contentType)}if(M.ifModified){J.setRequestHeader("If-Modified-Since",o.lastModified[M.url]||"Thu, 01 Jan 1970 00:00:00 GMT")}J.setRequestHeader("X-Requested-With","XMLHttpRequest");J.setRequestHeader("Accept",M.dataType&&M.accepts[M.dataType]?M.accepts[M.dataType]+", */*":M.accepts._default)}catch(S){}if(M.beforeSend&&M.beforeSend(J,M)===false){if(M.global&&!--o.active){o.event.trigger("ajaxStop")}J.abort();return false}if(M.global){o.event.trigger("ajaxSend",[J,M])}var N=function(X){if(J.readyState==0){if(P){clearInterval(P);P=null;if(M.global&&!--o.active){o.event.trigger("ajaxStop")}}}else{if(!K&&J&&(J.readyState==4||X=="timeout")){K=true;if(P){clearInterval(P);P=null}R=X=="timeout"?"timeout":!o.httpSuccess(J)?"error":M.ifModified&&o.httpNotModified(J,M.url)?"notmodified":"success";if(R=="success"){try{V=o.httpData(J,M.dataType,M)}catch(Z){R="parsererror"}}if(R=="success"){var Y;try{Y=J.getResponseHeader("Last-Modified")}catch(Z){}if(M.ifModified&&Y){o.lastModified[M.url]=Y}if(!W){I()}}else{o.handleError(M,J,R)}L();if(X){J.abort()}if(M.async){J=null}}}};if(M.async){var P=setInterval(N,13);if(M.timeout>0){setTimeout(function(){if(J&&!K){N("timeout")}},M.timeout)}}try{J.send(M.data)}catch(S){o.handleError(M,J,null,S)}if(!M.async){N()}function I(){if(M.success){M.success(V,R)}if(M.global){o.event.trigger("ajaxSuccess",[J,M])}}function L(){if(M.complete){M.complete(J,R)}if(M.global){o.event.trigger("ajaxComplete",[J,M])}if(M.global&&!--o.active){o.event.trigger("ajaxStop")}}return J},handleError:function(F,H,E,G){if(F.error){F.error(H,E,G)}if(F.global){o.event.trigger("ajaxError",[H,F,G])}},active:0,httpSuccess:function(F){try{return !F.status&&location.protocol=="file:"||(F.status>=200&&F.status<300)||F.status==304||F.status==1223}catch(E){}return false},httpNotModified:function(G,E){try{var H=G.getResponseHeader("Last-Modified");return G.status==304||H==o.lastModified[E]}catch(F){}return false},httpData:function(J,H,G){var F=J.getResponseHeader("content-type"),E=H=="xml"||!H&&F&&F.indexOf("xml")>=0,I=E?J.responseXML:J.responseText;if(E&&I.documentElement.tagName=="parsererror"){throw"parsererror"}if(G&&G.dataFilter){I=G.dataFilter(I,H)}if(typeof I==="string"){if(H=="script"){o.globalEval(I)}if(H=="json"){I=l["eval"]("("+I+")")}}return I},param:function(E){var G=[];function H(I,J){G[G.length]=encodeURIComponent(I)+"="+encodeURIComponent(J)}if(o.isArray(E)||E.jquery){o.each(E,function(){H(this.name,this.value)})}else{for(var F in E){if(o.isArray(E[F])){o.each(E[F],function(){H(F,this)})}else{H(F,o.isFunction(E[F])?E[F]():E[F])}}}return G.join("&").replace(/%20/g,"+")}});var m={},n,d=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];function t(F,E){var G={};o.each(d.concat.apply([],d.slice(0,E)),function(){G[this]=F});return G}o.fn.extend({show:function(J,L){if(J){return this.animate(t("show",3),J,L)}else{for(var H=0,F=this.length;H<F;H++){var E=o.data(this[H],"olddisplay");this[H].style.display=E||"";if(o.css(this[H],"display")==="none"){var G=this[H].tagName,K;if(m[G]){K=m[G]}else{var I=o("<"+G+" />").appendTo("body");K=I.css("display");if(K==="none"){K="block"}I.remove();m[G]=K}o.data(this[H],"olddisplay",K)}}for(var H=0,F=this.length;H<F;H++){this[H].style.display=o.data(this[H],"olddisplay")||""}return this}},hide:function(H,I){if(H){return this.animate(t("hide",3),H,I)}else{for(var G=0,F=this.length;G<F;G++){var E=o.data(this[G],"olddisplay");if(!E&&E!=="none"){o.data(this[G],"olddisplay",o.css(this[G],"display"))}}for(var G=0,F=this.length;G<F;G++){this[G].style.display="none"}return this}},_toggle:o.fn.toggle,toggle:function(G,F){var E=typeof G==="boolean";return o.isFunction(G)&&o.isFunction(F)?this._toggle.apply(this,arguments):G==null||E?this.each(function(){var H=E?G:o(this).is(":hidden");o(this)[H?"show":"hide"]()}):this.animate(t("toggle",3),G,F)},fadeTo:function(E,G,F){return this.animate({opacity:G},E,F)},animate:function(I,F,H,G){var E=o.speed(F,H,G);return this[E.queue===false?"each":"queue"](function(){var K=o.extend({},E),M,L=this.nodeType==1&&o(this).is(":hidden"),J=this;for(M in I){if(I[M]=="hide"&&L||I[M]=="show"&&!L){return K.complete.call(this)}if((M=="height"||M=="width")&&this.style){K.display=o.css(this,"display");K.overflow=this.style.overflow}}if(K.overflow!=null){this.style.overflow="hidden"}K.curAnim=o.extend({},I);o.each(I,function(O,S){var R=new o.fx(J,K,O);if(/toggle|show|hide/.test(S)){R[S=="toggle"?L?"show":"hide":S](I)}else{var Q=S.toString().match(/^([+-]=)?([\d+-.]+)(.*)$/),T=R.cur(true)||0;if(Q){var N=parseFloat(Q[2]),P=Q[3]||"px";if(P!="px"){J.style[O]=(N||1)+P;T=((N||1)/R.cur(true))*T;J.style[O]=T+P}if(Q[1]){N=((Q[1]=="-="?-1:1)*N)+T}R.custom(T,N,P)}else{R.custom(T,S,"")}}});return true})},stop:function(F,E){var G=o.timers;if(F){this.queue([])}this.each(function(){for(var H=G.length-1;H>=0;H--){if(G[H].elem==this){if(E){G[H](true)}G.splice(H,1)}}});if(!E){this.dequeue()}return this}});o.each({slideDown:t("show",1),slideUp:t("hide",1),slideToggle:t("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(E,F){o.fn[E]=function(G,H){return this.animate(F,G,H)}});o.extend({speed:function(G,H,F){var E=typeof G==="object"?G:{complete:F||!F&&H||o.isFunction(G)&&G,duration:G,easing:F&&H||H&&!o.isFunction(H)&&H};E.duration=o.fx.off?0:typeof E.duration==="number"?E.duration:o.fx.speeds[E.duration]||o.fx.speeds._default;E.old=E.complete;E.complete=function(){if(E.queue!==false){o(this).dequeue()}if(o.isFunction(E.old)){E.old.call(this)}};return E},easing:{linear:function(G,H,E,F){return E+F*G},swing:function(G,H,E,F){return((-Math.cos(G*Math.PI)/2)+0.5)*F+E}},timers:[],fx:function(F,E,G){this.options=E;this.elem=F;this.prop=G;if(!E.orig){E.orig={}}}});o.fx.prototype={update:function(){if(this.options.step){this.options.step.call(this.elem,this.now,this)}(o.fx.step[this.prop]||o.fx.step._default)(this);if((this.prop=="height"||this.prop=="width")&&this.elem.style){this.elem.style.display="block"}},cur:function(F){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null)){return this.elem[this.prop]}var E=parseFloat(o.css(this.elem,this.prop,F));return E&&E>-10000?E:parseFloat(o.curCSS(this.elem,this.prop))||0},custom:function(I,H,G){this.startTime=e();this.start=I;this.end=H;this.unit=G||this.unit||"px";this.now=this.start;this.pos=this.state=0;var E=this;function F(J){return E.step(J)}F.elem=this.elem;if(F()&&o.timers.push(F)&&!n){n=setInterval(function(){var K=o.timers;for(var J=0;J<K.length;J++){if(!K[J]()){K.splice(J--,1)}}if(!K.length){clearInterval(n);n=g}},13)}},show:function(){this.options.orig[this.prop]=o.attr(this.elem.style,this.prop);this.options.show=true;this.custom(this.prop=="width"||this.prop=="height"?1:0,this.cur());o(this.elem).show()},hide:function(){this.options.orig[this.prop]=o.attr(this.elem.style,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(H){var G=e();if(H||G>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;var E=true;for(var F in this.options.curAnim){if(this.options.curAnim[F]!==true){E=false}}if(E){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;this.elem.style.display=this.options.display;if(o.css(this.elem,"display")=="none"){this.elem.style.display="block"}}if(this.options.hide){o(this.elem).hide()}if(this.options.hide||this.options.show){for(var I in this.options.curAnim){o.attr(this.elem.style,I,this.options.orig[I])}}this.options.complete.call(this.elem)}return false}else{var J=G-this.startTime;this.state=J/this.options.duration;this.pos=o.easing[this.options.easing||(o.easing.swing?"swing":"linear")](this.state,J,0,1,this.options.duration);this.now=this.start+((this.end-this.start)*this.pos);this.update()}return true}};o.extend(o.fx,{speeds:{slow:600,fast:200,_default:400},step:{opacity:function(E){o.attr(E.elem.style,"opacity",E.now)},_default:function(E){if(E.elem.style&&E.elem.style[E.prop]!=null){E.elem.style[E.prop]=E.now+E.unit}else{E.elem[E.prop]=E.now}}}});if(document.documentElement.getBoundingClientRect){o.fn.offset=function(){if(!this[0]){return{top:0,left:0}}if(this[0]===this[0].ownerDocument.body){return o.offset.bodyOffset(this[0])}var G=this[0].getBoundingClientRect(),J=this[0].ownerDocument,F=J.body,E=J.documentElement,L=E.clientTop||F.clientTop||0,K=E.clientLeft||F.clientLeft||0,I=G.top+(self.pageYOffset||o.boxModel&&E.scrollTop||F.scrollTop)-L,H=G.left+(self.pageXOffset||o.boxModel&&E.scrollLeft||F.scrollLeft)-K;return{top:I,left:H}}}else{o.fn.offset=function(){if(!this[0]){return{top:0,left:0}}if(this[0]===this[0].ownerDocument.body){return o.offset.bodyOffset(this[0])}o.offset.initialized||o.offset.initialize();var J=this[0],G=J.offsetParent,F=J,O=J.ownerDocument,M,H=O.documentElement,K=O.body,L=O.defaultView,E=L.getComputedStyle(J,null),N=J.offsetTop,I=J.offsetLeft;while((J=J.parentNode)&&J!==K&&J!==H){M=L.getComputedStyle(J,null);N-=J.scrollTop,I-=J.scrollLeft;if(J===G){N+=J.offsetTop,I+=J.offsetLeft;if(o.offset.doesNotAddBorder&&!(o.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(J.tagName))){N+=parseInt(M.borderTopWidth,10)||0,I+=parseInt(M.borderLeftWidth,10)||0}F=G,G=J.offsetParent}if(o.offset.subtractsBorderForOverflowNotVisible&&M.overflow!=="visible"){N+=parseInt(M.borderTopWidth,10)||0,I+=parseInt(M.borderLeftWidth,10)||0}E=M}if(E.position==="relative"||E.position==="static"){N+=K.offsetTop,I+=K.offsetLeft}if(E.position==="fixed"){N+=Math.max(H.scrollTop,K.scrollTop),I+=Math.max(H.scrollLeft,K.scrollLeft)}return{top:N,left:I}}}o.offset={initialize:function(){if(this.initialized){return}var L=document.body,F=document.createElement("div"),H,G,N,I,M,E,J=L.style.marginTop,K='<div style="position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;"><div></div></div><table style="position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;" cellpadding="0" cellspacing="0"><tr><td></td></tr></table>';M={position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"};for(E in M){F.style[E]=M[E]}F.innerHTML=K;L.insertBefore(F,L.firstChild);H=F.firstChild,G=H.firstChild,I=H.nextSibling.firstChild.firstChild;this.doesNotAddBorder=(G.offsetTop!==5);this.doesAddBorderForTableAndCells=(I.offsetTop===5);H.style.overflow="hidden",H.style.position="relative";this.subtractsBorderForOverflowNotVisible=(G.offsetTop===-5);L.style.marginTop="1px";this.doesNotIncludeMarginInBodyOffset=(L.offsetTop===0);L.style.marginTop=J;L.removeChild(F);this.initialized=true},bodyOffset:function(E){o.offset.initialized||o.offset.initialize();var G=E.offsetTop,F=E.offsetLeft;if(o.offset.doesNotIncludeMarginInBodyOffset){G+=parseInt(o.curCSS(E,"marginTop",true),10)||0,F+=parseInt(o.curCSS(E,"marginLeft",true),10)||0}return{top:G,left:F}}};o.fn.extend({position:function(){var I=0,H=0,F;if(this[0]){var G=this.offsetParent(),J=this.offset(),E=/^body|html$/i.test(G[0].tagName)?{top:0,left:0}:G.offset();J.top-=j(this,"marginTop");J.left-=j(this,"marginLeft");E.top+=j(G,"borderTopWidth");E.left+=j(G,"borderLeftWidth");F={top:J.top-E.top,left:J.left-E.left}}return F},offsetParent:function(){var E=this[0].offsetParent||document.body;while(E&&(!/^body|html$/i.test(E.tagName)&&o.css(E,"position")=="static")){E=E.offsetParent}return o(E)}});o.each(["Left","Top"],function(F,E){var G="scroll"+E;o.fn[G]=function(H){if(!this[0]){return null}return H!==g?this.each(function(){this==l||this==document?l.scrollTo(!F?H:o(l).scrollLeft(),F?H:o(l).scrollTop()):this[G]=H}):this[0]==l||this[0]==document?self[F?"pageYOffset":"pageXOffset"]||o.boxModel&&document.documentElement[G]||document.body[G]:this[0][G]}});o.each(["Height","Width"],function(I,G){var E=I?"Left":"Top",H=I?"Right":"Bottom",F=G.toLowerCase();o.fn["inner"+G]=function(){return this[0]?o.css(this[0],F,false,"padding"):null};o.fn["outer"+G]=function(K){return this[0]?o.css(this[0],F,false,K?"margin":"border"):null};var J=G.toLowerCase();o.fn[J]=function(K){return this[0]==l?document.compatMode=="CSS1Compat"&&document.documentElement["client"+G]||document.body["client"+G]:this[0]==document?Math.max(document.documentElement["client"+G],document.body["scroll"+G],document.documentElement["scroll"+G],document.body["offset"+G],document.documentElement["offset"+G]):K===g?(this.length?o.css(this[0],J):null):this.css(J,typeof K==="string"?K:K+"px")}})})();







/**
* hoverIntent r5 // 2007.03.27 // jQuery 1.1.2+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
* 
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne <brian@cherne.net>
*/
(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:0};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY;};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev]);}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev]);};var handleHover=function(e){var p=(e.type=="mouseover"?e.fromElement:e.toElement)||e.relatedTarget;while(p&&p!=this){try{p=p.parentNode;}catch(e){p=this;}}if(p==this){return false;}var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);}if(e.type=="mouseover"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob);},cfg.timeout);}}};return this.mouseover(handleHover).mouseout(handleHover);};})(jQuery);
/* Copyright (c) 2006 Brandon Aaron (http://brandonaaron.net)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) 
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * $LastChangedDate: 2007-07-21 18:45:56 -0500 (Sat, 21 Jul 2007) $
 * $Rev: 2447 $
 *
 * Version 2.1.1
 */
(function($){$.fn.bgIframe=$.fn.bgiframe=function(s){if($.browser.msie&&/6.0/.test(navigator.userAgent)){s=$.extend({top:'auto',left:'auto',width:'auto',height:'auto',opacity:true,src:'javascript:false;'},s||{});var prop=function(n){return n&&n.constructor==Number?n+'px':n;},html='<iframe class="bgiframe"frameborder="0"tabindex="-1"src="'+s.src+'"'+'style="display:block;position:absolute;z-index:-1;'+(s.opacity!==false?'filter:Alpha(Opacity=\'0\');':'')+'top:'+(s.top=='auto'?'expression(((parseInt(this.parentNode.currentStyle.borderTopWidth)||0)*-1)+\'px\')':prop(s.top))+';'+'left:'+(s.left=='auto'?'expression(((parseInt(this.parentNode.currentStyle.borderLeftWidth)||0)*-1)+\'px\')':prop(s.left))+';'+'width:'+(s.width=='auto'?'expression(this.parentNode.offsetWidth+\'px\')':prop(s.width))+';'+'height:'+(s.height=='auto'?'expression(this.parentNode.offsetHeight+\'px\')':prop(s.height))+';'+'"/>';return this.each(function(){if($('> iframe.bgiframe',this).length==0)this.insertBefore(document.createElement(html),this.firstChild);});}return this;};})(jQuery);
/*
 * @name BeautyTips
 * @desc a tooltips/baloon-help plugin for jQuery
 *
 * @author Jeff Robbins - Lullabot - http://www.lullabot.com
 * @version 0.9.5-rc1  (5/20/2009)
 */
jQuery.bt={version:"0.9.5-rc1"};(function($){jQuery.fn.bt=function(content,options){if(typeof content!="string"){var contentSelect=true;options=content;content=false;}else{var contentSelect=false;}if(jQuery.fn.hoverIntent&&jQuery.bt.defaults.trigger=="hover"){jQuery.bt.defaults.trigger="hoverIntent";}return this.each(function(index){var opts=jQuery.extend(false,jQuery.bt.defaults,jQuery.bt.options,options);opts.spikeLength=numb(opts.spikeLength);opts.spikeGirth=numb(opts.spikeGirth);opts.overlap=numb(opts.overlap);var ajaxTimeout=false;if(opts.killTitle){$(this).find("[title]").andSelf().each(function(){if(!$(this).attr("bt-xTitle")){$(this).attr("bt-xTitle",$(this).attr("title")).attr("title","");}});}if(typeof opts.trigger=="string"){opts.trigger=[opts.trigger];}if(opts.trigger[0]=="hoverIntent"){var hoverOpts=jQuery.extend(opts.hoverIntentOpts,{over:function(){this.btOn();},out:function(){this.btOff();}});$(this).hoverIntent(hoverOpts);}else{if(opts.trigger[0]=="hover"){$(this).hover(function(){this.btOn();},function(){this.btOff();});}else{if(opts.trigger[0]=="now"){if($(this).hasClass("bt-active")){this.btOff();}else{this.btOn();}}else{if(opts.trigger[0]=="none"){}else{if(opts.trigger.length>1&&opts.trigger[0]!=opts.trigger[1]){$(this).bind(opts.trigger[0],function(){this.btOn();}).bind(opts.trigger[1],function(){this.btOff();});}else{$(this).bind(opts.trigger[0],function(){if($(this).hasClass("bt-active")){this.btOff();}else{this.btOn();}});}}}}}this.btOn=function(){if(typeof $(this).data("bt-box")=="object"){this.btOff();}opts.preBuild.apply(this);$(jQuery.bt.vars.closeWhenOpenStack).btOff();$(this).addClass("bt-active "+opts.activeClass);if(contentSelect&&opts.ajaxPath==null){if(opts.killTitle){$(this).attr("title",$(this).attr("bt-xTitle"));}content=$.isFunction(opts.contentSelector)?opts.contentSelector.apply(this):eval(opts.contentSelector);if(opts.killTitle){$(this).attr("title","");}}if(opts.ajaxPath!=null&&content==false){if(typeof opts.ajaxPath=="object"){var url=eval(opts.ajaxPath[0]);url+=opts.ajaxPath[1]?" "+opts.ajaxPath[1]:"";}else{var url=opts.ajaxPath;}var off=url.indexOf(" ");if(off>=0){var selector=url.slice(off,url.length);url=url.slice(0,off);}var cacheData=opts.ajaxCache?$(document.body).data("btCache-"+url.replace(/\./g,"")):null;if(typeof cacheData=="string"){content=selector?$("<div/>").append(cacheData.replace(/<script(.|\s)*?\/script>/g,"")).find(selector):cacheData;}else{var target=this;var ajaxOpts=jQuery.extend(false,{type:opts.ajaxType,data:opts.ajaxData,cache:opts.ajaxCache,url:url,complete:function(XMLHttpRequest,textStatus){if(textStatus=="success"||textStatus=="notmodified"){if(opts.ajaxCache){$(document.body).data("btCache-"+url.replace(/\./g,""),XMLHttpRequest.responseText);}ajaxTimeout=false;content=selector?$("<div/>").append(XMLHttpRequest.responseText.replace(/<script(.|\s)*?\/script>/g,"")).find(selector):XMLHttpRequest.responseText;}else{if(textStatus=="timeout"){ajaxTimeout=true;}content=opts.ajaxError.replace(/%error/g,XMLHttpRequest.statusText);}if($(target).hasClass("bt-active")){target.btOn();}}},opts.ajaxOpts);jQuery.ajax(ajaxOpts);content=opts.ajaxLoading;}}var shadowMarginX=0;var shadowMarginY=0;var shadowShiftX=0;var shadowShiftY=0;if(opts.shadow&&!shadowSupport()){opts.shadow=false;jQuery.extend(opts,opts.noShadowOpts);}if(opts.shadow){if(opts.shadowBlur>Math.abs(opts.shadowOffsetX)){shadowMarginX=opts.shadowBlur*2;}else{shadowMarginX=opts.shadowBlur+Math.abs(opts.shadowOffsetX);}shadowShiftX=(opts.shadowBlur-opts.shadowOffsetX)>0?opts.shadowBlur-opts.shadowOffsetX:0;if(opts.shadowBlur>Math.abs(opts.shadowOffsetY)){shadowMarginY=opts.shadowBlur*2;}else{shadowMarginY=opts.shadowBlur+Math.abs(opts.shadowOffsetY);}shadowShiftY=(opts.shadowBlur-opts.shadowOffsetY)>0?opts.shadowBlur-opts.shadowOffsetY:0;}if(opts.offsetParent){var offsetParent=$(opts.offsetParent);var offsetParentPos=offsetParent.offset();var pos=$(this).offset();var top=numb(pos.top)-numb(offsetParentPos.top)+numb($(this).css("margin-top"))-shadowShiftY;var left=numb(pos.left)-numb(offsetParentPos.left)+numb($(this).css("margin-left"))-shadowShiftX;}else{var offsetParent=($(this).css("position")=="absolute")?$(this).parents().eq(0).offsetParent():$(this).offsetParent();var pos=$(this).btPosition();var top=numb(pos.top)+numb($(this).css("margin-top"))-shadowShiftY;var left=numb(pos.left)+numb($(this).css("margin-left"))-shadowShiftX;}var width=$(this).btOuterWidth();var height=$(this).outerHeight();if(typeof content=="object"){var original=content;var clone=$(original).clone(true).show();var origClones=$(original).data("bt-clones")||[];origClones.push(clone);$(original).data("bt-clones",origClones);$(clone).data("bt-orig",original);$(this).data("bt-content-orig",{original:original,clone:clone});content=clone;}if(typeof content=="null"||content==""){return;}var $text=$('<div class="bt-content"></div>').append(content).css({padding:opts.padding,position:"absolute",width:(opts.shrinkToFit?"auto":opts.width),zIndex:opts.textzIndex,left:shadowShiftX,top:shadowShiftY}).css(opts.cssStyles);var $box=$('<div class="bt-wrapper"></div>').append($text).addClass(opts.cssClass).css({position:"absolute",width:opts.width,zIndex:opts.wrapperzIndex,visibility:"hidden"}).appendTo(offsetParent);if(jQuery.fn.bgiframe){$text.bgiframe();$box.bgiframe();}$(this).data("bt-box",$box);var scrollTop=numb($(document).scrollTop());var scrollLeft=numb($(document).scrollLeft());var docWidth=numb($(window).width());var docHeight=numb($(window).height());var winRight=scrollLeft+docWidth;var winBottom=scrollTop+docHeight;var space=new Object();var thisOffset=$(this).offset();space.top=thisOffset.top-scrollTop;space.bottom=docHeight-((thisOffset+height)-scrollTop);space.left=thisOffset.left-scrollLeft;space.right=docWidth-((thisOffset.left+width)-scrollLeft);var textOutHeight=numb($text.outerHeight());var textOutWidth=numb($text.btOuterWidth());if(opts.positions.constructor==String){opts.positions=opts.positions.replace(/ /,"").split(",");}if(opts.positions[0]=="most"){var position="top";for(var pig in space){position=space[pig]>space[position]?pig:position;}}else{for(var x in opts.positions){var position=opts.positions[x];if((position=="left"||position=="right")&&space[position]>textOutWidth+opts.spikeLength){break;}else{if((position=="top"||position=="bottom")&&space[position]>textOutHeight+opts.spikeLength){break;}}}}var horiz=left+((width-textOutWidth)*0.5);var vert=top+((height-textOutHeight)*0.5);var points=new Array();var textTop,textLeft,textRight,textBottom,textTopSpace,textBottomSpace,textLeftSpace,textRightSpace,crossPoint,textCenter,spikePoint;switch(position){case"top":$text.css("margin-bottom",opts.spikeLength+"px");$box.css({top:(top-$text.outerHeight(true))+opts.overlap,left:horiz});textRightSpace=(winRight-opts.windowMargin)-($text.offset().left+$text.btOuterWidth(true));var xShift=shadowShiftX;if(textRightSpace<0){$box.css("left",(numb($box.css("left"))+textRightSpace)+"px");xShift-=textRightSpace;}textLeftSpace=($text.offset().left+numb($text.css("margin-left")))-(scrollLeft+opts.windowMargin);if(textLeftSpace<0){$box.css("left",(numb($box.css("left"))-textLeftSpace)+"px");xShift+=textLeftSpace;}textTop=$text.btPosition().top+numb($text.css("margin-top"));textLeft=$text.btPosition().left+numb($text.css("margin-left"));textRight=textLeft+$text.btOuterWidth();textBottom=textTop+$text.outerHeight();textCenter={x:textLeft+($text.btOuterWidth()*opts.centerPointX),y:textTop+($text.outerHeight()*opts.centerPointY)};points[points.length]=spikePoint={y:textBottom+opts.spikeLength,x:((textRight-textLeft)*0.5)+xShift,type:"spike"};crossPoint=findIntersectX(spikePoint.x,spikePoint.y,textCenter.x,textCenter.y,textBottom);crossPoint.x=crossPoint.x<textLeft+opts.spikeGirth/2+opts.cornerRadius?textLeft+opts.spikeGirth/2+opts.cornerRadius:crossPoint.x;crossPoint.x=crossPoint.x>(textRight-opts.spikeGirth/2)-opts.cornerRadius?(textRight-opts.spikeGirth/2)-opts.CornerRadius:crossPoint.x;points[points.length]={x:crossPoint.x-(opts.spikeGirth/2),y:textBottom,type:"join"};points[points.length]={x:textLeft,y:textBottom,type:"corner"};points[points.length]={x:textLeft,y:textTop,type:"corner"};points[points.length]={x:textRight,y:textTop,type:"corner"};points[points.length]={x:textRight,y:textBottom,type:"corner"};points[points.length]={x:crossPoint.x+(opts.spikeGirth/2),y:textBottom,type:"join"};points[points.length]=spikePoint;break;case"left":$text.css("margin-right",opts.spikeLength+"px");$box.css({top:vert+"px",left:((left-$text.btOuterWidth(true))+opts.overlap)+"px"});textBottomSpace=(winBottom-opts.windowMargin)-($text.offset().top+$text.outerHeight(true));var yShift=shadowShiftY;if(textBottomSpace<0){$box.css("top",(numb($box.css("top"))+textBottomSpace)+"px");yShift-=textBottomSpace;}textTopSpace=($text.offset().top+numb($text.css("margin-top")))-(scrollTop+opts.windowMargin);if(textTopSpace<0){$box.css("top",(numb($box.css("top"))-textTopSpace)+"px");yShift+=textTopSpace;}textTop=$text.btPosition().top+numb($text.css("margin-top"));textLeft=$text.btPosition().left+numb($text.css("margin-left"));textRight=textLeft+$text.btOuterWidth();textBottom=textTop+$text.outerHeight();textCenter={x:textLeft+($text.btOuterWidth()*opts.centerPointX),y:textTop+($text.outerHeight()*opts.centerPointY)};points[points.length]=spikePoint={x:textRight+opts.spikeLength,y:((textBottom-textTop)*0.5)+yShift,type:"spike"};crossPoint=findIntersectY(spikePoint.x,spikePoint.y,textCenter.x,textCenter.y,textRight);crossPoint.y=crossPoint.y<textTop+opts.spikeGirth/2+opts.cornerRadius?textTop+opts.spikeGirth/2+opts.cornerRadius:crossPoint.y;crossPoint.y=crossPoint.y>(textBottom-opts.spikeGirth/2)-opts.cornerRadius?(textBottom-opts.spikeGirth/2)-opts.cornerRadius:crossPoint.y;points[points.length]={x:textRight,y:crossPoint.y+opts.spikeGirth/2,type:"join"};points[points.length]={x:textRight,y:textBottom,type:"corner"};points[points.length]={x:textLeft,y:textBottom,type:"corner"};points[points.length]={x:textLeft,y:textTop,type:"corner"};points[points.length]={x:textRight,y:textTop,type:"corner"};points[points.length]={x:textRight,y:crossPoint.y-opts.spikeGirth/2,type:"join"};points[points.length]=spikePoint;break;case"bottom":$text.css("margin-top",opts.spikeLength+"px");$box.css({top:(top+height)-opts.overlap,left:horiz});textRightSpace=(winRight-opts.windowMargin)-($text.offset().left+$text.btOuterWidth(true));var xShift=shadowShiftX;if(textRightSpace<0){$box.css("left",(numb($box.css("left"))+textRightSpace)+"px");xShift-=textRightSpace;}textLeftSpace=($text.offset().left+numb($text.css("margin-left")))-(scrollLeft+opts.windowMargin);if(textLeftSpace<0){$box.css("left",(numb($box.css("left"))-textLeftSpace)+"px");xShift+=textLeftSpace;}textTop=$text.btPosition().top+numb($text.css("margin-top"));textLeft=$text.btPosition().left+numb($text.css("margin-left"));textRight=textLeft+$text.btOuterWidth();textBottom=textTop+$text.outerHeight();textCenter={x:textLeft+($text.btOuterWidth()*opts.centerPointX),y:textTop+($text.outerHeight()*opts.centerPointY)};points[points.length]=spikePoint={x:((textRight-textLeft)*0.5)+xShift,y:shadowShiftY,type:"spike"};crossPoint=findIntersectX(spikePoint.x,spikePoint.y,textCenter.x,textCenter.y,textTop);crossPoint.x=crossPoint.x<textLeft+opts.spikeGirth/2+opts.cornerRadius?textLeft+opts.spikeGirth/2+opts.cornerRadius:crossPoint.x;crossPoint.x=crossPoint.x>(textRight-opts.spikeGirth/2)-opts.cornerRadius?(textRight-opts.spikeGirth/2)-opts.cornerRadius:crossPoint.x;points[points.length]={x:crossPoint.x+opts.spikeGirth/2,y:textTop,type:"join"};points[points.length]={x:textRight,y:textTop,type:"corner"};points[points.length]={x:textRight,y:textBottom,type:"corner"};points[points.length]={x:textLeft,y:textBottom,type:"corner"};points[points.length]={x:textLeft,y:textTop,type:"corner"};points[points.length]={x:crossPoint.x-(opts.spikeGirth/2),y:textTop,type:"join"};points[points.length]=spikePoint;break;case"right":$text.css("margin-left",(opts.spikeLength+"px"));$box.css({top:vert+"px",left:((left+width)-opts.overlap)+"px"});textBottomSpace=(winBottom-opts.windowMargin)-($text.offset().top+$text.outerHeight(true));var yShift=shadowShiftY;if(textBottomSpace<0){$box.css("top",(numb($box.css("top"))+textBottomSpace)+"px");yShift-=textBottomSpace;}textTopSpace=($text.offset().top+numb($text.css("margin-top")))-(scrollTop+opts.windowMargin);if(textTopSpace<0){$box.css("top",(numb($box.css("top"))-textTopSpace)+"px");yShift+=textTopSpace;}textTop=$text.btPosition().top+numb($text.css("margin-top"));textLeft=$text.btPosition().left+numb($text.css("margin-left"));textRight=textLeft+$text.btOuterWidth();textBottom=textTop+$text.outerHeight();textCenter={x:textLeft+($text.btOuterWidth()*opts.centerPointX),y:textTop+($text.outerHeight()*opts.centerPointY)};points[points.length]=spikePoint={x:shadowShiftX,y:((textBottom-textTop)*0.5)+yShift,type:"spike"};crossPoint=findIntersectY(spikePoint.x,spikePoint.y,textCenter.x,textCenter.y,textLeft);crossPoint.y=crossPoint.y<textTop+opts.spikeGirth/2+opts.cornerRadius?textTop+opts.spikeGirth/2+opts.cornerRadius:crossPoint.y;crossPoint.y=crossPoint.y>(textBottom-opts.spikeGirth/2)-opts.cornerRadius?(textBottom-opts.spikeGirth/2)-opts.cornerRadius:crossPoint.y;points[points.length]={x:textLeft,y:crossPoint.y-opts.spikeGirth/2,type:"join"};points[points.length]={x:textLeft,y:textTop,type:"corner"};points[points.length]={x:textRight,y:textTop,type:"corner"};points[points.length]={x:textRight,y:textBottom,type:"corner"};points[points.length]={x:textLeft,y:textBottom,type:"corner"};points[points.length]={x:textLeft,y:crossPoint.y+opts.spikeGirth/2,type:"join"};points[points.length]=spikePoint;break;}var canvas=document.createElement("canvas");$(canvas).attr("width",(numb($text.btOuterWidth(true))+opts.strokeWidth*2+shadowMarginX)).attr("height",(numb($text.outerHeight(true))+opts.strokeWidth*2+shadowMarginY)).appendTo($box).css({position:"absolute",zIndex:opts.boxzIndex});if(typeof G_vmlCanvasManager!="undefined"){canvas=G_vmlCanvasManager.initElement(canvas);}if(opts.cornerRadius>0){var newPoints=new Array();var newPoint;for(var i=0;i<points.length;i++){if(points[i].type=="corner"){newPoint=betweenPoint(points[i],points[(i-1)%points.length],opts.cornerRadius);newPoint.type="arcStart";newPoints[newPoints.length]=newPoint;newPoints[newPoints.length]=points[i];newPoint=betweenPoint(points[i],points[(i+1)%points.length],opts.cornerRadius);newPoint.type="arcEnd";newPoints[newPoints.length]=newPoint;}else{newPoints[newPoints.length]=points[i];}}points=newPoints;}var ctx=canvas.getContext("2d");if(opts.shadow&&opts.shadowOverlap!==true){var shadowOverlap=numb(opts.shadowOverlap);switch(position){case"top":if(opts.shadowOffsetX+opts.shadowBlur-shadowOverlap>0){$box.css("top",(numb($box.css("top"))-(opts.shadowOffsetX+opts.shadowBlur-shadowOverlap)));}break;case"right":if(shadowShiftX-shadowOverlap>0){$box.css("left",(numb($box.css("left"))+shadowShiftX-shadowOverlap));}break;case"bottom":if(shadowShiftY-shadowOverlap>0){$box.css("top",(numb($box.css("top"))+shadowShiftY-shadowOverlap));}break;case"left":if(opts.shadowOffsetY+opts.shadowBlur-shadowOverlap>0){$box.css("left",(numb($box.css("left"))-(opts.shadowOffsetY+opts.shadowBlur-shadowOverlap)));}break;}}drawIt.apply(ctx,[points],opts.strokeWidth);ctx.fillStyle=opts.fill;if(opts.shadow){ctx.shadowOffsetX=opts.shadowOffsetX;ctx.shadowOffsetY=opts.shadowOffsetY;ctx.shadowBlur=opts.shadowBlur;ctx.shadowColor=opts.shadowColor;}ctx.closePath();ctx.fill();if(opts.strokeWidth>0){ctx.shadowColor="rgba(0, 0, 0, 0)";ctx.lineWidth=opts.strokeWidth;ctx.strokeStyle=opts.strokeStyle;ctx.beginPath();drawIt.apply(ctx,[points],opts.strokeWidth);ctx.closePath();ctx.stroke();}opts.preShow.apply(this,[$box[0]]);$box.css({display:"none",visibility:"visible"});opts.showTip.apply(this,[$box[0]]);if(opts.overlay){var overlay=$('<div class="bt-overlay"></div>').css({position:"absolute",backgroundColor:"blue",top:top,left:left,width:width,height:height,opacity:".2"}).appendTo(offsetParent);$(this).data("overlay",overlay);}if((opts.ajaxPath!=null&&opts.ajaxCache==false)||ajaxTimeout){content=false;}if(opts.clickAnywhereToClose){jQuery.bt.vars.clickAnywhereStack.push(this);$(document).click(jQuery.bt.docClick);}if(opts.closeWhenOthersOpen){jQuery.bt.vars.closeWhenOpenStack.push(this);}opts.postShow.apply(this,[$box[0]]);};this.btOff=function(){var box=$(this).data("bt-box");opts.preHide.apply(this,[box]);var i=this;i.btCleanup=function(){var box=$(i).data("bt-box");var contentOrig=$(i).data("bt-content-orig");var overlay=$(i).data("bt-overlay");if(typeof box=="object"){$(box).remove();$(i).removeData("bt-box");}if(typeof contentOrig=="object"){var clones=$(contentOrig.original).data("bt-clones");$(contentOrig).data("bt-clones",arrayRemove(clones,contentOrig.clone));}if(typeof overlay=="object"){$(overlay).remove();$(i).removeData("bt-overlay");}jQuery.bt.vars.clickAnywhereStack=arrayRemove(jQuery.bt.vars.clickAnywhereStack,i);jQuery.bt.vars.closeWhenOpenStack=arrayRemove(jQuery.bt.vars.closeWhenOpenStack,i);$(i).removeClass("bt-active "+opts.activeClass);opts.postHide.apply(i);};opts.hideTip.apply(this,[box,i.btCleanup]);};var refresh=this.btRefresh=function(){this.btOff();this.btOn();};});function drawIt(points,strokeWidth){this.moveTo(points[0].x,points[0].y);for(i=1;i<points.length;i++){if(points[i-1].type=="arcStart"){this.quadraticCurveTo(round5(points[i].x,strokeWidth),round5(points[i].y,strokeWidth),round5(points[(i+1)%points.length].x,strokeWidth),round5(points[(i+1)%points.length].y,strokeWidth));i++;}else{this.lineTo(round5(points[i].x,strokeWidth),round5(points[i].y,strokeWidth));}}}function round5(num,strokeWidth){var ret;strokeWidth=numb(strokeWidth);if(strokeWidth%2){ret=num;}else{ret=Math.round(num-0.5)+0.5;}return ret;}function numb(num){return parseInt(num)||0;}function arrayRemove(arr,elem){var x,newArr=new Array();for(x in arr){if(arr[x]!=elem){newArr.push(arr[x]);}}return newArr;}function canvasSupport(){var canvas_compatible=false;try{canvas_compatible=!!(document.createElement("canvas").getContext("2d"));}catch(e){canvas_compatible=!!(document.createElement("canvas").getContext);}return canvas_compatible;}function shadowSupport(){try{var userAgent=navigator.userAgent.toLowerCase();if(/webkit/.test(userAgent)){return true;}else{if(/gecko|mozilla/.test(userAgent)&&parseFloat(userAgent.match(/firefox\/(\d+(?:\.\d+)+)/)[1])>=3.1){return true;}}}catch(err){}return false;}function betweenPoint(point1,point2,dist){var y,x;if(point1.x==point2.x){y=point1.y<point2.y?point1.y+dist:point1.y-dist;return{x:point1.x,y:y};}else{if(point1.y==point2.y){x=point1.x<point2.x?point1.x+dist:point1.x-dist;return{x:x,y:point1.y};}}}function centerPoint(arcStart,corner,arcEnd){var x=corner.x==arcStart.x?arcEnd.x:arcStart.x;var y=corner.y==arcStart.y?arcEnd.y:arcStart.y;var startAngle,endAngle;if(arcStart.x<arcEnd.x){if(arcStart.y>arcEnd.y){startAngle=(Math.PI/180)*180;endAngle=(Math.PI/180)*90;}else{startAngle=(Math.PI/180)*90;endAngle=0;}}else{if(arcStart.y>arcEnd.y){startAngle=(Math.PI/180)*270;endAngle=(Math.PI/180)*180;}else{startAngle=0;endAngle=(Math.PI/180)*270;}}return{x:x,y:y,type:"center",startAngle:startAngle,endAngle:endAngle};}function findIntersect(r1x1,r1y1,r1x2,r1y2,r2x1,r2y1,r2x2,r2y2){if(r2x1==r2x2){return findIntersectY(r1x1,r1y1,r1x2,r1y2,r2x1);}if(r2y1==r2y2){return findIntersectX(r1x1,r1y1,r1x2,r1y2,r2y1);}var r1m=(r1y1-r1y2)/(r1x1-r1x2);var r1b=r1y1-(r1m*r1x1);var r2m=(r2y1-r2y2)/(r2x1-r2x2);var r2b=r2y1-(r2m*r2x1);var x=(r2b-r1b)/(r1m-r2m);var y=r1m*x+r1b;return{x:x,y:y};}function findIntersectY(r1x1,r1y1,r1x2,r1y2,x){if(r1y1==r1y2){return{x:x,y:r1y1};}var r1m=(r1y1-r1y2)/(r1x1-r1x2);var r1b=r1y1-(r1m*r1x1);var y=r1m*x+r1b;return{x:x,y:y};}function findIntersectX(r1x1,r1y1,r1x2,r1y2,y){if(r1x1==r1x2){return{x:r1x1,y:y};}var r1m=(r1y1-r1y2)/(r1x1-r1x2);var r1b=r1y1-(r1m*r1x1);var x=(y-r1b)/r1m;return{x:x,y:y};}};jQuery.fn.btPosition=function(){function num(elem,prop){return elem[0]&&parseInt(jQuery.curCSS(elem[0],prop,true),10)||0;}var left=0,top=0,results;if(this[0]){var offsetParent=this.offsetParent(),offset=this.offset(),parentOffset=/^body|html$/i.test(offsetParent[0].tagName)?{top:0,left:0}:offsetParent.offset();offset.top-=num(this,"marginTop");offset.left-=num(this,"marginLeft");parentOffset.top+=num(offsetParent,"borderTopWidth");parentOffset.left+=num(offsetParent,"borderLeftWidth");results={top:offset.top-parentOffset.top,left:offset.left-parentOffset.left};}return results;};jQuery.fn.btOuterWidth=function(margin){function num(elem,prop){return elem[0]&&parseInt(jQuery.curCSS(elem[0],prop,true),10)||0;}return this["innerWidth"]()+num(this,"borderLeftWidth")+num(this,"borderRightWidth")+(margin?num(this,"marginLeft")+num(this,"marginRight"):0);};jQuery.fn.btOn=function(){return this.each(function(index){if(jQuery.isFunction(this.btOn)){this.btOn();}});};jQuery.fn.btOff=function(){return this.each(function(index){if(jQuery.isFunction(this.btOff)){this.btOff();}});};jQuery.bt.vars={clickAnywhereStack:[],closeWhenOpenStack:[]};jQuery.bt.docClick=function(e){if(!e){var e=window.event;}if(!$(e.target).parents().andSelf().filter(".bt-wrapper, .bt-active").length&&jQuery.bt.vars.clickAnywhereStack.length){$(jQuery.bt.vars.clickAnywhereStack).btOff();$(document).unbind("click",jQuery.bt.docClick);}};jQuery.bt.defaults={trigger:"hover",clickAnywhereToClose:true,closeWhenOthersOpen:false,shrinkToFit:false,width:"200px",padding:"10px",spikeGirth:10,spikeLength:15,overlap:0,overlay:false,killTitle:true,textzIndex:9999,boxzIndex:9998,wrapperzIndex:9997,offsetParent:null,positions:["most"],fill:"rgb(255, 255, 102)",windowMargin:10,strokeWidth:1,strokeStyle:"#000",cornerRadius:5,centerPointX:0.5,centerPointY:0.5,shadow:false,shadowOffsetX:2,shadowOffsetY:2,shadowBlur:3,shadowColor:"#000",shadowOverlap:false,noShadowOpts:{strokeStyle:"#999"},cssClass:"",cssStyles:{},activeClass:"bt-active",contentSelector:"$(this).attr('title')",ajaxPath:null,ajaxError:"<strong>ERROR:</strong> <em>%error</em>",ajaxLoading:"<blink>Loading...</blink>",ajaxData:{},ajaxType:"GET",ajaxCache:true,ajaxOpts:{},preBuild:function(){},preShow:function(box){},showTip:function(box){$(box).show();},postShow:function(box){},preHide:function(box){},hideTip:function(box,callback){$(box).hide();callback();},postHide:function(){},hoverIntentOpts:{interval:300,timeout:500}};jQuery.bt.options={};})(jQuery);
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '69' };

// browserify support

if ( typeof module === 'object' ) {

	module.exports = THREE;

}

// polyfills

if ( Math.sign === undefined ) {

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

	};

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

	}

	return this.set( color )

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;
	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function ( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function ( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function ( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function ( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		   && ( Math.abs( m13 - m31 ) < epsilon )
		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			   && ( Math.abs( m13 + m31 ) < epsilon2 )
			   && ( Math.abs( m23 + m32 ) < epsilon2 )
			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						  + ( m13 - m31 ) * ( m13 - m31 )
						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		var clamp = THREE.Math.clamp;

		// q is assumed to be normalized

		// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

		var sqx = q.x * q.x;
		var sqy = q.y * q.y;
		var sqz = q.z * q.z;
		var sqw = q.w * q.w;

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ), - 1, 1 ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order ===  'YXZ' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ), - 1, 1 ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ), - 1, 1 ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZYX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ), - 1, 1 ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order === 'YZX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ), - 1, 1 ) );

		} else if ( order === 'XZY' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ), - 1, 1 ) );

		} else {

			console.warn( 'THREE.Euler: .setFromQuaternion() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};


	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix3( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	},

	clone: function () {

		return new THREE.Matrix3().fromArray( this.elements );

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix4( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	getPosition: function () {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.warn( 'THREE.Matrix4: .translate() has been removed.' );

	},

	rotateX: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateX() has been removed.' );

	},

	rotateY: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateY() has been removed.' );

	},

	rotateZ: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},

	rotateByAxis: function ( axis, angle ) {

		console.warn( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {
				sx = - sx;
			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
		var segDir = v1.clone().sub( v0 ).normalize();
		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var diff = this.origin.clone().sub( segCenter );
		var a01 = - this.direction.dot( segDir );
		var b0 = diff.dot( this.direction );
		var b1 = - diff.dot( segDir );
		var c = diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det >= 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

		}

		return sqrDist;

	},

	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	intersectSphere: function () {

		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

		var v1 = new THREE.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );

			var tca = v1.dot( this.direction );

			var d2 = v1.dot( v1 ) - tca * tca;

			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0 
			return this.at( t0, optionalTarget );

		}

	}(),

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;
		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;
		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;
		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

					uuid[ i ] = '-';

				} else if ( i == 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}
			}

			return uuid.join( '' );

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if ( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Sprite: {},
			Mesh: {},
			PointCloud: { threshold: 1 },
			LOD: {},
			Line: {}
		};

	};

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var intersectObject = function ( object, raycaster, intersects, recursive ) {

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	};

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		precision: 0.0001,
		linePrecision: 1,

		set: function ( origin, direction ) {

			this.ray.set( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( objects instanceof Array === false ) {

				console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = undefined;
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var scope = this;

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	var onRotationChange = function () {
		quaternion.setFromEuler( rotation, false );
	};

	var onQuaternionChange = function () {
		rotation.setFromQuaternion( quaternion, undefined, false );
	};

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
	} );

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get eulerOrder () {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		};

		if ( object === this ) {

			console.error( "THREE.Object3D.add:", object, "can't be added as a child of itself." );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add:", object, "is not an instance of THREE.Object3D." );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.remove( arguments[ i ] );

			}

		};

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getChildByName: function ( name, recursive ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getObjectById: function ( id, recursive ) {

		if ( this.id === id ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectById( id, recursive );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getObjectByName: function ( name, recursive ) {

		if ( this.name === name ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByName( name, recursive );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		}

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		}

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		}

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		}

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverseVisible( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.3,
				type: 'Object',
				generator: 'ObjectExporter'
			}
		};

		//

		var geometries = {};

		var parseGeometry = function ( geometry ) {

			if ( output.geometries === undefined ) {

				output.geometries = [];

			}

			if ( geometries[ geometry.uuid ] === undefined ) {

				var json = geometry.toJSON();

				delete json.metadata;

				geometries[ geometry.uuid ] = json;

				output.geometries.push( json );

			}

			return geometry.uuid;

		};

		//

		var materials = {};

		var parseMaterial = function ( material ) {

			if ( output.materials === undefined ) {

				output.materials = [];

			}

			if ( materials[ material.uuid ] === undefined ) {

				var json = material.toJSON();

				delete json.metadata;

				materials[ material.uuid ] = json;

				output.materials.push( json );

			}

			return material.uuid;

		};

		//

		var parseObject = function ( object ) {

			var data = {};

			data.uuid = object.uuid;
			data.type = object.type;

			if ( object.name !== '' ) data.name = object.name;
			if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
			if ( object.visible !== true ) data.visible = object.visible;

			if ( object instanceof THREE.PerspectiveCamera ) {

				data.fov = object.fov;
				data.aspect = object.aspect;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.OrthographicCamera ) {

				data.left = object.left;
				data.right = object.right;
				data.top = object.top;
				data.bottom = object.bottom;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.AmbientLight ) {

				data.color = object.color.getHex();

			} else if ( object instanceof THREE.DirectionalLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;

			} else if ( object instanceof THREE.PointLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;

			} else if ( object instanceof THREE.SpotLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;
				data.angle = object.angle;
				data.exponent = object.exponent;

			} else if ( object instanceof THREE.HemisphereLight ) {

				data.color = object.color.getHex();
				data.groundColor = object.groundColor.getHex();

			} else if ( object instanceof THREE.Mesh ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Line ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Sprite ) {

				data.material = parseMaterial( object.material );

			}

			data.matrix = object.matrix.toArray();

			if ( object.children.length > 0 ) {

				data.children = [];

				for ( var i = 0; i < object.children.length; i ++ ) {

					data.children.push( parseObject( object.children[ i ] ) );

				}

			}

			return data;

		}

		output.object = parseObject( this );

		return output;

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Projector.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Projector = function () {

	console.warn( 'THREE.Projector has been moved to /examples/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() has been removed.' );

	};

};

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );

		face.materialIndex = this.materialIndex;

		for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

			face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

			face.vertexColors[ i ] = this.vertexColors[ i ].clone();

		}

		for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

			face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		}

		return face;

	}

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

	this.array = array;
	this.itemSize = itemSize;

	this.needsUpdate = false;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get length () {

		return this.array.length;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

	},

	set: function ( value ) {

		this.array.set( value );

		return this;

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

	}

};

//

THREE.Int8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );


};

THREE.Int16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Int32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float64Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.attributes = {};
	this.attributesKeys = [];

	this.drawcalls = [];
	this.offsets = this.drawcalls; // backwards compatibility

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

			return;

		}

		this.attributes[ name ] = attribute;
		this.attributesKeys = Object.keys( this.attributes );

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	addDrawCall: function ( start, count, indexOffset ) {

		this.drawcalls.push( {

			start: start,
			count: count,
			index: indexOffset !== undefined ? indexOffset : 0

		} );

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

	},

	center: function () {

		// TODO

	},

	fromGeometry: function ( geometry, settings ) {

		settings = settings || { 'vertexColors': THREE.NoColors };

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var faceVertexUvs = geometry.faceVertexUvs;
		var vertexColors = settings.vertexColors;
		var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

		var positions = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		var normals = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

		if ( vertexColors !== THREE.NoColors ) {

			var colors = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		}

		if ( hasFaceVertexUv === true ) {

			var uvs = new Float32Array( faces.length * 3 * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		}

		for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

			var face = faces[ i ];

			var a = vertices[ face.a ];
			var b = vertices[ face.b ];
			var c = vertices[ face.c ];

			positions[ i3     ] = a.x;
			positions[ i3 + 1 ] = a.y;
			positions[ i3 + 2 ] = a.z;

			positions[ i3 + 3 ] = b.x;
			positions[ i3 + 4 ] = b.y;
			positions[ i3 + 5 ] = b.z;

			positions[ i3 + 6 ] = c.x;
			positions[ i3 + 7 ] = c.y;
			positions[ i3 + 8 ] = c.z;

			if ( hasFaceVertexNormals === true ) {

				var na = face.vertexNormals[ 0 ];
				var nb = face.vertexNormals[ 1 ];
				var nc = face.vertexNormals[ 2 ];

				normals[ i3     ] = na.x;
				normals[ i3 + 1 ] = na.y;
				normals[ i3 + 2 ] = na.z;

				normals[ i3 + 3 ] = nb.x;
				normals[ i3 + 4 ] = nb.y;
				normals[ i3 + 5 ] = nb.z;

				normals[ i3 + 6 ] = nc.x;
				normals[ i3 + 7 ] = nc.y;
				normals[ i3 + 8 ] = nc.z;

			} else {

				var n = face.normal;

				normals[ i3     ] = n.x;
				normals[ i3 + 1 ] = n.y;
				normals[ i3 + 2 ] = n.z;

				normals[ i3 + 3 ] = n.x;
				normals[ i3 + 4 ] = n.y;
				normals[ i3 + 5 ] = n.z;

				normals[ i3 + 6 ] = n.x;
				normals[ i3 + 7 ] = n.y;
				normals[ i3 + 8 ] = n.z;

			}

			if ( vertexColors === THREE.FaceColors ) {

				var fc = face.color;

				colors[ i3     ] = fc.r;
				colors[ i3 + 1 ] = fc.g;
				colors[ i3 + 2 ] = fc.b;

				colors[ i3 + 3 ] = fc.r;
				colors[ i3 + 4 ] = fc.g;
				colors[ i3 + 5 ] = fc.b;

				colors[ i3 + 6 ] = fc.r;
				colors[ i3 + 7 ] = fc.g;
				colors[ i3 + 8 ] = fc.b;

			} else if ( vertexColors === THREE.VertexColors ) {

				var vca = face.vertexColors[ 0 ];
				var vcb = face.vertexColors[ 1 ];
				var vcc = face.vertexColors[ 2 ];

				colors[ i3     ] = vca.r;
				colors[ i3 + 1 ] = vca.g;
				colors[ i3 + 2 ] = vca.b;

				colors[ i3 + 3 ] = vcb.r;
				colors[ i3 + 4 ] = vcb.g;
				colors[ i3 + 5 ] = vcb.b;

				colors[ i3 + 6 ] = vcc.r;
				colors[ i3 + 7 ] = vcc.g;
				colors[ i3 + 8 ] = vcc.b;

			}

			if ( hasFaceVertexUv === true ) {

				var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
				var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
				var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

				uvs[ i2     ] = uva.x;
				uvs[ i2 + 1 ] = uva.y;

				uvs[ i2 + 2 ] = uvb.x;
				uvs[ i2 + 3 ] = uvb.y;

				uvs[ i2 + 4 ] = uvc.x;
				uvs[ i2 + 5 ] = uvc.y;

			}

		}

		this.computeBoundingSphere()

		return this;

	},

	computeBoundingBox: function () {

		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var bb = this.boundingBox;
				bb.makeEmpty();

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					bb.expandByPoint( vector );

				}

			}

			if ( positions === undefined || positions.length === 0 ) {

				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

			}

		}

	}(),

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.expandByPoint( vector );

				}

				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

				}

			}

		}

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var attributes = this.attributes;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var normals = attributes.normal.array;

				for ( var i = 0, il = normals.length; i < il; i ++ ) {

					normals[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( attributes.index ) {

				var indices = attributes.index.array;

				var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

				for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = ( index + indices[ i     ] ) * 3;
						vB = ( index + indices[ i + 1 ] ) * 3;
						vC = ( index + indices[ i + 2 ] ) * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA     ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB     ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC     ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i     ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes.index === undefined ||
			 this.attributes.position === undefined ||
			 this.attributes.normal === undefined ||
			 this.attributes.uv === undefined ) {

			console.warn( 'Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
			return;

		}

		var indices = this.attributes.index.array;
		var positions = this.attributes.position.array;
		var normals = this.attributes.normal.array;
		var uvs = this.attributes.uv.array;

		var nVertices = positions.length / 3;

		if ( this.attributes.tangent === undefined ) {

			this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		var tangents = this.attributes.tangent.array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var vA = new THREE.Vector3(),
			vB = new THREE.Vector3(),
			vC = new THREE.Vector3(),

			uvA = new THREE.Vector2(),
			uvB = new THREE.Vector2(),
			uvC = new THREE.Vector2(),

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;

			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;

			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;

			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		if ( this.drawcalls.length === 0 ) {

			this.addDrawCall( 0, indices.length, 0 );

		}

		var drawcalls = this.drawcalls;

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4     ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

	},

	/*
		computeOffsets
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
	*/
	computeOffsets: function ( indexBufferSize ) {

		var size = indexBufferSize;
		if ( indexBufferSize === undefined )
			size = 65535; //WebGL limits type of index buffer values to 16-bit.

		var s = Date.now();

		var indices = this.attributes.index.array;
		var vertices = this.attributes.position.array;

		var verticesCount = ( vertices.length / 3 );
		var facesCount = ( indices.length / 3 );

		/*
		console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
		console.log("Faces to process: "+(indices.length/3));
		console.log("Reordering "+verticesCount+" vertices.");
		*/

		var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
		var indexPtr = 0;
		var vertexPtr = 0;

		var offsets = [ { start:0, count:0, index:0 } ];
		var offset = offsets[ 0 ];

		var duplicatedVertices = 0;
		var newVerticeMaps = 0;
		var faceVertices = new Int32Array( 6 );
		var vertexMap = new Int32Array( vertices.length );
		var revVertexMap = new Int32Array( vertices.length );
		for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

		/*
			Traverse every face and reorder vertices in the proper offsets of 65k.
			We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
		*/
		for ( var findex = 0; findex < facesCount; findex ++ ) {
			newVerticeMaps = 0;

			for ( var vo = 0; vo < 3; vo ++ ) {
				var vid = indices[ findex * 3 + vo ];
				if ( vertexMap[ vid ] == - 1 ) {
					//Unmapped vertice
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					newVerticeMaps ++;
				} else if ( vertexMap[ vid ] < offset.index ) {
					//Reused vertices from previous block (duplicate)
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					duplicatedVertices ++;
				} else {
					//Reused vertice in the current block
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
				}
			}

			var faceMax = vertexPtr + newVerticeMaps;
			if ( faceMax > ( offset.index + size ) ) {
				var new_offset = { start:indexPtr, count:0, index:vertexPtr };
				offsets.push( new_offset );
				offset = new_offset;

				//Re-evaluate reused vertices in light of new offset.
				for ( var v = 0; v < 6; v += 2 ) {
					var new_vid = faceVertices[ v + 1 ];
					if ( new_vid > - 1 && new_vid < offset.index )
						faceVertices[ v + 1 ] = - 1;
				}
			}

			//Reindex the face.
			for ( var v = 0; v < 6; v += 2 ) {
				var vid = faceVertices[ v ];
				var new_vid = faceVertices[ v + 1 ];

				if ( new_vid === - 1 )
					new_vid = vertexPtr ++;

				vertexMap[ vid ] = new_vid;
				revVertexMap[ new_vid ] = vid;
				sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
				offset.count ++;
			}
		}

		/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
		this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
		this.offsets = offsets;

		/*
		var orderTime = Date.now();
		console.log("Reorder time: "+(orderTime-s)+"ms");
		console.log("Duplicated "+duplicatedVertices+" vertices.");
		console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
		console.log("Draw offsets: "+offsets.length);
		*/

		return offsets;
	},

	merge: function () {

		console.log( 'BufferGeometry.merge(): TODO' );

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i     ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	/*
		reoderBuffers:
		Reorder attributes based on a new indexBuffer and indexMap.
		indexBuffer - Uint16Array of the new ordered indices.
		indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
		vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
	*/
	reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

		/* Create a copy of all attributes for reordering. */
		var sortedAttributes = {};
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			var sourceArray = this.attributes[ attr ].array;
			sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
		}

		/* Move attribute positions based on the new index map */
		for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
			var vid = indexMap[ new_vid ];
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var attrArray = this.attributes[ attr ].array;
				var attrSize = this.attributes[ attr ].itemSize;
				var sortedAttr = sortedAttributes[ attr ];
				for ( var k = 0; k < attrSize; k ++ )
					sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
			}
		}

		/* Carry the new sorted buffers locally */
		this.attributes[ 'index' ].array = indexBuffer;
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			this.attributes[ attr ].array = sortedAttributes[ attr ];
			this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
		}
	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type,
			data: {
				attributes: {}
			}
		};

		var attributes = this.attributes;
		var offsets = this.offsets;
		var boundingSphere = this.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = [], typeArray = attribute.array;

			for ( var i = 0, l = typeArray.length; i < l; i ++ ) {

				array[ i ] = typeArray[ i ];

			}

			output.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array
			}

		}

		if ( offsets.length > 0 ) {

			output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== null ) {

			output.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			}

		}

		return output;

	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			geometry.addAttribute( attr, sourceAttr.clone() );

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in Points and Line

	this.faces = [];

	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var attributes = geometry.attributes;

		var vertices = attributes.position.array;
		var indices = attributes.index !== undefined ? attributes.index.array : undefined;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

		var tempNormals = [];
		var tempUVs = [];

		for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

		}

		var addFace = function ( a, b, c ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );
			scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ], tempUVs[ b ], tempUVs[ c ] ] );

		};

		if ( indices !== undefined ) {

			for ( var i = 0; i < indices.length; i += 3 ) {

				addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

			}

		} else {

			for ( var i = 0; i < vertices.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}
		
		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = new THREE.Vector3();

		offset.addVectors( this.boundingBox.min, this.boundingBox.max );
		offset.multiplyScalar( - 0.5 );

		this.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		this.computeBoundingBox();

		return offset;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

			}

			return output;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = false; // face.materialIndex !== undefined;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );


			/*
			if ( hasMaterial ) {

				faces.push( face.materialIndex );

			}
			*/

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		output.data = {};

		output.data.vertices = vertices;
		output.data.normals = normals;
		if ( colors.length > 0 ) output.data.colors = colors;
		if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
		output.data.faces = faces;

		//

		return output;

	},

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	}

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function ( camera ) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.zoom = 1;

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.type = 'Light';
	
	this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

	this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'AreaLight';

	this.normal = new THREE.Vector3( 0, - 1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = - 500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = - 500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;

	light.shadowCameraLeft = this.shadowCameraLeft;
	light.shadowCameraRight = this.shadowCameraRight;
	light.shadowCameraTop = this.shadowCameraTop;
	light.shadowCameraBottom = this.shadowCameraBottom;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	//

	light.shadowCascade = this.shadowCascade;

	light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
	light.shadowCascadeCount = this.shadowCascadeCount;

	light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
	light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
	light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

	light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
	light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

	return light;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.type = 'HemisphereLight';

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance ) {

	THREE.Light.call( this, color );

	this.type = 'PointLight';

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;

	return light;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, color );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;
	light.shadowCameraFov = this.shadowCameraFov;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	return light;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = function () {

	this.files = {};

};

THREE.Cache.prototype = {

	constructor: THREE.Cache,

	add: function ( key, file ) {

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {}

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.imageLoader = new THREE.ImageLoader();

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	addStatusElement: function () {

		var e = document.createElement( 'div' );

		e.style.position = 'absolute';
		e.style.right = '0px';
		e.style.top = '0px';
		e.style.fontSize = '0.8em';
		e.style.textAlign = 'left';
		e.style.background = 'rgba(0,0,0,0.25)';
		e.style.color = '#fff';
		e.style.width = '120px';
		e.style.padding = '0.5em 0.5em 0.5em 0.5em';
		e.style.zIndex = 1000;

		e.innerHTML = 'Loading ...';

		return e;

	},

	updateProgress: function ( progress ) {

		var message = 'Loaded ';

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


		} else {

			message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for ( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var scope = this;

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var fullPath = texturePath + sourceFile;

			var texture;

			var loader = THREE.Loader.Handlers.get( fullPath );

			if ( loader !== null ) {

				texture = loader.load( fullPath );

			} else {

				texture = new THREE.Texture();

				loader = scope.imageLoader;
				loader.crossOrigin = scope.crossOrigin;
				loader.load( fullPath, function ( image ) {

					if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
						 THREE.Math.isPowerOfTwo( image.height ) === false ) {

						var width = nearest_pow2( image.width );
						var height = nearest_pow2( image.height );

						var canvas = document.createElement( 'canvas' );
						canvas.width = width;
						canvas.height = height;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, 0, 0, width, height );

						texture.image = canvas;

					} else {

						texture.image = image;

					}

					texture.needsUpdate = true;

				} );

			}

			texture.sourceFile = sourceFile;

			if ( repeat ) {

				texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				texture.offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					'repeat': THREE.RepeatWrapping,
					'mirror': THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				texture.anisotropy = anisotropy;

			}

			where[ name ] = texture;

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = 'MeshLambertMaterial';
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
			else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === 'face' ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		if ( m.colorEmissive ) {

			mpars.emissive = rgb2hex( m.colorEmissive );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		if ( m.mapAlpha && texturePath ) {

			create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ 'normalmap' ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ 'tNormal' ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ 'uNormalScale' ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ 'tDiffuse' ].value = mpars.map;
				uniforms[ 'enableDiffuse' ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ 'tSpecular' ].value = mpars.specularMap;
				uniforms[ 'enableSpecular' ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ 'tAO' ].value = mpars.lightMap;
				uniforms[ 'enableAO' ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ 'diffuse' ].value.setHex( mpars.color );
			uniforms[ 'specular' ].value.setHex( mpars.specular );
			uniforms[ 'ambient' ].value.setHex( mpars.ambient );

			uniforms[ 'shininess' ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ 'opacity' ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

			var regex = this.handlers[ i ];
			var loader  = this.handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) onLoad( cached );
			return;

		}

		var request = new XMLHttpRequest();
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			scope.cache.add( url, this.response );

			if ( onLoad ) onLoad( this.response );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
		if ( this.responseType !== undefined ) request.responseType = this.responseType;

		request.send( null );

		scope.manager.itemStart( url );

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			onLoad( cached );
			return;

		}

		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.cache.add( url, this );

				onLoad( this );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata !== undefined && json.metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
						return;

					}

					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					console.error( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( 'Content-Length' );

			}

		}

	};

	xhr.open( 'GET', url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i ++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i ++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	     = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i ++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i ++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {
		var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

		if ( json.skinWeights ) {

			for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

				var x =                               json.skinWeights[ i     ];
				var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
				var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
				var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

				var a =                               json.skinIndices[ i     ];
				var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
				var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
				var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;

		if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

		}


		// could change this to json.animations[0] or remove completely

		geometry.animation = json.animation;
		geometry.animations = json.animations;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined || json.materials.length === 0 ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new self[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

		}

		var offsets = json.offsets;

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		var boundingSphere = json.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;		
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Line':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Line( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Sprite( material );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function () {

	// override in sub classes
	this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

	constructor: THREE.CompressedTextureLoader,

	load: function ( url, onLoad, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader();
		loader.setResponseType( 'arraybuffer' );

		if ( url instanceof Array ) {

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

 						if (texDatas.mipmapCount == 1)
 							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				} );

			};

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			} );

		}

		return texture;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw' ) {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this instanceof THREE.MeshBasicMaterial ) {

			output.color = this.color.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshLambertMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshPhongMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			output.specular = this.specular.getHex();
			output.shininess = this.shininess;
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshNormalMaterial ) {

			if ( this.shading !== THREE.FlatShading ) output.shading = this.shading;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshDepthMaterial ) {

			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.ShaderMaterial ) {

			output.uniforms = this.uniforms;
			output.vertexShader = this.vertexShader;
			output.fragmentShader = this.fragmentShader;

		} else if ( this instanceof THREE.SpriteMaterial ) {

			output.color = this.color.getHex();

		}

		if ( this.opacity < 1 ) output.opacity = this.opacity;
		if ( this.transparent !== false ) output.transparent = this.transparent;
		if ( this.wireframe !== false ) output.wireframe = this.wireframe;

		return output;

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.morphTargets = false;
	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshFaceMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MeshFaceMaterial';
	
	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype = {

	constructor: THREE.MeshFaceMaterial,

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

			output.materials.push( this.materials[ i ].toJSON() );

		}

		return output;

	},

	clone: function () {

		var material = new THREE.MeshFaceMaterial();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		return material;

	}

};

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointCloudMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.PointCloudMaterial.prototype.clone = function () {

	var material = new THREE.PointCloudMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};
	this.attributes = null;

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

THREE.RawShaderMaterial.prototype.clone = function () {

	var material = new THREE.RawShaderMaterial();

	THREE.ShaderMaterial.prototype.clone.call( this, material );

	return material;

};

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.fog = this.fog;

	return material;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this._needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping();

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice( 0 );

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.images = images;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CubeTexture.clone = function ( texture ) {

	if ( texture === undefined ) texture = new THREE.CubeTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	texture.images = this.images;

	return texture;

};

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	var update = function () {

		requestAnimationFrame( update );

		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

			scope.needsUpdate = true;

		}

	};

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );

// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'PointCloud';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );

THREE.PointCloud.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();

	return function ( raycaster, intersects ) {

		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.PointCloud.threshold;

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

				return;

			}

		}

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var position = new THREE.Vector3();

		var testPoint = function ( point, index ) {

			var rayPointDistance = ray.distanceToPoint( point );

			if ( rayPointDistance < localThreshold ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				intersects.push( {

					distance: distance,
					distanceToRay: rayPointDistance,
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		};

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					var offset = {
						start: 0,
						count: indices.length,
						index: 0
					};

					offsets = [ offset ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i ++ ) {

						var a = index + indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				}

			} else {

				var pointCount = positions.length / 3;

				for ( var i = 0; i < pointCount; i ++ ) {

					position.set(
						positions[ 3 * i ],
						positions[ 3 * i + 1 ],
						positions[ 3 * i + 2 ]
					);

					testPoint( position, i );

				}

			}

		} else {

			var vertices = this.geometry.vertices;

			for ( var i = 0; i < vertices.length; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

THREE.PointCloud.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
	return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.mode = ( mode !== undefined ) ? mode : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	return function ( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		// Checking boundingSphere distance to ray

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		/* if ( geometry instanceof THREE.BufferGeometry ) {

		} else */ if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this.mode === THREE.LineStrip ? 1 : 2;

			for ( var i = 0; i < nbVertices - 1; i = i + step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				var distance = ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';
	
	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		var geometry = this.geometry;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		// Check boundingBox before continuing

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false )  {

				return;

			}

		}

		if ( geometry instanceof THREE.BufferGeometry ) {

			var material = this.material;

			if ( material === undefined ) return;

			var attributes = geometry.attributes;

			var a, b, c;
			var precision = raycaster.precision;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var positions = attributes.position.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					offsets = [ { start: 0, count: indices.length, index: 0 } ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						a = index + indices[ i ];
						b = index + indices[ i + 1 ];
						c = index + indices[ i + 2 ];

						vA.fromArray( positions, a * 3 );
						vB.fromArray( positions, b * 3 );
						vC.fromArray( positions, c * 3 );

						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this

						} );

					}

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

					a = i;
					b = i + 1;
					c = i + 2;

					vA.fromArray( positions, j );
					vB.fromArray( positions, j + 3 );
					vC.fromArray( positions, j + 6 );

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

					} else {

						var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
			var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

			var a, b, c, d;
			var precision = raycaster.precision;

			var vertices = geometry.vertices;

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];

				var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

				if ( material === undefined ) continue;

				a = vertices[ face.a ];
				b = vertices[ face.b ];
				c = vertices[ face.c ];

				if ( material.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.x += ( targets[ face.a ].x - a.x ) * influence;
						vA.y += ( targets[ face.a ].y - a.y ) * influence;
						vA.z += ( targets[ face.a ].z - a.z ) * influence;

						vB.x += ( targets[ face.b ].x - b.x ) * influence;
						vB.y += ( targets[ face.b ].y - b.y ) * influence;
						vB.z += ( targets[ face.b ].z - b.z ) * influence;

						vC.x += ( targets[ face.c ].x - c.x ) * influence;
						vC.y += ( targets[ face.c ].y - c.y ) * influence;
						vC.z += ( targets[ face.c ].z - c.z ) * influence;

					}

					vA.add( a );
					vB.add( b );
					vC.add( c );

					a = vA;
					b = vB;
					c = vC;

				}

				if ( material.side === THREE.BackSide ) {

					var intersectionPoint = ray.intersectTriangle( c, b, a, true );

				} else {

					var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

				}

				if ( intersectionPoint === null ) continue;

				intersectionPoint.applyMatrix4( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

				if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					point: intersectionPoint,
					face: face,
					faceIndex: f,
					object: this

				} );

			}

		}

	};

}() );

THREE.Mesh.prototype.clone = function ( object, recursive ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object, recursive );

	return object;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );


// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
		//       16x16 pixel texture max   64 bones (16 * 16 / 4)
		//       32x32 pixel texture max  256 bones (32 * 32 / 4)
		//       64x64 pixel texture max 1024 bones (64 * 64 / 4)

		var size;

		if ( this.bones.length > 256 )
			size = 64;
		else if ( this.bones.length > 64 )
			size = 32;
		else if ( this.bones.length > 16 )
			size = 16;
		else
			size = 8;

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
		this.boneTexture.minFilter = THREE.NearestFilter;
		this.boneTexture.magFilter = THREE.NearestFilter;
		this.boneTexture.generateMipmaps = false;
		this.boneTexture.flipY = false;

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

THREE.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new THREE.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

THREE.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

THREE.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new THREE.Matrix4();
	
	return function () {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}
		
	};

} )();


// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone, p, q, s;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
			bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

			if ( s !== undefined ) {

				bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

	}

};

THREE.SkinnedMesh.prototype.clone = function( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};


// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'MorphAnimMesh';

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = - 1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)_?(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( 'animation[' + label + '] undefined' );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= - 1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

	var influences = this.morphTargetInfluences;

	for ( var i = 0, l = influences.length; i < l; i ++ ) {

		influences[ i ] = 0;

	}

	if ( a > -1 ) influences[ a ] = 1 - t;
	if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.LOD();

	THREE.Object3D.prototype.clone.call( this, object );

	for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
		var x = this.objects[ i ].object.clone();
		x.visible = i === 0;
		object.addLevel( x, this.objects[ i ].distance );
	}

	return object;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	return function ( material ) {

		THREE.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

THREE.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.distanceToPoint( matrixPosition );

		if ( distance > this.scale.x ) {

			return;

		}

		intersects.push( {

			distance: distance,
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new THREE.Color( 0xffffff );
	if ( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture, 			// THREE.Texture
		size: size, 				// size in pixels (-1 = use texture.width)
		distance: distance, 		// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		scale: 1, 					// scale
		rotation: 1, 				// rotation
		opacity: opacity,			// opacity
		color: color,				// color
		blending: blending			// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};


// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call( this, object );

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n	mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	uniform samplerCube envMap;\n	uniform float flipEnvMap;\n	uniform int combine;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform bool useRefract;\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n	uniform bool useRefract;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	vec3 reflectVec;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		if ( useRefract ) {\n\n			reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		} else { \n\n			reflectVec = reflect( cameraToVertex, worldNormal );\n\n		}\n\n	#else\n\n		reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n		vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#else\n\n		vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		cubeColor.xyz *= cubeColor.xyz;\n\n	#endif\n\n	if ( combine == 1 ) {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n	} else if ( combine == 2 ) {\n\n		gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n	} else {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n	objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n	objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n	objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	if ( useRefract ) {\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	} else {\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#endif\n\n	#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#endif\n\n	#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },
		"alphaMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: - 1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

			"	#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

			"		if ( gl_FrontFacing )",
			"			gl_FragColor.xyz *= vLightFront;",
			"		else",
			"			gl_FragColor.xyz *= vLightBack;",

			"	#else",

			"		gl_FragColor.xyz *= vLightFront;",

			"	#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"	vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"#define PHONG",

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

			"	#ifdef USE_SIZEATTENUATION",
			"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
			"	#else",
			"		gl_PointSize = size;",
			"	#endif",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale"    : { type: "f", value: 1 },
				"dashSize" : { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vLineDistance = scale * lineDistance;",

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

			"		discard;",

			"	}",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

			"	#else",

			"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"	#endif",

			"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
			"	gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"          : { type: "i", value: 0 },
			"enableDiffuse"     : { type: "i", value: 0 },
			"enableSpecular"    : { type: "i", value: 0 },
			"enableReflection"  : { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"     : { type: "t", value: null },
			"tCube"        : { type: "t", value: null },
			"tNormal"      : { type: "t", value: null },
			"tSpecular"    : { type: "t", value: null },
			"tAO"          : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
			"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
			"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
			"shininess": { type: "f", value: 30 },
			"opacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"refractionRatio": { type: "f", value: 0.98 },
			"reflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB" : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float refractionRatio;",
			"uniform float reflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

			"	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

			"	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

			"	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

			"	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

			"	uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",
				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

			"	vec3 specularTex = vec3( 1.0 );",

			"	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
			"	normalTex.xy *= uNormalScale;",
			"	normalTex = normalize( normalTex );",

			"	if( enableDiffuse ) {",

			"		#ifdef GAMMA_INPUT",

			"			vec4 texelColor = texture2D( tDiffuse, vUv );",
			"			texelColor.xyz *= texelColor.xyz;",

			"			gl_FragColor = gl_FragColor * texelColor;",

			"		#else",

			"			gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

			"		#endif",

			"	}",

			"	if( enableAO ) {",

			"		#ifdef GAMMA_INPUT",

			"			vec4 aoColor = texture2D( tAO, vUv );",
			"			aoColor.xyz *= aoColor.xyz;",

			"			gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

			"		#else",

			"			gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

			"		#endif",

			"	}",
			
			THREE.ShaderChunk[ "alphatest_fragment" ],

			"	if( enableSpecular )",
			"		specularTex = texture2D( tSpecular, vUv ).xyz;",

			"	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
			"	vec3 finalNormal = tsb * normalTex;",

			"	#ifdef FLIP_SIDED",

			"		finalNormal = -finalNormal;",

			"	#endif",

			"	vec3 normal = normalize( finalNormal );",
			"	vec3 viewPosition = normalize( vViewPosition );",

				// point lights

			"	#if MAX_POINT_LIGHTS > 0",

			"		vec3 pointDiffuse = vec3( 0.0 );",
			"		vec3 pointSpecular = vec3( 0.0 );",

			"		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

			"			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
			"			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

			"			float pointDistance = 1.0;",
			"			if ( pointLightDistance[ i ] > 0.0 )",
			"				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

			"			pointVector = normalize( pointVector );",

						// diffuse

			"			#ifdef WRAP_AROUND",

			"				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
			"				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

			"				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

			"			#else",

			"				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

			"			#endif",

			"			pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

						// specular

			"			vec3 pointHalfVector = normalize( pointVector + viewPosition );",
			"			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
			"			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );",
			"			pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

			"		}",

			"	#endif",

				// spot lights

			"	#if MAX_SPOT_LIGHTS > 0",

			"		vec3 spotDiffuse = vec3( 0.0 );",
			"		vec3 spotSpecular = vec3( 0.0 );",

			"		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

			"			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
			"			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

			"			float spotDistance = 1.0;",
			"			if ( spotLightDistance[ i ] > 0.0 )",
			"				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

			"			spotVector = normalize( spotVector );",

			"			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

			"			if ( spotEffect > spotLightAngleCos[ i ] ) {",

			"				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );",

							// diffuse

			"				#ifdef WRAP_AROUND",

			"					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
			"					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

			"					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

			"				#else",

			"					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

			"				#endif",

			"				spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

							// specular

			"				vec3 spotHalfVector = normalize( spotVector + viewPosition );",
			"				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
			"				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

			"				float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );",
			"				spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

			"			}",

			"		}",

			"	#endif",

				// directional lights

			"	#if MAX_DIR_LIGHTS > 0",

			"		vec3 dirDiffuse = vec3( 0.0 );",
			"		vec3 dirSpecular = vec3( 0.0 );",

			"		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

			"			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"			vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

			"			#ifdef WRAP_AROUND",

			"				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
			"				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

			"				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

			"			#else",

			"				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

			"			#endif",

			"			dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

						// specular

			"			vec3 dirHalfVector = normalize( dirVector + viewPosition );",
			"			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
			"			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
			"			dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

			"		}",

			"	#endif",

				// hemisphere lights

			"	#if MAX_HEMI_LIGHTS > 0",

			"		vec3 hemiDiffuse = vec3( 0.0 );",
			"		vec3 hemiSpecular = vec3( 0.0 );" ,

			"		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

			"			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
			"			vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

			"			float dotProduct = dot( normal, lVector );",
			"			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

			"			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

			"			hemiDiffuse += diffuse * hemiColor;",

						// specular (sky light)


			"			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
			"			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
			"			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );",

						// specular (ground light)

			"			vec3 lVectorGround = -lVector;",

			"			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
			"			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
			"			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );",

			"			float dotProductGround = dot( normal, lVectorGround );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
			"			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
			"			hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

			"		}",

			"	#endif",

				// all lights contribution summation

			"	vec3 totalDiffuse = vec3( 0.0 );",
			"	vec3 totalSpecular = vec3( 0.0 );",

			"	#if MAX_DIR_LIGHTS > 0",

			"		totalDiffuse += dirDiffuse;",
			"		totalSpecular += dirSpecular;",

			"	#endif",

			"	#if MAX_HEMI_LIGHTS > 0",

			"		totalDiffuse += hemiDiffuse;",
			"		totalSpecular += hemiSpecular;",

			"	#endif",

			"	#if MAX_POINT_LIGHTS > 0",

			"		totalDiffuse += pointDiffuse;",
			"		totalSpecular += pointSpecular;",

			"	#endif",

			"	#if MAX_SPOT_LIGHTS > 0",

			"		totalDiffuse += spotDiffuse;",
			"		totalSpecular += spotSpecular;",

			"	#endif",

			"	#ifdef METAL",

			"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

			"	#else",

			"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

			"	#endif",

			"	if ( enableReflection ) {",

			"		vec3 vReflect;",
			"		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

			"		if ( useRefract ) {",

			"			vReflect = refract( cameraToVertex, normal, refractionRatio );",

			"		} else {",

			"			vReflect = reflect( cameraToVertex, normal );",

			"		}",

			"		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

			"		#ifdef GAMMA_INPUT",

			"			cubeColor.xyz *= cubeColor.xyz;",

			"		#endif",

			"		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

			"	}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

			"	uniform sampler2D tDisplacement;",
			"	uniform float uDisplacementScale;",
			"	uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

			"	#ifdef USE_SKINNING",

			"		vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

			"		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
			"		vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

			"	#else",

			"		vNormal = normalize( normalMatrix * normal );",
			"		vTangent = normalize( normalMatrix * tangent.xyz );",

			"	#endif",

			"	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

			"	vUv = uv * uRepeat + uOffset;",

				// displacement mapping

			"	vec3 displacedPosition;",

			"	#ifdef VERTEX_TEXTURES",

			"		if ( enableDisplacement ) {",

			"			vec3 dv = texture2D( tDisplacement, uv ).xyz;",
			"			float df = uDisplacementScale * dv.x + uDisplacementBias;",
			"			displacedPosition = position + normalize( normal ) * df;",

			"		} else {",

			"			#ifdef USE_SKINNING",

			"				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

			"				vec4 skinned = vec4( 0.0 );",
			"				skinned += boneMatX * skinVertex * skinWeight.x;",
			"				skinned += boneMatY * skinVertex * skinWeight.y;",
			"				skinned += boneMatZ * skinVertex * skinWeight.z;",
			"				skinned += boneMatW * skinVertex * skinWeight.w;",
			"				skinned  = bindMatrixInverse * skinned;",

			"				displacedPosition = skinned.xyz;",

			"			#else",

			"				displacedPosition = position;",

			"			#endif",

			"		}",

			"	#else",

			"		#ifdef USE_SKINNING",

			"			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

			"			vec4 skinned = vec4( 0.0 );",
			"			skinned += boneMatX * skinVertex * skinWeight.x;",
			"			skinned += boneMatY * skinVertex * skinWeight.y;",
			"			skinned += boneMatZ * skinVertex * skinWeight.z;",
			"			skinned += boneMatW * skinVertex * skinWeight.w;",
			"			skinned  = bindMatrixInverse * skinned;",

			"			displacedPosition = skinned.xyz;",

			"		#else",

			"			displacedPosition = position;",

			"		#endif",

			"	#endif",

				//

			"	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
			"	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				//

			"	vWorldPosition = worldPosition.xyz;",
			"	vViewPosition = -mvPosition.xyz;",

				// shadows

			"	#ifdef USE_SHADOWMAP",

			"		for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

			"			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"		}",

			"	#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
			"	vWorldPosition = worldPosition.xyz;",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join("\n")

	},

	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"vec4 pack_depth( const in float depth ) {",

			"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
			"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
			"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
			"	res -= res.xxyz * bit_mask;",
			"	return res;",

			"}",

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

			"	#else",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

			"	#endif",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];

	var _webglObjects = {};
	var _webglObjectsImmediate = [];

	var opaqueObjects = [];
	var transparentObjects = [];

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				 ? parameters.devicePixelRatio
				 : self.devicePixelRatio !== undefined
					 ? self.devicePixelRatio
					 : 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryGroupHash = - 1,
	_currentCamera = null,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = - 1,
	_oldFlipSided = - 1,

	_oldBlending = - 1,

	_oldBlendEquation = - 1,
	_oldBlendSrc = - 1,
	_oldBlendDst = - 1,

	_oldDepthTest = - 1,
	_oldDepthWrite = - 1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_newAttributes = new Uint8Array( 16 ),
	_enabledAttributes = new Uint8Array( 16 ),

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors:[], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	};

	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl') !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

	} catch ( error ) {

		console.error( error );

	}

	if ( _gl.getShaderPrecisionFormat === undefined ) {

		_gl.getShaderPrecisionFormat = function () {

			return {
				'rangeMin': 1,
				'rangeMax': 1,
				'precision': 1
			};

		}

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_standard_derivatives' );

	if ( _logarithmicDepthBuffer ) {

		extensions.get( 'EXT_frag_depth' );

	}

	//

	function setDefaultGLState() {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _supportsVertexTextures = _maxVertexTextures > 0;
	var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var getCompressedTextureFormats = ( function () {

		var array;

		return function () {

			if ( array !== undefined ) {

				return array;

			}

			array = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ){

					array.push( formats[ i ] );

				}

			}
			
			return array;

		};

	} )();

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === 'highp' && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = 'mediump';
			console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

		} else {

			_precision = 'lowp';
			console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

		}

	}

	if ( _precision === 'mediump' && ! mediumpAvailable ) {

		_precision = 'lowp';
		console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

	}

	// Plugins

	var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return extensions.get( 'OES_texture_float' );

	};

	this.supportsStandardDerivatives = function () {

		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	this.supportsCompressedTexturePVRTC = function () {

		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	this.supportsBlendMinMax = function () {

		return extensions.get( 'EXT_blend_minmax' );

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function () {

			if ( value !== undefined ) {

				return value;

			}

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

			return value;

		}

	} )();

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * this.devicePixelRatio;
		_viewportY = y * this.devicePixelRatio;

		_viewportWidth = width * this.devicePixelRatio;
		_viewportHeight = height * this.devicePixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * this.devicePixelRatio,
			y * this.devicePixelRatio,
			width * this.devicePixelRatio,
			height * this.devicePixelRatio
		);

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = function () {

		_currentProgram = null;
		_currentCamera = null;

		_oldBlending = - 1;
		_oldDepthTest = - 1;
		_oldDepthWrite = - 1;
		_oldDoubleSided = - 1;
		_oldFlipSided = - 1;
		_currentGeometryGroupHash = - 1;
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

	};

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onObjectRemoved = function ( event ) {

		var object = event.target;

		object.traverse( function ( child ) {

			child.removeEventListener( 'remove', onObjectRemoved );

			removeObject( child );

		} );

	};

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {
	
		var buffers = [
			'__webglVertexBuffer',
			'__webglNormalBuffer',
			'__webglTangentBuffer',
			'__webglColorBuffer',
			'__webglUVBuffer',
			'__webglUV2Buffer',
			
			'__webglSkinIndicesBuffer',
			'__webglSkinWeightsBuffer',
			
			'__webglFaceBuffer',
			'__webglLineBuffer',
			
			'__webglLineDistanceBuffer'
		];

		for ( var i = 0, l = buffers.length; i < l; i ++ ) {

			var name = buffers[ i ];

			if ( geometry[ name ] !== undefined ) {

				_gl.deleteBuffer( geometry[ name ] );

				delete geometry[ name ];

			}

		}

		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var name in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

			}

			delete geometry.__webglCustomAttributesList;

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		delete geometry.__webglInit;

		if ( geometry instanceof THREE.BufferGeometry ) {

			for ( var name in geometry.attributes ) {
			
				var attribute = geometry.attributes[ name ];

				if ( attribute.buffer !== undefined ) {

					_gl.deleteBuffer( attribute.buffer );

					delete attribute.buffer;

				}

			}

			_this.info.memory.geometries --;

		} else {

			var geometryGroupsList = geometryGroups[ geometry.id ];

			if ( geometryGroupsList !== undefined ) {

				for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphTargetsBuffers;

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphNormalsBuffers;

					}

					deleteBuffers( geometryGroup );

				}

				delete geometryGroups[ geometry.id ];

			} else {

				deleteBuffers( geometry );

			}

		}

		// TOFIX: Workaround for deleted geometry being currently bound

		_currentGeometryGroupHash = - 1;

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

			delete texture.image.__webglTextureCube;

		} else {

			// 2D texture

			if ( texture.__webglInit === undefined ) return;

			_gl.deleteTexture( texture.__webglTexture );

			delete texture.__webglTexture;
			delete texture.__webglInit;

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		delete renderTarget.__webglTexture;

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

		delete renderTarget.__webglFramebuffer;
		delete renderTarget.__webglRenderbuffer;

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( object ) {

		var geometry = object.geometry;
		var material = object.material;

		var nvertices = geometry.vertices.length;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				var attribute = material.attributes[ name ];

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes( object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes( object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
		geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
		geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
		geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

		if ( geometry.faceVertexUvs.length > 1 ) {

			geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

		geometryGroup.__typeArray = UintArray;
		geometryGroup.__faceArray = new UintArray( ntris * 3 );
		geometryGroup.__lineArray = new UintArray( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ name ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			 ? object.material.materials[ geometryGroup.materialIndex ]
			 : object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[ v ][ 1 ] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[ c ][ 1 ] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
							 customAttribute.boundTo === 'vertices' ) ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
						 customAttribute.boundTo === 'vertices' ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]    = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var needsSmoothNormals = materialNeedsSmoothNormals( material );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ]     = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ]     = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ]   = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === 'c' ) {

						pp = [ 'r', 'g', 'b' ];

					} else {

						pp = [ 'x', 'y', 'z' ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	function setDirectBuffers( geometry ) {

		var attributes = geometry.attributes;
		var attributesKeys = geometry.attributesKeys;

		for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

			var key = attributesKeys[ i ];
			var attribute = attributes[ key ];

			if ( attribute.buffer === undefined ) {

				attribute.buffer = _gl.createBuffer();
				attribute.needsUpdate = true;

			}

			if ( attribute.needsUpdate === true ) {

				var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

				_gl.bindBuffer( bufferType, attribute.buffer );
				_gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );

				attribute.needsUpdate = false;

			}

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		initAttributes();

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for ( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ]   = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.attributes;
		var programAttributesKeys = program.attributesKeys;

		for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

			var key = programAttributesKeys[ i ];
			var programAttribute = programAttributes[ key ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ key ];

				if ( geometryAttribute !== undefined ) {

					var size = geometryAttribute.itemSize;

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

					enableAttribute( programAttribute );

					_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

				} else if ( material.defaultAttributeValues !== undefined ) {

					if ( material.defaultAttributeValues[ key ].length === 2 ) {

						_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

					} else if ( material.defaultAttributeValues[ key ].length === 3 ) {

						_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var program = setProgram( camera, lights, fog, material, object );

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed triangles

				var type, size;

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 );

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
					_this.info.render.faces += index.array.length / 3;

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed triangles

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
						_this.info.render.faces += offsets[ i ].count / 3;

					}

				}

			} else {

				// non-indexed triangles

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes[ 'position' ];

				// render non-indexed triangles

				_gl.drawArrays( mode, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.array.length / 3;
				_this.info.render.faces += position.array.length / 9;

			}

		} else if ( object instanceof THREE.PointCloud ) {

			// render particles

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry, 0 );

			}

			var position = geometry.attributes.position;

			// render particles

			_gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );

			_this.info.render.calls ++;
			_this.info.render.points += position.array.length / 3;

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed lines

				var type, size;

				if ( index.array instanceof Uint32Array ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					if ( offsets.length > 1 ) updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed lines

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

					}

				}

			} else {

				// non-indexed lines

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes.position;

				_gl.drawArrays( mode, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.array.length / 3;

			}

		}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// vertices

		if ( ! material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					var attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 0 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 1 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		disableUnusedAttributes();

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );
				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.PointCloud ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function initAttributes() {

		for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

			_newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		_newAttributes[ attribute ] = 1;

		if ( _enabledAttributes[ attribute ] === 0 ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = 1;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

			if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {

				_gl.disableVertexAttribArray( i );
				_enabledAttributes[ i ] = 0;

			}

		}

	}

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ 'morphTarget' + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ 'morphTarget' + m ] );
					_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ 'morphNormal' + m ] );
					_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ 'morphTarget' + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ 'morphTarget' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ 'morphNormal' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	}

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.material.id !== b.material.id ) {

			return b.material.id - a.material.id;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryGroupHash = - 1;
		_currentMaterialId = - 1;
		_currentCamera = null;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		// update Skeleton objects

		scene.traverse( function ( object ) {

			if ( object instanceof THREE.SkinnedMesh ) {

				object.skeleton.update();

			}

		} );

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;
		opaqueObjects.length = 0;
		transparentObjects.length = 0;

		sprites.length = 0;
		lensFlares.length = 0;

		projectObject( scene, scene );

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		// custom render plugins (pre pass)

		shadowMapPlugin.render( scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for immediate objects

		for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

			var webglObject = _webglObjectsImmediate[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( opaqueObjects, camera, lights, fog, true, material );
			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( opaqueObjects, camera, lights, fog, false, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function projectObject( scene, object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

			// skip

		} else {

			initObject( object, scene );

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					updateObject( object, scene );

					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

						var webglObject = webglObjects[i];

						unrollBufferMaterial( webglObject );

						webglObject.render = true;

						if ( _this.sortObjects === true ) {

							if ( object.renderDepth !== null ) {

								webglObject.z = object.renderDepth;

							} else {

								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );

								webglObject.z = _vector3.z;

							}

						}

					}

				}

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( scene, object.children[ i ] );

		}

	}

	function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = renderList.length - 1; i !== - 1; i -- ) {

			var webglObject = renderList[ i ];

			var object = webglObject.object;
			var buffer = webglObject.buffer;

			setupMatrices( object, camera );

			if ( overrideMaterial ) {

				material = overrideMaterial;

			} else {

				material = webglObject.material;

				if ( ! material ) continue;

				if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

				_this.setDepthTest( material.depthTest );
				_this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			_this.setMaterialFaces( material );

			if ( buffer instanceof THREE.BufferGeometry ) {

				_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

			} else {

				_this.renderBuffer( camera, lights, fog, material, buffer, object );

			}

		}

	}

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			var webglObject = renderList[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	}

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = - 1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	}

	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		} else if ( material ) {

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		}

	}

	function initObject( object, scene ) {

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;
			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			object.addEventListener( 'removed', onObjectRemoved );

		}

		var geometry = object.geometry;

		if ( geometry === undefined ) {

			// ImmediateRenderObject

		} else if ( geometry.__webglInit === undefined ) {

			geometry.__webglInit = true;
			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry instanceof THREE.BufferGeometry ) {

				//

			} else if ( object instanceof THREE.Mesh ) {

				initGeometryGroups( scene, object, geometry );

			} else if ( object instanceof THREE.Line ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.PointCloud ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined) {

			object.__webglActive = true;

			if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( _webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					var geometryGroupsList = geometryGroups[ geometry.id ];

					for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

						addBuffer( _webglObjects, geometryGroupsList[ i ], object );

					}

				}

			} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

				addBuffer( _webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( _webglObjectsImmediate, object );

			}

		}

	}

	// Geometry splitting

	var geometryGroups = {};
	var geometryGroupCounter = 0;

	function makeGroups( geometry, usesFaceMaterial ) {

		var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

		var groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var group;
		var groups = {};
		var groupsList = [];

		for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			var face = geometry.faces[ f ];
			var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( ! ( materialIndex in hash_map ) ) {

				hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( ! ( groupHash in groups ) ) {

				group = {
					id: geometryGroupCounter ++,
					faces3: [],
					materialIndex: materialIndex,
					vertices: 0,
					numMorphTargets: numMorphTargets,
					numMorphNormals: numMorphNormals
				};
				
				groups[ groupHash ] = group;
				groupsList.push( group );

			}

			if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};
					
					groups[ groupHash ] = group;
					groupsList.push( group );

				}

			}

			groups[ groupHash ].faces3.push( f );
			groups[ groupHash ].vertices += 3;

		}

		return groupsList;

	}

	function initGeometryGroups( scene, object, geometry ) {

		var material = object.material, addBuffers = false;

		if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

			delete _webglObjects[ object.id ];

			geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

			geometry.groupsNeedUpdate = false;

		}

		var geometryGroupsList = geometryGroups[ geometry.id ];

		// create separate VBOs per geometry chunk

		for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

			var geometryGroup = geometryGroupsList[ i ];

			// initialise VBO on the first access

			if ( geometryGroup.__webglVertexBuffer === undefined ) {

				createMeshBuffers( geometryGroup );
				initMeshBuffers( geometryGroup, object );

				geometry.verticesNeedUpdate = true;
				geometry.morphTargetsNeedUpdate = true;
				geometry.elementsNeedUpdate = true;
				geometry.uvsNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				geometry.tangentsNeedUpdate = true;
				geometry.colorsNeedUpdate = true;

				addBuffers = true;

			} else {

				addBuffers = false;

			}

			if ( addBuffers || object.__webglActive === undefined ) {

				addBuffer( _webglObjects, geometryGroup, object );

			}

		}

		object.__webglActive = true;

	}

	function addBuffer( objlist, buffer, object ) {

		var id = object.id;
		objlist[id] = objlist[id] || [];
		objlist[id].push(
			{
				id: id,
				buffer: buffer,
				object: object,
				material: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object, scene ) {

		var geometry = object.geometry, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			if ( geometry.groupsNeedUpdate === true ) {

				initGeometryGroups( scene, object, geometry );

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.groupsNeedUpdate === true ) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );


		} else if ( object instanceof THREE.PointCloud ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	}

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var name in material.attributes ) {

			if ( material.attributes[ name ].needsUpdate ) return true;

		}

		return false;

	}

	function clearCustomAttributes( material ) {

		for ( var name in material.attributes ) {

			material.attributes[ name ].needsUpdate = false;

		}

	}

	// Objects removal

	function removeObject( object ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.PointCloud ||
			 object instanceof THREE.Line ) {

			delete _webglObjects[ object.id ];

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( _webglObjectsImmediate, object );

		}

		delete object.__webglInit;
		delete object._modelViewMatrix;
		delete object._normalMatrix;

		delete object.__webglActive;

	}

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	}

	// Materials

	function initMaterial( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.PointCloudMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			var shader = THREE.ShaderLib[ shaderID ];

			material.__webglShader = {
				uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			}

		} else {

			material.__webglShader = {
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			}

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );
		var maxShadows = allocateShadows( lights );
		var maxBones = allocateBones( object );

		var parameters = {

			precision: _precision,
			supportsVertexTextures: _supportsVertexTextures,

			map: !! material.map,
			envMap: !! material.envMap,
			lightMap: !! material.lightMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: _logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: _this.maxMorphTargets,
			maxMorphNormals: _this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
			shadowMapType: _this.shadowMapType,
			shadowMapDebug: _this.shadowMapDebug,
			shadowMapCascade: _this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		// Generate code

		var chunks = [];

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				chunks.push( name );
				chunks.push( material.defines[ name ] );

			}

		}

		for ( var name in parameters ) {

			chunks.push( name );
			chunks.push( parameters[ name ] );

		}

		var code = chunks.join();

		var program;

		// Check if code has been already compiled

		for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				program.usedTimes ++;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( _this, code, material, parameters );
			_programs.push( program );

			_this.info.memory.programs = _programs.length;

		}

		material.program = program;

		var attributes = program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = 'morphTarget';

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = 'morphNormal';

			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( var u in material.__webglShader.uniforms ) {

			var location = material.program.uniforms[ u ];

			if ( location ) {
				material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
			}

		}

	}

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === -1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( _logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) _currentCamera = camera;

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

			}

			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

			}

			if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.skeleton.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

				}

			} else if ( object.skeleton && object.skeleton.boneMatrices ) {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights );
					_lightsNeedUpdate = false;
				}

				if ( refreshLights ) {
					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );
				} else {
					markUniformsLightsNeedsUpdate( m_uniforms, false );
				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointCloudMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( material.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//  1. color map
		//  2. specular map
		//  3. normal map
		//  4. bump map
		//  5. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

		uniforms.ambientLightColor.needsUpdate = boolean;

		uniforms.directionalLightColor.needsUpdate = boolean;
		uniforms.directionalLightDirection.needsUpdate = boolean;

		uniforms.pointLightColor.needsUpdate = boolean;
		uniforms.pointLightPosition.needsUpdate = boolean;
		uniforms.pointLightDistance.needsUpdate = boolean;

		uniforms.spotLightColor.needsUpdate = boolean;
		uniforms.spotLightPosition.needsUpdate = boolean;
		uniforms.spotLightDistance.needsUpdate = boolean;
		uniforms.spotLightDirection.needsUpdate = boolean;
		uniforms.spotLightAngleCos.needsUpdate = boolean;
		uniforms.spotLightExponent.needsUpdate = boolean;

		uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
		uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
		uniforms.hemisphereLightDirection.needsUpdate = boolean;

	}

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit, offset;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 2;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 3;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 4;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
					   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						_this.setTexture( texture, textureUnit );

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	}

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	}

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_direction.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _direction.x;
				spotPositions[ spotOffset + 1 ] = _direction.y;
				spotPositions[ spotOffset + 2 ] = _direction.z;

				spotDistances[ spotLength ] = distance;

				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	}

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	}

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	}

	this.uploadTexture = function ( texture ) {

		if ( texture.__webglInit === undefined ) {

			texture.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			texture.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

		}

		_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, _maxTextureSize );

		var image = texture.image,
		isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "Attempt to load unsupported compressed texture format" );

					}

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else { // regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		texture.needsUpdate = false;

		if ( texture.onUpdate ) texture.onUpdate();

	};

	this.setTexture = function ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );

		if ( texture.needsUpdate ) {

			_this.uploadTexture( texture );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.log( 'THREE.WebGLRenderer:', image, 'is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height + '.' );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

									_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "Attempt to load unsupported compressed texture format" );

								}

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	}

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	}

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow || light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	}

	// DEPRECATED
	
	this.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	this.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	this.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	this.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	setSize: function ( width, height ) {

		this.width = width;
		this.height = height;

	},

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/webgl/WebGLExtensions.js

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {
		
			case 'OES_texture_float':
				extension = gl.getExtension( 'OES_texture_float' );
				break;

			case 'OES_texture_float_linear':
				extension = gl.getExtension( 'OES_texture_float_linear' );
				break;

			case 'OES_standard_derivatives':
				extension = gl.getExtension( 'OES_standard_derivatives' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			case 'OES_element_index_uint':
				extension = gl.getExtension( 'OES_element_index_uint' );
				break;

			case 'EXT_blend_minmax':
				extension = gl.getExtension( 'EXT_blend_minmax' );
				break;

			case 'EXT_frag_depth':
				extension = gl.getExtension( 'EXT_frag_depth' );
				break;

		}

		if ( extension === null ) {

			console.log( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	var generateDefines = function ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	var cacheUniformLocations = function ( gl, program, identifiers ) {

		var uniforms = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			uniforms[ id ] = gl.getUniformLocation( program, id );

		}

		return uniforms;

	};

	var cacheAttributeLocations = function ( gl, program, identifiers ) {

		var attributes = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			attributes[ id ] = gl.getAttribLocation( program, id );

		}

		return attributes;

	};

	return function ( renderer, code, material, parameters ) {

		var _this = renderer;
		var _gl = _this.context;

		var defines = material.defines;
		var uniforms = material.__webglShader.uniforms;
		var attributes = material.attributes;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var index0AttributeName = material.index0AttributeName;

		if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0

			index0AttributeName = 'position';

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		var program = _gl.createProgram();

		var prefix_vertex, prefix_fragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefix_vertex = '';
			prefix_fragment = '';

		} else {

			prefix_vertex = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				customDefines,

				parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				"#define MAX_BONES " + parameters.maxBones,

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.skinning ? "#define USE_SKINNING" : "",
				parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

				parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
				parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",


				"uniform mat4 modelMatrix;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform mat4 viewMatrix;",
				"uniform mat3 normalMatrix;",
				"uniform vec3 cameraPosition;",

				"attribute vec3 position;",
				"attribute vec3 normal;",
				"attribute vec2 uv;",
				"attribute vec2 uv2;",

				"#ifdef USE_COLOR",

				"	attribute vec3 color;",

				"#endif",

				"#ifdef USE_MORPHTARGETS",

				"	attribute vec3 morphTarget0;",
				"	attribute vec3 morphTarget1;",
				"	attribute vec3 morphTarget2;",
				"	attribute vec3 morphTarget3;",

				"	#ifdef USE_MORPHNORMALS",

				"		attribute vec3 morphNormal0;",
				"		attribute vec3 morphNormal1;",
				"		attribute vec3 morphNormal2;",
				"		attribute vec3 morphNormal3;",

				"	#else",

				"		attribute vec3 morphTarget4;",
				"		attribute vec3 morphTarget5;",
				"		attribute vec3 morphTarget6;",
				"		attribute vec3 morphTarget7;",

				"	#endif",

				"#endif",

				"#ifdef USE_SKINNING",

				"	attribute vec4 skinIndex;",
				"	attribute vec4 skinWeight;",

				"#endif",

				""

			].join( '\n' );

			prefix_fragment = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

				customDefines,

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
				( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.metal ? "#define METAL" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",

				"uniform mat4 viewMatrix;",
				"uniform vec3 cameraPosition;",
				""

			].join( '\n' );

		}

		var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
		var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		if ( index0AttributeName !== undefined ) {

			// Force a particular attribute to index 0.
			// because potentially expensive emulation is done by browser if attribute 0 is disabled.
			// And, color, for example is often automatically bound to index 0 so disabling it

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
			console.error( 'gl.getError()', _gl.getError() );

		}

		if ( _gl.getProgramInfoLog( program ) !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

		}

		// clean up

		_gl.deleteShader( glVertexShader );
		_gl.deleteShader( glFragmentShader );

		// cache uniform locations

		var identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition', 'morphTargetInfluences', 'bindMatrix', 'bindMatrixInverse'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		if ( parameters.logarithmicDepthBuffer ) {

			identifiers.push('logDepthBufFC');

		}


		for ( var u in uniforms ) {

			identifiers.push( u );

		}

		this.uniforms = cacheUniformLocations( _gl, program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( var a in attributes ) {

			identifiers.push( a );

		}

		this.attributes = cacheAttributeLocations( _gl, program, identifiers );
		this.attributesKeys = Object.keys( this.attributes );

		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	var addLineNumbers = function ( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	};

	return function ( gl, type, string ) {

		var shader = gl.createShader( type ); 

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ) );
			console.warn( addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var hasVertexTexture;

	var tempTexture, occlusionTexture;

	var init = function () {

		var vertices = new Float32Array( [
			-1, -1,  0, 0,
			 1, -1,  1, 0,
			 1,  1,  1, 1,
			-1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		gl.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

		var shader;

		if ( hasVertexTexture ) {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		} else {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"precision mediump float;",

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform sampler2D occlusionMap;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
							"visibility = ( 1.0 - visibility / 4.0 );",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * visibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		}

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		}

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	};

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.vertex );
		gl.enableVertexAttribArray( attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.disable( gl.CULL_FACE );
		gl.depthMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];
			
			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				gl.disable( gl.BLEND );
				gl.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				gl.activeTexture( gl.TEXTURE0 );
				gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				gl.disable( gl.DEPTH_TEST );

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				gl.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		gl.enable( gl.CULL_FACE );
		gl.enable( gl.DEPTH_TEST );
		gl.depthMask( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

	var _gl = _renderer.context;

	var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3(),
	
	_renderList = [];

	// init

	var depthShader = THREE.ShaderLib[ "depthRGBA" ];
	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

	_depthMaterial = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader
	 } );

	_depthMaterialMorph = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true
	} );

	_depthMaterialSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		skinning: true
	} );

	_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true,
		skinning: true
	} );

	_depthMaterial._shadowPass = true;
	_depthMaterialMorph._shadowPass = true;
	_depthMaterialSkin._shadowPass = true;
	_depthMaterialMorphSkin._shadowPass = true;

	this.render = function ( scene, camera ) {

		if ( _renderer.shadowMapEnabled === false ) return;

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = _lights.length; i < il; i ++ ) {

			light = _lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position.copy( light.shadowCascadeOffset );

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				scene.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			//

			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			//

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			_renderList.length = 0;

			projectObject( scene, scene, shadowCamera );


			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

				webglObject = _renderList[ j ];

				object = webglObject.object;
				buffer = webglObject.buffer;

				// culling is overriden globally for all objects
				// while rendering depth map

				// need to deal with MeshFaceMaterial somehow
				// in that case just use the first of material.materials for now
				// (proper solution would require to break objects by materials
				//  similarly to regular rendering and then set corresponding
				//  depth materials per each chunk instead of just once per object)

				objectMaterial = getObjectMaterial( object );

				useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				_renderer.setMaterialFaces( objectMaterial );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

				}

			}

			// set matrices and render immediate objects

			for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

				webglObject = _webglObjectsImmediate[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.resetGLState();

	};

	function projectObject( scene, object, shadowCamera ){

		if ( object.visible ) {

			var webglObjects = _webglObjects[ object.id ];

			if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

				for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

					var webglObject = webglObjects[ i ];

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( webglObject );

				}

			}

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( scene, object.children[ i ], shadowCamera );

			}

		}

	}

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
		pointsFrustum[ 1 ].set(  1, - 1, nearZ );
		pointsFrustum[ 2 ].set( - 1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( - 1, - 1, farZ );
		pointsFrustum[ 5 ].set(  1, - 1, farZ );
		pointsFrustum[ 6 ].set( - 1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( - Infinity, - Infinity, - Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			p.unproject( camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;
	
	var init = function () {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	};

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.position );
		gl.enableVertexAttribArray( attributes.uv );

		gl.disable( gl.CULL_FACE );
		gl.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		gl.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );

			if ( sprite.renderDepth === null ) {

				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

			} else {

				sprite.z = sprite.renderDepth;

			}

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			scale[ 0 ] = sprite.scale.x;
			scale[ 1 ] = sprite.scale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			renderer.setDepthTest( material.depthTest );
			renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				renderer.setTexture( material.map, 0 );

			} else {

				renderer.setTexture( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		gl.enable( gl.CULL_FACE );
		
		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}, undefined, function ( event ) {

			if ( onError ) onError( event );

		} );

		texture.sourceFile = url;

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.CubeTexture( images, mapping );

		// no flipping needed for cube textures

		texture.flipY = false;

		var loaded = 0;

		var loadTexture = function ( i ) {

			loader.load( array[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded += 1;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			} );

		}

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	   = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces: {},

	// Just for now. face[weight][style]

	face: 'helvetiker',
	weight: 'normal',
	style: 'normal',
	size: 150,
	divisions: 10,

	getFace: function () {

		try {

			return this.faces[ this.face ][ this.weight ][ this.style ];

		} catch (e) {

			throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

		};

	},

	loadFace: function ( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText: function ( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths: fontPaths, offset: width };

	},




	extractGlyphPoints: function ( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( ! glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch ( action ) {

				case 'm':

					// Move To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;
					path.lineTo( x,y );
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i ++ ] * scaleX + offset;
					cpy  = outline[ i ++ ] * scaleY;
					cpx1 = outline[ i ++ ] * scaleX + offset;
					cpy1 = outline[ i ++ ] * scaleY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i ++ ] *  scaleX + offset;
					cpy  = outline[ i ++ ] *  scaleY;
					cpx1 = outline[ i ++ ] *  scaleX + offset;
					cpy1 = outline[ i ++ ] *  scaleY;
					cpx2 = outline[ i ++ ] *  scaleX + offset;
					cpy2 = outline[ i ++ ] *  scaleY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha * scale, path:path };
	}

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

	// Parameters 

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

	var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
	var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
	var style = parameters.style !== undefined ? parameters.style : 'normal';

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function ( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v ++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for ( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count -- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( 'Warning, unable to triangulate polygon!' );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv --;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p ++ ) {

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			if ( ( ( px === ax ) && ( py === ay ) ) ||
				 ( ( px === bx ) && ( py === by ) ) ||
				 ( ( px === cx ) && ( py === cy ) ) )	continue;

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX * bpy - aY * bpx;
			cCROSSap = cX * apy - cY * apx;
			bCROSScp = bX * cpy - bY * cpx;

			if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );

THREE.Audio.prototype.load = function ( file ) {

	var scope = this;

	var request = new XMLHttpRequest();
	request.open( 'GET', file, true );
	request.responseType = 'arraybuffer';
	request.onload = function ( e ) {

		scope.context.decodeAudioData( this.response, function ( buffer ) {

			scope.source.buffer = buffer;
			scope.source.connect( scope.panner );
			scope.source.start( 0 );

		} );

	};
	request.send();

	return this;

};

THREE.Audio.prototype.setLoop = function ( value ) {

	this.source.loop = value;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	var orientation = new THREE.Vector3();
	var velocity = new THREE.Vector3();

	var positionPrev = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
		velocity.subVectors( position, positionPrev );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );
		listener.setVelocity( velocity.x, velocity.y, velocity.z );

		positionPrev.copy( position );

	};

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& ! this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return - 3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];
	
	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);
	
	if (! startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}
	
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getTangent( xNorm );
		normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


// File:src/extras/core/Gyroscope.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

	var translationObject = new THREE.Vector3();
	var quaternionObject = new THREE.Quaternion();
	var scaleObject = new THREE.Vector3();

	var translationWorld = new THREE.Vector3();
	var quaternionWorld = new THREE.Quaternion();
	var scaleWorld = new THREE.Vector3();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
				this.matrix.decompose( translationObject, quaternionObject, scaleObject );

				this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


			} else {

				this.matrixWorld.copy( this.matrix );

			}


			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	};
	
}() );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;
		  
		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var i, il, item, action, args;

		var subPaths = [], lastPath = new THREE.Path();

		for ( i = 0, il = inActions.length; i < il; i ++ ) {

			item = inActions[ i ];

			args = item.args;
			action = item.action;

			if ( action == THREE.PathActions.MOVE_TO ) {

				if ( lastPath.actions.length != 0 ) {

					subPaths.push( lastPath );
					lastPath = new THREE.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length != 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;
	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );
		}

		//console.log("shape", shapes);

		return shapes;
	};

	function isPointInsidePolygon( inPt, inPolygon ) {
		var EPSILON = 0.0000000001;

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
				if ( edgeDy < 0 ) {
					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y == edgeLowPt.y ) {
					if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!
				} else {
					var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
					if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt
				}
			} else {		// parallel or colinear
				if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
				// egde lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;
			}
		}

		return	inside;
	}


	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length == 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);
	
	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[mainIdx] = undefined;
	newShapeHoles[mainIdx] = [];

	var i, il;

	for ( i = 0, il = subPaths.length; i < il; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = THREE.Shape.Utils.isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;

			newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[mainIdx].s.actions = tmpPath.actions;
			newShapes[mainIdx].s.curves = tmpPath.curves;
			
			if ( holesFirst )	mainIdx ++;
			newShapeHoles[mainIdx] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {
		var ambigious = false;
		var toChange = [];

		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			betterShapeHoles[sIdx] = [];
		}
		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			var sh = newShapes[sIdx];
			var sho = newShapeHoles[sIdx];
			for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
				var ho = sho[hIdx];
				var hole_unassigned = true;
				for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
					if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
						if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {
							hole_unassigned = false;
							betterShapeHoles[s2Idx].push( ho );
						} else {
							ambigious = true;
						}
					}
				}
				if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
			}
		}
		// console.log("ambigious: ", ambigious);
		if ( toChange.length > 0 ) {
			// console.log("to change: ", toChange);
			if (! ambigious)	newShapeHoles = betterShapeHoles;
		}
	}

	var tmpHoles, j, jl;
	for ( i = 0, il = newShapes.length; i < il; i ++ ) {
		tmpShape = newShapes[i].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[i];
		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
			tmpShape.holes.push( tmpHoles[j].h );
		}
	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
			// inOtherPt needs to be colinear to the inSegment
			if ( inSegPt1.x != inSegPt2.x ) {
				if ( inSegPt1.x < inSegPt2.x ) {
					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
				} else {
					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
				}
			} else {
				if ( inSegPt1.y < inSegPt2.y ) {
					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
				} else {
					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
				}
			}
		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
			var EPSILON = 0.0000000001;

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs(limit) > EPSILON ) {			// not parallel

				var perpSeg2;
				if ( limit > 0 ) {
					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
				} else {
					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 == 0 ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt1 ];
				}
				if ( perpSeg2 == limit ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt2 ];
				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];
				if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {		// parallel or colinear
				if ( ( perpSeg1 != 0 ) ||
					 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
				var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {
					if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
						 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
					return  [ inSeg1Pt1 ];                 					// they are the same point
				}
				// segment#1  is a single point
				if ( seg1Pt ) {
					if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return  [ inSeg1Pt1 ];
				}
				// segment#2  is a single point
				if ( seg2Pt ) {
					if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return  [ inSeg2Pt1 ];
				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if (seg1dx != 0) {		// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
					}
				} else {				// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
					}
				}
				if ( seg1minVal <= seg2minVal ) {
					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal == seg2minVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];
				} else {
					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal == seg2maxVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];
				}
			}
		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
			// The order of legs is important

			var EPSILON = 0.0000000001;

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {				// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
				} else {								// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
				}
			} else {										// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );
			}
		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;
				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;
				}

				return	true;
			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {
				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
					nextIdx = sIdx+1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
					if ( intersection.length > 0 )		return	true;
				}

				return	false;
			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {
				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
					chkHole = holes[indepHoles[ihIdx]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
						nextIdx = hIdx+1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}
				}
				return	false;
			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {
				counter --;
				if ( counter < 0 ) {
					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;
				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {
						holeIdx = indepHoles[h];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[cutKey] !== undefined )			continue;

						hole = holes[holeIdx];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
							holePt = hole[ h2 ];
							if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice(h,1);

							tmpShape1 = shape.slice( 0, shapeIndex+1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex+1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[cutKey] = true;			// remember failure
					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found
				}
			}

			return shape; 			/* shape with no holes */
		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[h] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		return triangles;
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
	var point1 = points[ intPoint ]
	var point2 = points[ intPoint > points.length - 2 ? points.length -1 : intPoint + 1 ]
	var point3 = points[ intPoint > points.length - 3 ? points.length -1 : intPoint + 2 ]

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
	vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

	return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var vector = new THREE.Vector2();

	vector.x = this.aX + this.xRadius * Math.cos( angle );
	vector.y = this.aY + this.yRadius * Math.sin( angle );

	return vector;

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return vector;

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return vector;

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		var point0 = points[ ( intPoint - 1 ) % points.length ];
		var point1 = points[ ( intPoint     ) % points.length ];
		var point2 = points[ ( intPoint + 1 ) % points.length ];
		var point3 = points[ ( intPoint + 2 ) % points.length ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

	LINEAR: 0,
	CATMULLROM: 1,
	CATMULLROM_FORWARD: 2,

	//

	add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
	get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
	remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

	//

	animations: [],

	init: function ( data ) {

		if ( data.initialized === true ) return;

		// loop through all keys

		for ( var h = 0; h < data.hierarchy.length; h ++ ) {

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

					 data.hierarchy[ h ].keys[ k ].time = 0;

				}

				// create quaternions

				if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

				}

			}

			// prepare morph target keys

			if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = - 1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}

		data.initialized = true;

		return data;

	},

	parse: function ( root ) {

		var parseRecurseHierarchy = function ( root, hierarchy ) {

			hierarchy.push( root );

			for ( var c = 0; c < root.children.length; c ++ )
				parseRecurseHierarchy( root.children[ c ], hierarchy );

		};

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

				hierarchy.push( root.skeleton.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	},

	play: function ( animation ) {

		if ( this.animations.indexOf( animation ) === - 1 ) {

			this.animations.push( animation );

		}

	},

	stop: function ( animation ) {

		var index = this.animations.indexOf( animation );

		if ( index !== - 1 ) {

			this.animations.splice( index, 1 );

		}

	},

	update: function ( deltaTimeMS ) {

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].resetBlendWeights( );

		}

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].update( deltaTimeMS );

		}

	}

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

	this.root = root;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.loop = true;
	this.weight = 0;

	this.interpolationType = THREE.AnimationHandler.LINEAR;

};


THREE.Animation.prototype.keyTypes = [ "pos", "rot", "scl" ];


THREE.Animation.prototype.play = function ( startTime, weight ) {

	this.currentTime = startTime !== undefined ? startTime : 0;
	this.weight = weight !== undefined ? weight: 1;

	this.isPlaying = true;

	this.reset();

	THREE.AnimationHandler.play( this );

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;

	THREE.AnimationHandler.stop( this );

};

THREE.Animation.prototype.reset = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		object.matrixAutoUpdate = true;

		if ( object.animationCache === undefined ) {

			object.animationCache = {
				animations: {},
				blending: {
					positionWeight: 0.0,
					quaternionWeight: 0.0,
					scaleWeight: 0.0
				}
			};
		}

		if ( object.animationCache.animations[this.data.name] === undefined ) {

			object.animationCache.animations[this.data.name] = {};
			object.animationCache.animations[this.data.name].prevKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].nextKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].originalMatrix = object.matrix;

		}

		var animationCache = object.animationCache.animations[this.data.name];

		// Get keys to match our current time

		for ( var t = 0; t < 3; t ++ ) {

			var type = this.keyTypes[ t ];

			var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
			var nextKey = this.getNextKeyWith( type, h, 1 );

			while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

				prevKey = nextKey;
				nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

			}

			animationCache.prevKey[ type ] = prevKey;
			animationCache.nextKey[ type ] = nextKey;

		}

	}

};

THREE.Animation.prototype.resetBlendWeights = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		if ( object.animationCache !== undefined ) {

			object.animationCache.blending.positionWeight = 0.0;
			object.animationCache.blending.quaternionWeight = 0.0;
			object.animationCache.blending.scaleWeight = 0.0;

		}

	}

};

THREE.Animation.prototype.update = (function(){

	var points = [];
	var target = new THREE.Vector3();
	var newVector = new THREE.Vector3();
	var newQuat = new THREE.Quaternion();

	// Catmull-Rom spline

	var interpolateCatmullRom = function ( points, scale ) {

		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

		return v3;

	};

	var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

	return function ( delta ) {

		if ( this.isPlaying === false ) return;

		this.currentTime += delta * this.timeScale;

		if ( this.weight === 0 )
			return;

		//

		var duration = this.data.length;

		if ( this.currentTime > duration || this.currentTime < 0 ) {

			if ( this.loop ) {

				this.currentTime %= duration;

				if ( this.currentTime < 0 )
					this.currentTime += duration;

				this.reset();

			} else {

				this.stop();
				return;

			}

		}

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var object = this.hierarchy[ h ];
			var animationCache = object.animationCache.animations[this.data.name];
			var blending = object.animationCache.blending;

			// loop through pos/rot/scl

			for ( var t = 0; t < 3; t ++ ) {

				// get keys

				var type    = this.keyTypes[ t ];
				var prevKey = animationCache.prevKey[ type ];
				var nextKey = animationCache.nextKey[ type ];

				if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
					( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

					prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;

				var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

				var prevXYZ = prevKey[ type ];
				var nextXYZ = nextKey[ type ];

				if ( scale < 0 ) scale = 0;
				if ( scale > 1 ) scale = 1;

				// interpolate

				if ( type === "pos" ) {

					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

						newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

						// blend
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						object.position.lerp( newVector, proportionalWeight );
						blending.positionWeight += this.weight;

					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
								this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						points[ 1 ] = prevXYZ;
						points[ 2 ] = nextXYZ;
						points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

						scale = scale * 0.33 + 0.33;

						var currentPoint = interpolateCatmullRom( points, scale );
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						blending.positionWeight += this.weight;

						// blend

						var vector = object.position;
						
						vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
						vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
						vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

							var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

							target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							target.sub( vector );
							target.y = 0;
							target.normalize();

							var angle = Math.atan2( target.x, target.z );
							object.rotation.set( 0, angle, 0 );

						}

					}

				} else if ( type === "rot" ) {

					THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

					// Avoid paying the cost of an additional slerp if we don't have to
					if ( blending.quaternionWeight === 0 ) {

						object.quaternion.copy(newQuat);
						blending.quaternionWeight = this.weight;

					} else {

						var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
						THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
						blending.quaternionWeight += this.weight;

					}

				} else if ( type === "scl" ) {

					newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

					var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
					object.scale.lerp( newVector, proportionalWeight );
					blending.scaleWeight += this.weight;

				}

			}

		}

		return true;

	};

})();





// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key ++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

	this.root = data.node;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( this.root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s ++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};


THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h ++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.play( this );

};


THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;

	THREE.AnimationHandler.stop( this );

	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {
		
		var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			original.copy( obj.matrix );
			obj.matrix = original;

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

	if ( this.isPlaying === false ) return;

	this.currentTime += delta * this.timeScale;

	//

	var duration = this.data.length;

	if ( this.loop === true && this.currentTime > duration ) {

		this.currentTime %= duration;

	}

	this.currentTime = Math.min( this.currentTime, duration );

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;


		if ( keys.length ) {

			var prevKey = animationCache.prevKey;
			var nextKey = animationCache.nextKey;

			if ( nextKey.time <= this.currentTime ) {

				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

					prevKey = nextKey;
					nextKey = keys[ prevKey.index + 1 ];

				}

				animationCache.prevKey = prevKey;
				animationCache.nextKey = nextKey;

			}

			if ( nextKey.time >= this.currentTime ) {

				prevKey.interpolate( nextKey, this.currentTime );

			} else {

				prevKey.interpolate( nextKey, nextKey.time );

			}

			this.data.hierarchy[ h ].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key ++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key -- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 */

THREE.MorphAnimation = function ( mesh ) {

	this.mesh = mesh;
	this.frames = mesh.morphTargetInfluences.length;
	this.currentTime = 0;
	this.duration = 1000;
	this.loop = true;

	this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

	play: function () {

		this.isPlaying = true;

	},

	pause: function () {

		this.isPlaying = false;

	},

	update: ( function () {

		var lastFrame = 0;
		var currentFrame = 0;

		return function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );

			if ( frame != currentFrame ) {

				this.mesh.morphTargetInfluences[ lastFrame ] = 0;
				this.mesh.morphTargetInfluences[ currentFrame ] = 1;
				this.mesh.morphTargetInfluences[ frame ] = 0;

				lastFrame = currentFrame;
				currentFrame = frame;

			}

			this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			this.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

		}

	} )()

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var scope = this;

	var width_half = width / 2;
	var height_half = height / 2;
	var depth_half = depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CubeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	console.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
	return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

 };

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded
	};

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = radialSegments || 8;
	heightSegments = heightSegments || 1;

	openEnded = openEnded !== undefined ? openEnded : false;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( inPt, inPrev, inNext ) {

		var EPSILON = 0.0000000001;
		
		// computes for inPt the corresponding point inPt' on a new contour
		//   shiftet by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.
		
		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
		
		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
		
		// check for colinear edges
		var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
		if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
			
			// length of vectors for normalizing
	
			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
			
			// shift adjacent points by unit vectors to the left
	
			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
			
			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
			// scaling factor for v_prev to intersection point
	
			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			// vector from inPt to intersection point
	
			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
			if ( v_trans_lensq <= 2 ) {
				return	new THREE.Vector2( v_trans_x, v_trans_y );
			} else {
				shrink_by = Math.sqrt( v_trans_lensq / 2 );
			}
			
		} else {		// handle special case of colinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > EPSILON ) {
				if ( v_next_x > EPSILON ) { direction_eq = true; }
			} else {
				if ( v_prev_x < - EPSILON ) {
					if ( v_next_x < - EPSILON ) { direction_eq = true; }
				} else {
					if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
				}
			}

			if ( direction_eq ) {
				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );
			} else {
				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );
			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {
			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];
		} else {
			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];
		}
	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = widthSegments || 1;
	var gridY = heightSegments || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset     ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2     ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset     ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

		for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * (thetaSegments + 1);

		for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment;
			var v2 = segment + thetaSegments + 1;
			var v3 = segment + thetaSegments + 2;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment;
			v2 = segment + thetaSegments + 2;
			v3 = segment + 1;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );


// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength 
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < heightSegments; y ++ ) {

		for ( x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

	this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 8;
	tubularSegments = tubularSegments || 6;
	arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= radialSegments; j ++ ) {

		for ( var i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}

	for ( var j = 1; j <= radialSegments; j ++ ) {

		for ( var i = 1; i <= tubularSegments; i ++ ) {

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		p: p,
		q: q,
		heightScale: heightScale
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 64;
	tubularSegments = tubularSegments || 8;
	p = p || 2;
	q = q || 3;
	heightScale = heightScale || 1;
	
	var grid = new Array( radialSegments );
	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < radialSegments; ++ i ) {

		grid[ i ] = new Array( tubularSegments );
		var u = i / radialSegments * 2 * p * Math.PI;
		var p1 = getPos( u, q, p, radius, heightScale );
		var p2 = getPos( u + 0.01, q, p, radius, heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var v = j / tubularSegments * 2 * Math.PI;
			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			grid[ i ][ j ] = this.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < radialSegments; ++ i ) {

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % radialSegments;
			var jp = ( j + 1 ) % tubularSegments;

			var a = grid[ i ][ j ];
			var b = grid[ ip ][ j ];
			var c = grid[ ip ][ jp ];
			var d = grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// consruct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? (i + 1) % segments : i + 1;
			jp = (j + 1) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i     ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		-1, -1, -1,    -1, -1,  1,
		-1,  1, -1,    -1,  1,  1,
		 1, -1, -1,     1, -1,  1,
		 1,  1, -1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, -r, -t,     0, -r,  t,
		 0,  r, -t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		-r, -t,  0,    -r,  t,  0,
		 r, -t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		-t,  0, -r,     t,  0, -r,
		-t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

	return function ( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );

		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, length, 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;

	/*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/

	var vertices = this.geometry.attributes.position.array;

	vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
	vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

	vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
	vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

	vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
	vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

	vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
	vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

	//

	vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
	vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

	vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
	vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

	vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
	vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

	vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
	vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

	//

	vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
	vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

	vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
	vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

	vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
	vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

	vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
	vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

	this.geometry.attributes.position.needsUpdate = true;

	this.geometry.computeBoundingSphere();

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;
	
	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	var setPoint = function ( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	};

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3( - size,   size, 0 ),
		new THREE.Vector3(   size,   size, 0 ),
		new THREE.Vector3(   size, - size, 0 ),
		new THREE.Vector3( - size, - size, 0 ),
		new THREE.Vector3( - size,   size, 0 )
	);

	var material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(),
		new THREE.Vector3()
	);

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = new Float32Array( numEdges * 2 * 3 );

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = function () {

	var vertices = this.geometry.vertices;

	var object = this.object;
	var objectVertices = object.geometry.vertices;
	var objectFaces = object.geometry.faces;
	var objectWorldMatrix = object.matrixWorld;

	object.updateMatrixWorld( true );

	this.normalMatrix.getNormalMatrix( objectWorldMatrix );

	for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

		var face = objectFaces[ i ];

		vertices[ i2 ].copy( objectVertices[ face.a ] )
			.add( objectVertices[ face.b ] )
			.add( objectVertices[ face.c ] )
			.divideScalar( 3 )
			.applyMatrix4( objectWorldMatrix );

		vertices[ i2 + 1 ].copy( face.normal )
			.applyMatrix3( this.normalMatrix )
			.normalize()
			.multiplyScalar( this.size )
			.add( vertices[ i2 ] );

	}

	this.geometry.verticesNeedUpdate = true;

	return this;

};


// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0x0000ff;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	if ( object.geometry instanceof THREE.Geometry ) {

		var vertices = object.geometry.vertices;
		var faces = object.geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( object.geometry instanceof THREE.BufferGeometry ) {

		if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

			var vertices = object.geometry.attributes.position.array;
			var indices = object.geometry.attributes.index.array;
			var drawcalls = object.geometry.drawcalls;
			var numEdges = 0;

			if ( drawcalls.length === 0 ) {

				drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

				var start = drawcalls[ o ].start;
				var count = drawcalls[ o ].count;
				var index = drawcalls[ o ].index;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = index + indices[ i + j ];
						edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = 3 * edges[ 2 * i + j];
					coords[ index + 0 ] = vertices[ index2 ];
					coords[ index + 1 ] = vertices[ index2 + 1 ];
					coords[ index + 2 ] = vertices[ index2 + 2 ];

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else { // non-indexed BufferGeometry

			var vertices = object.geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};


/* JSModeler 0.32.183 - http://www.github.com/kovacsv/JSModeler */ 'use strict';var JSM={mainVersion:0,subVersion:32,Eps:1E-8,Inf:9999999999,RadDeg:57.29577951308232,DegRad:0.017453292519943,IsZero:function(a){return Math.abs(a)<JSM.Eps},IsPositive:function(a){return a>JSM.Eps},IsNegative:function(a){return a<-JSM.Eps},IsLower:function(a,b){return b-a>JSM.Eps},IsGreater:function(a,b){return a-b>JSM.Eps},IsEqual:function(a,b){return Math.abs(b-a)<JSM.Eps},IsEqualWithEps:function(a,b,c){return Math.abs(b-a)<c},IsLowerOrEqual:function(a,b){return JSM.IsLower(a,b)||
JSM.IsEqual(a,b)},IsGreaterOrEqual:function(a,b){return JSM.IsGreater(a,b)||JSM.IsEqual(a,b)},Minimum:function(a,b){return JSM.IsLower(a,b)?a:b},Maximum:function(a,b){return JSM.IsGreater(a,b)?a:b},ArcSin:function(a){return JSM.IsGreaterOrEqual(a,1)?Math.PI/2:JSM.IsLowerOrEqual(a,-1)?-Math.PI/2:Math.asin(a)},ArcCos:function(a){return JSM.IsGreaterOrEqual(a,1)?0:JSM.IsLowerOrEqual(a,-1)?Math.PI:Math.acos(a)},RandomNumber:function(a,b){return Math.random()*(b-a)+a},RandomInt:function(a,b){return Math.floor(Math.random()*
(b-a+1)+a)},SeededRandomInt:function(a,b,c){return Math.floor((9301*c+49297)%233280/233280*(b-a+1)+a)},ValueOrDefault:function(a,b){return void 0===a||null===a?b:a},Assert:function(a,b){if(!a){var c="Assertion failed.";void 0!==b&&null!==b&&(c+=" "+b);alert(c)}},Timer:function(){this.stop=this.start=0}};JSM.Timer.prototype.Start=function(){this.start=(new Date).getTime()};JSM.Timer.prototype.Stop=function(){this.end=(new Date).getTime()};JSM.Timer.prototype.Result=function(){return this.end-this.start};
JSM.FPSCounter=function(){this.current=this.frames=this.start=null};JSM.FPSCounter.prototype.Get=function(a){var b=(new Date).getTime();null===this.start&&(this.start=b,this.current=this.frames=0);if(null===a||void 0===a)a=1E3;this.frames+=1;var c=b-this.start;c>=a&&(this.current=1E3*(this.frames/c),this.start=b,this.frames=0);return parseInt(this.current,10)};
JSM.BubbleSort=function(a,b){if(!(2>a.length||void 0===b||null===b)){var c,d;for(c=0;c<a.length-1;c++)for(d=0;d<a.length-c-1;d++)if(!b(a[d],a[d+1])){var e=a,f=d+1,g=e[d];e[d]=e[f];e[f]=g}}};JSM.AsyncEnvironment=function(a){this.parameters=a};JSM.AsyncEnvironment.prototype.OnStart=function(a,b){if(void 0!==this.parameters&&void 0!==this.parameters.onStart)this.parameters.onStart(a,b)};
JSM.AsyncEnvironment.prototype.OnProcess=function(a,b){if(void 0!==this.parameters&&void 0!==this.parameters.onProcess)this.parameters.onProcess(a,b)};JSM.AsyncEnvironment.prototype.OnFinish=function(a){if(void 0!==this.parameters&&void 0!==this.parameters.onFinish)this.parameters.onFinish(a)};
JSM.AsyncRunTask=function(a,b,c,d,e){function f(g){var h=a();b.OnProcess(g,e);h&&g<c-1?setTimeout(function(){f(g+1)},d):setTimeout(function(){b.OnFinish(e)},d)}if(void 0===b||null===b){var g,h;for(g=0;g<c&&!(h=a(),!h);g++);}else b.OnStart(c,e),f(0)};JSM.Coord2D=function(a,b){this.x=a;this.y=b};JSM.Coord2D.prototype.Set=function(a,b){this.x=a;this.y=b};JSM.Coord2D.prototype.ToString=function(){return"("+this.x+", "+this.y+")"};JSM.Coord2D.prototype.Clone=function(){return new JSM.Coord2D(this.x,this.y)};
JSM.PolarCoord=function(a,b){this.radius=a;this.angle=b};JSM.PolarCoord.prototype.Set=function(a,b){this.radius=a;this.angle=b};JSM.PolarCoord.prototype.ToString=function(){return"("+this.radius+", "+this.angle+")"};JSM.PolarCoord.prototype.Clone=function(){return new JSM.PolarCoord(this.radius,this.angle)};JSM.Coord=function(a,b,c){this.x=a;this.y=b;this.z=c};JSM.Coord.prototype.Set=function(a,b,c){this.x=a;this.y=b;this.z=c};
JSM.Coord.prototype.ToString=function(){return"("+this.x+", "+this.y+", "+this.z+")"};JSM.Coord.prototype.Clone=function(){return new JSM.Coord(this.x,this.y,this.z)};JSM.SphericalCoord=function(a,b,c){this.radius=a;this.theta=b;this.phi=c};JSM.SphericalCoord.prototype.Set=function(a,b,c){this.radius=a;this.theta=b;this.phi=c};JSM.SphericalCoord.prototype.ToString=function(){return"("+this.radius+", "+this.theta+", "+this.phi+")"};
JSM.SphericalCoord.prototype.Clone=function(){return new JSM.SphericalCoord(this.radius,this.theta,this.phi)};JSM.Vector2D=JSM.Coord2D;JSM.Vector=JSM.Coord;JSM.MatrixDeterminant2x2=function(a,b,c,d){return a*d-b*c};JSM.MatrixDeterminant3x3=function(a,b,c,d,e,f,g,h,l){var k=JSM.MatrixDeterminant2x2(e,f,h,l);f=JSM.MatrixDeterminant2x2(d,f,g,l);d=JSM.MatrixDeterminant2x2(d,e,g,h);return a*k-b*f+c*d};
JSM.MatrixDeterminant4x4=function(a,b,c,d,e,f,g,h,l,k,m,n,p,q,r,s){var x=JSM.MatrixDeterminant3x3(f,g,h,k,m,n,q,r,s),v=JSM.MatrixDeterminant3x3(e,g,h,l,m,n,p,r,s);h=JSM.MatrixDeterminant3x3(e,f,h,l,k,n,p,q,s);e=JSM.MatrixDeterminant3x3(e,f,g,l,k,m,p,q,r);return x*a-v*b+h*c-e*d};JSM.CoordFromArray2D=function(a){return new JSM.Coord2D(a[0],a[1])};JSM.CoordFromArray=function(a){return new JSM.Coord(a[0],a[1],a[2])};JSM.CoordIsEqual2D=function(a,b){return JSM.IsEqual(a.x,b.x)&&JSM.IsEqual(a.y,b.y)};
JSM.CoordIsEqual2DWithEps=function(a,b,c){return JSM.IsEqualWithEps(a.x,b.x,c)&&JSM.IsEqualWithEps(a.y,b.y,c)};JSM.CoordDistance2D=function(a,b){var c=a.x,d=a.y,e=b.x,f=b.y;return Math.sqrt((e-c)*(e-c)+(f-d)*(f-d))};JSM.MidCoord2D=function(a,b){return new JSM.Coord2D((a.x+b.x)/2,(a.y+b.y)/2)};JSM.PolarToCartesian=function(a,b){var c=new JSM.Coord2D(0,0);c.x=a*Math.cos(b);c.y=a*Math.sin(b);return c};JSM.GetArcLengthFromAngle=function(a,b){return b*a};
JSM.GetAngleFromArcLength=function(a,b){return JSM.IsEqual(a,0)?0:b/a};JSM.CoordTurnType2D=function(a,b,c){a=JSM.MatrixDeterminant3x3(a.x,a.y,1,b.x,b.y,1,c.x,c.y,1);return JSM.IsPositive(a)?"CounterClockwise":JSM.IsNegative(a)?"Clockwise":"Collinear"};JSM.CoordIsEqual=function(a,b){return JSM.IsEqual(a.x,b.x)&&JSM.IsEqual(a.y,b.y)&&JSM.IsEqual(a.z,b.z)};JSM.CoordIsEqualWithEps=function(a,b,c){return JSM.IsEqualWithEps(a.x,b.x,c)&&JSM.IsEqualWithEps(a.y,b.y,c)&&JSM.IsEqualWithEps(a.z,b.z,c)};
JSM.SphericalCoordIsEqual=function(a,b){return JSM.IsEqual(a.radius,b.radius)&&JSM.IsEqual(a.phi,b.phi)&&JSM.IsEqual(a.theta,b.theta)};JSM.CoordDistance=function(a,b){var c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;return Math.sqrt((f-c)*(f-c)+(g-d)*(g-d)+(h-e)*(h-e))};JSM.CoordSignedDistance=function(a,b,c){var d=JSM.CoordSub(b,a);a=JSM.CoordDistance(a,b);c=JSM.GetVectorsAngle(d,c);JSM.IsPositive(c)&&(a=-a);return a};JSM.MidCoord=function(a,b){return new JSM.Coord((a.x+b.x)/2,(a.y+b.y)/2,(a.z+b.z)/2)};
JSM.VectorMultiply=function(a,b){var c=new JSM.Vector(0,0,0);c.x=a.x*b;c.y=a.y*b;c.z=a.z*b;return c};JSM.VectorDot=function(a,b){return a.x*b.x+a.y*b.y+a.z*b.z};JSM.VectorCross=function(a,b){var c=new JSM.Vector(0,0,0);c.x=a.y*b.z-a.z*b.y;c.y=a.z*b.x-a.x*b.z;c.z=a.x*b.y-a.y*b.x;return c};JSM.VectorLength=function(a){var b=a.x,c=a.y;a=a.z;return Math.sqrt(b*b+c*c+a*a)};
JSM.VectorNormalize=function(a){var b=JSM.VectorLength(a),c=new JSM.Vector(0,0,0);JSM.IsGreater(b,0)&&(c=JSM.VectorMultiply(a,1/b));return c};JSM.VectorSetLength=function(a,b){var c=b/JSM.VectorLength(a);return JSM.VectorMultiply(a,c)};JSM.GetVectorsAngle=function(a,b){var c=JSM.VectorNormalize(a),d=JSM.VectorNormalize(b);if(JSM.CoordIsEqual(c,d))return 0;c=JSM.VectorDot(c,d);return JSM.ArcCos(c)};
JSM.GetVectorsFullAngle=function(a,b,c){var d=JSM.GetVectorsAngle(a,b),e=new JSM.Coord(0,0,0);"Clockwise"==JSM.CoordTurnType(a,e,b,c)&&(d=2*Math.PI-d);return d};JSM.VectorsAreCollinear=function(a,b){var c=JSM.GetVectorsAngle(a,b);return JSM.IsEqual(c,0)||JSM.IsEqual(c,Math.PI)};JSM.CoordAdd=function(a,b){return new JSM.Vector(a.x+b.x,a.y+b.y,a.z+b.z)};JSM.CoordSub=function(a,b){return new JSM.Vector(a.x-b.x,a.y-b.y,a.z-b.z)};
JSM.CoordOffset=function(a,b,c){b=JSM.VectorNormalize(b);var d=new JSM.Coord(0,0,0);d.x=a.x+b.x*c;d.y=a.y+b.y*c;d.z=a.z+b.z*c;return d};
JSM.CoordRotate=function(a,b,c,d){var e=JSM.CoordSub(a,d),f=JSM.VectorNormalize(b);b=f.x;a=f.y;var f=f.z,g=e.x,h=e.y,e=e.z,l=new JSM.Coord(0,0,0);l.x=-b*(-b*g-a*h-f*e)*(1-Math.cos(c))+g*Math.cos(c)+(-f*h+a*e)*Math.sin(c);l.y=-a*(-b*g-a*h-f*e)*(1-Math.cos(c))+h*Math.cos(c)+(f*g-b*e)*Math.sin(c);l.z=-f*(-b*g-a*h-f*e)*(1-Math.cos(c))+e*Math.cos(c)+(-a*g+b*h)*Math.sin(c);return l=JSM.CoordAdd(l,d)};
JSM.GetCoord2DFromCoord=function(a,b,c){var d=new JSM.Vector(0,0,1),e=JSM.VectorCross(c,d);c=JSM.GetVectorsAngle(c,d);a=JSM.CoordRotate(a,e,c,b);return new JSM.Coord2D(a.x,a.y)};
JSM.CoordTurnType=function(a,b,c,d){var e=new JSM.Coord(0,0,0);a=JSM.GetCoord2DFromCoord(a,e,d);b=JSM.GetCoord2DFromCoord(b,e,d);c=JSM.GetCoord2DFromCoord(c,e,d);c=JSM.CoordTurnType2D(a,b,c);e=new JSM.Vector(0,0,1);d=JSM.GetVectorsAngle(d,e);JSM.IsEqual(d,Math.PI)&&("CounterClockwise"===c?c="Clockwise":"Clockwise"===c&&(c="CounterClockwise"));return c};
JSM.CalculateCentroid=function(a){var b=a.length,c=new JSM.Coord(0,0,0);if(1<=b){var d;for(d=0;d<b;d++)c=JSM.CoordAdd(c,a[d]);c=JSM.VectorMultiply(c,1/b)}return c};JSM.CalculateTriangleNormal=function(a,b,c){b=JSM.CoordSub(b,a);a=JSM.CoordSub(c,a);c=new JSM.Vector(0,0,0);c.x=b.y*a.z-b.z*a.y;c.y=b.z*a.x-b.x*a.z;c.z=b.x*a.y-b.y*a.x;return JSM.VectorNormalize(c)};
JSM.CalculateNormal=function(a){var b=a.length,c=new JSM.Vector(0,0,0);if(3<=b){var d,e,f;for(d=0;d<b;d++)e=d%b,f=(d+1)%b,e=a[e],f=a[f],c.x+=(e.y-f.y)*(e.z+f.z),c.y+=(e.z-f.z)*(e.x+f.x),c.z+=(e.x-f.x)*(e.y+f.y)}return JSM.VectorNormalize(c)};JSM.SphericalToCartesian=function(a,b,c){var d=new JSM.Coord(0,0,0);d.x=a*Math.sin(b)*Math.cos(c);d.y=a*Math.sin(b)*Math.sin(c);d.z=a*Math.cos(b);return d};
JSM.CartesianToSpherical=function(a,b,c){var d=new JSM.SphericalCoord(0,0,0);d.radius=Math.sqrt(a*a+b*b+c*c);if(JSM.IsZero(d.radius))return d;d.theta=Math.acos(c/d.radius);d.phi=Math.atan2(b,a);return d};JSM.SphericalToCartesianWithOrigo=function(a,b){var c=JSM.SphericalToCartesian(a.radius,a.theta,a.phi);return JSM.CoordAdd(c,b)};JSM.CartesianToSphericalWithOrigo=function(a,b){var c=JSM.CoordSub(a,b);return JSM.CartesianToSpherical(c.x,c.y,c.z)};
JSM.MoveCoordOnSphere=function(a,b,c,d){a=JSM.CartesianToSphericalWithOrigo(a,b);a.theta+=c;a.phi+=d;return JSM.SphericalToCartesianWithOrigo(a,b)};JSM.CylindricalToCartesian=function(a,b,c){var d=new JSM.Coord(0,0,0);d.x=a*Math.cos(c);d.y=a*Math.sin(c);d.z=b;return d};JSM.GetArcLength=function(a,b,c){return JSM.GetVectorsAngle(a,b)*c};JSM.GetFullArcLength=function(a,b,c,d){return JSM.GetVectorsFullAngle(a,b,d)*c};JSM.MatrixIdentity=function(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]};
JSM.MatrixClone=function(a){var b=[];b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};JSM.MatrixTranspose=function(a){var b=[];b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};
JSM.MatrixVectorMultiply=function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=a[1],h=a[2],l=a[3],k=a[5],m=a[6],n=a[7],p=a[9],q=a[10],r=a[11],s=a[13],x=a[14],v=a[15],t=[];t[0]=c*a[0]+d*a[4]+e*a[8]+f*a[12];t[1]=c*g+d*k+e*p+f*s;t[2]=c*h+d*m+e*q+f*x;t[3]=c*l+d*n+e*r+f*v;return t};
JSM.MatrixMultiply=function(a,b){var c=a[0],d=a[1],e=a[2],f=a[3],g=a[4],h=a[5],l=a[6],k=a[7],m=a[8],n=a[9],p=a[10],q=a[11],r=a[12],s=a[13],x=a[14],v=a[15],t=b[0],y=b[1],F=b[2],C=b[3],u=b[4],H=b[5],z=b[6],I=b[7],J=b[8],D=b[9],A=b[10],B=b[11],K=b[12],L=b[13],M=b[14],w=b[15],G=[];G[0]=c*t+d*u+e*J+f*K;G[1]=c*y+d*H+e*D+f*L;G[2]=c*F+d*z+e*A+f*M;G[3]=c*C+d*I+e*B+f*w;G[4]=g*t+h*u+l*J+k*K;G[5]=g*y+h*H+l*D+k*L;G[6]=g*F+h*z+l*A+k*M;G[7]=g*C+h*I+l*B+k*w;G[8]=m*t+n*u+p*J+q*K;G[9]=m*y+n*H+p*D+q*L;G[10]=m*F+n*z+
p*A+q*M;G[11]=m*C+n*I+p*B+q*w;G[12]=r*t+s*u+x*J+v*K;G[13]=r*y+s*H+x*D+v*L;G[14]=r*F+s*z+x*A+v*M;G[15]=r*C+s*I+x*B+v*w;return G};JSM.MatrixDeterminant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],l=a[7],k=a[8],m=a[9],n=a[10],p=a[11],q=a[12],r=a[13],s=a[14];a=a[15];return(b*g-c*f)*(n*a-p*s)-(b*h-d*f)*(m*a-p*r)+(b*l-e*f)*(m*s-n*r)+(c*h-d*g)*(k*a-p*q)-(c*l-e*g)*(k*s-n*q)+(d*l-e*h)*(k*r-m*q)};
JSM.MatrixInvert=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],l=a[7],k=a[8],m=a[9],n=a[10],p=a[11],q=a[12],r=a[13],s=a[14];a=a[15];var x=b*g-c*f,v=b*h-d*f,t=b*l-e*f,y=c*h-d*g,F=c*l-e*g,C=d*l-e*h,u=k*r-m*q,H=k*s-n*q,z=k*a-p*q,I=m*s-n*r,J=m*a-p*r,D=n*a-p*s,A=x*D-v*J+t*I+y*z-F*H+C*u;if(JSM.IsZero(A))return null;var B=[];B[0]=(g*D-h*J+l*I)/A;B[1]=(d*J-c*D-e*I)/A;B[2]=(r*C-s*F+a*y)/A;B[3]=(n*F-m*C-p*y)/A;B[4]=(h*z-f*D-l*H)/A;B[5]=(b*D-d*z+e*H)/A;B[6]=(s*t-q*C-a*v)/A;B[7]=(k*C-n*t+p*
v)/A;B[8]=(f*J-g*z+l*u)/A;B[9]=(c*z-b*J-e*u)/A;B[10]=(q*F-r*t+a*x)/A;B[11]=(m*t-k*F-p*x)/A;B[12]=(g*H-f*I-h*u)/A;B[13]=(b*I-c*H+d*u)/A;B[14]=(r*v-q*y-s*x)/A;B[15]=(k*y-m*v+n*x)/A;return B};JSM.MatrixTranslation=function(a,b,c){var d=[1,0,0,0,0,1,0,0,0,0,1,0];d[12]=a;d[13]=b;d[14]=c;d[15]=1;return d};
JSM.MatrixRotation=function(a,b,c){var d=JSM.VectorNormalize(a);a=d.x;var e=d.y,d=d.z,f=a*a,g=e*e,h=d*d,l=Math.sin(b);b=Math.cos(b);var k=[];if(void 0===c||null===c)k[0]=f+(g+h)*b,k[1]=a*e*(1-b)+d*l,k[2]=a*d*(1-b)-e*l,k[3]=0,k[4]=a*e*(1-b)-d*l,k[5]=g+(f+h)*b,k[6]=e*d*(1-b)+a*l,k[7]=0,k[8]=a*d*(1-b)+e*l,k[9]=e*d*(1-b)-a*l,k[10]=h+(f+g)*b,k[11]=0,k[12]=0,k[13]=0,k[14]=0;else{var m=c.x,n=c.y;c=c.z;k[0]=f+(g+h)*b;k[1]=a*e*(1-b)+d*l;k[2]=a*d*(1-b)-e*l;k[3]=0;k[4]=a*e*(1-b)-d*l;k[5]=g+(f+h)*b;k[6]=e*d*
(1-b)+a*l;k[7]=0;k[8]=a*d*(1-b)+e*l;k[9]=e*d*(1-b)-a*l;k[10]=h+(f+g)*b;k[11]=0;k[12]=(m*(g+h)-a*(n*e+c*d))*(1-b)+(n*d-c*e)*l;k[13]=(n*(f+h)-e*(m*a+c*d))*(1-b)+(c*a-m*d)*l;k[14]=(c*(f+g)-d*(m*a+n*e))*(1-b)+(m*e-n*a)*l}k[15]=1;return k};
JSM.MatrixRotationQuaternion=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],f=b+b,g=c+c,h=d+d;a=b*f;var l=b*g,b=b*h,k=c*g,c=c*h,d=d*h,f=e*f,g=e*g,e=e*h,h=[];h[0]=1-(k+d);h[1]=l+e;h[2]=b-g;h[3]=0;h[4]=l-e;h[5]=1-(a+d);h[6]=c+f;h[7]=0;h[8]=b+g;h[9]=c-f;h[10]=1-(a+k);h[11]=0;h[12]=0;h[13]=0;h[14]=0;h[15]=1;return h};JSM.MatrixRotationX=function(a){var b=Math.sin(a);a=Math.cos(a);var c=[1,0,0,0,0];c[5]=a;c[6]=b;c[7]=0;c[8]=0;c[9]=-b;c[10]=a;c[11]=0;c[12]=0;c[13]=0;c[14]=0;c[15]=1;return c};
JSM.MatrixRotationY=function(a){var b=Math.sin(a);a=Math.cos(a);var c=[];c[0]=a;c[1]=0;c[2]=-b;c[3]=0;c[4]=0;c[5]=1;c[6]=0;c[7]=0;c[8]=b;c[9]=0;c[10]=a;c[11]=0;c[12]=0;c[13]=0;c[14]=0;c[15]=1;return c};JSM.MatrixRotationZ=function(a){var b=Math.sin(a);a=Math.cos(a);var c=[];c[0]=a;c[1]=b;c[2]=0;c[3]=0;c[4]=-b;c[5]=a;c[6]=0;c[7]=0;c[8]=0;c[9]=0;c[10]=1;c[11]=0;c[12]=0;c[13]=0;c[14]=0;c[15]=1;return c};
JSM.MatrixView=function(a,b,c){if(JSM.CoordIsEqual(a,b))return JSM.MatrixIdentity();var d=[];b=JSM.VectorNormalize(JSM.CoordSub(a,b));c=JSM.VectorNormalize(JSM.VectorCross(c,b));var e=JSM.VectorNormalize(JSM.VectorCross(b,c));d[0]=c.x;d[1]=e.x;d[2]=b.x;d[3]=0;d[4]=c.y;d[5]=e.y;d[6]=b.y;d[7]=0;d[8]=c.z;d[9]=e.z;d[10]=b.z;d[11]=0;d[12]=-JSM.VectorDot(c,a);d[13]=-JSM.VectorDot(e,a);d[14]=-JSM.VectorDot(b,a);d[15]=1;return d};
JSM.MatrixPerspective=function(a,b,c,d){var e=[];a=1/Math.tan(a/2);var f=1/(c-d);e[0]=a/b;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=a;e[6]=0;e[7]=0;e[8]=0;e[9]=0;e[10]=(d+c)*f;e[11]=-1;e[12]=0;e[13]=0;e[14]=2*d*c*f;e[15]=0;return e};JSM.ApplyTransformation=function(a,b){var c=[];c[0]=b.x;c[1]=b.y;c[2]=b.z;c[3]=1;c=JSM.MatrixVectorMultiply(a,c);return new JSM.Coord(c[0],c[1],c[2])};JSM.CoordSystem=function(a,b,c,d){this.origo=a;this.e1=b;this.e2=c;this.e3=d};
JSM.CoordSystem.prototype.Set=function(a,b,c,d){this.origo=a;this.e1=b;this.e2=c;this.e3=d};JSM.CoordSystem.prototype.Clone=function(){return new JSM.CoordSystem(this.origo.Clone(),this.e1.Clone(),this.e2.Clone(),this.e3.Clone())};JSM.CoordSystemToDirectionVectors=function(a){return new JSM.CoordSystem(a.origo,JSM.CoordSub(a.e1,a.origo),JSM.CoordSub(a.e2,a.origo),JSM.CoordSub(a.e3,a.origo))};
JSM.CoordSystemToAbsoluteCoords=function(a){return new JSM.CoordSystem(a.origo,JSM.CoordAdd(a.e1,a.origo),JSM.CoordAdd(a.e2,a.origo),JSM.CoordAdd(a.e3,a.origo))};
JSM.ChangeCoordSystem=function(a,b,c){var d=JSM.VectorNormalize(b.e1),e=JSM.VectorNormalize(b.e2),f=JSM.VectorNormalize(b.e3),g=JSM.VectorNormalize(c.e1),h=JSM.VectorNormalize(c.e2),l=JSM.VectorNormalize(c.e3);a=JSM.CoordSub(a,b.origo);b=new JSM.Coord(0,0,0);b.x=JSM.VectorDot(g,d)*a.x+JSM.VectorDot(g,e)*a.y+JSM.VectorDot(g,f)*a.z;b.y=JSM.VectorDot(h,d)*a.x+JSM.VectorDot(h,e)*a.y+JSM.VectorDot(h,f)*a.z;b.z=JSM.VectorDot(l,d)*a.x+JSM.VectorDot(l,e)*a.y+JSM.VectorDot(l,f)*a.z;return b=JSM.CoordAdd(b,
c.origo)};JSM.Sector2D=function(a,b){this.beg=a;this.end=b};JSM.Sector2D.prototype.Set=function(a,b){this.beg=a;this.end=b};JSM.Sector2D.prototype.Clone=function(){return new JSM.Sector2D(this.beg.Clone(),this.end.Clone())};JSM.Sector=function(a,b){this.beg=a;this.end=b};JSM.Sector.prototype.Set=function(a,b){this.beg=a;this.end=b};JSM.Sector.prototype.Clone=function(){return new JSM.Sector(this.beg.Clone(),this.end.Clone())};
JSM.CoordSectorPosition2D=function(a,b){var c=a.x,d=a.y,e=b.beg.x,f=b.beg.y,g=b.end.x,h=b.end.y,l=Math.pow(g-e,2)+Math.pow(h-f,2);if(JSM.IsZero(l))return JSM.CoordIsEqual2D(a,b.beg)?"CoordOnSectorEndCoord":"CoordOutsideOfSector";l=((c-e)*(g-e)+(d-f)*(h-f))/l;if(JSM.IsLower(l,0)||JSM.IsGreater(l,1))return"CoordOutsideOfSector";f+=l*(h-f);return!JSM.IsEqual(e+l*(g-e),c)||!JSM.IsEqual(f,d)?"CoordOutsideOfSector":JSM.IsEqual(l,0)||JSM.IsEqual(l,1)?"CoordOnSectorEndCoord":"CoordInsideOfSector"};
JSM.SectorSectorPosition2D=function(a,b,c){var d=a.beg.x,e=a.beg.y,f=a.end.x,g=a.end.y,h=b.beg.x,l=b.beg.y,k=b.end.x,m=b.end.y,n=(k-h)*(e-l)-(m-l)*(d-h),p=(f-d)*(e-l)-(g-e)*(d-h);if(JSM.IsZero(n)&&JSM.IsZero(p))return c=JSM.CoordSectorPosition2D(a.beg,b),d=JSM.CoordSectorPosition2D(a.end,b),e=JSM.CoordSectorPosition2D(b.beg,a),a=JSM.CoordSectorPosition2D(b.end,a),"CoordInsideOfSector"===c||("CoordInsideOfSector"===d||"CoordInsideOfSector"===e||"CoordInsideOfSector"===a)||"CoordOnSectorEndCoord"===
c&&"CoordOnSectorEndCoord"===d&&"CoordOnSectorEndCoord"===e&&"CoordOnSectorEndCoord"===a?"SectorsIntersectsCoincident":"CoordOnSectorEndCoord"===c||"CoordOnSectorEndCoord"===d||"CoordOnSectorEndCoord"===e||"CoordOnSectorEndCoord"===a?"SectorsIntersectsEndPoint":"SectorsDontIntersects";a=(m-l)*(f-d)-(k-h)*(g-e);if(JSM.IsZero(a))return"SectorsDontIntersects";n/=a;p/=a;if(JSM.IsLower(n,0)||JSM.IsGreater(n,1)||JSM.IsLower(p,0)||JSM.IsGreater(p,1))return"SectorsDontIntersects";void 0!==c&&(c.x=d+n*(f-
d),c.y=e+n*(g-e));return JSM.IsEqual(n,0)||JSM.IsEqual(n,1)||JSM.IsEqual(p,0)||JSM.IsEqual(p,1)?"SectorsIntersectsEndPoint":"SectorsIntersectsOnePoint"};JSM.GetSectorSegmentation=function(a,b,c){var d=JSM.CoordSub(a.end,a.beg),e=JSM.CoordDistance(a.beg,a.end)/b,f=0,g;for(g=0;g<=b;g++)c.push(JSM.CoordOffset(a.beg,d,f)),f+=e};JSM.Line2D=function(a,b){this.start=a;this.direction=b};JSM.Line2D.prototype.Set=function(a,b){this.start=a;this.direction=b};
JSM.Line2D.prototype.Clone=function(){return new JSM.Line2D(this.start.Clone(),this.direction.Clone())};JSM.Line=function(a,b){this.start=a;this.direction=b};JSM.Line.prototype.Set=function(a,b){this.start=a;this.direction=b};JSM.Line.prototype.Clone=function(){return new JSM.Line(this.start.Clone(),this.direction.Clone())};
JSM.CoordLinePosition2D=function(a,b){var c=b.start,d=b.direction,c=d.x*(a.y-c.y)-d.y*(a.x-c.x);return JSM.IsPositive(c)?"CoordAtLineLeft":JSM.IsNegative(c)?"CoordAtLineRight":"CoordOnLine"};
JSM.CoordLinePosition=function(a,b,c){var d=a.x,e=a.y,f=a.z,g=b.start;b=b.direction;var h=g.x,l=g.y,k=g.z,m=g.x+b.x,n=g.y+b.y,p=g.z+b.z,q=(m-h)*(m-h)+(n-l)*(n-l)+(p-k)*(p-k);if(JSM.IsZero(q))return void 0!==c&&c.Set(g.x,g.y,g.z),JSM.CoordIsEqual(g,a)?"CoordOnLine":"CoordOutsideOfLine";d=JSM.CoordAdd(g,JSM.VectorMultiply(b,((m-h)*(d-h)+(n-l)*(e-l)+(p-k)*(f-k))/q));void 0!==c&&c.Set(d.x,d.y,d.z);a=JSM.CoordDistance(a,d);return JSM.IsZero(a)?"CoordOnLine":"CoordOutsideOfLine"};
JSM.ProjectCoordToLine=function(a,b){var c=new JSM.Coord(0,0,0),d=a.x,e=a.y,f=a.z,g=b.start,h=b.direction,l=g.x,k=g.y,m=g.z,n=g.x+h.x,p=g.y+h.y,q=g.z+h.z,r=(n-l)*(n-l)+(p-k)*(p-k)+(q-m)*(q-m);if(JSM.IsZero(r))return c.Set(g.x,g.y,g.z),c;d=JSM.CoordAdd(g,JSM.VectorMultiply(h,((n-l)*(d-l)+(p-k)*(e-k)+(q-m)*(f-m))/r));c.Set(d.x,d.y,d.z);return c};
JSM.LineLineClosestPoint=function(a,b,c,d){function e(a,b,c,d,e){return(a[b].x-a[c].x)*(a[d].x-a[e].x)+(a[b].y-a[c].y)*(a[d].y-a[e].y)+(a[b].z-a[c].z)*(a[d].z-a[e].z)}var f=JSM.VectorNormalize(a.direction),g=a.start,f=JSM.CoordAdd(g,f);a=JSM.VectorNormalize(b.direction);b=b.start;var h=JSM.CoordAdd(b,a),l=[g,f,b,h],k=e(l,1,0,1,0),m=e(l,0,2,1,0),h=e(l,0,2,3,2),n=e(l,3,2,1,0),l=e(l,3,2,3,2),k=k*l-n*n;if(JSM.IsEqual(k,0))return!1;m=(h*n-m*l)/k;h=(h+m*n)/l;void 0!==c&&(f=JSM.VectorNormalize(JSM.CoordSub(f,
g)),g=JSM.CoordAdd(g,JSM.VectorMultiply(f,m)),c.Set(g.x,g.y,g.z));void 0!==d&&(c=JSM.CoordAdd(b,JSM.VectorMultiply(a,h)),d.Set(c.x,c.y,c.z));return!0};JSM.LineLinePosition=function(a,b,c){var d=new JSM.Coord(0,0,0),e=new JSM.Coord(0,0,0);return!JSM.LineLineClosestPoint(a,b,d,e)?"LinesIntersectsCoincident":JSM.CoordIsEqual(d,e)?(void 0!==c&&c.Set(d.x,d.y,d.z),"LinesIntersectsOnePoint"):"LinesDontIntersects"};JSM.Transformation=function(){this.matrix=JSM.MatrixIdentity()};
JSM.Transformation.prototype.GetMatrix=function(){return this.matrix};JSM.Transformation.prototype.SetMatrix=function(a){this.matrix=a};JSM.Transformation.prototype.Append=function(a){this.matrix=JSM.MatrixMultiply(this.matrix,a.matrix)};JSM.Transformation.prototype.Apply=function(a){return JSM.ApplyTransformation(this.matrix,a)};JSM.Transformation.prototype.Clone=function(){var a=new JSM.Transformation;a.matrix=JSM.MatrixClone(this.matrix);return a};
JSM.IdentityTransformation=function(){var a=new JSM.Transformation;a.matrix=JSM.MatrixIdentity();return a};JSM.TranslationTransformation=function(a){var b=new JSM.Transformation;b.matrix=JSM.MatrixTranslation(a.x,a.y,a.z);return b};JSM.OffsetTransformation=function(a,b){var c=JSM.VectorNormalize(a),c=JSM.VectorMultiply(c,b);return JSM.TranslationTransformation(c)};JSM.RotationTransformation=function(a,b,c){var d=new JSM.Transformation;d.matrix=JSM.MatrixRotation(a,b,c);return d};
JSM.RotationXTransformation=function(a,b){var c=new JSM.Transformation;void 0===b||null===b?c.matrix=JSM.MatrixRotationX(a):(c.Append(JSM.TranslationTransformation(new JSM.Vector(-b.x,-b.y,-b.z))),c.Append(JSM.RotationXTransformation(a)),c.Append(JSM.TranslationTransformation(new JSM.Vector(b.x,b.y,b.z))));return c};
JSM.RotationYTransformation=function(a,b){var c=new JSM.Transformation;void 0===b||null===b?c.matrix=JSM.MatrixRotationY(a):(c.Append(JSM.TranslationTransformation(new JSM.Vector(-b.x,-b.y,-b.z))),c.Append(JSM.RotationYTransformation(a)),c.Append(JSM.TranslationTransformation(new JSM.Vector(b.x,b.y,b.z))));return c};
JSM.RotationZTransformation=function(a,b){var c=new JSM.Transformation;void 0===b||null===b?c.matrix=JSM.MatrixRotationZ(a):(c.Append(JSM.TranslationTransformation(new JSM.Vector(-b.x,-b.y,-b.z))),c.Append(JSM.RotationZTransformation(a)),c.Append(JSM.TranslationTransformation(new JSM.Vector(b.x,b.y,b.z))));return c};
JSM.RotationXYZTransformation=function(a,b,c,d){var e=new JSM.Transformation;e.Append(JSM.RotationXTransformation(a,d));e.Append(JSM.RotationYTransformation(b,d));e.Append(JSM.RotationZTransformation(c,d));return e};JSM.Plane=function(a,b,c,d){this.a=a;this.b=b;this.c=c;this.d=d};JSM.Plane.prototype.Set=function(a,b,c,d){this.a=a;this.b=b;this.c=c;this.d=d};JSM.Plane.prototype.GetNormal=function(){return new JSM.Vector(this.a,this.b,this.c)};
JSM.Plane.prototype.Clone=function(){return new JSM.Plane(this.a,this.b,this.c,this.d)};JSM.GetPlaneFromCoordAndDirection=function(a,b){var c=new JSM.Plane,d=JSM.VectorNormalize(b),e=d.x,f=d.y,d=d.z;c.Set(e,f,d,-(e*a.x+f*a.y+d*a.z));return c};JSM.GetPlaneFromThreeCoords=function(a,b,c){var d=new JSM.Plane,e=(b.y-a.y)*(c.z-a.z)-(c.y-a.y)*(b.z-a.z),f=(b.z-a.z)*(c.x-a.x)-(c.z-a.z)*(b.x-a.x);b=(b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);d.Set(e,f,b,-(e*a.x+f*a.y+b*a.z));return d};
JSM.CoordPlanePosition=function(a,b){var c=b.a*a.x+b.b*a.y+b.c*a.z+b.d;return JSM.IsPositive(c)?"CoordInFrontOfPlane":JSM.IsNegative(c)?"CoordAtBackOfPlane":"CoordOnPlane"};
JSM.LinePlanePosition=function(a,b,c){var d=JSM.VectorNormalize(a.direction),e=a.start.x,f=a.start.y,g=a.start.z,h=b.a,l=b.b,k=b.c;b=b.d;var m=h*(e-(a.start.x+d.x))+l*(f-(a.start.y+d.y))+k*(g-(a.start.z+d.z));if(JSM.IsZero(m))return"LineParallelToPlane";void 0!==c&&(a=JSM.CoordAdd(a.start,JSM.VectorMultiply(d,(h*e+l*f+k*g+b)/m)),c.Set(a.x,a.y,a.z));return"LineIntersectsPlane"};
JSM.LinePlaneIntersection=function(a,b){var c=JSM.VectorNormalize(a.direction),d=a.start.x,e=a.start.y,f=a.start.z,g=a.start.x+c.x,h=a.start.y+c.y,l=a.start.z+c.z,k=b.a,m=b.b,n=b.c,p=b.d,q=new JSM.Coord(0,0,0),g=k*(d-g)+m*(e-h)+n*(f-l);return JSM.IsZero(g)?q:q=JSM.CoordAdd(a.start,JSM.VectorMultiply(c,(k*d+m*e+n*f+p)/g))};JSM.CoordPlaneSignedDistance=function(a,b){var c=b.a,d=b.b,e=b.c;return(c*a.x+d*a.y+e*a.z+b.d)/Math.sqrt(c*c+d*d+e*e)};
JSM.CoordPlaneDistance=function(a,b){return Math.abs(JSM.CoordPlaneSignedDistance(a,b))};JSM.CoordPlaneSignedDirectionalDistance=function(a,b,c){var d=JSM.VectorNormalize(b);b=a.x;var e=a.y,f=a.z,g=c.a,h=c.b,l=c.c;c=c.d;var k=g*(b-(a.x+d.x))+h*(e-(a.y+d.y))+l*(f-(a.z+d.z));if(JSM.IsZero(k))return 0;d=JSM.CoordAdd(a,JSM.VectorMultiply(d,(g*b+h*e+l*f+c)/k));a=JSM.CoordDistance(a,d);JSM.IsNegative(g*b+h*e+l*f+c)&&(a=-a);return a};
JSM.CoordPlaneDirectionalDistance=function(a,b,c){return Math.abs(JSM.CoordPlaneSignedDirectionalDistance(a,b,c))};JSM.ProjectCoordToPlane=function(a,b){var c=a.x,d=a.y,e=a.z,f=b.a,g=b.b,h=b.c,l=b.d,k=JSM.CoordPlaneDistance(a,b);JSM.IsGreater(f*c+g*d+h*e+l,0)&&(k=-k);c=JSM.VectorNormalize(new JSM.Coord(f,g,h));return JSM.CoordOffset(a,c,k)};
JSM.Project=function(a,b,c,d,e,f,g,h,l){b=JSM.MatrixView(b,c,d);g=JSM.MatrixPerspective(e,f,g,h);e=new JSM.Coord(0,0,0);h=[];f=[];h[0]=a.x;h[1]=a.y;h[2]=a.z;h[3]=1;f=JSM.MatrixVectorMultiply(g,JSM.MatrixVectorMultiply(b,h));a=f[3];JSM.IsZero(a)?l=null:(f[0]=0.5*(f[0]/a)+0.5,f[1]=0.5*(f[1]/a)+0.5,f[2]=0.5*(f[2]/a)+0.5,f[0]=f[0]*l[2]+l[0],f[1]=f[1]*l[3]+l[1],e.x=f[0],e.y=f[1],e.z=f[2],l=e);return l};
JSM.ConvexHull2D=function(a){function b(a,b){var c=a.length,d=0,e;for(e=1;e<c;e++)b==d?d=e:"Clockwise"==JSM.CoordTurnType2D(a[b],a[d],a[e])&&(d=e);return d}var c=[];if(3>a.length)return c;var d=function(a){var b=a.length,c=JSM.Inf,d=-1,e,f;for(e=0;e<b;e++)f=a[e].x,JSM.IsLower(f,c)&&(c=f,d=e);return d}(a),e=d,f;do c.push(e),e=f=b(a,e);while(f!=d);return c};
JSM.ConvexHull3D=function(a){function b(){this.position=null}function c(){this.tri2=this.tri1=this.vert2=this.vert1=null}function d(){this.valid=this.edges=this.vertices=null}function e(a,c){var d=new b;d.position=c;a.vertices.push(d);return a.vertices.length-1}function f(a,b,d,e){var f=-1,g,h;for(g=0;g<a.edges.length;g++)if(h=a.edges[g],h.vert1==d&&h.vert2==e||h.vert1==e&&h.vert2==d){f=g;break}-1==f&&(f=new c,f.vert1=d,f.vert2=e,f.tri1=-1,f.tri2=-1,a.edges.push(f),f=a.edges.length-1);a=a.edges[f];
a.tri1!=b&&a.tri2!=b&&(-1==a.tri1?a.tri1=b:-1==a.tri2&&(a.tri2=b));return f}function g(a,b,c,e){var g=a.triangles.length,h=f(a,g,b,c),k=f(a,g,c,e),g=f(a,g,e,b),l=new d;l.vertices=[b,c,e];l.edges=[h,k,g];l.valid=!0;a.triangles.push(l);return a.triangles.length-1}function h(a,b,c){a=a.edges[c];a.tri1==b?a.tri1=-1:a.tri2==b&&(a.tri2=-1)}function l(a,b,c,d,e){c=a.vertices[c].position;d=a.vertices[d].position;e=a.vertices[e].position;a=JSM.CoordSub(a.vertices[b].position,e);b=JSM.CoordSub(c,e);c=JSM.CoordSub(d,
e);return JSM.VectorDot(a,JSM.VectorCross(b,c))/6}function k(a,b){var c=[],d,e;for(d=0;d<a.triangles.length;d++)e=a.triangles[d],e.valid?!JSM.IsLower(l(a,e.vertices[0],e.vertices[2],e.vertices[1],b),0)?c.push(!0):c.push(!1):c.push(!1);var f,k,m,n=[];for(d=0;d<c.length;d++)c[d]&&(e=a.triangles[d],e.valid&&(f=a.edges[e.edges[0]],k=a.edges[e.edges[1]],m=a.edges[e.edges[2]],f=-1==f.tri1||-1==f.tri2||c[f.tri1]!=c[f.tri2],k=-1==k.tri1||-1==k.tri2||c[k.tri1]!=c[k.tri2],m=-1==m.tri1||-1==m.tri2||c[m.tri1]!=
c[m.tri2],f&&n.push([e.vertices[0],e.vertices[1],b]),k&&n.push([e.vertices[1],e.vertices[2],b]),m&&n.push([e.vertices[2],e.vertices[0],b])));for(d=0;d<c.length;d++)c[d]&&(e=a.triangles[d],e.valid&&(e=a,m=d,f=e.triangles[m],f.valid&&(h(e,m,f.edges[0]),h(e,m,f.edges[1]),h(e,m,f.edges[2]),f.valid=!1)));for(d=0;d<n.length;d++)c=n[d],g(a,c[0],c[1],c[2])}var m=[],n=a.length;if(4>n)return m;var p=new function(){this.vertices=[];this.edges=[];this.triangles=[]},q;for(q=0;q<n;q++)e(p,a[q]);(function(a){var b=
-1,b=!JSM.IsLower(l(a,0,1,2,3),0)?g(a,0,1,2):g(a,0,2,1),b=a.triangles[b];g(a,b.vertices[0],b.vertices[2],3);g(a,b.vertices[2],b.vertices[1],3);g(a,b.vertices[1],b.vertices[0],3)})(p);for(q=4;q<n;q++)k(p,q);for(q=0;q<p.triangles.length;q++)a=p.triangles[q],a.valid&&m.push(a.vertices);return m};JSM.Polygon2D=function(){this.vertices=[]};JSM.Polygon2D.prototype.AddVertex=function(a,b){this.vertices.push(new JSM.Coord2D(a,b))};JSM.Polygon2D.prototype.GetVertex=function(a){return this.vertices[a]};
JSM.Polygon2D.prototype.SetVertex=function(a,b,c){this.vertices[a].Set(b,c)};JSM.Polygon2D.prototype.VertexCount=function(){return this.vertices.length};JSM.Polygon2D.prototype.Clear=function(){this.vertices=[]};JSM.Polygon2D.prototype.Clone=function(){var a=new JSM.Polygon2D,b;for(b=0;b<this.vertices.length;b++)a.vertices.push(this.vertices[b].Clone());return a};JSM.ContourPolygon2D=function(){this.polygons=[]};
JSM.ContourPolygon2D.prototype.AddVertex=function(a,b,c){void 0===this.polygons[a]&&(this.polygons[a]=new JSM.Polygon2D);this.polygons[a].AddVertex(b,c)};JSM.ContourPolygon2D.prototype.VertexCount=function(a){return void 0===this.polygons[a]?0:this.polygons[a].VertexCount()};JSM.ContourPolygon2D.prototype.GetVertex=function(a,b){return this.polygons[a].GetVertex(b)};JSM.ContourPolygon2D.prototype.SetVertex=function(a,b,c,d){this.polygons[a].SetVertex(b,c,d)};
JSM.ContourPolygon2D.prototype.AddContour=function(){this.polygons.push(new JSM.Polygon2D)};JSM.ContourPolygon2D.prototype.ContourCount=function(){return this.polygons.length};JSM.ContourPolygon2D.prototype.GetContour=function(a){return this.polygons[a]};JSM.ContourPolygon2D.prototype.Clear=function(){this.polygons=[]};JSM.ContourPolygon2D.prototype.Clone=function(){var a=new JSM.ContourPolygon2D,b;for(b=0;b<this.polygons.length;b++)a.polygons.push(this.polygons[b].Clone());return a};
JSM.Polygon=function(){this.vertices=[]};JSM.Polygon.prototype.AddVertex=function(a,b,c){this.vertices.push(new JSM.Coord(a,b,c))};JSM.Polygon.prototype.GetVertex=function(a){return this.vertices[a]};JSM.Polygon.prototype.SetVertex=function(a,b,c,d){this.vertices[a].Set(b,c,d)};JSM.Polygon.prototype.VertexCount=function(){return this.vertices.length};JSM.Polygon.prototype.Clear=function(){this.vertices=[]};
JSM.Polygon.prototype.Clone=function(){var a=new JSM.Polygon,b;for(b=0;b<this.vertices.length;b++)a.vertices.push(this.vertices[b].Clone());return a};JSM.CreatePolygonFromVertices=function(a){var b=new JSM.Polygon2D,c,d;for(c=0;c<a.length;c++)d=a[c],b.AddVertex(d.x,d.y);return b};JSM.PolygonSignedArea2D=function(a){var b=a.VertexCount(),c=0,d,e,f;for(d=0;d<b;d++)e=a.GetVertex(d),f=a.GetVertex((d+1)%b),c+=e.x*f.y-f.x*e.y;return c/2};JSM.PolygonArea2D=function(a){return Math.abs(JSM.PolygonSignedArea2D(a))};
JSM.PolygonOrientation2D=function(a){a=JSM.PolygonSignedArea2D(a);return JSM.IsPositive(a)?"CounterClockwise":JSM.IsNegative(a)?"Clockwise":"Invalid"};JSM.ChangePolygonOrientation2D=function(a){var b=a.Clone();a.Clear();var c,d;for(c=b.VertexCount()-1;0<=c;c--)d=b.GetVertex(c),a.AddVertex(d.x,d.y)};JSM.CreateCCWPolygonFromVertices=function(a){a=JSM.CreatePolygonFromVertices(a);"CounterClockwise"!=JSM.PolygonOrientation2D(a)&&JSM.ChangePolygonOrientation2D(a);return a};
JSM.PolygonComplexity2D=function(a){var b=!1,c=!1,d=a.VertexCount(),e,f,g,h;for(e=0;e<d;e++)if(f=0===e?d-1:e-1,g=e,h=e===d-1?0:e+1,f=a.GetVertex(f),g=a.GetVertex(g),h=a.GetVertex(h),h=JSM.CoordTurnType2D(f,g,h),"CounterClockwise"===h?b=!0:"Clockwise"===h&&(c=!0),b&&c)return"Concave";return!b&&!c?"Invalid":"Convex"};
JSM.CoordPolygonPosition2D=function(a,b){var c=b.VertexCount(),d,e,f;for(d=0;d<c;d++)if(e=b.GetVertex(d),f=b.GetVertex((d+1)%c),e=new JSM.Sector2D(e,f),"CoordOutsideOfSector"!==JSM.CoordSectorPosition2D(a,e))return"CoordOnPolygonEdge";var g=0,h;for(d=0;d<c;d++)h=Math.abs(b.GetVertex(d).x-a.x),JSM.IsGreater(h,g)&&(g=h);g=new JSM.Sector2D(a,new JSM.Coord2D(a.x+2*g,a.y));h=0;var l;for(d=0;d<c;d++)e=b.GetVertex(d),f=b.GetVertex((d+1)%c),e=new JSM.Sector2D(e,f),f=new JSM.Coord2D(0,0),l=JSM.SectorSectorPosition2D(g,
e,f),"SectorsDontIntersects"!==l&&("SectorsIntersectsOnePoint"===l?h++:"SectorsIntersectsEndPoint"===l&&(JSM.CoordIsEqual2D(f,e.beg)?JSM.IsGreater(e.beg.y,e.end.y)&&h++:JSM.CoordIsEqual2D(f,e.end)&&JSM.IsLower(e.beg.y,e.end.y)&&h++));return 0===h%2?"CoordOutsideOfPolygon":"CoordInsideOfPolygon"};
JSM.SectorIntersectsPolygon2D=function(a,b,c,d){var e=a.VertexCount(),f,g,h;for(f=0;f<e;f++)if(g=f,h=(f+1)%e,!(g==c||h==c||g==d||h==d))if(g=new JSM.Sector2D(a.GetVertex(g),a.GetVertex(h)),g=JSM.SectorSectorPosition2D(b,g),"SectorsDontIntersects"!==g)return!0;return!1};
JSM.IsPolygonVertexVisible2D=function(a,b,c){if(b===c)return!1;var d=a.VertexCount();if(c===(0<b?b-1:d-1)||c===(b<d-1?b+1:0))return!1;d=new JSM.Sector2D(a.GetVertex(b),a.GetVertex(c));if(JSM.SectorIntersectsPolygon2D(a,d,b,c))return!1;b=JSM.MidCoord2D(d.beg,d.end);return"CoordInsideOfPolygon"!==JSM.CoordPolygonPosition2D(b,a)?!1:!0};
JSM.CreatePolygonWithHole2D=function(a){var b=[],c=[],d=0,e;c.push(-1);for(e=0;e<a.length;e++)null===a[e]&&(c.push(e),d+=1);c.push(e);d+=1;for(e=0;e<d;e++){var f=e,g=c[f]+1,h=c[f+1];if(0===f){f=void 0;for(f=g;f<h;f++)b.push(f)}else{for(var g=void 0,g=new JSM.Polygon2D,h=new JSM.Polygon2D,l=void 0,k=void 0,k=void 0,l=0;l<b.length;l++)k=a[b[l]],g.AddVertex(k.x,k.y);for(var m=c[f]+1,n=c[f+1],l=m;l<n;l++)k=a[l],h.AddVertex(k.x,k.y);for(var p=null,q=void 0,r=void 0,s=void 0,l=0;l<g.VertexCount();l++){r=
b[l];for(k=m;k<n;k++)if(s=k-m,q=new JSM.Sector(a[r],a[k]),!JSM.SectorIntersectsPolygon2D(g,q,l,-1)&&!JSM.SectorIntersectsPolygon2D(h,q,-1,s)){p=[r,k];break}if(null!==p)break}g=p;h=c[f]+1;f=c[f+1];l=[];n=m=void 0;for(m=0;m<b.length;m++)l[m]=b[m];b=[];p=k=void 0;for(m=0;m<l.length;m++)if(b.push(l[m]),l[m]==g[0]){n=g[1];k=!0;for(p=!1;!p;)b.push(n),!k&&n==g[1]&&(p=!0),k&&(k=!1),n=n<f-1?n+1:h;b.push(l[m])}}}return b};
JSM.PolygonTriangulate2D=function(a){function b(){var a=[],b,c,d,e;for(b=0;b<g.length;b++)if(d=g[b],3===d.length)if("CounterClockwise"===k)a.push(d);else{e=[];for(c=d.length-1;0<=c;c--)e.push(f-d[c]-1);a.push(e)}return a}function c(a,b,c){if(b===c)return!1;var d=a.VertexCount(),e;if(!(e=(b<d-1?b+1:0)===c))e=(0<b?b-1:d-1)===c;return e?!1:JSM.IsPolygonVertexVisible2D(a,b,c)}function d(a,b,c){var d=a.length;if(3>=d)return!0;var e,f,h,k;for(e=0;2>e;e++){h=f=-1;0===e?(f=b,h=c):1===e&&(f=c,h=b);k=[];for(k.push(a[h]);f!==
h;f=f<d-1?f+1:0)k.push(a[f]);g.push(k)}return!0}var e=a.Clone(),f=e.VertexCount();if(3>f)return[];var g=[],h=[],l;for(a=0;a<f;a++)h.push(a);g.push(h);if(3===f)return b();var h=JSM.PolygonComplexity2D(e),k=JSM.PolygonOrientation2D(e);if("Invalid"===h||"Invalid"===k)return[];if("CounterClockwise"!==k){var m,n,p;for(a=0;a<f/2;a++)m=a,n=f-a-1,p=e.vertices[m],e.vertices[m]=e.vertices[n],e.vertices[n]=p}if("Convex"===h){for(a=0;a<f-2;a++)e=[],e.push(0),e.push((a+1)%f),e.push((a+2)%f),g.push(e);return b()}var q;
for(a=0;a<g.length;a++)if(m=g[a],n=m.length,3!==n){p=new JSM.Polygon2D;for(h=0;h<n;h++)l=e.GetVertex(m[h]),p.AddVertex(l.x,l.y);q=!1;for(h=0;h<n;h++){for(l=0;l<n;l++)if(c(p,h,l)){d(m,h,l);q=!0;break}if(q)break}}return b()};
JSM.CheckTriangulation2D=function(a,b){var c=JSM.PolygonSignedArea2D(a),d=0,e,f,g,h,l;for(e=0;e<b.length;e++){g=b[e];if(3!==g.length)return!1;h=new JSM.Polygon2D;for(f=0;f<g.length;f++)l=a.GetVertex(g[f]),h.AddVertex(l.x,l.y);d+=JSM.PolygonSignedArea2D(h)}return!JSM.IsEqual(c,d)?!1:!0};
JSM.CreatePolygonWithHole=function(a){var b=[],c;for(c=0;c<a.length;c++)null!==a[c]&&b.push(a[c]);var b=JSM.CalculateNormal(b),d=new JSM.Coord(0,0,0),e=[],f;for(c=0;c<a.length;c++)null!==a[c]?(f=JSM.GetCoord2DFromCoord(a[c],d,b),e.push(f)):e.push(null);return JSM.CreatePolygonWithHole2D(e)};
JSM.PolygonTriangulate=function(a){var b=new JSM.Polygon2D,c=JSM.CalculateNormal(a.vertices),d=new JSM.Coord(0,0,0),e=a.VertexCount(),f,g;for(f=0;f<e;f++)g=JSM.GetCoord2DFromCoord(a.GetVertex(f),d,c),b.AddVertex(g.x,g.y);return JSM.PolygonTriangulate2D(b)};
JSM.OffsetPolygonContour=function(a,b){var c=a.VertexCount(),d=JSM.CalculateNormal(a.vertices),e,f,g,h,l,k=new JSM.Polygon,m;for(m=0;m<c;m++)e=0===m?c-1:m-1,f=m,g=m===c-1?0:m+1,e=a.GetVertex(e),f=a.GetVertex(f),h=a.GetVertex(g),l=JSM.CoordSub(e,f),g=JSM.CoordSub(h,f),l=JSM.GetVectorsAngle(l,g)/2,"Clockwise"===JSM.CoordTurnType(e,f,h,d)&&(l=Math.PI-l),e=b/Math.sin(l),e=JSM.CoordOffset(f,g,e),e=JSM.CoordRotate(e,d,l,f),k.AddVertex(e.x,e.y,e.z);return k};
JSM.CutPolygonWithPlane=function(a,b,c,d,e){function f(a,b,c,d,e){1==b?c.push(a):-1==b?d.push(a):e.push(a)}function g(a,b,c,d){function e(a,b){if(!(2>b.length)){for(var c=a.GetVertex(b[0]),d=a.GetVertex(b[1]),d=JSM.CoordSub(d,c),f=JSM.GetPlaneFromCoordAndDirection(c,d),g,d=[],c=0;c<b.length;c++)g=a.GetVertex(b[c]),d.push(JSM.CoordPlaneSignedDistance(g,f));for(c=0;c<b.length-1;c++)for(f=0;f<b.length-c-1;f++)if(JSM.IsGreater(d[f],d[f+1])){g=d;var h=f+1,k=g[f];g[f]=g[h];g[h]=k;g=b;h=f+1;k=g[f];g[f]=
g[h];g[h]=k}}}function f(a,b,c,d,e,g){function h(a,b){a[a[b]]=-1;a[b]=-1}var k=[];(function(a,b,c){var d;for(d=0;d<a.VertexCount();d++)c.push(-1);for(d=0;d<b.length;d+=2){a=c;var e=b,f=d;a[e[f]]=e[f+1];a[e[f+1]]=e[f]}})(a,b,k);var l=0;g&&(l=b.length-1);for(var m=b[l],n=m,p=!1,q=0,r=new JSM.Polygon,s;;){p||(q=c[n],0!==q&&(p=!0));if(0<r.VertexCount()&&n==m)if(1==q?d.push(r):-1==q&&e.push(r),r=new JSM.Polygon,0<l&&l<b.length){n=m=b[l];continue}else break;s=a.GetVertex(n);r.AddVertex(s.x,s.y,s.z);-1!=
k[n]?(l=g?l-2:l+2,n=k[n],h(k,n)):n=n<a.VertexCount()-1?n+1:0}}var g=[];(function(a,b){var c,d,e,f;for(c=0;c<a.length;c++)if(d=a[c],0===d){d=0<c?c-1:a.length-1;e=c<a.length-1?c+1:0;f=a[d];e=a[e];if(0!==e&&0===f){for(;0===a[d];)d=0<d?d-1:a.length-1;f=a[d]}(-1==f&&1==e||1==f&&-1==e)&&b.push(c)}})(b,g);0===g.length||0!==g.length%2||(e(a,g),f(a,g,b,c,d,!1),f(a,g,b,c,d,!0))}var h=new JSM.Polygon,l=[];b=function(a,b,c,d){function e(a,c,d,f,g){function h(a,c,d,e,f,g){var k=d[d.length-1];0!==k&&(0!==g&&k!=
g)&&(e=a.GetVertex(e),a=a.GetVertex(f),a=new JSM.Line(a,JSM.CoordSub(a,e)),f=new JSM.Coord(0,0,0),"LineIntersectsPlane"==JSM.LinePlanePosition(a,b,f)&&(c.AddVertex(f.x,f.y,f.z),d.push(0)))}function k(a,b,c,d,e){a=a.GetVertex(d);b.AddVertex(a.x,a.y,a.z);c.push(e)}var l=0===c,n=c===a.VertexCount(),p;n?(c=0,p=a.VertexCount()-1):p=c-1;f=f[c];l||h(a,d,g,p,c,f);n||k(a,d,g,c,f);return f}var f=[],g=!1,h=!1,l,t,y;for(l=0;l<a.VertexCount();l++)t=a.GetVertex(l),t=JSM.CoordPlanePosition(t,b),y=0,"CoordInFrontOfPlane"==
t?(y=1,h=!0):"CoordAtBackOfPlane"==t&&(y=-1,g=!0),f.push(y);if(g&&h)for(l=0;l<=a.VertexCount();l++)e(a,l,c,f,d);else{if(g)return-1;if(h)return 1}return 0}(a,b,h,l);0===h.VertexCount()&&0===l.length?f(a,b,c,d,e):g(h,l,c,d);return 0===c.length+d.length+e.length?!1:!0};JSM.BSPNode=function(){this.outside=this.inside=this.parent=this.plane=this.userData=this.polygon=null};JSM.BSPNode.prototype.IsLeaf=function(){return null===this.inside&&null===this.outside};JSM.BSPTree=function(){this.root=null};
JSM.BSPTree.prototype.AddPolygon=function(a,b){null===this.root&&(this.root=this.GetNewNode());return this.AddPolygonToNode(this.root,a,b)};JSM.BSPTree.prototype.Traverse=function(a){this.TraverseNode(this.root,a)};JSM.BSPTree.prototype.TraverseNode=function(a,b){null!==a&&(b(a),this.TraverseNode(a.inside,b),this.TraverseNode(a.outside,b))};JSM.BSPTree.prototype.GetNodes=function(){var a=[];this.Traverse(function(b){a.push(b)});return a};
JSM.BSPTree.prototype.NodeCount=function(){var a=0;this.Traverse(function(){a+=1});return a};
JSM.BSPTree.prototype.AddPolygonToNode=function(a,b,c){if(3>b.VertexCount())return!1;var d;if(null===a.polygon){d=JSM.CalculateNormal(b.vertices);var e=JSM.GetPlaneFromCoordAndDirection(b.GetVertex(0),d);a.polygon=b;void 0!==c&&(a.userData=c);a.plane=e}else{d=[];var f=[],e=[];JSM.CutPolygonWithPlane(b,a.plane,f,d,e)&&(0<d.length&&this.AddInsidePolygonsToNode(a,d,c),0<f.length&&this.AddOutsidePolygonsToNode(a,f,c),0<e.length&&(d=JSM.CalculateNormal(b.vertices),0<JSM.VectorDot(d,a.plane.GetNormal())?
this.AddInsidePolygonsToNode(a,e,c):this.AddOutsidePolygonsToNode(a,e,c)))}return!0};JSM.BSPTree.prototype.AddInsidePolygonsToNode=function(a,b,c){null===a.inside&&(a.inside=this.GetNewNode(),a.inside.parent=a);var d;for(d=0;d<b.length;d++)this.AddPolygonToNode(a.inside,b[d],c)};JSM.BSPTree.prototype.AddOutsidePolygonsToNode=function(a,b,c){null===a.outside&&(a.outside=this.GetNewNode(),a.outside.parent=a);var d;for(d=0;d<b.length;d++)this.AddPolygonToNode(a.outside,b[d],c)};
JSM.BSPTree.prototype.GetNewNode=function(){return new JSM.BSPNode};
JSM.ClipPolygonWithBSPTree=function(a,b,c,d,e,f){function g(a,b,c){if(null!==b){var d=[],e=[],f=[];JSM.CutPolygonWithPlane(a,b.plane,e,d,f)&&(0<d.length&&l(b,d,c),0<e.length&&k(b,e,c),0<f.length&&(a=JSM.CalculateNormal(a.vertices),0<JSM.VectorDot(a,b.plane.GetNormal())?l(b,f,!0):k(b,f,!0)))}}function h(a,b){var c;for(c=0;c<a.length;c++)b.push(a[c])}function l(a,b,c){if(null!==a.inside){a=a.inside;var e;for(e=0;e<b.length;e++)g(b[e],a,c)}else h(b,c?f:d)}function k(a,b,d){if(null!==a.outside){a=a.outside;
var f;for(f=0;f<b.length;f++)g(b[f],a,d)}else h(b,d?e:c)}g(a,b.root,!1);return!0};JSM.GetGaussianCParameter=function(a,b,c,d){return Math.sqrt(-(Math.pow(a-c,2)/(2*Math.log(d/Math.abs(b)))))};JSM.GetGaussianValue=function(a,b,c,d){return b*Math.exp(-(Math.pow(a-c,2)/(2*Math.pow(d,2))))};JSM.GenerateCirclePoints=function(a,b,c){var d=[],e=2*Math.PI,f=2*Math.PI/b,g,h;for(g=0;g<b;g++)h=JSM.CylindricalToCartesian(a,0,e),void 0!==c&&null!==c&&(h=JSM.CoordAdd(h,c)),d.push(h),e+=f;return d};
JSM.GetRuledMesh=function(a,b,c,d,e){if(a.length===b.length){var f=a.length-1,g=[],h=[],l;for(l=0;l<=f;l++)g.push(JSM.CoordSub(b[l],a[l])),h.push(JSM.CoordDistance(a[l],b[l]));var k,m;for(l=0;l<=f;l++){k=h[l]/c;for(b=0;b<=c;b++)m=JSM.CoordOffset(a[l],g[l],k*b),d.push(m)}for(l=0;l<f;l++)for(b=0;b<c;b++)a=l*(c+1)+b,d=a+1,g=a+c+1,h=g+1,a=[a,g,h,d],e.push(a)}};JSM.BodyVertex=function(a){this.position=a};JSM.BodyVertex.prototype.GetPosition=function(){return this.position};
JSM.BodyVertex.prototype.SetPosition=function(a){this.position=a};JSM.BodyVertex.prototype.Clone=function(){return new JSM.BodyVertex(this.position.Clone())};JSM.BodyPolygon=function(a){this.vertices=a;this.curved=this.material=-1};JSM.BodyPolygon.prototype.AddVertexIndex=function(a){this.vertices.push(a)};JSM.BodyPolygon.prototype.GetVertexIndex=function(a){return this.vertices[a]};JSM.BodyPolygon.prototype.VertexIndexCount=function(){return this.vertices.length};
JSM.BodyPolygon.prototype.HasMaterialIndex=function(){return-1!==this.material};JSM.BodyPolygon.prototype.GetMaterialIndex=function(){return this.material};JSM.BodyPolygon.prototype.SetMaterialIndex=function(a){this.material=a};JSM.BodyPolygon.prototype.HasCurveGroup=function(){return-1!==this.curved};JSM.BodyPolygon.prototype.GetCurveGroup=function(){return this.curved};JSM.BodyPolygon.prototype.SetCurveGroup=function(a){this.curved=a};
JSM.BodyPolygon.prototype.InheritAttributes=function(a){this.material=a.material;this.curved=a.curved};JSM.BodyPolygon.prototype.Clone=function(){var a=new JSM.BodyPolygon([]),b;for(b=0;b<this.vertices.length;b++)a.vertices.push(this.vertices[b]);a.material=this.material;a.curved=this.curved;return a};JSM.Body=function(){this.vertices=[];this.polygons=[];this.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1))};
JSM.Body.prototype.AddVertex=function(a){this.vertices.push(a);return this.vertices.length-1};JSM.Body.prototype.AddPolygon=function(a){this.polygons.push(a);return this.polygons.length-1};JSM.Body.prototype.GetVertex=function(a){return this.vertices[a]};JSM.Body.prototype.GetVertexPosition=function(a){return this.vertices[a].position};JSM.Body.prototype.SetVertexPosition=function(a,b){this.vertices[a].position=b};JSM.Body.prototype.VertexCount=function(){return this.vertices.length};
JSM.Body.prototype.GetPolygon=function(a){return this.polygons[a]};JSM.Body.prototype.PolygonCount=function(){return this.polygons.length};JSM.Body.prototype.SetPolygonsMaterialIndex=function(a){var b;for(b=0;b<this.polygons.length;b++)this.polygons[b].SetMaterialIndex(a)};JSM.Body.prototype.SetPolygonsCurveGroup=function(a){var b;for(b=0;b<this.polygons.length;b++)this.polygons[b].SetCurveGroup(a)};JSM.Body.prototype.GetTextureProjectionType=function(){return this.projection};
JSM.Body.prototype.SetTextureProjectionType=function(a){this.projection=a};JSM.Body.prototype.GetTextureProjectionCoords=function(){return this.coords};JSM.Body.prototype.SetTextureProjectionCoords=function(a){this.coords=a};JSM.Body.prototype.SetPlanarTextureProjection=function(a,b,c){this.SetTextureProjectionType("Planar");this.SetTextureProjectionCoords(new JSM.CoordSystem(a,b,JSM.VectorCross(b,c),new JSM.Coord(0,0,0)))};
JSM.Body.prototype.SetCubicTextureProjection=function(a,b,c,d){this.SetTextureProjectionType("Cubic");this.SetTextureProjectionCoords(new JSM.CoordSystem(a,b,c,d))};JSM.Body.prototype.SetCylindricalTextureProjection=function(a,b,c,d){this.SetTextureProjectionType("Cylindrical");this.SetTextureProjectionCoords(new JSM.CoordSystem(a,JSM.VectorSetLength(c,b),JSM.VectorSetLength(JSM.VectorCross(d,c),b),d))};
JSM.Body.prototype.Transform=function(a){var b;for(b=0;b<this.vertices.length;b++)this.vertices[b].position=a.Apply(this.vertices[b].position);null!==this.coords&&(b=JSM.CoordSystemToAbsoluteCoords(this.coords),b.origo=a.Apply(b.origo),b.e1=a.Apply(b.e1),b.e2=a.Apply(b.e2),b.e3=a.Apply(b.e3),this.coords=JSM.CoordSystemToDirectionVectors(b))};
JSM.Body.prototype.GetBoundingBox=function(){var a=new JSM.Coord(JSM.Inf,JSM.Inf,JSM.Inf),b=new JSM.Coord(-JSM.Inf,-JSM.Inf,-JSM.Inf),c,d;for(c=0;c<this.vertices.length;c++)d=this.vertices[c].position,a.x=JSM.Minimum(a.x,d.x),a.y=JSM.Minimum(a.y,d.y),a.z=JSM.Minimum(a.z,d.z),b.x=JSM.Maximum(b.x,d.x),b.y=JSM.Maximum(b.y,d.y),b.z=JSM.Maximum(b.z,d.z);return[a,b]};JSM.Body.prototype.GetCenter=function(){var a=this.GetBoundingBox();return JSM.MidCoord(a[0],a[1])};
JSM.Body.prototype.GetBoundingSphereRadius=function(){var a=this.GetCenter(),b=0,c,d;for(c=0;c<this.vertices.length;c++)d=JSM.CoordDistance(a,this.vertices[c].position),JSM.IsGreater(d,b)&&(b=d);return b};JSM.Body.prototype.OffsetToOrigo=function(){var a=this.GetCenter(),a=JSM.VectorMultiply(a,-1),b;for(b=0;b<this.vertices.length;b++)this.vertices[b].position=JSM.CoordAdd(this.vertices[b].position,a)};
JSM.Body.prototype.Merge=function(a){var b=this.vertices.length,c,d;for(c=0;c<a.VertexCount();c++)this.vertices.push(a.GetVertex(c).Clone());var e;for(c=0;c<a.PolygonCount();c++){e=a.GetPolygon(c).Clone();for(d=0;d<e.VertexIndexCount();d++)e.vertices[d]+=b;this.polygons.push(e)}};JSM.Body.prototype.Clear=function(){this.vertices=[];this.polygons=[];this.coords=this.projection=null};JSM.Model=function(){this.bodies=[]};
JSM.Model.prototype.AddBody=function(a){this.bodies.push(a);return this.bodies.length-1};JSM.Model.prototype.GetBody=function(a){return this.bodies[a]};JSM.Model.prototype.BodyCount=function(){return this.bodies.length};JSM.Model.prototype.VertexCount=function(){var a=0,b;for(b=0;b<this.bodies.length;b++)a+=this.bodies[b].VertexCount();return a};JSM.Model.prototype.PolygonCount=function(){var a=0,b;for(b=0;b<this.bodies.length;b++)a+=this.bodies[b].PolygonCount();return a};
JSM.HexColorToRGBComponents=function(a){for(var b=a.toString(16);6>b.length;)b="0"+b;a=parseInt(b.substr(0,2),16);var c=parseInt(b.substr(2,2),16),b=parseInt(b.substr(4,2),16);return[a,c,b]};JSM.HexColorToNormalizedRGBComponents=function(a){a=JSM.HexColorToRGBComponents(a);return[a[0]/255,a[1]/255,a[2]/255]};JSM.HexColorToRGBColor=function(a){return parseInt("0x"+a,16)};
JSM.RGBComponentsToHexColor=function(a,b,c){function d(a){for(a=parseInt(a,10).toString(16);2>a.length;)a="0"+a;return a}a=d(a);b=d(b);c=d(c);return parseInt("0x"+a+b+c,16)};JSM.Light=function(a){var b=8355711,c=8355711,d=0,e=new JSM.Vector(1,0,0);void 0!==a&&null!==a&&(b=JSM.ValueOrDefault(a.ambient,b),c=JSM.ValueOrDefault(a.diffuse,c),d=JSM.ValueOrDefault(a.specular,d),e=JSM.ValueOrDefault(a.direction,e));this.ambient=b;this.diffuse=c;this.specular=d;this.direction=e};
JSM.Material=function(a){var b=52224,c=52224,d=0,e=0,f=1,g=null,h=1,l=1;void 0!==a&&null!==a&&(b=JSM.ValueOrDefault(a.ambient,b),c=JSM.ValueOrDefault(a.diffuse,c),d=JSM.ValueOrDefault(a.specular,d),e=JSM.ValueOrDefault(a.shininess,e),f=JSM.ValueOrDefault(a.opacity,f),g=JSM.ValueOrDefault(a.texture,g),h=JSM.ValueOrDefault(a.textureWidth,h),l=JSM.ValueOrDefault(a.textureHeight,l));this.ambient=b;this.diffuse=c;this.specular=d;this.shininess=e;this.opacity=f;this.texture=g;this.textureWidth=h;this.textureHeight=
l};JSM.Materials=function(){this.materials=[];this.defaultMaterial=new JSM.Material};JSM.Materials.prototype.GetMaterial=function(a){return 0>a||a>=this.materials.length?this.defaultMaterial:this.materials[a]};JSM.Materials.prototype.AddMaterial=function(a){this.materials.push(a)};JSM.Materials.prototype.GetDefaultMaterial=function(){return this.defaultMaterial};JSM.Materials.prototype.Count=function(){return this.materials.length};
JSM.AddVertexToBody=function(a,b,c,d){a.AddVertex(new JSM.BodyVertex(new JSM.Coord(b,c,d)))};JSM.AddPolygonToBody=function(a,b){a.AddPolygon(new JSM.BodyPolygon(b))};JSM.CalculateBodyVertexToPolygon=function(a){var b=[],c,d;for(c=0;c<a.VertexCount();c++)b.push([]);var e;for(c=0;c<a.PolygonCount();c++){e=a.GetPolygon(c);for(d=0;d<e.VertexIndexCount();d++)b[e.GetVertexIndex(d)].push(c)}return b};
JSM.CalculateBodyPolygonNormal=function(a,b){var c=a.GetPolygon(b),d=c.VertexIndexCount(),e=new JSM.Vector(0,0,0);if(3<=d){var f,g,h;for(f=0;f<d;f++)g=f,h=(f+1)%d,g=a.GetVertexPosition(c.GetVertexIndex(g)),h=a.GetVertexPosition(c.GetVertexIndex(h)),e.x+=(g.y-h.y)*(g.z+h.z),e.y+=(g.z-h.z)*(g.x+h.x),e.z+=(g.x-h.x)*(g.y+h.y)}return JSM.VectorNormalize(e)};JSM.CalculateBodyPolygonNormals=function(a){var b=[],c;for(c=0;c<a.PolygonCount();c++)b.push(JSM.CalculateBodyPolygonNormal(a,c));return b};
JSM.CalculateBodyVertexNormals=function(a){var b=[],c=JSM.CalculateBodyPolygonNormals(a),d=null,e,f,g,h,l,k,m,n;for(e=0;e<a.PolygonCount();e++)if(h=a.GetPolygon(e),b[e]=[],h.HasCurveGroup()){null===d&&(d=JSM.CalculateBodyVertexToPolygon(a));for(f=0;f<h.VertexIndexCount();f++){l=new JSM.Vector(0,0,0);k=0;m=d[h.GetVertexIndex(f)];for(g=0;g<m.length;g++)n=a.GetPolygon(m[g]),n.GetCurveGroup()===h.GetCurveGroup()&&(l=JSM.CoordAdd(l,c[m[g]]),k++);l=JSM.VectorMultiply(l,1/k);l=JSM.VectorNormalize(l);b[e].push(l)}}else{g=
c[e];for(f=0;f<h.VertexIndexCount();f++)b[e].push(new JSM.Vector(g.x,g.y,g.z))}return b};JSM.MakeBodyInsideOut=function(a){var b,c,d,e,f;for(b=0;b<a.PolygonCount();b++){d=a.GetPolygon(b);f=d.vertices.slice(0);e=f.length;d.vertices=[];for(c=0;c<e;c++)d.vertices.push(f[e-c-1])}};
JSM.SoftMoveBodyVertex=function(a,b,c,d,e){b=a.GetVertex(b).position;var f=JSM.GetGaussianCParameter(c,e,0,1E-5),g,h,l;for(g=0;g<a.VertexCount();g++)h=JSM.CoordDistance(b,a.GetVertex(g).position),JSM.IsGreater(h,c)||(h=JSM.GetGaussianValue(h,e,0,f),l=a.GetVertex(g).position,a.GetVertex(g).position=JSM.CoordOffset(l,d,h))};
JSM.CalculatePolygonCentroid=function(a,b){var c=a.GetPolygon(b),d=c.VertexIndexCount(),e=new JSM.Coord(0,0,0),f;for(f=0;f<d;f++)e=JSM.CoordAdd(e,a.GetVertexPosition(c.GetVertexIndex(f)));return e=JSM.VectorMultiply(e,1/d)};
JSM.TriangulateWithCentroids=function(a){var b=new JSM.Body,c,d;for(c=0;c<a.VertexCount();c++)d=a.GetVertex(c).position,b.AddVertex(new JSM.BodyVertex(new JSM.Coord(d.x,d.y,d.z)));var e,f,g,h,l;for(c=0;c<a.PolygonCount();c++){d=JSM.CalculatePolygonCentroid(a,c);l=b.VertexCount();b.AddVertex(new JSM.BodyVertex(new JSM.Coord(d.x,d.y,d.z)));f=a.GetPolygon(c);g=f.VertexIndexCount();for(d=0;d<g;d++)e=f.GetVertexIndex(d),h=f.GetVertexIndex(d<g-1?d+1:0),e=new JSM.BodyPolygon([e,h,l]),e.material=f.material,
e.curved=f.curved,b.AddPolygon(e)}return b};
JSM.TriangulatePolygons=function(a){var b=new JSM.Body,c,d,e;for(c=0;c<a.VertexCount();c++)e=a.GetVertexPosition(c),b.AddVertex(new JSM.BodyVertex(new JSM.Coord(e.x,e.y,e.z)));var f,g;for(c=0;c<a.PolygonCount();c++){f=new JSM.Polygon;g=a.GetPolygon(c);for(d=0;d<g.VertexIndexCount();d++)e=a.GetVertexPosition(g.GetVertexIndex(d)),f.AddVertex(e.x,e.y,e.z);e=JSM.PolygonTriangulate(f);for(d=0;d<e.length;d++)f=e[d],f=new JSM.BodyPolygon([g.GetVertexIndex(f[0]),g.GetVertexIndex(f[1]),g.GetVertexIndex(f[2])]),
f.InheritAttributes(g),b.AddPolygon(f)}return b};JSM.GenerateRandomMaterials=function(a,b,c){var d,e;for(d=0;d<a.PolygonCount();d++)e=void 0!==c&&c?JSM.SeededRandomInt(0,16777215,d+1):JSM.RandomInt(0,16777215),b.AddMaterial(new JSM.Material({ambient:e,diffuse:e})),e=b.Count()-1,a.GetPolygon(d).SetMaterialIndex(e)};JSM.VertInfo=function(){this.edges=[];this.pgons=[]};JSM.EdgeInfo=function(){this.pgon2=this.pgon1=this.vert2=this.vert1=-1};JSM.PolyEdgeInfo=function(){this.index=-1;this.reverse=!1};
JSM.PgonInfo=function(){this.verts=[];this.pedges=[]};JSM.AdjacencyInfo=function(){this.verts=[];this.edges=[];this.pgons=[]};JSM.GetPolyEdgeStartVertex=function(a,b){return a.reverse?b.edges[a.index].vert2:b.edges[a.index].vert1};JSM.GetPolyEdgeEndVertex=function(a,b){return a.reverse?b.edges[a.index].vert1:b.edges[a.index].vert2};
JSM.CalculateAdjacencyInfo=function(a){var b=new JSM.AdjacencyInfo,c,d,e;for(c=0;c<a.VertexCount();c++)d=new JSM.VertInfo,b.verts.push(d);var f,g,h,l,k;for(c=0;c<a.PolygonCount();c++){f=a.GetPolygon(c);e=new JSM.PgonInfo;g=f.VertexIndexCount();for(d=0;d<g;d++){h=f.GetVertexIndex(d);l=f.GetVertexIndex(d<g-1?d+1:0);k=h;var m=l;l=c;for(var n=new JSM.PolyEdgeInfo,p=void 0,q=void 0,p=0;p<b.edges.length;p++)q=b.edges[p],q.vert1===k&&q.vert2===m?(n.index=p,n.reverse=!1):q.vert1===m&&q.vert2===k&&(n.index=
p,n.reverse=!0);-1===n.index?(p=new JSM.EdgeInfo,p.vert1=k,p.vert2=m,p.pgon1=l,p.pgon2=-1,b.edges.push(p),n.index=b.edges.length-1,n.reverse=!1):(k=b.edges[n.index],-1===k.pgon1?k.pgon1=l:k.pgon1!==l&&-1===k.pgon2&&(k.pgon2=l));k=n;e.verts.push(h);e.pedges.push(k);b.verts[h].edges.push(k.index);b.verts[h].pgons.push(c)}b.pgons.push(e)}return b};JSM.IsSolidBody=function(a){a=JSM.CalculateAdjacencyInfo(a);var b,c;for(b=0;b<a.edges.length;b++)if(c=a.edges[b],-1===c.pgon1||-1===c.pgon2)return!1;return!0};
JSM.CheckSolidBody=function(a){a=JSM.CalculateAdjacencyInfo(a);var b,c,d,e,f,g,h,l;for(b=0;b<a.edges.length;b++){d=a.edges[b];if(-1===d.pgon1||-1===d.pgon2)return!1;g=a.pgons[d.pgon1];f=!1;for(c=0;c<g.pedges.length;c++)if(e=g.pedges[c],e.index==b){h=e.reverse;f=!0;break}if(!f)return!1;d=a.pgons[d.pgon2];f=!1;for(c=0;c<d.pedges.length;c++)if(e=d.pedges[c],e.index==b){l=e.reverse;f=!0;break}if(!f||h==l)return!1}return!0};
JSM.CalculatePlanarTextureCoord=function(a,b){var c=new JSM.Coord2D(0,0),d=JSM.VectorNormalize(b.e1),e=JSM.VectorNormalize(b.e2),f=JSM.VectorCross(b.e1,b.e2),f=JSM.GetPlaneFromCoordAndDirection(b.origo,f),e=JSM.GetPlaneFromCoordAndDirection(b.origo,e),d=JSM.GetPlaneFromCoordAndDirection(b.origo,d),f=JSM.ProjectCoordToPlane(a,f);c.x=JSM.CoordPlaneSignedDistance(f,d);c.y=JSM.CoordPlaneSignedDistance(f,e);return c};
JSM.CalculateCubicTextureCoord=function(a,b,c){var d=new JSM.Coord2D(0,0),e=JSM.VectorNormalize(c.e1),f=JSM.VectorNormalize(c.e2),g=JSM.VectorNormalize(c.e3),h=-1,l=0,k,m,n;for(k=0;3>k;k++)0===k?m=e:1===k?m=f:2===k&&(m=g),n=Math.abs(JSM.VectorDot(b,m)),JSM.IsGreater(n,l)&&(h=k,l=n);if(-1===h)return d;b=null;0===h?b=new JSM.CoordSystem(c.origo,f,g,new JSM.Coord(0,0,0)):1===h?b=new JSM.CoordSystem(c.origo,e,g,new JSM.Coord(0,0,0)):2===h&&(b=new JSM.CoordSystem(c.origo,e,f,new JSM.Coord(0,0,0)));return null===
b?d:JSM.CalculatePlanarTextureCoord(a,b)};JSM.CalculateCylindricalTextureCoord=function(a,b,c){var d=new JSM.Coord2D(0,0),e=JSM.VectorNormalize(c.e3);if(JSM.VectorsAreCollinear(e,b))return d=JSM.CalculateCubicTextureCoord(a,b,c),[d,0];b=new JSM.Line(c.origo,e);var f=JSM.ProjectCoordToLine(a,b);b=JSM.CoordSignedDistance(c.origo,f,e);var g=JSM.VectorNormalize(c.e1);a=JSM.CoordSub(a,f);e=JSM.GetVectorsFullAngle(a,g,e);c=JSM.VectorLength(c.e1);d.x=e*c;d.y=b;return[d,e]};
JSM.CalculatePolygonPlanarTextureCoords=function(a,b){var c=[],d=a.GetPolygon(b),e=a.GetTextureProjectionCoords(),f,g;for(f=0;f<d.VertexIndexCount();f++)g=a.GetVertexPosition(d.GetVertexIndex(f)),c.push(JSM.CalculatePlanarTextureCoord(g,e));return c};JSM.CalculatePolygonCubicTextureCoords=function(a,b,c){var d=[];b=a.GetPolygon(b);var e=a.GetTextureProjectionCoords(),f,g;for(f=0;f<b.VertexIndexCount();f++)g=a.GetVertexPosition(b.GetVertexIndex(f)),d.push(JSM.CalculateCubicTextureCoord(g,c,e));return d};
JSM.CalculatePolygonCylindricalTextureCoords=function(a,b,c){var d=[],e=[],f=a.GetPolygon(b);b=a.GetTextureProjectionCoords();var g,h;for(g=0;g<f.VertexIndexCount();g++)h=a.GetVertexPosition(f.GetVertexIndex(g)),h=JSM.CalculateCylindricalTextureCoord(h,c,b),d.push(h[0]),e.push(h[1]);g=JSM.VectorNormalize(b.e3);if(JSM.VectorsAreCollinear(g,c))return d;a=!1;for(g=0;g<e.length;g++){for(c=g+1;c<e.length;c++)if(JSM.IsGreater(Math.abs(e[g]-e[c]),Math.PI)){a=!0;break}if(a)break}if(a){b=JSM.VectorLength(b.e1);
for(g=0;g<e.length;g++)JSM.IsLower(e[g],Math.PI)&&(d[g].x=b*(e[g]+2*Math.PI))}return d};JSM.CalculateBodyPlanarTextureCoords=function(a){var b=[],c;for(c=0;c<a.PolygonCount();c++)b.push(JSM.CalculatePolygonPlanarTextureCoords(a,c));return b};JSM.CalculateBodyCubicTextureCoords=function(a){var b=[],c=JSM.CalculateBodyPolygonNormals(a),d,e;for(d=0;d<a.PolygonCount();d++)e=c[d],b.push(JSM.CalculatePolygonCubicTextureCoords(a,d,e));return b};
JSM.CalculateBodyCylindricalTextureCoords=function(a){var b=[],c=JSM.CalculateBodyPolygonNormals(a),d,e;for(d=0;d<a.PolygonCount();d++)e=c[d],b.push(JSM.CalculatePolygonCylindricalTextureCoords(a,d,e));return b};JSM.CalculateBodyTextureCoords=function(a){var b=[],c=a.GetTextureProjectionType();"Planar"===c?b=JSM.CalculateBodyPlanarTextureCoords(a):"Cubic"===c?b=JSM.CalculateBodyCubicTextureCoords(a):"Cylindrical"===c&&(b=JSM.CalculateBodyCylindricalTextureCoords(a));return b};
JSM.CutBodyByPlane=function(a,b){function c(a,b,c){function d(a){q.push(new JSM.Coord(p.x,p.y,p.z));r.push(a)}function e(c,d){s=JSM.VectorNormalize(JSM.CoordSub(a[d],a[c]));M=new JSM.Line(a[c],s);w=JSM.LinePlaneIntersection(M,b);q.push(new JSM.Coord(w.x,w.y,w.z));r.push(-1)}var f=void 0!==c&&null!==c,g=a.length,h=[],k=[],l=!1,m,n,p;for(m=0;m<g;m++)p=a[m],n=JSM.CoordPlanePosition(p,b),k.push("CoordAtBackOfPlane"!==n),0<m&&k[m-1]!==k[m]&&(l=!0);if(!l){if(!1===k[0])return h;for(m=0;m<g;m++)p=a[m],h.push(new JSM.Coord(p.x,
p.y,p.z)),f&&c.push(m);return h}var q=[],r=[],s,M,w;for(m=0;m<g;m++)l=m-1,n=m,0===m&&(l=g-1),p=a[n],k[n]?(k[l]||e(l,n),d(n)):k[l]&&e(l,n);for(m=0;m<q.length;m++)g=q[m],k=h[h.length-1],0===m||!JSM.CoordIsEqual(k,g)?(h.push(new JSM.Coord(g.x,g.y,g.z)),f&&(g=r[m],c.push(g))):f&&(g=r[m],k=r[m-1],-1!==g?c[c.length-1]=g:-1!==k&&(c[c.length-1]=k));return h}function d(a){var b=-1,c;for(c=s;c<e.VertexCount();c++)if(JSM.CoordIsEqual(e.GetVertexPosition(c),a)){b=c;break}-1===b&&(b=e.AddVertex(new JSM.BodyVertex(new JSM.Coord(a.x,
a.y,a.z))));return b}var e=new JSM.Body,f=[],g=[],h=[],l=[],k,m,n,p,q;for(k=0;k<a.PolygonCount();k++){n=a.GetPolygon(k);p=[];for(m=0;m<n.VertexIndexCount();m++)q=a.GetVertexPosition(n.GetVertexIndex(m)),p.push(new JSM.Coord(q.x,q.y,q.z));q=[];p=c(p,b,q);for(m=0;m<q.length;m++)-1!==q[m]&&(h[n.GetVertexIndex(q[m])]=!0);f.push(p);g.push(q)}var r;for(k=0;k<a.VertexCount();k++)h[k]&&(r=a.GetVertexPosition(k),l[k]=e.AddVertex(new JSM.BodyVertex(new JSM.Coord(r.x,r.y,r.z))));var s=e.VertexCount();for(k=
0;k<a.PolygonCount();k++)if(n=a.GetPolygon(k),p=f[k],q=g[k],0!==q.length){h=[];for(m=0;m<q.length;m++)-1!==q[m]?h.push(l[n.GetVertexIndex(q[m])]):(r=p[m],h.push(d(r)));m=new JSM.BodyPolygon(h);m.InheritAttributes(n);e.AddPolygon(m)}return e};
JSM.GenerateRectangle=function(a,b){var c=new JSM.Body,d=a/2,e=b/2;c.AddVertex(new JSM.BodyVertex(new JSM.Coord(-d,-e,0)));c.AddVertex(new JSM.BodyVertex(new JSM.Coord(d,-e,0)));c.AddVertex(new JSM.BodyVertex(new JSM.Coord(d,e,0)));c.AddVertex(new JSM.BodyVertex(new JSM.Coord(-d,e,0)));c.AddPolygon(new JSM.BodyPolygon([0,1,2,3]));c.SetCubicTextureProjection(new JSM.Coord(-d,-e,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return c};
JSM.GenerateCuboid=function(a,b,c){var d=new JSM.Body;a/=2;b/=2;c/=2;d.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,-b,-c)));d.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,-b,-c)));d.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,-b,c)));d.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,-b,c)));d.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,b,-c)));d.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,b,-c)));d.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,b,c)));d.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,
b,c)));d.AddPolygon(new JSM.BodyPolygon([0,1,2,3]));d.AddPolygon(new JSM.BodyPolygon([1,5,6,2]));d.AddPolygon(new JSM.BodyPolygon([5,4,7,6]));d.AddPolygon(new JSM.BodyPolygon([4,0,3,7]));d.AddPolygon(new JSM.BodyPolygon([0,4,5,1]));d.AddPolygon(new JSM.BodyPolygon([3,2,6,7]));d.SetCubicTextureProjection(new JSM.Coord(-a,-b,-c),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return d};
JSM.GenerateCuboidSides=function(a,b,c,d){var e=new JSM.Body;a/=2;b/=2;c/=2;e.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,-b,-c)));e.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,-b,-c)));e.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,-b,c)));e.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,-b,c)));e.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,b,-c)));e.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,b,-c)));e.AddVertex(new JSM.BodyVertex(new JSM.Coord(a,b,c)));e.AddVertex(new JSM.BodyVertex(new JSM.Coord(-a,
b,c)));d[0]&&e.AddPolygon(new JSM.BodyPolygon([0,1,2,3]));d[1]&&e.AddPolygon(new JSM.BodyPolygon([1,5,6,2]));d[2]&&e.AddPolygon(new JSM.BodyPolygon([5,4,7,6]));d[3]&&e.AddPolygon(new JSM.BodyPolygon([4,0,3,7]));d[4]&&e.AddPolygon(new JSM.BodyPolygon([0,4,5,1]));d[5]&&e.AddPolygon(new JSM.BodyPolygon([3,2,6,7]));e.SetCubicTextureProjection(new JSM.Coord(-a,-b,-c),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return e};
JSM.GenerateSegmentedRectangle=function(a,b,c,d){var e=new JSM.Body,f=a/2,g=b/2,h=a/c,l=b/d;(function(){var a,b,n;for(a=0;a<=d;a++)for(b=0;b<=c;b++)n=new JSM.Coord(b*h-f,a*l-g,0),e.AddVertex(new JSM.BodyVertex(n))})();(function(){var a,b,f,g,h,l;for(b=0;b<d;b++)for(a=0;a<c;a++)f=b*(c+1)+a,g=f+1,h=f+c+1,l=h+1,e.AddPolygon(new JSM.BodyPolygon([f,g,l,h]))})();return e};
JSM.GenerateSegmentedCuboid=function(a,b,c,d){function e(a){var b=0;0<a&&a<=d&&(b=(d+1)*(d+1)+(a-1)*4*d);return b}function f(a){var b=[],c=e(a);if(0===a||a===d){for(a=0;a<=d;a++)b.push(c+a);for(a=1;a<=d;a++)b.push(c+(a+1)*d+a);for(a=d-1;0<=a;a--)b.push(c+(d+1)*d+a);for(a=d-1;0<a;a--)b.push(c+a*(d+1))}else if(0<a&&a<d){for(a=0;a<=d;a++)b.push(c+a);for(a=1;a<d;a++)b.push(c+d+2*a);for(a=d;0<=a;a--)b.push(c+3*d+a-1);for(a=d-1;0<a;a--)b.push(c+d+2*a-1)}return b}function g(a){var b,c,e=a*r;if(0===a||a===
d)for(a=0;a<=d;a++)for(b=0;b<=d;b++)c=new JSM.Coord(b*p-k,a*q-m,e-n),l.AddVertex(new JSM.BodyVertex(c));else if(0<a&&a<d)for(a=0;a<=d;a++)for(b=0;b<=d;b++)if(0===a||a===d||0===b||b===d)c=new JSM.Coord(b*p-k,a*q-m,e-n),l.AddVertex(new JSM.BodyVertex(c))}function h(a){var b,c,f,g,h,k;if(0===a||a===d){var m=e(a);for(b=0;b<d;b++)for(c=0;c<d;c++)f=m+b*(d+1)+c,g=f+1,h=f+d+1,k=h+1,0===a?l.AddPolygon(new JSM.BodyPolygon([f,h,k,g])):l.AddPolygon(new JSM.BodyPolygon([f,g,k,h]))}if(0<a&&a<=d){c=s[a-1];a=s[a];
for(b=0;b<4*d;b++)f=c[b],h=a[b],b<4*d-1?(g=c[b+1],k=a[b+1]):(g=c[0],k=a[0]),l.AddPolygon(new JSM.BodyPolygon([f,g,k,h]))}}var l=new JSM.Body,k=a/2,m=b/2,n=c/2,p=a/d,q=b/d,r=c/d;for(a=0;a<=d;a++)g(a);var s=[];for(a=0;a<=d;a++)s.push(f(a));for(a=0;a<=d;a++)h(a);return l};
JSM.GenerateCircle=function(a,b){var c=new JSM.Body,d=JSM.GenerateCirclePoints(a,b),e;for(e=0;e<d.length;e++)c.AddVertex(new JSM.BodyVertex(d[e]));d=new JSM.BodyPolygon([]);for(e=0;e<b;e++)d.AddVertexIndex(e);c.AddPolygon(d);c.SetCylindricalTextureProjection(new JSM.Coord(0,0,0),a,new JSM.Coord(1,0,0),new JSM.Coord(0,0,1));return c};
JSM.GenerateSphere=function(a,b,c){var d=new JSM.Body,e=2*b,f=d.AddVertex(new JSM.BodyVertex(JSM.SphericalToCartesian(a,0,0))),g=Math.PI/b,h=g,l,k,m;for(l=1;l<b;l++){for(k=m=0;k<e;k++)d.AddVertex(new JSM.BodyVertex(JSM.SphericalToCartesian(a,h,m))),m+=g;h+=g}a=d.AddVertex(new JSM.BodyVertex(JSM.SphericalToCartesian(-a,0,0)));var n,p;for(l=1;l<=b;l++)if(1===l){g=1;for(k=0;k<e;k++)h=g+k,m=h+1,k===e-1&&(m=g),h=new JSM.BodyPolygon([h,m,f]),c&&h.SetCurveGroup(0),d.AddPolygon(h)}else if(l<b){g=(l-1)*e+
1;for(k=0;k<e;k++)h=g+k,m=h+1,n=h-e,p=n+1,k===e-1&&(m=g,p=g-e),h=new JSM.BodyPolygon([h,m,p,n]),c&&h.SetCurveGroup(0),d.AddPolygon(h)}else if(l===b){g=(l-2)*e+1;for(k=0;k<e;k++)h=g+k,m=h+1,k===e-1&&(m=g),h=new JSM.BodyPolygon([h,a,m]),c&&h.SetCurveGroup(0),d.AddPolygon(h)}d.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return d};
JSM.GenerateTriangulatedSphere=function(a,b,c){var d;d=new JSM.Body;var e=(1+Math.sqrt(5))/2;JSM.AddVertexToBody(d,0,1,+e);JSM.AddVertexToBody(d,0,1,-e);JSM.AddVertexToBody(d,0,-1,+e);JSM.AddVertexToBody(d,0,-1,-e);JSM.AddVertexToBody(d,1,+e,0);JSM.AddVertexToBody(d,1,-e,0);JSM.AddVertexToBody(d,-1,+e,0);JSM.AddVertexToBody(d,-1,-e,0);JSM.AddVertexToBody(d,+e,0,1);JSM.AddVertexToBody(d,-e,0,1);JSM.AddVertexToBody(d,+e,0,-1);JSM.AddVertexToBody(d,-e,0,-1);JSM.AddPolygonToBody(d,[0,2,8]);JSM.AddPolygonToBody(d,
[0,4,6]);JSM.AddPolygonToBody(d,[0,6,9]);JSM.AddPolygonToBody(d,[0,8,4]);JSM.AddPolygonToBody(d,[0,9,2]);JSM.AddPolygonToBody(d,[1,3,11]);JSM.AddPolygonToBody(d,[1,4,10]);JSM.AddPolygonToBody(d,[1,6,4]);JSM.AddPolygonToBody(d,[1,10,3]);JSM.AddPolygonToBody(d,[1,11,6]);JSM.AddPolygonToBody(d,[2,5,8]);JSM.AddPolygonToBody(d,[2,7,5]);JSM.AddPolygonToBody(d,[2,9,7]);JSM.AddPolygonToBody(d,[3,5,7]);JSM.AddPolygonToBody(d,[3,7,11]);JSM.AddPolygonToBody(d,[3,10,5]);JSM.AddPolygonToBody(d,[4,8,10]);JSM.AddPolygonToBody(d,
[6,11,9]);JSM.AddPolygonToBody(d,[5,10,8]);JSM.AddPolygonToBody(d,[7,9,11]);for(var e=JSM.VectorLength(d.GetVertexPosition(0)),f=a/e,g,h,e=0;e<d.VertexCount();e++)h=d.GetVertex(e),h.SetPosition(JSM.VectorMultiply(h.GetPosition(),f));for(var l,k,m,n,f=0;f<b;f++){g=d;d=new JSM.Body;h=JSM.CalculateAdjacencyInfo(g);for(e=0;e<h.verts.length;e++)l=g.GetVertexPosition(e),JSM.AddVertexToBody(d,l.x,l.y,l.z);l=[];for(e=0;e<h.edges.length;e++)k=h.edges[e],k=JSM.MidCoord(g.GetVertexPosition(k.vert1),g.GetVertexPosition(k.vert2)),
k=JSM.VectorMultiply(JSM.VectorNormalize(k),a),l.push(d.AddVertex(new JSM.BodyVertex(k)));for(e=0;e<h.pgons.length;e++){k=h.pgons[e];m=[];for(g=0;g<k.pedges.length;g++)n=k.pedges[g],m.push(JSM.GetPolyEdgeStartVertex(n,h)),m.push(l[n.index]);JSM.AddPolygonToBody(d,[m[0],m[1],m[5]]);JSM.AddPolygonToBody(d,[m[1],m[2],m[3]]);JSM.AddPolygonToBody(d,[m[3],m[4],m[5]]);JSM.AddPolygonToBody(d,[m[1],m[3],m[5]])}}if(c)for(e=0;e<d.PolygonCount();e++)d.GetPolygon(e).SetCurveGroup(0);d.SetCubicTextureProjection(new JSM.Coord(0,
0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return d};
JSM.GenerateCylinder=function(a,b,c,d,e){var f=new JSM.Body,g=2*Math.PI,h=2*Math.PI/c,l;for(l=0;l<c;l++)f.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(a,b/2,g))),f.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(a,-b/2,g))),g-=h;for(l=0;l<c;l++)g=2*l,h=g+2,l===c-1&&(h=0),g=new JSM.BodyPolygon([g,h,h+1,g+1]),e&&g.SetCurveGroup(0),f.AddPolygon(g);if(d){d=new JSM.BodyPolygon([]);e=new JSM.BodyPolygon([]);for(l=0;l<c;l++)d.AddVertexIndex(2*(c-l-1)),e.AddVertexIndex(2*l+1);f.AddPolygon(d);
f.AddPolygon(e)}f.SetCylindricalTextureProjection(new JSM.Coord(0,0,-(b/2)),a,new JSM.Coord(1,0,0),new JSM.Coord(0,0,1));return f};
JSM.GeneratePie=function(a,b,c,d,e,f){var g=new JSM.Body,h=c,l=c/(d-1);g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(0,b/2,0)));g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(0,-b/2,0)));for(c=0;c<d;c++)g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(a,b/2,h))),g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(a,-b/2,h))),h-=l;for(c=0;c<=d;c++)h=2*c,l=h+2,c===d&&(l=0),h=new JSM.BodyPolygon([h,l,l+1,h+1]),f&&(0<c&&c<d)&&h.SetCurveGroup(0),g.AddPolygon(h);if(e){e=
new JSM.BodyPolygon([]);f=new JSM.BodyPolygon([]);for(c=0;c<=d;c++)e.AddVertexIndex(2*(d-c)),f.AddVertexIndex(2*c+1);g.AddPolygon(e);g.AddPolygon(f)}g.SetCylindricalTextureProjection(new JSM.Coord(0,0,-(b/2)),a,new JSM.Coord(1,0,0),new JSM.Coord(0,0,1));return g};
JSM.GenerateCone=function(a,b,c,d,e,f){var g=new JSM.Body,h=JSM.IsZero(a),l=JSM.IsZero(b),k=2*Math.PI,m=2*Math.PI/d;h&&g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(0,c/2,0)));var n;for(n=0;n<d;n++)h||g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(a,c/2,k))),l||g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(b,-c/2,k))),k-=m;l&&g.AddVertex(new JSM.BodyVertex(JSM.CylindricalToCartesian(0,-c/2,0)));for(n=0;n<d;n++)h?(k=n+1,m=k+1,n===d-1&&(m=1),k=new JSM.BodyPolygon([0,
m,k])):l?(k=n,m=k+1,n===d-1&&(m=0),k=new JSM.BodyPolygon([k,m,d])):(k=2*n,m=k+2,n===d-1&&(m=0),k=new JSM.BodyPolygon([k,m,m+1,k+1])),f&&k.SetCurveGroup(0),g.AddPolygon(k);if(e)if(h){f=new JSM.BodyPolygon([]);for(n=0;n<d;n++)f.AddVertexIndex(n+1);g.AddPolygon(f)}else if(l){e=new JSM.BodyPolygon([]);for(n=0;n<d;n++)e.AddVertexIndex(d-n-1);g.AddPolygon(e)}else{e=new JSM.BodyPolygon([]);f=new JSM.BodyPolygon([]);for(n=0;n<d;n++)e.AddVertexIndex(2*(d-n-1)),f.AddVertexIndex(2*n+1);g.AddPolygon(e);g.AddPolygon(f)}g.SetCylindricalTextureProjection(new JSM.Coord(0,
0,-(c/2)),(a+b)/2,new JSM.Coord(1,0,0),new JSM.Coord(0,0,1));return g};
JSM.GeneratePrism=function(a,b,c,d){var e=new JSM.Body,f=a.length,g;for(g=0;g<f;g++)e.AddVertex(new JSM.BodyVertex(a[g])),e.AddVertex(new JSM.BodyVertex(JSM.CoordOffset(a[g],b,c)));var h;for(g=0;g<f;g++)c=2*g,h=c+2,g===f-1&&(h=0),e.AddPolygon(new JSM.BodyPolygon([c,h,h+1,c+1]));if(d){d=new JSM.BodyPolygon([]);c=new JSM.BodyPolygon([]);for(g=0;g<f;g++)d.AddVertexIndex(2*g+1),c.AddVertexIndex(2*(f-g-1));e.AddPolygon(d);e.AddPolygon(c)}f=JSM.VectorNormalize(JSM.CoordSub(a[1],a[0]));a=new JSM.Coord(a[0].x,
a[0].y,a[0].z);b=JSM.VectorNormalize(b);f=JSM.VectorCross(b,f);g=JSM.VectorCross(f,b);e.SetCubicTextureProjection(a,g,f,b);return e};JSM.GenerateCurvedPrism=function(a,b,c,d,e){c=JSM.GeneratePrism(a,c,d,e);if(void 0===b||null===b||a.length!=b.length)return c;for(d=0;d<a.length;d++)e=b[d],c.GetPolygon(d).SetCurveGroup(e);return c};
JSM.GeneratePrismWithHole=function(a,b,c,d){function e(){var b=0,c=[],d;for(d=0;d<a.length;d++)null===a[d]&&(b+=1),c.push(d-b);var b=JSM.CreatePolygonWithHole(a),e=new JSM.Polygon,g;for(d=0;d<b.length;d++)g=a[b[d]],e.AddVertex(g.x,g.y,g.z);g=JSM.PolygonTriangulate(e);var h,l,x;for(d=0;d<g.length;d++){h=g[d];l=new JSM.BodyPolygon([]);x=new JSM.BodyPolygon([]);for(e=0;3>e;e++)l.AddVertexIndex(2*c[b[h[e]]]+1),x.AddVertexIndex(2*c[b[h[3-e-1]]]);f.AddPolygon(l);f.AddPolygon(x)}}var f=new JSM.Body;(function(){var d;
for(d=0;d<a.length;d++)null!==a[d]&&(f.AddVertex(new JSM.BodyVertex(a[d])),f.AddVertex(new JSM.BodyVertex(JSM.CoordOffset(a[d],b,c))))})();(function(){var b=0,c=[];c.push(0);var d;for(d=0;d<a.length;d++)null===a[d]&&(c.push(d-b),b+=1);c.push(d-b);for(b=0;b<c.length-1;b++){var e=d=void 0,g=void 0,h=c[b],l=c[b+1];for(d=h;d<l;d++)e=2*d,g=e+2,d===l-1&&(g=2*h),f.AddPolygon(new JSM.BodyPolygon([e,g,g+1,e+1]))}})();d&&e();var g=JSM.VectorNormalize(JSM.CoordSub(a[1],a[0]));d=new JSM.Coord(a[0].x,a[0].y,a[0].z);
var h=JSM.VectorNormalize(b),g=JSM.VectorCross(h,g),l=JSM.VectorCross(g,h);f.SetCubicTextureProjection(d,l,g,h);return f};JSM.GenerateCurvedPrismWithHole=function(a,b,c,d,e){c=JSM.GeneratePrismWithHole(a,c,d,e);if(void 0===b||null===b||a.length!=b.length)return c;d=0;var f;for(e=0;e<a.length;e++)f=b[e],null!==f&&(c.GetPolygon(d).SetCurveGroup(f),d++);return c};
JSM.GeneratePrismShell=function(a,b,c,d,e){var f=new JSM.Body,g=a.length,h;for(h=0;h<g;h++)f.AddVertex(new JSM.BodyVertex(a[h]));h=new JSM.Polygon;h.vertices=a;d=JSM.OffsetPolygonContour(h,d).vertices;for(h=0;h<g;h++)f.AddVertex(new JSM.BodyVertex(d[h]));var l;for(h=0;h<g;h++)l=JSM.CoordOffset(a[h],b,c),f.AddVertex(new JSM.BodyVertex(l));for(h=0;h<g;h++)l=JSM.CoordOffset(d[h],b,c),f.AddVertex(new JSM.BodyVertex(l));var k;for(h=0;h<g;h++)c=h,d=c+1,l=c+2*g,k=l+1,h===g-1&&(d=0,k=2*g),f.AddPolygon(new JSM.BodyPolygon([c,
d,k,l])),f.AddPolygon(new JSM.BodyPolygon([c+g,l+g,k+g,d+g]));if(e)for(h=0;h<g;h++)c=h,d=c+1,l=h+g,k=l+1,h===g-1&&(d=0,k=g),f.AddPolygon(new JSM.BodyPolygon([c,l,k,d])),f.AddPolygon(new JSM.BodyPolygon([c+2*g,d+2*g,k+2*g,l+2*g]));e=JSM.VectorNormalize(JSM.CoordSub(a[1],a[0]));a=new JSM.Coord(a[0].x,a[0].y,a[0].z);b=JSM.VectorNormalize(b);e=JSM.VectorCross(b,e);g=JSM.VectorCross(e,b);f.SetCubicTextureProjection(a,g,e,b);return f};
JSM.GenerateCylinderShell=function(a,b,c,d,e,f){for(var g=new JSM.Vector(0,0,1),h=-b/2,l=[],k=2*Math.PI/d,m,n=0,n=0;n<d;n++)m=n*k,m=JSM.PolarToCartesian(a,m),l.push(new JSM.Coord(m.x,m.y,h));a=JSM.GeneratePrismShell(l,g,b,c,e);if(f)for(f=0;f<d;f++)a.GetPolygon(2*f).SetCurveGroup(0),a.GetPolygon(2*f+1).SetCurveGroup(0);return a};
JSM.GenerateLineShell=function(a,b,c,d,e,f){var g=new JSM.Body,h=a.length,l=[],k,m,n,p,q,r;for(k=0;k<h;k++)0===k||k===h-1?q=Math.PI/2:(m=k-1,n=k,p=k+1,r=JSM.CoordSub(a[p],a[n]),q=JSM.CoordSub(a[m],a[n]),q=JSM.GetVectorsAngle(r,q)/2,"Clockwise"===JSM.CoordTurnType(a[m],a[n],a[p],b)&&(q=Math.PI-q)),l.push(q);r=new JSM.Vector(0,0,1);m=[];var s;for(k=0;k<h;k++)n=k,k===h-1?s=JSM.CoordSub(a[n-1],a[n]):(p=(k+1)%h,s=JSM.CoordSub(a[n],a[p])),q=l[n],p=d/Math.sin(q),p=JSM.CoordOffset(a[n],s,p),p=JSM.CoordRotate(p,
r,-(Math.PI-q),a[n]),m.push(p);for(k=0;k<h;k++)g.AddVertex(new JSM.BodyVertex(a[k]));for(k=0;k<h;k++)g.AddVertex(new JSM.BodyVertex(m[k]));for(k=0;k<h;k++)n=JSM.CoordOffset(a[k],b,c),g.AddVertex(new JSM.BodyVertex(n));for(k=0;k<h;k++)n=JSM.CoordOffset(m[k],b,c),g.AddVertex(new JSM.BodyVertex(n));for(k=0;k<h-1;k++)n=k,p=n+1,c=n+2*h,d=c+1,g.AddPolygon(new JSM.BodyPolygon([n,p,d,c])),g.AddPolygon(new JSM.BodyPolygon([n+h,c+h,d+h,p+h]));e&&(n=0,g.AddPolygon(new JSM.BodyPolygon([n,n+2*h,n+3*h,n+h])),n=
h-1,g.AddPolygon(new JSM.BodyPolygon([n,n+h,n+3*h,n+2*h])));if(f)for(k=0;k<h-1;k++)n=k,p=n+1,c=k+h,d=c+1,g.AddPolygon(new JSM.BodyPolygon([n,c,d,p])),g.AddPolygon(new JSM.BodyPolygon([n+2*h,p+2*h,d+2*h,c+2*h]));e=JSM.VectorNormalize(JSM.CoordSub(a[1],a[0]));a=new JSM.Coord(a[0].x,a[0].y,a[0].z);b=JSM.VectorNormalize(b);e=JSM.VectorCross(b,e);f=JSM.VectorCross(e,b);g.SetCubicTextureProjection(a,f,e,b);return g};
JSM.GenerateTorus=function(a,b,c,d,e){var f=new JSM.Body,g=0,h=2*Math.PI/d,l=[],k,m;for(k=0;k<d;k++)m=JSM.PolarToCartesian(b,g),m=new JSM.Coord(m.x+a,0,m.y),l.push(m),g+=h;b=new JSM.Coord(0,0,1);g=new JSM.Coord(0,0,0);h=2*Math.PI/c;for(k=0;k<c;k++)for(a=0;a<d;a++)m=JSM.CoordRotate(l[a],b,k*h,g),f.AddVertex(new JSM.BodyVertex(m));for(k=0;k<c;k++){new JSM.BodyPolygon([]);for(a=0;a<d;a++)h=k*d+a,b=h+d,l=h+1,g=b+1,a===d-1&&(l=k*d,g=(k+1)*d),k===c-1&&(b=a,g=a+1,a===d-1&&(g=0)),h=new JSM.BodyPolygon([h,
b,g,l]),e&&h.SetCurveGroup(0),f.AddPolygon(h)}f.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return f};
JSM.GeneratePolyTorus=function(a,b,c,d){var e=new JSM.Body,f=a.length,g=2*Math.PI/f,h=[],l;for(l=0;l<f;l++)g=a[l],g=new JSM.Coord(g.x+b,0,g.y),h.push(g);b=new JSM.Coord(0,0,1);var k=new JSM.Coord(0,0,0),g=2*Math.PI/c,m;for(l=0;l<c;l++)for(a=0;a<f;a++)m=JSM.CoordRotate(h[a],b,l*g,k),e.AddVertex(new JSM.BodyVertex(m));for(l=0;l<c;l++){new JSM.BodyPolygon([]);for(a=0;a<f;a++)h=l*f+a,b=h+f,g=h+1,k=b+1,a===f-1&&(g=l*f,k=(l+1)*f),l===c-1&&(b=a,k=a+1,a===f-1&&(k=0)),h=new JSM.BodyPolygon([h,b,k,g]),d&&h.SetCurveGroup(a),
e.AddPolygon(h)}e.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return e};
JSM.GenerateRuledFromSectors=function(a,b,c,d,e){var f=new JSM.Body,g=[],h=[];JSM.GetSectorSegmentation(a,c,g);JSM.GetSectorSegmentation(b,c,h);b=[];a=[];JSM.GetRuledMesh(g,h,d,b,a);for(d=0;d<b.length;d++)f.AddVertex(new JSM.BodyVertex(b[d]));for(d=0;d<a.length;d++)g=a[d],g=new JSM.BodyPolygon(g),e&&g.SetCurveGroup(0),f.AddPolygon(g);f.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return f};
JSM.GenerateGrid=function(a,b,c,d,e){var f=new JSM.Sector(new JSM.Coord(0,0,0),new JSM.Coord(a,0,0));a=new JSM.Sector(new JSM.Coord(0,b,0),new JSM.Coord(a,b,0));return JSM.GenerateRuledFromSectors(f,a,c,d,e)};JSM.GenerateSquareGrid=function(a,b,c){return JSM.GenerateGrid(a,a,b,b,c)};
JSM.GenerateRuledFromSectorsWithHeight=function(a,b,c,d,e,f){var g=new JSM.Body,h=[],l=[];JSM.GetSectorSegmentation(a,c,h);JSM.GetSectorSegmentation(b,c,l);b=[];a=[];JSM.GetRuledMesh(h,l,d,b,a);for(h=0;h<b.length;h++)g.AddVertex(new JSM.BodyVertex(b[h]));for(var k,h=0;h<a.length;h++)k=a[h],k=new JSM.BodyPolygon(k),e&&k.SetCurveGroup(0),g.AddPolygon(k);l=g.VertexCount();for(h=0;h<b.length;h++)k=b[h],k=new JSM.Coord(k.x,k.y,k.z),k.z-=f,g.AddVertex(new JSM.BodyVertex(k));for(h=0;h<a.length;h++){k=a[h];
b=[];for(f=k.length-1;0<=f;f--)b.push(k[f]+l);k=new JSM.BodyPolygon(b);e&&k.SetCurveGroup(0);g.AddPolygon(k)}for(h=0;h<d;h++)e=h+l,f=e+1,a=e-l,b=a+1,k=new JSM.BodyPolygon([e,f,b,a]),g.AddPolygon(k);for(h=0;h<d;h++)e=h+c*(d+1)+l,f=e+1,a=e-l,b=a+1,k=new JSM.BodyPolygon([e,a,b,f]),g.AddPolygon(k);for(h=0;h<c;h++)e=h*(d+1)+l,f=e+d+1,a=e-l,b=a+d+1,k=new JSM.BodyPolygon([e,a,b,f]),g.AddPolygon(k);for(h=0;h<c;h++)e=(h+1)*d+h+l,f=e+d+1,a=e-l,b=a+d+1,k=new JSM.BodyPolygon([e,f,b,a]),g.AddPolygon(k);g.SetCubicTextureProjection(new JSM.Coord(0,
0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return g};JSM.GenerateRuledFromCoords=function(a,b,c,d){var e=new JSM.Body,f=[],g=[];JSM.GetRuledMesh(a,b,c,f,g);for(a=0;a<f.length;a++)e.AddVertex(new JSM.BodyVertex(f[a]));for(a=0;a<g.length;a++)f=g[a],f=new JSM.BodyPolygon(f),d&&f.SetCurveGroup(0),e.AddPolygon(f);e.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return e};
JSM.GenerateRevolved=function(a,b,c,d,e,f){var g=new JSM.Body,h=JSM.IsEqual(c,2*Math.PI),l=a.length,k=c/d;c=JSM.CoordSub(b.end,b.beg);var m,n,p;for(m=0;m<l;m++)for(n=0;n<=d;n++)h&&n===d||(p=JSM.CoordRotate(a[m],c,n*k,b.beg),g.AddVertex(new JSM.BodyVertex(p)));var q,r;for(m=0;m<l-1;m++)for(n=0;n<d;n++)k=m*(d+1)+n,p=k+d+1,q=k+1,r=p+1,h&&(k=m*d+n,p=k+d,q=k+1,r=p+1,n===d-1&&(q=m*d,r=(m+1)*d)),k=new JSM.BodyPolygon([k,q,r,p]),f&&k.SetCurveGroup(m),g.AddPolygon(k);if(h&&e){e=new JSM.BodyPolygon([]);f=new JSM.BodyPolygon([]);
for(m=0;m<d;m++)e.AddVertexIndex(d*(l-1)+m),f.AddVertexIndex(d-m-1);g.AddPolygon(e);g.AddPolygon(f)}e=new JSM.Line(b.beg,JSM.VectorNormalize(c));for(m=d=0;m<l;m++)f=JSM.ProjectCoordToLine(a[m],e),d+=JSM.CoordDistance(f,a[m]);d/=l;b=new JSM.Coord(b.beg.x,b.beg.y,b.beg.z);l=JSM.VectorNormalize(c);c=new JSM.Line(b,c);c=JSM.ProjectCoordToLine(a[0],c);a=JSM.VectorNormalize(JSM.CoordSub(a[0],c));g.SetCylindricalTextureProjection(b,d,a,l);return g};
JSM.GenerateTube=function(a,b){var c=new JSM.Body,d=a.length,e=a[0].length,f,g;for(g=0;g<e;g++)for(f=0;f<d;f++)c.AddVertex(new JSM.BodyVertex(a[f][g]));var h,l;for(g=0;g<d-1;g++)for(f=0;f<e;f++)h=g+d*f,l=h+d,f===e-1&&(l=g),c.AddPolygon(new JSM.BodyPolygon([h,l,l+1,h+1]));if(b){g=new JSM.BodyPolygon([]);h=new JSM.BodyPolygon([]);for(f=0;f<e;f++)g.AddVertexIndex(d*f+d-1);for(f=e-1;0<=f;f--)h.AddVertexIndex(d*f);c.AddPolygon(g);c.AddPolygon(h)}c.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,
0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return c};JSM.GenerateFunctionSurface=function(a,b,c,d,e){var f=new JSM.Sector(new JSM.Coord(b.x,b.y,0),new JSM.Coord(c.x,b.y,0));b=new JSM.Sector(new JSM.Coord(b.x,c.y,0),new JSM.Coord(c.x,c.y,0));d=JSM.GenerateRuledFromSectors(f,b,d,d,e);for(e=0;e<d.VertexCount();e++)f=d.GetVertexPosition(e),f.z=a(f.x,f.y);d.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return d};
JSM.GenerateFunctionSurfaceSolid=function(a,b,c,d,e,f){var g=new JSM.Sector(new JSM.Coord(c.x,b.y,0),new JSM.Coord(b.x,b.y,0));b=new JSM.Sector(new JSM.Coord(c.x,c.y,0),new JSM.Coord(b.x,c.y,0));e=JSM.GenerateRuledFromSectorsWithHeight(g,b,d,d,e,f);g=(d+1)*(d+1);for(d=0;d<g;d++)f=e.GetVertexPosition(d),f.z=a(f.x,f.y);e.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return e};
JSM.Camera=function(a,b,c,d,e,f){this.eye=JSM.ValueOrDefault(a,new JSM.Coord(1,1,1));this.center=JSM.ValueOrDefault(b,new JSM.Coord(0,0,0));this.up=JSM.ValueOrDefault(c,new JSM.Vector(0,0,1));this.fieldOfView=JSM.ValueOrDefault(d,45);this.nearClippingPlane=JSM.ValueOrDefault(e,0.1);this.farClippingPlane=JSM.ValueOrDefault(f,1E3)};
JSM.Camera.prototype.Set=function(a,b,c,d,e,f){this.eye=a;this.center=b;this.up=c;this.fieldOfView=JSM.ValueOrDefault(d,45);this.nearClippingPlane=JSM.ValueOrDefault(e,0.1);this.farClippingPlane=JSM.ValueOrDefault(f,1E3)};JSM.Camera.prototype.Clone=function(){var a=new JSM.Camera;a.eye=this.eye;a.center=this.center;a.up=this.up;a.fieldOfView=this.fieldOfView;a.nearClippingPlane=this.nearClippingPlane;a.farClippingPlane=this.farClippingPlane;return a};
JSM.ExplodeBodyToTriangles=function(a,b,c){if(void 0===c||null===c)return!1;var d=JSM.CalculateBodyVertexNormals(a),e,f,g=!1;if(void 0!==b&&null!==b)for(e=0;e<b.Count();e++)if(null!==b.GetMaterial(e).texture){g=!0;break}var h,l;if(g){h=JSM.CalculateBodyTextureCoords(a);for(e=0;e<h.length;e++)if(f=a.GetPolygon(e),f.HasMaterialIndex()){l=b.GetMaterial(f.GetMaterialIndex());for(f=0;f<h[e].length;f++)h[e][f].x/=l.textureWidth,h[e][f].y/=-l.textureHeight}}var k=!0;void 0!==c.hasConvexPolygons&&null!==
c.hasConvexPolygons&&(k=c.hasConvexPolygons);(function(a,b,c,d,e){function f(h,l){var t=b.GetMaterial(l);if(void 0!==e.onGeometryStart&&null!==e.onGeometryStart)e.onGeometryStart(t);var x;for(x=0;x<h.length;x++){var s=h[x],v=a.GetPolygon(s),y=v.VertexIndexCount();if(!(3>y)){var D=void 0,A=void 0,B=void 0,K=void 0,L=void 0,M=void 0,w=void 0,G=void 0,N=void 0,E=void 0;if(3==y||k)for(E=0;E<y-2;E++){if(D=a.GetVertex(v.GetVertexIndex(0)).position,A=a.GetVertex(v.GetVertexIndex((E+1)%y)).position,B=a.GetVertex(v.GetVertexIndex((E+
2)%y)).position,K=c[s][0],L=c[s][(E+1)%y],M=c[s][(E+2)%y],N=G=w=null,g&&(w=d[s][0],G=d[s][(E+1)%y],N=d[s][(E+2)%y]),void 0!==e.onTriangle&&null!==e.onTriangle)e.onTriangle(D,A,B,K,L,M,w,G,N)}else{D=new JSM.Polygon;A=void 0;for(E=0;E<y;E++)A=a.GetVertex(v.vertices[E]),D.AddVertex(A.position.x,A.position.y,A.position.z);for(var E=JSM.CalculateBodyPolygonNormal(a,s),y=JSM.PolygonTriangulate(D,E),O=void 0,E=0;E<y.length;E++)if(O=y[E],D=a.GetVertex(v.GetVertexIndex(O[0])).position,A=a.GetVertex(v.GetVertexIndex(O[1])).position,
B=a.GetVertex(v.GetVertexIndex(O[2])).position,K=c[s][O[0]],L=c[s][O[1]],M=c[s][O[2]],N=G=w=null,g&&(w=d[s][O[0]],G=d[s][O[1]],N=d[s][O[2]]),void 0!==e.onTriangle&&null!==e.onTriangle)e.onTriangle(D,A,B,K,L,M,w,G,N)}}}if(void 0!==e.onGeometryEnd&&null!==e.onGeometryEnd)e.onGeometryEnd(t)}var h,l=[],t=[];if(void 0===b||null===b)b=new JSM.Materials;for(h=0;h<b.Count();h++)l[h]=[];var y;for(h=0;h<a.PolygonCount();h++)y=a.GetPolygon(h),y.HasMaterialIndex()?(y=y.GetMaterialIndex(),l[y].push(h)):t.push(h);
for(h=0;h<l.length;h++)y=l[h],0!==y.length&&f(y,h);0!==t.length&&f(t,-1)})(a,b,d,h,c);return!0};
JSM.ExportBodyContentToStl=function(a,b,c){function d(a){g+=a+"\n"}function e(a,b,c,e){d("\tfacet normal "+a.x+" "+a.y+" "+a.z);d("\t\touter loop");d("\t\t\tvertex "+b.x+" "+b.y+" "+b.z);d("\t\t\tvertex "+c.x+" "+c.y+" "+c.z);d("\t\t\tvertex "+e.x+" "+e.y+" "+e.z);d("\t\tendloop");d("\tendfacet")}function f(b){var d=a.GetPolygon(b),f=d.VertexIndexCount();if(!(3>f)){var g,n,p,q=null;if(3===f)q=JSM.CalculateBodyPolygonNormal(a,b),g=a.GetVertex(d.GetVertexIndex(0)).position,n=a.GetVertex(d.GetVertexIndex(1)).position,
p=a.GetVertex(d.GetVertexIndex(2)).position,e(q,g,n,p);else if(g=!0,void 0!==c&&c&&(g=!1),q=JSM.CalculateBodyPolygonNormal(a,b),g){g=new JSM.Polygon;for(b=0;b<f;b++)n=a.GetVertex(d.vertices[b]),g.AddVertex(n.position.x,n.position.y,n.position.z);f=JSM.PolygonTriangulate(g,q);for(b=0;b<f.length;b++)p=f[b],g=a.GetVertex(d.GetVertexIndex(p[0])).position,n=a.GetVertex(d.GetVertexIndex(p[1])).position,p=a.GetVertex(d.GetVertexIndex(p[2])).position,e(q,g,n,p)}else for(b=0;b<f-2;b++)g=a.GetVertex(d.GetVertexIndex(0)).position,
n=a.GetVertex(d.GetVertexIndex((b+1)%f)).position,p=a.GetVertex(d.GetVertexIndex((b+2)%f)).position,e(q,g,n,p)}}var g="";for(b=0;b<a.PolygonCount();b++)f(b);return g};JSM.ExportBodyToStl=function(a,b,c){a=""+("solid "+b+"\n")+JSM.ExportBodyContentToStl(a,b,c);return a+="endsolid "+b+"\n"};JSM.ExportModelToStl=function(a,b,c){var d;d=""+("solid "+b+"\n");var e,f;for(e=0;e<a.BodyCount();e++)f=a.GetBody(e),d+=JSM.ExportBodyContentToStl(f,b+(e+1).toString(),c);return d+("endsolid "+b+"\n")};
JSM.ExportBodyContentToObj=function(a,b,c){function d(b){b=a.GetVertex(b).position;g+="v "+b.x+" "+b.y+" "+b.z+"\n"}function e(b){b=JSM.CalculateBodyPolygonNormal(a,b);g+="vn "+b.x+" "+b.y+" "+b.z+"\n"}function f(d){var e=a.GetPolygon(d);g+="f ";var f;for(f=0;f<e.VertexIndexCount();f++){var h=b+e.GetVertexIndex(f)+1+"//"+(c+d+1)+" ";g+=h}g+="\n"}var g="",h;for(h=0;h<a.VertexCount();h++)d(h);for(h=0;h<a.PolygonCount();h++)e(h);for(h=0;h<a.PolygonCount();h++)f(h);return g};
JSM.ExportBodyToObj=function(a){return JSM.ExportBodyContentToObj(a,0,0)};JSM.ExportModelToObj=function(a){var b="",c=0,d=0,e,f;for(e=0;e<a.BodyCount();e++)f=a.GetBody(e),b+=JSM.ExportBodyContentToObj(f,c,d),c+=f.VertexCount(),d+=f.PolygonCount();return b};
JSM.ExportMaterialsToGdl=function(a){function b(a,b){var d=JSM.HexColorToRGBComponents(a.diffuse);c+='define material "material'+b+'" 2, '+(d[0]/255+","+d[1]/255+","+d[2]/255)+" ! "+b+"\n"}var c="",d=!1;void 0!==a&&null!==a&&(d=!0);if(d){b(a.GetDefaultMaterial(),1);for(d=0;d<a.Count();d++)b(a.GetMaterial(d),d+2)}return c};
JSM.ExportBodyGeometryToGdl=function(a,b){function c(a){if(200<a.length){var b=0,c,d;for(c=0;c<a.length;c++)d=a[c],h+=d,b++,200<b&&","==d&&(h+="\n",b=0)}else h+=a}function d(a){c(a+"\n")}function e(b){var c=a.GetVertex(b).position;d("vert "+c.x+", "+c.y+", "+c.z+" ! "+(b+1))}function f(b){var c=l.edges[b],e=0;-1!=c.pgon1&&-1!=c.pgon2&&a.GetPolygon(c.pgon1).HasCurveGroup()&&a.GetPolygon(c.pgon2).HasCurveGroup()&&a.GetPolygon(c.pgon1).GetCurveGroup()==a.GetPolygon(c.pgon2).GetCurveGroup()&&(e=2);d("edge "+
(c.vert1+1)+", "+(c.vert2+1)+", -1, -1, "+e+" ! "+(b+1))}function g(e,f){var g=-1;b&&(g=a.GetPolygon(e).GetMaterialIndex()+2,g!=f&&d('set material "material'+g+'"'));var h=l.pgons[e],k=0;a.GetPolygon(e).HasCurveGroup()&&(k=2);c("pgon "+h.pedges.length+", 0, "+k+", ");var k="",m,v;for(m=0;m<h.pedges.length;m++)v=h.pedges[m],k=v.reverse?k+-(v.index+1):k+(v.index+1),m<h.pedges.length-1&&(k+=", ");c(k);c(" ! "+(e+1));d("");return g}var h="";d("base");var l=JSM.CalculateAdjacencyInfo(a),k;for(k=0;k<l.verts.length;k++)e(k);
for(k=0;k<l.edges.length;k++)f(k);var m=-1;for(k=0;k<l.pgons.length;k++)m=g(k,m);d("body -1");return h};JSM.ExportBodyToGdl=function(a,b){var c="",d=!1;void 0!==b&&null!==b&&(c+=JSM.ExportMaterialsToGdl(b),d=!0);return c+=JSM.ExportBodyGeometryToGdl(a,d)};JSM.ExportModelToGdl=function(a,b){var c="",d=!1;void 0!==b&&null!==b&&(c+=JSM.ExportMaterialsToGdl(b),d=!0);var e,f;for(e=0;e<a.BodyCount();e++)f=a.GetBody(e),c+=JSM.ExportBodyGeometryToGdl(f,d);return c};
JSM.TriangleBody=function(a){this.name=a;this.vertices=[];this.normals=[];this.triangles=[]};JSM.TriangleBody.prototype.SetName=function(a){this.name=a};JSM.TriangleBody.prototype.GetName=function(){return this.name};JSM.TriangleBody.prototype.AddVertex=function(a,b,c){this.vertices.push(new JSM.Coord(a,b,c));return this.vertices.length-1};JSM.TriangleBody.prototype.GetVertex=function(a){return this.vertices[a]};
JSM.TriangleBody.prototype.SetVertex=function(a,b,c,d){this.vertices[a]=new JSM.Coord(b,c,d)};JSM.TriangleBody.prototype.VertexCount=function(){return this.vertices.length};JSM.TriangleBody.prototype.AddNormal=function(a,b,c){this.normals.push(new JSM.Coord(a,b,c));return this.normals.length-1};JSM.TriangleBody.prototype.GetNormal=function(a){return this.normals[a]};JSM.TriangleBody.prototype.NormalCount=function(){return this.normals.length};
JSM.TriangleBody.prototype.AddTriangle=function(a,b,c,d,e,f,g,h,l,k,m){this.triangles.push({v0:a,v1:b,v2:c,n0:d,n1:e,n2:f,u0:g,u1:h,u2:l,mat:k,curve:m});return this.triangles.length-1};JSM.TriangleBody.prototype.GetTriangle=function(a){return this.triangles[a]};JSM.TriangleBody.prototype.TriangleCount=function(){return this.triangles.length};
JSM.TriangleBody.prototype.Finalize=function(a){function b(b,c,d,f){function g(a,b,c,d,e){var f=new JSM.Vector(0,0,0),h=0;c=a.GetTriangle(c);b=e[b];var k,l;for(e=0;e<b.length;e++)k=b[e],l=a.GetTriangle(k),c.curve==l.curve&&(f=JSM.CoordAdd(f,d[k]),h+=1);f=JSM.VectorMultiply(f,1/h);f=JSM.VectorNormalize(f);return a.AddNormal(f.x,f.y,f.z)}var p=b.triangles[e];void 0===p.mat&&(p.mat=a.AddDefaultMaterial());if(void 0===p.n0||void 0===p.n1||void 0===p.n2)void 0===p.curve||0===p.curve?(c=d[e],b=b.AddNormal(c.x,
c.y,c.z),p.n0=b,p.n1=b,p.n2=b):(p.n0=g(b,p.v0,c,d,f),p.n1=g(b,p.v1,c,d,f),p.n2=g(b,p.v2,c,d,f))}var c=[],d={},e;for(e=0;e<this.vertices.length;e++)d[e]=[];var f,g;for(e=0;e<this.triangles.length;e++)f=this.triangles[e],g=JSM.CalculateTriangleNormal(this.vertices[f.v0],this.vertices[f.v1],this.vertices[f.v2]),c.push(g),d[f.v0].push(e),d[f.v1].push(e),d[f.v2].push(e);for(e=0;e<this.triangles.length;e++)b(this,e,c,d)};
JSM.TriangleBody.prototype.Clone=function(){var a=new JSM.TriangleBody(this.name),b,c;for(b=0;b<this.vertices.length;b++)a.vertices.push(this.vertices[b].Clone());for(b=0;b<this.normals.length;b++)a.normals.push(this.normals[b].Clone());for(b=0;b<this.triangles.length;b++)c=this.triangles[b],a.triangles.push({v0:c.v0,v1:c.v1,v2:c.v2,n0:c.n0,n1:c.n1,n2:c.n2,u0:c.u0,u1:c.u1,u2:c.u2,mat:c.mat,curve:c.curve});return a};
JSM.TriangleModel=function(){this.materials=[];this.bodies=[];this.defaultMaterial=-1};JSM.TriangleModel.prototype.AddMaterial=function(a,b,c,d,e){this.materials.push({name:a,ambient:b,diffuse:c,specular:d,opacity:e});return this.materials.length-1};JSM.TriangleModel.prototype.GetMaterial=function(a){return this.materials[a]};
JSM.TriangleModel.prototype.AddDefaultMaterial=function(){-1==this.defaultMaterial&&(this.materials.push({name:"Default",ambient:{r:0.5,g:0.5,b:0.5},diffuse:{r:0.5,g:0.5,b:0.5},specular:{r:0.1,g:0.1,b:0.1},opacity:1}),this.defaultMaterial=this.materials.length-1);return this.defaultMaterial};JSM.TriangleModel.prototype.GetDefaultMaterialIndex=function(){return this.AddDefaultMaterial()};JSM.TriangleModel.prototype.MaterialCount=function(){return this.materials.length};
JSM.TriangleModel.prototype.AddBody=function(a){this.bodies.push(a);return this.bodies.length-1};JSM.TriangleModel.prototype.AddBodyToIndex=function(a,b){this.bodies.splice(b,0,a);return b};JSM.TriangleModel.prototype.GetBody=function(a){return this.bodies[a]};JSM.TriangleModel.prototype.BodyCount=function(){return this.bodies.length};JSM.TriangleModel.prototype.GetBody=function(a){return this.bodies[a]};
JSM.TriangleModel.prototype.Finalize=function(){var a,b;for(a=0;a<this.bodies.length;a++)b=this.bodies[a],b.Finalize(this)};JSM.BinaryReader=function(a,b){this.arrayBuffer=a;this.dataView=new DataView(a);this.isLittleEndian=b;this.position=0};JSM.BinaryReader.prototype.GetPosition=function(){return this.position};JSM.BinaryReader.prototype.GetByteLength=function(){return this.arrayBuffer.byteLength};JSM.BinaryReader.prototype.Skip=function(a){this.position+=a};
JSM.BinaryReader.prototype.End=function(){return this.position>=this.arrayBuffer.byteLength};JSM.BinaryReader.prototype.ReadBoolean=function(){var a=this.dataView.getInt8(this.position,this.isLittleEndian);this.position+=1;return a?!0:!1};JSM.BinaryReader.prototype.ReadCharacter=function(){var a=this.dataView.getInt8(this.position,this.isLittleEndian);this.position+=1;return a};
JSM.BinaryReader.prototype.ReadUnsignedCharacter=function(){var a=this.dataView.getUint8(this.position,this.isLittleEndian);this.position+=1;return a};JSM.BinaryReader.prototype.ReadInteger16=function(){var a=this.dataView.getInt16(this.position,this.isLittleEndian);this.position+=2;return a};JSM.BinaryReader.prototype.ReadUnsignedInteger16=function(){var a=this.dataView.getUint16(this.position,this.isLittleEndian);this.position+=2;return a};
JSM.BinaryReader.prototype.ReadInteger32=function(){var a=this.dataView.getInt32(this.position,this.isLittleEndian);this.position+=4;return a};JSM.BinaryReader.prototype.ReadUnsignedInteger32=function(){var a=this.dataView.getUint32(this.position,this.isLittleEndian);this.position+=4;return a};JSM.BinaryReader.prototype.ReadFloat32=function(){var a=this.dataView.getFloat32(this.position,this.isLittleEndian);this.position+=4;return a};
JSM.BinaryReader.prototype.ReadDouble64=function(){var a=this.dataView.getFloat64(this.position,this.isLittleEndian);this.position+=8;return a};JSM.GetArrayBufferFromURL=function(a,b){var c=new XMLHttpRequest;c.open("GET",a,!0);c.responseType="arraybuffer";c.onload=function(){var a=c.response;a&&b(a)};c.send(null)};JSM.GetArrayBufferFromFile=function(a,b){var c=new FileReader;c.onloadend=function(a){a.target.readyState==FileReader.DONE&&b(a.target.result)};c.readAsArrayBuffer(a)};
JSM.GetStringBufferFromURL=function(a,b){var c=new XMLHttpRequest;c.open("GET",a,!0);c.responseType="text";c.onload=function(){var a=c.response;a&&b(a)};c.send(null)};JSM.LoadMultipleBuffers=function(a,b,c,d,e){c>=a.length?e(b):d(a[c],function(f){b.push(f);JSM.LoadMultipleBuffers(a,b,c+1,d,e)})};JSM.GetStringBufferFromFile=function(a,b){var c=new FileReader;c.onloadend=function(a){a.target.readyState==FileReader.DONE&&b(a.target.result)};c.readAsText(a)};
JSM.GetStringBuffersFromURLList=function(a,b){JSM.LoadMultipleBuffers(a,[],0,JSM.GetStringBufferFromURL,function(a){b(a)})};JSM.GetStringBuffersFromFileList=function(a,b){JSM.LoadMultipleBuffers(a,[],0,JSM.GetStringBufferFromFile,function(a){b(a)})};
JSM.ConvertTriangleModelToJsonData=function(a){function b(a,b,c){var d=[],e=a.MaterialCount(),f;for(a=0;a<b.VertexCount();a++)f=b.GetVertex(a),c.vertices.push(f.x,f.y,f.z);for(a=0;a<b.NormalCount();a++)f=b.GetNormal(a),c.normals.push(f.x,f.y,f.z);c.uvs.push(0,0);for(a=0;a<e;a++)d.push([]);for(a=0;a<b.TriangleCount();a++)f=b.GetTriangle(a),void 0===f.mat||(0>f.mat||f.mat>=e)||d[f.mat].push(a);var p,q;for(a=0;a<d.length;a++)if(p=d[a],0!==p.length){q={material:a,parameters:[]};for(e=0;e<p.length;e++)f=
b.GetTriangle(p[e]),q.parameters.push(f.v0,f.v1,f.v2,f.n0,f.n1,f.n2,0,0,0);c.triangles.push(q)}}var c={version:1,materials:[],meshes:[]};(function(a,b){var c,d;for(c=0;c<a.MaterialCount();c++)d=a.GetMaterial(c),b.push({name:d.name,ambient:[d.ambient.r,d.ambient.g,d.ambient.b],diffuse:[d.diffuse.r,d.diffuse.g,d.diffuse.b],specular:[d.specular.r,d.specular.g,d.specular.b],opacity:d.opacity})})(a,c.materials);var d,e,f;for(d=0;d<a.BodyCount();d++)e=a.GetBody(d),0!==e.TriangleCount()&&(f={name:e.GetName(),
vertices:[],normals:[],uvs:[],triangles:[]},b(a,e,f),c.meshes.push(f));return c};
JSM.MergeJsonDataMeshes=function(a){function b(a,b,c){function d(a,b,c){var h=b.material,l=c[h];void 0===l&&(a.triangles.push({material:h,parameters:[]}),l=a.triangles.length-1,c[h]=l);a=a.triangles[l].parameters;for(c=0;c<b.parameters.length;c+=9)a.push(b.parameters[c]+e,b.parameters[c+1]+e,b.parameters[c+2]+e,b.parameters[c+3]+f,b.parameters[c+4]+f,b.parameters[c+5]+f,b.parameters[c+6]+g,b.parameters[c+7]+g,b.parameters[c+8]+g)}var e=a.vertices.length/3,f=a.normals.length/3,g=a.uvs.length/2;(function(a,
b){var c;for(c=0;c<b.vertices.length;c++)a.vertices.push(b.vertices[c]);for(c=0;c<b.normals.length;c++)a.normals.push(b.normals[c]);for(c=0;c<b.uvs.length;c++)a.uvs.push(b.uvs[c])})(a,b);var r,s;for(r=0;r<b.triangles.length;r++)s=b.triangles[r],d(a,s,c)}var c={version:a.version,materials:a.materials,meshes:[]},d={name:"Merged",vertices:[],normals:[],uvs:[],triangles:[]},e={},f,g;for(f=0;f<a.meshes.length;f++)g=a.meshes[f],b(d,g,e);c.meshes.push(d);return c};
JSM.Read3dsFile=function(a,b){var c,d,e,f,g,h,l,k,m,n,p,q,r,s,x,v,t,y,F,C,u,H,z,I,J,D,A,B,K,L,M;function w(a,c){if(void 0!==b.onLog&&null!==b.onLog)b.onLog(a,c)}function G(a){for(var b="",c=0,d=0;64>d;){c=a.ReadCharacter();if(0===c)break;b+=String.fromCharCode(c);d+=1}return b}function N(a){var b=[],c;for(c=0;3>c;c++)b[c]=a.ReadFloat32();return b}function E(a,b,c){for(;a.GetPosition()<=b-6;){var d=a,e=c,f=d.ReadUnsignedInteger16(),d=d.ReadUnsignedInteger32();e(f,d)}}if(void 0===b||null===b)b={};c=
15677;d=45055;e=40960;f=40976;g=40992;h=41008;l=41024;k=41040;m=16;n=17;p=18;q=19;r=48;s=49;x=16384;v=16640;t=17920;y=18176;F=16656;C=16672;u=16736;H=16688;z=16720;I=45056;J=45058;D=45072;A=45075;B=45088;K=45089;L=45090;M=45104;(function(a){function P(a,b,c){var d={};b=a.GetPosition()+c-6;var e=!1;E(a,b,function(b,c){b==n?e||(d.r=a.ReadUnsignedCharacter()/255,d.g=a.ReadUnsignedCharacter()/255,d.b=a.ReadUnsignedCharacter()/255):b==p?(d.r=a.ReadUnsignedCharacter()/255,d.g=a.ReadUnsignedCharacter()/
255,d.b=a.ReadUnsignedCharacter()/255,e=!0):b==m?e||(d.r=a.ReadFloat32(),d.g=a.ReadFloat32(),d.b=a.ReadFloat32()):b==q?(d.r=a.ReadFloat32(),d.g=a.ReadFloat32(),d.b=a.ReadFloat32(),e=!0):a.Skip(c-6)});return d}function Q(a,b,c){var d=0;b=a.GetPosition()+c-6;E(a,b,function(b,c){b==r?d=a.ReadUnsignedInteger16()/100:b==s?d=a.ReadFloat32():a.Skip(c-6)});return d}function R(a,c,d){w("Read material chunk ("+c.toString(16)+", "+d+")",2);var m={},n=a.GetPosition()+d-6;E(a,n,function(b,n){b==e?(w("Read material name chunk ("+
c.toString(16)+", "+d+")",3),m.name=G(a)):b==f?(w("Read material ambient chunk ("+c.toString(16)+", "+d+")",3),m.ambient=P(a,b,n)):b==g?(w("Read material diffuse chunk ("+c.toString(16)+", "+d+")",3),m.diffuse=P(a,b,n)):b==h?(w("Read material specular chunk ("+c.toString(16)+", "+d+")",3),m.specular=P(a,b,n)):b==l?(w("Read material shininess chunk ("+c.toString(16)+", "+d+")",3),m.shininess=Q(a,b,n)):b==k?(w("Read material transparency chunk ("+c.toString(16)+", "+d+")",3),m.transparency=Q(a,b,n)):
(w("Skip chunk ("+b.toString(16)+", "+n+")",3),a.Skip(n-6))});if(void 0!==b.onMaterial&&null!==b.onMaterial)b.onMaterial(m)}function S(a,c,d){w("Read faces chunk ("+c.toString(16)+", "+d+")",4);c=a.GetPosition()+d-6;var e=a.ReadUnsignedInteger16(),f,g,h,l;for(d=0;d<e;d++)if(f=a.ReadUnsignedInteger16(),g=a.ReadUnsignedInteger16(),h=a.ReadUnsignedInteger16(),l=a.ReadUnsignedInteger16(),void 0!==b.onFace&&null!==b.onFace)b.onFace(f,g,h,l);E(a,c,function(c,d){if(c==H){w("Read face materials chunk ("+
c.toString(16)+", "+d+")",5);var f=G(a),g=a.ReadUnsignedInteger16(),h,l;for(h=0;h<g;h++)if(l=a.ReadUnsignedInteger16(),void 0!==b.onFaceMaterial&&null!==b.onFaceMaterial)b.onFaceMaterial(l,f)}else if(c==z){w("Read face smoothing groups chunk ("+c.toString(16)+", "+d+")",5);for(f=0;f<e;f++)if(g=a.ReadUnsignedInteger32(),void 0!==b.onFaceSmoothingGroup&&null!==b.onFaceSmoothingGroup)b.onFaceSmoothingGroup(f,g)}else w("Skip chunk ("+c.toString(16)+", "+d+")",5),a.Skip(d-6)})}function T(a,c,d,e){w("Read mesh chunk ("+
c+", "+d.toString(16)+", "+e+")",3);if(void 0!==b.onMesh&&null!==b.onMesh)b.onMesh(c);c=a.GetPosition()+e-6;E(a,c,function(c,d){if(c==F){w("Read vertices chunk ("+c.toString(16)+", "+d+")",4);var e=a.ReadUnsignedInteger16(),f,g,h,l;for(f=0;f<e;f++)if(g=a.ReadFloat32(),h=a.ReadFloat32(),l=a.ReadFloat32(),void 0!==b.onVertex&&null!==b.onVertex)b.onVertex(g,h,l)}else if(c==C)S(a,c,d);else if(c==u){w("Read transformation chunk ("+c.toString(16)+", "+d+")",4);e=[];for(f=0;4>f;f++){for(g=0;3>g;g++)e.push(a.ReadFloat32());
3>f?e.push(0):e.push(1)}if(void 0!==b.onTransformation&&null!==b.onTransformation)b.onTransformation(e)}else w("Skip chunk ("+c.toString(16)+", "+d+")",4),a.Skip(d-6)})}function U(a,b,c){w("Read object chunk ("+b.toString(16)+", "+c+")",2);b=a.GetPosition()+c-6;var d=G(a);E(a,b,function(b,c){b==v?T(a,d,b,c):(b==t?w("Skip light chunk ("+d+", "+b.toString(16)+", "+c+")",3):b==y?w("Skip camera chunk ("+d+", "+b.toString(16)+", "+c+")",3):w("Skip chunk ("+b.toString(16)+", "+c+")",3),a.Skip(c-6))})}function V(a,
b,c){w("Read editor chunk ("+b.toString(16)+", "+c+")",1);b=a.GetPosition()+c-6;E(a,b,function(b,c){b==d?R(a,b,c):b==x?U(a,b,c):(w("Skip chunk ("+b.toString(16)+", "+c+")",2),a.Skip(c-6))})}function W(a,c,d){function e(a,b){var c=[];a.Skip(10);var d,f,g,h=a.ReadInteger32();for(d=0;d<h;d++)a.ReadInteger32(),f=a.ReadUnsignedInteger16(),0!==f&&a.ReadFloat32(),b==K?(g=a.ReadFloat32(),f=N(a),f[3]=g):f=N(a),c.push(f);return c}w("Read object node chunk ("+c.toString(16)+", "+d+")",2);var f={name:"",nodeId:-1,
flags:-1,userId:-1,pivot:[0,0,0],positions:[],rotations:[],scales:[]};c=a.GetPosition()+d-6;E(a,c,function(b,c){b==D?(f.name=G(a),f.flags=a.ReadUnsignedInteger32(),f.userId=a.ReadUnsignedInteger16()):b==A?f.pivot=N(a):b==B?f.positions=e(a,B):b==K?f.rotations=e(a,K):b==L?f.scales=e(a,L):b==M?f.nodeId=a.ReadUnsignedInteger16():(w("Skip chunk ("+b.toString(16)+", "+c+")",3),a.Skip(c-6))});if(void 0!==b.onObjectNode&&null!==b.onObjectNode)b.onObjectNode(f)}function X(a,b,c){w("Read keyframe chunk ("+
b.toString(16)+", "+c+")",1);b=a.GetPosition()+c-6;E(a,b,function(b,c){b==J?W(a,b,c):(w("Skip chunk ("+b.toString(16)+", "+c+")",2),a.Skip(c-6))})}function Y(a,b,d){w("Read main chunk ("+b.toString(16)+", "+d+")",0);b=a.GetPosition()+d-6;E(a,b,function(b,d){b==c?V(a,b,d):b==I?X(a,b,d):(w("Skip chunk ("+b.toString(16)+", "+d+")",1),a.Skip(d-6))})}var Z=a.GetByteLength();E(a,Z,function(b,c){19789==b?Y(a,b,c):(w("Skip chunk ("+b.toString(16)+", "+c+")",0),a.Skip(c-6))})})(new JSM.BinaryReader(a,!0))};
JSM.Convert3dsToJsonData=function(a){var b=new JSM.TriangleModel,c=null,d={},e={},f={nodes:[],nodeIdToIndex:{}};JSM.Read3dsFile(a,{onMaterial:function(a){function c(a){return void 0===a||null===a?{r:0,g:0,b:0}:a}var e=b.AddMaterial(a.name,c(a.ambient),c(a.diffuse),c(a.specular),void 0===a.transparency||null===a.transparency?1:1-a.transparency);void 0===d[a.name]&&(d[a.name]=e)},onMesh:function(a){var d=b.AddBody(new JSM.TriangleBody(a));c=b.GetBody(d);c.meshData={faceToMaterial:{},faceToSmoothingGroup:{},
objectNodes:[],transformation:null};e[a]=d},onTransformation:function(a){null!==c&&(c.meshData.transformation=a)},onObjectNode:function(a){var c=f.nodes.length;f.nodes.push(a);f.nodeIdToIndex[a.nodeId]=c;a=e[a.name];void 0!==a&&b.GetBody(a).meshData.objectNodes.push(c)},onVertex:function(a,b,d){null!==c&&c.AddVertex(a,b,d)},onFace:function(a,b,d){null!==c&&c.AddTriangle(a,b,d)},onFaceMaterial:function(a,b){null!==c&&(c.meshData.faceToMaterial[a]=b)},onFaceSmoothingGroup:function(a,b){null!==c&&(c.meshData.faceToSmoothingGroup[a]=
b)}});(function(a,b,c){function d(a,b,c){function e(a,b){var c=b[0],d=b[1],f=b[2],g;for(g=0;4>g;g++)a[0+g]*=c,a[4+g]*=d,a[8+g]*=f;return a}function f(a,b){var c=b[0],d=b[1],e=b[2],g;for(g=0;3>g;g++)a[12+g]+=a[0+g]*c+a[4+g]*d+a[8+g]*e;return a}function g(a,b){var c,d;for(c=0;c<a.VertexCount();c++)d=a.GetVertex(c),d=JSM.ApplyTransformation(b,d),a.SetVertex(c,d.x,d.y,d.z)}function h(a,b,c){var d=JSM.MatrixDeterminant(b);JSM.IsNegative(d)&&(b=JSM.MatrixClone(b),e(b,[-1,1,1]),c=JSM.MatrixMultiply(c,b),
g(a,c))}function l(a,b){if(void 0!==a.matrix)return a.matrix;var c=JSM.MatrixIdentity(),d;d=0===a.positions.length?[0,0,0]:a.positions[0];c=f(c,d);if(0===a.rotations.length)d=[0,0,0,0];else{d=a.rotations[0];var g=[0,0,0,1],h=Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);JSM.IsPositive(h)&&(g=-0.5*d[3],h=Math.sin(g)/h,g=[h*d[0],h*d[1],h*d[2],Math.cos(g)]);d=g}d=JSM.MatrixRotationQuaternion(d);c=JSM.MatrixMultiply(d,c);d=0===a.scales.length?[0,0,0,0]:a.scales[0];c=e(c,d);65535!=a.userId&&(d=b.nodeIdToIndex[a.userId],
void 0!==d&&(d=l(b.nodes[d],b),c=JSM.MatrixMultiply(c,d)));return a.matrix=c}var k=a.meshData;k=void 0===k||null===k?null:k.transformation;if(null!==k){var m=null,m=null!==b?l(b,c):k;c=JSM.MatrixClone(m);m=JSM.MatrixClone(k);k=JSM.MatrixInvert(m);null!==k&&(h(a,m,k),b=void 0===b||null===b?[0,0,0]:b.pivot,f(c,[-b[0],-b[1],-b[2]]),b=JSM.MatrixMultiply(k,c),g(a,b))}}function e(a,b,c,f){d(a,b,f);b=a.meshData;var g,h;for(f=0;f<a.TriangleCount();f++)g=a.GetTriangle(f),h=b.faceToMaterial[f],void 0!==h&&
(h=c[h],void 0!==h&&(g.mat=h)),h=b.faceToSmoothingGroup[f],void 0!==h&&(g.curve=h)}function f(a,b,c,d){b=b.Clone();b.SetName(b.GetName()+" ("+d+")");c<a.BodyCount()?a.AddBodyToIndex(b,c):a.AddBody(b);return b}var p,q,r,s,x,v,t;for(p=0;p<b.BodyCount();p++)if(r=b.GetBody(p),s=r.meshData,0===s.objectNodes.length)e(r,null,c,a);else{v=a.nodes[s.objectNodes[0]];for(q=1;q<s.objectNodes.length;q++)x=a.nodes[s.objectNodes[q]],t=f(b,r,p+1,q+1),t.meshData=r.meshData,e(t,x,c,a),p+=1;e(r,v,c,a)}})(f,b,d);b.Finalize();
return JSM.ConvertTriangleModelToJsonData(b)};
JSM.ReadObjFile=function(a,b){function c(a){a=a.split("\n");var e,f;for(e=0;e<a.length;e++){var g=f=a[e].trim();if(0!==g.length&&"#"!=g[0]&&(f=g.split(/\s+/),!(0===f.length||"#"==f[0][0]))){var h=void 0,h=void 0;if("g"==f[0]){if(!(2>f.length)){g="";for(h=1;h<f.length;h++)g+=f[h],h<f.length-1&&(g+=" ");if(void 0!==b.onMesh&&null!==b.onMesh)b.onMesh(g)}}else if("v"==f[0]){if(!(4>f.length)&&(h=parseFloat(f[1]),g=parseFloat(f[2]),f=parseFloat(f[3]),void 0!==b.onVertex&&null!==b.onVertex))b.onVertex(h,
g,f)}else if("vn"==f[0]){if(!(4>f.length)&&(h=parseFloat(f[1]),g=parseFloat(f[2]),f=parseFloat(f[3]),void 0!==b.onNormal&&null!==b.onNormal))b.onNormal(h,g,f)}else if("f"==f[0]){if(!(4>f.length)){for(var g=[],l=[],k=void 0,h=1;h<f.length;h++)k=f[h].split("/"),g.push(parseInt(k[0],10)-1),2<k.length&&0<k[2].length&&l.push(parseInt(k[2],10)-1);if(void 0!==b.onFace&&null!==b.onFace)b.onFace(g,l)}}else if("usemtl"==f[0]){if(!(2>f.length)&&void 0!==b.onUseMaterial&&null!==b.onUseMaterial)b.onUseMaterial(f[1])}else if("newmtl"==
f[0]){if(!(2>f.length)&&void 0!==b.onNewMaterial&&null!==b.onNewMaterial)b.onNewMaterial(f[1])}else if("Ka"==f[0]||"Kd"==f[0]||"Ks"==f[0]){if(!(4>f.length)&&(h=parseFloat(f[1]),g=parseFloat(f[2]),l=parseFloat(f[3]),void 0!==b.onMaterialComponent&&null!==b.onMaterialComponent))b.onMaterialComponent(f[0],h,g,l)}else if("Ka"==f[0]||"Kd"==f[0]||"Ks"==f[0]){if(!(4>f.length)&&(h=parseFloat(f[1]),g=parseFloat(f[2]),l=parseFloat(f[3]),void 0!==b.onMaterialComponent&&null!==b.onMaterialComponent))b.onMaterialComponent(f[0],
h,g,l)}else"mtllib"==f[0]&&!(2>f.length)&&(f=g.indexOf("mtllib")+6,h=g.substr(f,g.length-f).trim(),f=h.trim(),f=void 0!==b.onFileRequested&&null!==b.onFileRequested?b.onFileRequested(f):null,null!==f&&c(f))}}}c(a)};
JSM.ConvertObjToJsonData=function(a,b){var c=new JSM.TriangleModel,d=c.AddBody(new JSM.TriangleBody("Default")),e=c.GetBody(d),f={},g=null,h=null,l=[],k=[];JSM.ReadObjFile(a,{onNewMaterial:function(a){var b=c.AddMaterial(a,{r:1,g:0,b:0},{r:1,g:0,b:0},{r:0,g:0,b:0},1);g=c.GetMaterial(b);f[a]=b},onMaterialComponent:function(a,b,c,d){null!==g&&("Ka"==a?(a=g.ambient,a.r=b,a.g=c,a.b=d):"Kd"==a?(a=g.diffuse,a.r=b,a.g=c,a.b=d):"Ks"==a&&(a=g.specular,a.r=b,a.g=c,a.b=d))},onUseMaterial:function(a){a=f[a];
void 0!==a&&(h=a)},onMesh:function(a){a=c.AddBody(new JSM.TriangleBody(a));e=c.GetBody(a)},onVertex:function(a,b,c){l.push(new JSM.Coord(a,b,c))},onNormal:function(a,b,c){k.push(new JSM.Coord(a,b,c))},onFace:function(a,b){var c,d,f=a.length==b.length,g=a.length;for(c=0;c<g-2;c++)d=e.AddTriangle(a[0],a[(c+1)%g],a[(c+2)%g]),d=e.GetTriangle(d),f&&(d.n0=b[0],d.n1=b[(c+1)%g],d.n2=b[(c+2)%g]),null!==h&&(d.mat=h)},onFileRequested:function(a){return void 0!==b.onFileRequested&&null!==b.onFileRequested?b.onFileRequested(a):
null}});(function(a,b,c){function d(a,b,c,e,f){if(void 0!==c){var g=e[c];if(void 0!==g)return g;b=b[c];0===f?g=a.AddVertex(b.x,b.y,b.z):1===f&&(g=a.AddNormal(b.x,b.y,b.z));return e[c]=g}}var e,f,g,h,l,k;for(e=0;e<a.BodyCount();e++){g=a.GetBody(e);l={};k={};for(f=0;f<g.TriangleCount();f++)h=g.GetTriangle(f),h.v0=d(g,b,h.v0,l,0),h.v1=d(g,b,h.v1,l,0),h.v2=d(g,b,h.v2,l,0),h.n0=d(g,c,h.n0,k,1),h.n1=d(g,c,h.n1,k,1),h.n2=d(g,c,h.n2,k,1)}})(c,l,k);c.Finalize();return JSM.ConvertTriangleModelToJsonData(c)};
JSM.ReadBinaryStlFile=function(a,b){function c(a){var b=[],c;for(c=0;3>c;c++)b[c]=a.ReadFloat32();return b}var d=new JSM.BinaryReader(a,!0);d.Skip(80);var e=d.ReadUnsignedInteger32(),f,g,h,l,k;for(f=0;f<e;f++)if(k=c(d),g=c(d),h=c(d),l=c(d),d.Skip(2),void 0!==b.onFace&&null!==b.onFace)b.onFace(g,h,l,k)};
JSM.ReadAsciiStlFile=function(a,b){function c(a,c){var d=a[c].trim();if(0===d.length)return c+1;d=d.split(/\s+/);if(0===d.length)return c+1;if("solid"!=d[0]&&"facet"==d[0]&&"normal"==d[1]){if(5>d.length)return-1;var d=[parseFloat(d[2]),parseFloat(d[3]),parseFloat(d[4])],e=[],k,m;for(k=c+1;k<a.length&&3>e.length;k++)if(m=a[k].trim(),0!==m.length&&(m=m.split(/\s+/),0!==m.length&&"vertex"==m[0]))if(4>m.length)break;else m=[parseFloat(m[1]),parseFloat(m[2]),parseFloat(m[3])],e.push(m);k+=1;if(3!=e.length)return-1;
if(void 0!==b.onFace&&null!==b.onFace)b.onFace(e[0],e[1],e[2],d);return k}return c+1}for(var d=0,e=a.split("\n");d<e.length&&-1!=d;)d=c(e,d)};
JSM.ConvertStlToJsonData=function(a){var b=new JSM.TriangleModel,c=b.AddBody(new JSM.TriangleBody("Default")),d=b.GetBody(c);(function(a){var b=a.byteLength;if(84>b)return!1;a=new JSM.BinaryReader(a,!0);a.Skip(80);a=a.ReadUnsignedInteger32();return b!=50*a+84?!1:!0})(a)?JSM.ReadBinaryStlFile(a,{onFace:function(a,b,c,h){a=d.AddVertex(a[0],a[1],a[2]);b=d.AddVertex(b[0],b[1],b[2]);c=d.AddVertex(c[0],c[1],c[2]);h=JSM.VectorNormalize(new JSM.Vector(h[0],h[1],h[2]));h=d.AddNormal(h.x,h.y,h.z);d.AddTriangle(a,
b,c,h,h,h)}}):(a=String.fromCharCode.apply(null,new Uint8Array(a)),JSM.ReadAsciiStlFile(a,{onFace:function(a,b,c,h){a=d.AddVertex(a[0],a[1],a[2]);b=d.AddVertex(b[0],b[1],b[2]);c=d.AddVertex(c[0],c[1],c[2]);h=JSM.VectorNormalize(new JSM.Vector(h[0],h[1],h[2]));h=d.AddNormal(h.x,h.y,h.z);d.AddTriangle(a,b,c,h,h,h)}}));b.Finalize();return JSM.ConvertTriangleModelToJsonData(b)};JSM.ImportFileList=function(){this.descriptors=null};
JSM.ImportFileList.prototype.Init=function(a){this.descriptors=[];var b,c;for(b=0;b<a.length;b++)c=a[b],c={originalObject:c,originalFileName:c.name,fileName:c.name.toUpperCase(),extension:this.GetFileExtension(c.name)},this.descriptors.push(c)};JSM.ImportFileList.prototype.GetFileDescriptor=function(a){return this.descriptors[a]};
JSM.ImportFileList.prototype.GetMainFileIndex=function(a){var b;for(a=0;a<this.descriptors.length;a++)if(b=this.descriptors[a],this.IsSupportedExtension(b.extension))return a;return-1};JSM.ImportFileList.prototype.GetFileIndexByName=function(a){var b,c;for(b=0;b<this.descriptors.length;b++)if(c=this.descriptors[b],c.fileName==a.toUpperCase())return b;return-1};JSM.ImportFileList.prototype.IsSupportedExtension=function(a){return".3DS"==a||".OBJ"==a||".STL"==a?!0:!1};
JSM.ImportFileList.prototype.GetFileExtension=function(a){var b=a.lastIndexOf(".");if(-1==b)return"";a=a.substr(b);return a=a.toUpperCase()};
JSM.ConvertFileListToJsonData=function(a,b){function c(a,c){if(void 0!==b.onReady&&null!==b.onReady)b.onReady(a,c)}var d=new JSM.ImportFileList;d.Init(a);var e=d.GetMainFileIndex();if(-1===e){if(void 0!==b.onError&&null!==b.onError)b.onError()}else{var f=d.GetFileDescriptor(e),g={main:f.originalFileName,requested:[],missing:[]};".3DS"==f.extension?JSM.GetArrayBufferFromFile(f.originalObject,function(a){a=JSM.Convert3dsToJsonData(a);c(g,a)}):".OBJ"==f.extension?JSM.GetStringBuffersFromFileList(a,function(a){var b=
JSM.ConvertObjToJsonData(a[e],{onFileRequested:function(b){var c=d.GetFileIndexByName(b);if(-1==c)return g.missing.push(b),null;g.requested.push(b);return a[c]}});c(g,b)}):".STL"==f.extension&&JSM.GetArrayBufferFromFile(f.originalObject,function(a){a=JSM.ConvertStlToJsonData(a);c(g,a)})}};
JSM.GenerateSolidWithRadius=function(a,b){var c=new JSM.Body,d=!0;"Tetrahedron"===a?c=JSM.GenerateTetrahedron():"Hexahedron"===a?c=JSM.GenerateHexahedron():"Octahedron"===a?c=JSM.GenerateOctahedron():"Dodecahedron"===a?c=JSM.GenerateDodecahedron():"Icosahedron"===a?c=JSM.GenerateIcosahedron():"TruncatedTetrahedron"===a?c=JSM.GenerateTruncatedTetrahedron():"Cuboctahedron"===a?c=JSM.GenerateCuboctahedron():"TruncatedCube"===a?c=JSM.GenerateTruncatedCube():"TruncatedOctahedron"===a?c=JSM.GenerateTruncatedOctahedron():
"Rhombicuboctahedron"===a?c=JSM.GenerateRhombicuboctahedron():"TruncatedCuboctahedron"===a?c=JSM.GenerateTruncatedCuboctahedron():"SnubCube"===a?c=JSM.GenerateSnubCube():"Icosidodecahedron"===a?c=JSM.GenerateIcosidodecahedron():"TruncatedDodecahedron"===a?c=JSM.GenerateTruncatedDodecahedron():"TruncatedIcosahedron"===a?c=JSM.GenerateTruncatedIcosahedron():"Rhombicosidodecahedron"===a?c=JSM.GenerateRhombicosidodecahedron():"TruncatedIcosidodecahedron"===a?c=JSM.GenerateTruncatedIcosidodecahedron():
"SnubDodecahedron"===a?c=JSM.GenerateSnubDodecahedron():"TetrakisHexahedron"===a?(c=JSM.GenerateTetrakisHexahedron(),d=!1):"RhombicDodecahedron"===a?(c=JSM.GenerateRhombicDodecahedron(),d=!1):"PentakisDodecahedron"===a?(c=JSM.GeneratePentakisDodecahedron(),d=!1):"SmallStellatedDodecahedron"===a?(c=JSM.GenerateSmallStellatedDodecahedron(),d=!1):"GreatDodecahedron"===a?(c=JSM.GenerateGreatDodecahedron(),d=!1):"SmallTriambicIcosahedron"===a?(c=JSM.GenerateSmallTriambicIcosahedron(),d=!1):"GreatStellatedDodecahedron"===
a?(c=JSM.GenerateGreatStellatedDodecahedron(),d=!1):"SmallTriakisOctahedron"===a?(c=JSM.GenerateSmallTriakisOctahedron(),d=!1):"StellaOctangula"===a?(c=JSM.GenerateStellaOctangula(),d=!1):"TriakisTetrahedron"===a&&(c=JSM.GenerateTriakisTetrahedron(),d=!1);if(0<c.VertexCount()){var e=0;if(d)e=JSM.VectorLength(c.GetVertexPosition(0));else for(var f,d=0;d<c.VertexCount();d++)f=JSM.VectorLength(c.GetVertexPosition(d)),JSM.IsGreater(f,e)&&(e=f);e=b/e;for(d=0;d<c.VertexCount();d++)f=c.GetVertex(d),f.SetPosition(JSM.VectorMultiply(f.GetPosition(),
e))}return c};JSM.GenerateTetrahedron=function(){var a=new JSM.Body;a.AddVertex(new JSM.BodyVertex(new JSM.Coord(1,1,1)));a.AddVertex(new JSM.BodyVertex(new JSM.Coord(-1,-1,1)));a.AddVertex(new JSM.BodyVertex(new JSM.Coord(-1,1,-1)));a.AddVertex(new JSM.BodyVertex(new JSM.Coord(1,-1,-1)));a.AddPolygon(new JSM.BodyPolygon([0,1,3]));a.AddPolygon(new JSM.BodyPolygon([0,2,1]));a.AddPolygon(new JSM.BodyPolygon([0,3,2]));a.AddPolygon(new JSM.BodyPolygon([1,2,3]));return a};
JSM.GenerateHexahedron=function(){var a=new JSM.Body;JSM.AddVertexToBody(a,1,1,1);JSM.AddVertexToBody(a,1,1,-1);JSM.AddVertexToBody(a,1,-1,1);JSM.AddVertexToBody(a,-1,1,1);JSM.AddVertexToBody(a,1,-1,-1);JSM.AddVertexToBody(a,-1,1,-1);JSM.AddVertexToBody(a,-1,-1,1);JSM.AddVertexToBody(a,-1,-1,-1);JSM.AddPolygonToBody(a,[0,1,5,3]);JSM.AddPolygonToBody(a,[0,2,4,1]);JSM.AddPolygonToBody(a,[0,3,6,2]);JSM.AddPolygonToBody(a,[1,4,7,5]);JSM.AddPolygonToBody(a,[2,6,7,4]);JSM.AddPolygonToBody(a,[3,5,7,6]);
return a};JSM.GenerateOctahedron=function(){var a=new JSM.Body;JSM.AddVertexToBody(a,1,0,0);JSM.AddVertexToBody(a,-1,0,0);JSM.AddVertexToBody(a,0,1,0);JSM.AddVertexToBody(a,0,-1,0);JSM.AddVertexToBody(a,0,0,1);JSM.AddVertexToBody(a,0,0,-1);JSM.AddPolygonToBody(a,[0,2,4]);JSM.AddPolygonToBody(a,[0,3,5]);JSM.AddPolygonToBody(a,[0,4,3]);JSM.AddPolygonToBody(a,[0,5,2]);JSM.AddPolygonToBody(a,[1,2,5]);JSM.AddPolygonToBody(a,[1,3,4]);JSM.AddPolygonToBody(a,[1,4,2]);JSM.AddPolygonToBody(a,[1,5,3]);return a};
JSM.GenerateDodecahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2,c=1/b;JSM.AddVertexToBody(a,1,1,1);JSM.AddVertexToBody(a,1,1,-1);JSM.AddVertexToBody(a,1,-1,1);JSM.AddVertexToBody(a,-1,1,1);JSM.AddVertexToBody(a,1,-1,-1);JSM.AddVertexToBody(a,-1,1,-1);JSM.AddVertexToBody(a,-1,-1,1);JSM.AddVertexToBody(a,-1,-1,-1);JSM.AddVertexToBody(a,0,+c,+b);JSM.AddVertexToBody(a,0,+c,-b);JSM.AddVertexToBody(a,0,-c,+b);JSM.AddVertexToBody(a,0,-c,-b);JSM.AddVertexToBody(a,+c,+b,0);JSM.AddVertexToBody(a,
+c,-b,0);JSM.AddVertexToBody(a,-c,+b,0);JSM.AddVertexToBody(a,-c,-b,0);JSM.AddVertexToBody(a,+b,0,+c);JSM.AddVertexToBody(a,-b,0,+c);JSM.AddVertexToBody(a,+b,0,-c);JSM.AddVertexToBody(a,-b,0,-c);JSM.AddPolygonToBody(a,[0,8,10,2,16]);JSM.AddPolygonToBody(a,[0,16,18,1,12]);JSM.AddPolygonToBody(a,[0,12,14,3,8]);JSM.AddPolygonToBody(a,[1,9,5,14,12]);JSM.AddPolygonToBody(a,[1,18,4,11,9]);JSM.AddPolygonToBody(a,[2,10,6,15,13]);JSM.AddPolygonToBody(a,[2,13,4,18,16]);JSM.AddPolygonToBody(a,[3,14,5,19,17]);
JSM.AddPolygonToBody(a,[3,17,6,10,8]);JSM.AddPolygonToBody(a,[4,13,15,7,11]);JSM.AddPolygonToBody(a,[5,9,11,7,19]);JSM.AddPolygonToBody(a,[6,17,19,7,15]);return a};
JSM.GenerateIcosahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2;JSM.AddVertexToBody(a,0,1,+b);JSM.AddVertexToBody(a,0,1,-b);JSM.AddVertexToBody(a,0,-1,+b);JSM.AddVertexToBody(a,0,-1,-b);JSM.AddVertexToBody(a,1,+b,0);JSM.AddVertexToBody(a,1,-b,0);JSM.AddVertexToBody(a,-1,+b,0);JSM.AddVertexToBody(a,-1,-b,0);JSM.AddVertexToBody(a,+b,0,1);JSM.AddVertexToBody(a,-b,0,1);JSM.AddVertexToBody(a,+b,0,-1);JSM.AddVertexToBody(a,-b,0,-1);JSM.AddPolygonToBody(a,[0,2,8]);JSM.AddPolygonToBody(a,[0,4,
6]);JSM.AddPolygonToBody(a,[0,6,9]);JSM.AddPolygonToBody(a,[0,8,4]);JSM.AddPolygonToBody(a,[0,9,2]);JSM.AddPolygonToBody(a,[1,3,11]);JSM.AddPolygonToBody(a,[1,4,10]);JSM.AddPolygonToBody(a,[1,6,4]);JSM.AddPolygonToBody(a,[1,10,3]);JSM.AddPolygonToBody(a,[1,11,6]);JSM.AddPolygonToBody(a,[2,5,8]);JSM.AddPolygonToBody(a,[2,7,5]);JSM.AddPolygonToBody(a,[2,9,7]);JSM.AddPolygonToBody(a,[3,5,7]);JSM.AddPolygonToBody(a,[3,7,11]);JSM.AddPolygonToBody(a,[3,10,5]);JSM.AddPolygonToBody(a,[4,8,10]);JSM.AddPolygonToBody(a,
[6,11,9]);JSM.AddPolygonToBody(a,[5,10,8]);JSM.AddPolygonToBody(a,[7,9,11]);return a};
JSM.GenerateTruncatedTetrahedron=function(){var a=new JSM.Body;JSM.AddVertexToBody(a,1,1,3);JSM.AddVertexToBody(a,1,-1,-3);JSM.AddVertexToBody(a,-1,-1,3);JSM.AddVertexToBody(a,-1,1,-3);JSM.AddVertexToBody(a,1,3,1);JSM.AddVertexToBody(a,1,-3,-1);JSM.AddVertexToBody(a,-1,-3,1);JSM.AddVertexToBody(a,-1,3,-1);JSM.AddVertexToBody(a,3,1,1);JSM.AddVertexToBody(a,3,-1,-1);JSM.AddVertexToBody(a,-3,-1,1);JSM.AddVertexToBody(a,-3,1,-1);JSM.AddPolygonToBody(a,[0,8,4]);JSM.AddPolygonToBody(a,[1,9,5]);JSM.AddPolygonToBody(a,
[2,10,6]);JSM.AddPolygonToBody(a,[3,11,7]);JSM.AddPolygonToBody(a,[0,2,6,5,9,8]);JSM.AddPolygonToBody(a,[0,4,7,11,10,2]);JSM.AddPolygonToBody(a,[1,3,7,4,8,9]);JSM.AddPolygonToBody(a,[1,5,6,10,11,3]);return a};
JSM.GenerateCuboctahedron=function(){var a=new JSM.Body;JSM.AddVertexToBody(a,1,1,0);JSM.AddVertexToBody(a,1,-1,0);JSM.AddVertexToBody(a,-1,-1,0);JSM.AddVertexToBody(a,-1,1,0);JSM.AddVertexToBody(a,1,0,1);JSM.AddVertexToBody(a,1,0,-1);JSM.AddVertexToBody(a,-1,0,1);JSM.AddVertexToBody(a,-1,0,-1);JSM.AddVertexToBody(a,0,1,1);JSM.AddVertexToBody(a,0,-1,-1);JSM.AddVertexToBody(a,0,-1,1);JSM.AddVertexToBody(a,0,1,-1);JSM.AddPolygonToBody(a,[0,5,11]);JSM.AddPolygonToBody(a,[0,8,4]);JSM.AddPolygonToBody(a,
[1,4,10]);JSM.AddPolygonToBody(a,[1,9,5]);JSM.AddPolygonToBody(a,[2,7,9]);JSM.AddPolygonToBody(a,[2,10,6]);JSM.AddPolygonToBody(a,[3,6,8]);JSM.AddPolygonToBody(a,[3,11,7]);JSM.AddPolygonToBody(a,[0,4,1,5]);JSM.AddPolygonToBody(a,[0,11,3,8]);JSM.AddPolygonToBody(a,[1,10,2,9]);JSM.AddPolygonToBody(a,[2,6,3,7]);JSM.AddPolygonToBody(a,[4,8,6,10]);JSM.AddPolygonToBody(a,[5,9,7,11]);return a};
JSM.GenerateTruncatedCube=function(){var a=new JSM.Body,b=Math.sqrt(2)-1;JSM.AddVertexToBody(a,1,1,+b);JSM.AddVertexToBody(a,1,1,-b);JSM.AddVertexToBody(a,1,-1,+b);JSM.AddVertexToBody(a,-1,1,+b);JSM.AddVertexToBody(a,1,-1,-b);JSM.AddVertexToBody(a,-1,1,-b);JSM.AddVertexToBody(a,-1,-1,+b);JSM.AddVertexToBody(a,-1,-1,-b);JSM.AddVertexToBody(a,1,+b,1);JSM.AddVertexToBody(a,1,+b,-1);JSM.AddVertexToBody(a,1,-b,1);JSM.AddVertexToBody(a,-1,+b,1);JSM.AddVertexToBody(a,1,-b,-1);JSM.AddVertexToBody(a,-1,+b,
-1);JSM.AddVertexToBody(a,-1,-b,1);JSM.AddVertexToBody(a,-1,-b,-1);JSM.AddVertexToBody(a,+b,1,1);JSM.AddVertexToBody(a,+b,1,-1);JSM.AddVertexToBody(a,+b,-1,1);JSM.AddVertexToBody(a,-b,1,1);JSM.AddVertexToBody(a,+b,-1,-1);JSM.AddVertexToBody(a,-b,1,-1);JSM.AddVertexToBody(a,-b,-1,1);JSM.AddVertexToBody(a,-b,-1,-1);JSM.AddPolygonToBody(a,[0,16,8]);JSM.AddPolygonToBody(a,[1,9,17]);JSM.AddPolygonToBody(a,[2,10,18]);JSM.AddPolygonToBody(a,[3,11,19]);JSM.AddPolygonToBody(a,[4,20,12]);JSM.AddPolygonToBody(a,
[5,21,13]);JSM.AddPolygonToBody(a,[6,22,14]);JSM.AddPolygonToBody(a,[7,15,23]);JSM.AddPolygonToBody(a,[0,1,17,21,5,3,19,16]);JSM.AddPolygonToBody(a,[0,8,10,2,4,12,9,1]);JSM.AddPolygonToBody(a,[2,18,22,6,7,23,20,4]);JSM.AddPolygonToBody(a,[3,5,13,15,7,6,14,11]);JSM.AddPolygonToBody(a,[8,16,19,11,14,22,18,10]);JSM.AddPolygonToBody(a,[9,12,20,23,15,13,21,17]);return a};
JSM.GenerateTruncatedOctahedron=function(){var a=new JSM.Body;JSM.AddVertexToBody(a,0,1,2);JSM.AddVertexToBody(a,0,1,-2);JSM.AddVertexToBody(a,0,-1,2);JSM.AddVertexToBody(a,0,-1,-2);JSM.AddVertexToBody(a,0,2,1);JSM.AddVertexToBody(a,0,-2,1);JSM.AddVertexToBody(a,0,2,-1);JSM.AddVertexToBody(a,0,-2,-1);JSM.AddVertexToBody(a,1,0,2);JSM.AddVertexToBody(a,1,0,-2);JSM.AddVertexToBody(a,-1,0,2);JSM.AddVertexToBody(a,-1,0,-2);JSM.AddVertexToBody(a,1,2,0);JSM.AddVertexToBody(a,1,-2,0);JSM.AddVertexToBody(a,
-1,2,0);JSM.AddVertexToBody(a,-1,-2,0);JSM.AddVertexToBody(a,2,0,1);JSM.AddVertexToBody(a,-2,0,1);JSM.AddVertexToBody(a,2,0,-1);JSM.AddVertexToBody(a,-2,0,-1);JSM.AddVertexToBody(a,2,1,0);JSM.AddVertexToBody(a,-2,1,0);JSM.AddVertexToBody(a,2,-1,0);JSM.AddVertexToBody(a,-2,-1,0);JSM.AddPolygonToBody(a,[0,10,2,8]);JSM.AddPolygonToBody(a,[1,9,3,11]);JSM.AddPolygonToBody(a,[4,12,6,14]);JSM.AddPolygonToBody(a,[5,15,7,13]);JSM.AddPolygonToBody(a,[16,22,18,20]);JSM.AddPolygonToBody(a,[17,21,19,23]);JSM.AddPolygonToBody(a,
[0,4,14,21,17,10]);JSM.AddPolygonToBody(a,[0,8,16,20,12,4]);JSM.AddPolygonToBody(a,[1,6,12,20,18,9]);JSM.AddPolygonToBody(a,[1,11,19,21,14,6]);JSM.AddPolygonToBody(a,[2,5,13,22,16,8]);JSM.AddPolygonToBody(a,[2,10,17,23,15,5]);JSM.AddPolygonToBody(a,[3,7,15,23,19,11]);JSM.AddPolygonToBody(a,[3,9,18,22,13,7]);return a};
JSM.GenerateRhombicuboctahedron=function(){var a=new JSM.Body,b=1+Math.sqrt(2);JSM.AddVertexToBody(a,1,1,+b);JSM.AddVertexToBody(a,1,1,-b);JSM.AddVertexToBody(a,1,-1,+b);JSM.AddVertexToBody(a,-1,1,+b);JSM.AddVertexToBody(a,1,-1,-b);JSM.AddVertexToBody(a,-1,1,-b);JSM.AddVertexToBody(a,-1,-1,+b);JSM.AddVertexToBody(a,-1,-1,-b);JSM.AddVertexToBody(a,1,+b,1);JSM.AddVertexToBody(a,1,+b,-1);JSM.AddVertexToBody(a,1,-b,1);JSM.AddVertexToBody(a,-1,+b,1);JSM.AddVertexToBody(a,1,-b,-1);JSM.AddVertexToBody(a,
-1,+b,-1);JSM.AddVertexToBody(a,-1,-b,1);JSM.AddVertexToBody(a,-1,-b,-1);JSM.AddVertexToBody(a,+b,1,1);JSM.AddVertexToBody(a,+b,1,-1);JSM.AddVertexToBody(a,+b,-1,1);JSM.AddVertexToBody(a,-b,1,1);JSM.AddVertexToBody(a,+b,-1,-1);JSM.AddVertexToBody(a,-b,1,-1);JSM.AddVertexToBody(a,-b,-1,1);JSM.AddVertexToBody(a,-b,-1,-1);JSM.AddPolygonToBody(a,[0,16,8]);JSM.AddPolygonToBody(a,[1,9,17]);JSM.AddPolygonToBody(a,[2,10,18]);JSM.AddPolygonToBody(a,[3,11,19]);JSM.AddPolygonToBody(a,[4,20,12]);JSM.AddPolygonToBody(a,
[5,21,13]);JSM.AddPolygonToBody(a,[6,22,14]);JSM.AddPolygonToBody(a,[7,15,23]);JSM.AddPolygonToBody(a,[0,2,18,16]);JSM.AddPolygonToBody(a,[0,3,6,2]);JSM.AddPolygonToBody(a,[0,8,11,3]);JSM.AddPolygonToBody(a,[1,4,7,5]);JSM.AddPolygonToBody(a,[1,5,13,9]);JSM.AddPolygonToBody(a,[1,17,20,4]);JSM.AddPolygonToBody(a,[2,6,14,10]);JSM.AddPolygonToBody(a,[3,19,22,6]);JSM.AddPolygonToBody(a,[4,12,15,7]);JSM.AddPolygonToBody(a,[5,7,23,21]);JSM.AddPolygonToBody(a,[8,9,13,11]);JSM.AddPolygonToBody(a,[8,16,17,
9]);JSM.AddPolygonToBody(a,[10,12,20,18]);JSM.AddPolygonToBody(a,[10,14,15,12]);JSM.AddPolygonToBody(a,[11,13,21,19]);JSM.AddPolygonToBody(a,[14,22,23,15]);JSM.AddPolygonToBody(a,[16,18,20,17]);JSM.AddPolygonToBody(a,[19,21,23,22]);return a};
JSM.GenerateTruncatedCuboctahedron=function(){var a=new JSM.Body,b=1+Math.sqrt(2),c=1+2*Math.sqrt(2);JSM.AddVertexToBody(a,1,+b,+c);JSM.AddVertexToBody(a,1,+b,-c);JSM.AddVertexToBody(a,1,-b,+c);JSM.AddVertexToBody(a,-1,+b,+c);JSM.AddVertexToBody(a,1,-b,-c);JSM.AddVertexToBody(a,-1,+b,-c);JSM.AddVertexToBody(a,-1,-b,+c);JSM.AddVertexToBody(a,-1,-b,-c);JSM.AddVertexToBody(a,1,+c,+b);JSM.AddVertexToBody(a,1,-c,+b);JSM.AddVertexToBody(a,1,+c,-b);JSM.AddVertexToBody(a,-1,+c,+b);JSM.AddVertexToBody(a,1,
-c,-b);JSM.AddVertexToBody(a,-1,-c,+b);JSM.AddVertexToBody(a,-1,+c,-b);JSM.AddVertexToBody(a,-1,-c,-b);JSM.AddVertexToBody(a,+b,1,+c);JSM.AddVertexToBody(a,+b,1,-c);JSM.AddVertexToBody(a,-b,1,+c);JSM.AddVertexToBody(a,+b,-1,+c);JSM.AddVertexToBody(a,-b,1,-c);JSM.AddVertexToBody(a,+b,-1,-c);JSM.AddVertexToBody(a,-b,-1,+c);JSM.AddVertexToBody(a,-b,-1,-c);JSM.AddVertexToBody(a,+b,+c,1);JSM.AddVertexToBody(a,+b,-c,1);JSM.AddVertexToBody(a,-b,+c,1);JSM.AddVertexToBody(a,+b,+c,-1);JSM.AddVertexToBody(a,
-b,-c,1);JSM.AddVertexToBody(a,+b,-c,-1);JSM.AddVertexToBody(a,-b,+c,-1);JSM.AddVertexToBody(a,-b,-c,-1);JSM.AddVertexToBody(a,+c,1,+b);JSM.AddVertexToBody(a,-c,1,+b);JSM.AddVertexToBody(a,+c,1,-b);JSM.AddVertexToBody(a,+c,-1,+b);JSM.AddVertexToBody(a,-c,1,-b);JSM.AddVertexToBody(a,-c,-1,+b);JSM.AddVertexToBody(a,+c,-1,-b);JSM.AddVertexToBody(a,-c,-1,-b);JSM.AddVertexToBody(a,+c,+b,1);JSM.AddVertexToBody(a,-c,+b,1);JSM.AddVertexToBody(a,+c,-b,1);JSM.AddVertexToBody(a,+c,+b,-1);JSM.AddVertexToBody(a,
-c,-b,1);JSM.AddVertexToBody(a,-c,+b,-1);JSM.AddVertexToBody(a,+c,-b,-1);JSM.AddVertexToBody(a,-c,-b,-1);JSM.AddPolygonToBody(a,[0,8,11,3]);JSM.AddPolygonToBody(a,[1,5,14,10]);JSM.AddPolygonToBody(a,[2,6,13,9]);JSM.AddPolygonToBody(a,[4,12,15,7]);JSM.AddPolygonToBody(a,[16,19,35,32]);JSM.AddPolygonToBody(a,[17,34,38,21]);JSM.AddPolygonToBody(a,[18,33,37,22]);JSM.AddPolygonToBody(a,[23,39,36,20]);JSM.AddPolygonToBody(a,[24,40,43,27]);JSM.AddPolygonToBody(a,[25,29,46,42]);JSM.AddPolygonToBody(a,[26,
30,45,41]);JSM.AddPolygonToBody(a,[28,44,47,31]);JSM.AddPolygonToBody(a,[0,16,32,40,24,8]);JSM.AddPolygonToBody(a,[1,10,27,43,34,17]);JSM.AddPolygonToBody(a,[2,9,25,42,35,19]);JSM.AddPolygonToBody(a,[3,11,26,41,33,18]);JSM.AddPolygonToBody(a,[4,21,38,46,29,12]);JSM.AddPolygonToBody(a,[5,20,36,45,30,14]);JSM.AddPolygonToBody(a,[6,22,37,44,28,13]);JSM.AddPolygonToBody(a,[7,15,31,47,39,23]);JSM.AddPolygonToBody(a,[0,3,18,22,6,2,19,16]);JSM.AddPolygonToBody(a,[1,17,21,4,7,23,20,5]);JSM.AddPolygonToBody(a,
[8,24,27,10,14,30,26,11]);JSM.AddPolygonToBody(a,[9,13,28,31,15,12,29,25]);JSM.AddPolygonToBody(a,[32,35,42,46,38,34,43,40]);JSM.AddPolygonToBody(a,[33,41,45,36,39,47,44,37]);return a};
JSM.GenerateSnubCube=function(){var a=new JSM.Body,b=1/3*(Math.pow(17+3*Math.sqrt(33),1/3)-Math.pow(-17+3*Math.sqrt(33),1/3)-1),c=1/b;JSM.AddVertexToBody(a,1,+b,-c);JSM.AddVertexToBody(a,1,-b,+c);JSM.AddVertexToBody(a,-1,+b,+c);JSM.AddVertexToBody(a,-1,-b,-c);JSM.AddVertexToBody(a,+b,-c,1);JSM.AddVertexToBody(a,-b,+c,1);JSM.AddVertexToBody(a,+b,+c,-1);JSM.AddVertexToBody(a,-b,-c,-1);JSM.AddVertexToBody(a,-c,1,+b);JSM.AddVertexToBody(a,+c,1,-b);JSM.AddVertexToBody(a,+c,-1,+b);JSM.AddVertexToBody(a,
-c,-1,-b);JSM.AddVertexToBody(a,1,+c,+b);JSM.AddVertexToBody(a,1,-c,-b);JSM.AddVertexToBody(a,-1,+c,-b);JSM.AddVertexToBody(a,-1,-c,+b);JSM.AddVertexToBody(a,+b,1,+c);JSM.AddVertexToBody(a,-b,1,-c);JSM.AddVertexToBody(a,-b,-1,+c);JSM.AddVertexToBody(a,+b,-1,-c);JSM.AddVertexToBody(a,+c,+b,1);JSM.AddVertexToBody(a,-c,-b,1);JSM.AddVertexToBody(a,+c,-b,-1);JSM.AddVertexToBody(a,-c,+b,-1);JSM.AddPolygonToBody(a,[0,6,9]);JSM.AddPolygonToBody(a,[0,9,22]);JSM.AddPolygonToBody(a,[0,17,6]);JSM.AddPolygonToBody(a,
[0,22,19]);JSM.AddPolygonToBody(a,[1,4,10]);JSM.AddPolygonToBody(a,[1,10,20]);JSM.AddPolygonToBody(a,[1,18,4]);JSM.AddPolygonToBody(a,[1,20,16]);JSM.AddPolygonToBody(a,[2,5,8]);JSM.AddPolygonToBody(a,[2,8,21]);JSM.AddPolygonToBody(a,[2,16,5]);JSM.AddPolygonToBody(a,[2,21,18]);JSM.AddPolygonToBody(a,[3,7,11]);JSM.AddPolygonToBody(a,[3,11,23]);JSM.AddPolygonToBody(a,[3,19,7]);JSM.AddPolygonToBody(a,[3,23,17]);JSM.AddPolygonToBody(a,[4,13,10]);JSM.AddPolygonToBody(a,[4,18,15]);JSM.AddPolygonToBody(a,
[5,14,8]);JSM.AddPolygonToBody(a,[5,16,12]);JSM.AddPolygonToBody(a,[6,12,9]);JSM.AddPolygonToBody(a,[6,17,14]);JSM.AddPolygonToBody(a,[7,15,11]);JSM.AddPolygonToBody(a,[7,19,13]);JSM.AddPolygonToBody(a,[8,14,23]);JSM.AddPolygonToBody(a,[9,12,20]);JSM.AddPolygonToBody(a,[10,13,22]);JSM.AddPolygonToBody(a,[11,15,21]);JSM.AddPolygonToBody(a,[12,16,20]);JSM.AddPolygonToBody(a,[13,19,22]);JSM.AddPolygonToBody(a,[14,17,23]);JSM.AddPolygonToBody(a,[15,18,21]);JSM.AddPolygonToBody(a,[0,19,3,17]);JSM.AddPolygonToBody(a,
[1,16,2,18]);JSM.AddPolygonToBody(a,[4,15,7,13]);JSM.AddPolygonToBody(a,[5,12,6,14]);JSM.AddPolygonToBody(a,[8,23,11,21]);JSM.AddPolygonToBody(a,[9,20,10,22]);return a};
JSM.GenerateIcosidodecahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2,c=b/2,d=(1+b)/2;JSM.AddVertexToBody(a,0,0,+b);JSM.AddVertexToBody(a,0,0,-b);JSM.AddVertexToBody(a,0,+b,0);JSM.AddVertexToBody(a,0,-b,0);JSM.AddVertexToBody(a,+b,0,0);JSM.AddVertexToBody(a,-b,0,0);JSM.AddVertexToBody(a,0.5,+c,+d);JSM.AddVertexToBody(a,0.5,+c,-d);JSM.AddVertexToBody(a,0.5,-c,+d);JSM.AddVertexToBody(a,-0.5,+c,+d);JSM.AddVertexToBody(a,0.5,-c,-d);JSM.AddVertexToBody(a,-0.5,+c,-d);JSM.AddVertexToBody(a,-0.5,
-c,+d);JSM.AddVertexToBody(a,-0.5,-c,-d);JSM.AddVertexToBody(a,+c,+d,0.5);JSM.AddVertexToBody(a,+c,-d,0.5);JSM.AddVertexToBody(a,-c,+d,0.5);JSM.AddVertexToBody(a,+c,+d,-0.5);JSM.AddVertexToBody(a,-c,-d,0.5);JSM.AddVertexToBody(a,+c,-d,-0.5);JSM.AddVertexToBody(a,-c,+d,-0.5);JSM.AddVertexToBody(a,-c,-d,-0.5);JSM.AddVertexToBody(a,+d,0.5,+c);JSM.AddVertexToBody(a,-d,0.5,+c);JSM.AddVertexToBody(a,+d,0.5,-c);JSM.AddVertexToBody(a,+d,-0.5,+c);JSM.AddVertexToBody(a,-d,0.5,-c);JSM.AddVertexToBody(a,-d,-0.5,
+c);JSM.AddVertexToBody(a,+d,-0.5,-c);JSM.AddVertexToBody(a,-d,-0.5,-c);JSM.AddPolygonToBody(a,[0,6,9]);JSM.AddPolygonToBody(a,[0,12,8]);JSM.AddPolygonToBody(a,[1,10,13]);JSM.AddPolygonToBody(a,[1,11,7]);JSM.AddPolygonToBody(a,[2,14,17]);JSM.AddPolygonToBody(a,[2,20,16]);JSM.AddPolygonToBody(a,[3,18,21]);JSM.AddPolygonToBody(a,[3,19,15]);JSM.AddPolygonToBody(a,[4,22,25]);JSM.AddPolygonToBody(a,[4,28,24]);JSM.AddPolygonToBody(a,[5,26,29]);JSM.AddPolygonToBody(a,[5,27,23]);JSM.AddPolygonToBody(a,[6,
22,14]);JSM.AddPolygonToBody(a,[7,17,24]);JSM.AddPolygonToBody(a,[8,15,25]);JSM.AddPolygonToBody(a,[9,16,23]);JSM.AddPolygonToBody(a,[10,28,19]);JSM.AddPolygonToBody(a,[11,26,20]);JSM.AddPolygonToBody(a,[12,27,18]);JSM.AddPolygonToBody(a,[13,21,29]);JSM.AddPolygonToBody(a,[0,8,25,22,6]);JSM.AddPolygonToBody(a,[0,9,23,27,12]);JSM.AddPolygonToBody(a,[1,7,24,28,10]);JSM.AddPolygonToBody(a,[1,13,29,26,11]);JSM.AddPolygonToBody(a,[2,16,9,6,14]);JSM.AddPolygonToBody(a,[2,17,7,11,20]);JSM.AddPolygonToBody(a,
[3,15,8,12,18]);JSM.AddPolygonToBody(a,[3,21,13,10,19]);JSM.AddPolygonToBody(a,[4,24,17,14,22]);JSM.AddPolygonToBody(a,[4,25,15,19,28]);JSM.AddPolygonToBody(a,[5,23,16,20,26]);JSM.AddPolygonToBody(a,[5,29,21,18,27]);return a};
JSM.GenerateTruncatedDodecahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2,c=1/b,d=2+b,e=2*b,f=Math.pow(b,2);JSM.AddVertexToBody(a,0,+c,+d);JSM.AddVertexToBody(a,0,+c,-d);JSM.AddVertexToBody(a,0,-c,+d);JSM.AddVertexToBody(a,0,-c,-d);JSM.AddVertexToBody(a,+d,0,+c);JSM.AddVertexToBody(a,-d,0,+c);JSM.AddVertexToBody(a,+d,0,-c);JSM.AddVertexToBody(a,-d,0,-c);JSM.AddVertexToBody(a,+c,+d,0);JSM.AddVertexToBody(a,+c,-d,0);JSM.AddVertexToBody(a,-c,+d,0);JSM.AddVertexToBody(a,-c,-d,0);JSM.AddVertexToBody(a,
+c,+b,+e);JSM.AddVertexToBody(a,+c,+b,-e);JSM.AddVertexToBody(a,+c,-b,+e);JSM.AddVertexToBody(a,-c,+b,+e);JSM.AddVertexToBody(a,+c,-b,-e);JSM.AddVertexToBody(a,-c,+b,-e);JSM.AddVertexToBody(a,-c,-b,+e);JSM.AddVertexToBody(a,-c,-b,-e);JSM.AddVertexToBody(a,+e,+c,+b);JSM.AddVertexToBody(a,+e,+c,-b);JSM.AddVertexToBody(a,+e,-c,+b);JSM.AddVertexToBody(a,-e,+c,+b);JSM.AddVertexToBody(a,+e,-c,-b);JSM.AddVertexToBody(a,-e,+c,-b);JSM.AddVertexToBody(a,-e,-c,+b);JSM.AddVertexToBody(a,-e,-c,-b);JSM.AddVertexToBody(a,
+b,+e,+c);JSM.AddVertexToBody(a,+b,+e,-c);JSM.AddVertexToBody(a,+b,-e,+c);JSM.AddVertexToBody(a,-b,+e,+c);JSM.AddVertexToBody(a,+b,-e,-c);JSM.AddVertexToBody(a,-b,+e,-c);JSM.AddVertexToBody(a,-b,-e,+c);JSM.AddVertexToBody(a,-b,-e,-c);JSM.AddVertexToBody(a,+b,2,+f);JSM.AddVertexToBody(a,+b,2,-f);JSM.AddVertexToBody(a,+b,-2,+f);JSM.AddVertexToBody(a,-b,2,+f);JSM.AddVertexToBody(a,+b,-2,-f);JSM.AddVertexToBody(a,-b,2,-f);JSM.AddVertexToBody(a,-b,-2,+f);JSM.AddVertexToBody(a,-b,-2,-f);JSM.AddVertexToBody(a,
+f,+b,2);JSM.AddVertexToBody(a,+f,+b,-2);JSM.AddVertexToBody(a,+f,-b,2);JSM.AddVertexToBody(a,-f,+b,2);JSM.AddVertexToBody(a,+f,-b,-2);JSM.AddVertexToBody(a,-f,+b,-2);JSM.AddVertexToBody(a,-f,-b,2);JSM.AddVertexToBody(a,-f,-b,-2);JSM.AddVertexToBody(a,2,+f,+b);JSM.AddVertexToBody(a,2,+f,-b);JSM.AddVertexToBody(a,2,-f,+b);JSM.AddVertexToBody(a,-2,+f,+b);JSM.AddVertexToBody(a,2,-f,-b);JSM.AddVertexToBody(a,-2,+f,-b);JSM.AddVertexToBody(a,-2,-f,+b);JSM.AddVertexToBody(a,-2,-f,-b);JSM.AddPolygonToBody(a,
[0,12,15]);JSM.AddPolygonToBody(a,[1,17,13]);JSM.AddPolygonToBody(a,[2,18,14]);JSM.AddPolygonToBody(a,[3,16,19]);JSM.AddPolygonToBody(a,[4,20,22]);JSM.AddPolygonToBody(a,[5,26,23]);JSM.AddPolygonToBody(a,[6,24,21]);JSM.AddPolygonToBody(a,[7,25,27]);JSM.AddPolygonToBody(a,[8,28,29]);JSM.AddPolygonToBody(a,[9,32,30]);JSM.AddPolygonToBody(a,[10,33,31]);JSM.AddPolygonToBody(a,[11,34,35]);JSM.AddPolygonToBody(a,[36,44,52]);JSM.AddPolygonToBody(a,[37,53,45]);JSM.AddPolygonToBody(a,[38,54,46]);JSM.AddPolygonToBody(a,
[39,55,47]);JSM.AddPolygonToBody(a,[40,48,56]);JSM.AddPolygonToBody(a,[41,49,57]);JSM.AddPolygonToBody(a,[42,50,58]);JSM.AddPolygonToBody(a,[43,59,51]);JSM.AddPolygonToBody(a,[0,2,14,38,46,22,20,44,36,12]);JSM.AddPolygonToBody(a,[0,15,39,47,23,26,50,42,18,2]);JSM.AddPolygonToBody(a,[1,3,19,43,51,27,25,49,41,17]);JSM.AddPolygonToBody(a,[1,13,37,45,21,24,48,40,16,3]);JSM.AddPolygonToBody(a,[4,6,21,45,53,29,28,52,44,20]);JSM.AddPolygonToBody(a,[4,22,46,54,30,32,56,48,24,6]);JSM.AddPolygonToBody(a,[5,
7,27,51,59,35,34,58,50,26]);JSM.AddPolygonToBody(a,[5,23,47,55,31,33,57,49,25,7]);JSM.AddPolygonToBody(a,[8,10,31,55,39,15,12,36,52,28]);JSM.AddPolygonToBody(a,[8,29,53,37,13,17,41,57,33,10]);JSM.AddPolygonToBody(a,[9,11,35,59,43,19,16,40,56,32]);JSM.AddPolygonToBody(a,[9,30,54,38,14,18,42,58,34,11]);return a};
JSM.GenerateTruncatedIcosahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2,c=3*b,d=1+2*b,e=2+b,f=2*b;JSM.AddVertexToBody(a,0,1,+c);JSM.AddVertexToBody(a,0,1,-c);JSM.AddVertexToBody(a,0,-1,+c);JSM.AddVertexToBody(a,0,-1,-c);JSM.AddVertexToBody(a,1,+c,0);JSM.AddVertexToBody(a,1,-c,0);JSM.AddVertexToBody(a,-1,+c,0);JSM.AddVertexToBody(a,-1,-c,0);JSM.AddVertexToBody(a,+c,0,1);JSM.AddVertexToBody(a,-c,0,1);JSM.AddVertexToBody(a,+c,0,-1);JSM.AddVertexToBody(a,-c,0,-1);JSM.AddVertexToBody(a,2,+d,
+b);JSM.AddVertexToBody(a,2,+d,-b);JSM.AddVertexToBody(a,2,-d,+b);JSM.AddVertexToBody(a,-2,+d,+b);JSM.AddVertexToBody(a,2,-d,-b);JSM.AddVertexToBody(a,-2,+d,-b);JSM.AddVertexToBody(a,-2,-d,+b);JSM.AddVertexToBody(a,-2,-d,-b);JSM.AddVertexToBody(a,+d,+b,2);JSM.AddVertexToBody(a,+d,-b,2);JSM.AddVertexToBody(a,-d,+b,2);JSM.AddVertexToBody(a,+d,+b,-2);JSM.AddVertexToBody(a,-d,-b,2);JSM.AddVertexToBody(a,+d,-b,-2);JSM.AddVertexToBody(a,-d,+b,-2);JSM.AddVertexToBody(a,-d,-b,-2);JSM.AddVertexToBody(a,+b,
2,+d);JSM.AddVertexToBody(a,-b,2,+d);JSM.AddVertexToBody(a,+b,2,-d);JSM.AddVertexToBody(a,+b,-2,+d);JSM.AddVertexToBody(a,-b,2,-d);JSM.AddVertexToBody(a,-b,-2,+d);JSM.AddVertexToBody(a,+b,-2,-d);JSM.AddVertexToBody(a,-b,-2,-d);JSM.AddVertexToBody(a,1,+e,+f);JSM.AddVertexToBody(a,1,+e,-f);JSM.AddVertexToBody(a,1,-e,+f);JSM.AddVertexToBody(a,-1,+e,+f);JSM.AddVertexToBody(a,1,-e,-f);JSM.AddVertexToBody(a,-1,+e,-f);JSM.AddVertexToBody(a,-1,-e,+f);JSM.AddVertexToBody(a,-1,-e,-f);JSM.AddVertexToBody(a,
+e,+f,1);JSM.AddVertexToBody(a,+e,-f,1);JSM.AddVertexToBody(a,-e,+f,1);JSM.AddVertexToBody(a,+e,+f,-1);JSM.AddVertexToBody(a,-e,-f,1);JSM.AddVertexToBody(a,+e,-f,-1);JSM.AddVertexToBody(a,-e,+f,-1);JSM.AddVertexToBody(a,-e,-f,-1);JSM.AddVertexToBody(a,+f,1,+e);JSM.AddVertexToBody(a,-f,1,+e);JSM.AddVertexToBody(a,+f,1,-e);JSM.AddVertexToBody(a,+f,-1,+e);JSM.AddVertexToBody(a,-f,1,-e);JSM.AddVertexToBody(a,-f,-1,+e);JSM.AddVertexToBody(a,+f,-1,-e);JSM.AddVertexToBody(a,-f,-1,-e);JSM.AddPolygonToBody(a,
[0,28,36,39,29]);JSM.AddPolygonToBody(a,[1,32,41,37,30]);JSM.AddPolygonToBody(a,[2,33,42,38,31]);JSM.AddPolygonToBody(a,[3,34,40,43,35]);JSM.AddPolygonToBody(a,[4,12,44,47,13]);JSM.AddPolygonToBody(a,[5,16,49,45,14]);JSM.AddPolygonToBody(a,[6,17,50,46,15]);JSM.AddPolygonToBody(a,[7,18,48,51,19]);JSM.AddPolygonToBody(a,[8,20,52,55,21]);JSM.AddPolygonToBody(a,[9,24,57,53,22]);JSM.AddPolygonToBody(a,[10,25,58,54,23]);JSM.AddPolygonToBody(a,[11,26,56,59,27]);JSM.AddPolygonToBody(a,[0,2,31,55,52,28]);
JSM.AddPolygonToBody(a,[0,29,53,57,33,2]);JSM.AddPolygonToBody(a,[1,3,35,59,56,32]);JSM.AddPolygonToBody(a,[1,30,54,58,34,3]);JSM.AddPolygonToBody(a,[4,6,15,39,36,12]);JSM.AddPolygonToBody(a,[4,13,37,41,17,6]);JSM.AddPolygonToBody(a,[5,7,19,43,40,16]);JSM.AddPolygonToBody(a,[5,14,38,42,18,7]);JSM.AddPolygonToBody(a,[8,10,23,47,44,20]);JSM.AddPolygonToBody(a,[8,21,45,49,25,10]);JSM.AddPolygonToBody(a,[9,11,27,51,48,24]);JSM.AddPolygonToBody(a,[9,22,46,50,26,11]);JSM.AddPolygonToBody(a,[12,36,28,52,
20,44]);JSM.AddPolygonToBody(a,[13,47,23,54,30,37]);JSM.AddPolygonToBody(a,[14,45,21,55,31,38]);JSM.AddPolygonToBody(a,[15,46,22,53,29,39]);JSM.AddPolygonToBody(a,[16,40,34,58,25,49]);JSM.AddPolygonToBody(a,[17,41,32,56,26,50]);JSM.AddPolygonToBody(a,[18,42,33,57,24,48]);JSM.AddPolygonToBody(a,[19,51,27,59,35,43]);return a};
JSM.GenerateRhombicosidodecahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2,c=Math.pow(b,2),d=Math.pow(b,3),e=2*b,f=2+b;JSM.AddVertexToBody(a,1,1,+d);JSM.AddVertexToBody(a,1,1,-d);JSM.AddVertexToBody(a,1,-1,+d);JSM.AddVertexToBody(a,-1,1,+d);JSM.AddVertexToBody(a,1,-1,-d);JSM.AddVertexToBody(a,-1,1,-d);JSM.AddVertexToBody(a,-1,-1,+d);JSM.AddVertexToBody(a,-1,-1,-d);JSM.AddVertexToBody(a,+d,1,1);JSM.AddVertexToBody(a,+d,1,-1);JSM.AddVertexToBody(a,+d,-1,1);JSM.AddVertexToBody(a,-d,1,1);JSM.AddVertexToBody(a,
+d,-1,-1);JSM.AddVertexToBody(a,-d,1,-1);JSM.AddVertexToBody(a,-d,-1,1);JSM.AddVertexToBody(a,-d,-1,-1);JSM.AddVertexToBody(a,1,+d,1);JSM.AddVertexToBody(a,1,+d,-1);JSM.AddVertexToBody(a,1,-d,1);JSM.AddVertexToBody(a,-1,+d,1);JSM.AddVertexToBody(a,1,-d,-1);JSM.AddVertexToBody(a,-1,+d,-1);JSM.AddVertexToBody(a,-1,-d,1);JSM.AddVertexToBody(a,-1,-d,-1);JSM.AddVertexToBody(a,+c,+b,+e);JSM.AddVertexToBody(a,+c,+b,-e);JSM.AddVertexToBody(a,+c,-b,+e);JSM.AddVertexToBody(a,-c,+b,+e);JSM.AddVertexToBody(a,
+c,-b,-e);JSM.AddVertexToBody(a,-c,+b,-e);JSM.AddVertexToBody(a,-c,-b,+e);JSM.AddVertexToBody(a,-c,-b,-e);JSM.AddVertexToBody(a,+e,+c,+b);JSM.AddVertexToBody(a,+e,+c,-b);JSM.AddVertexToBody(a,+e,-c,+b);JSM.AddVertexToBody(a,-e,+c,+b);JSM.AddVertexToBody(a,+e,-c,-b);JSM.AddVertexToBody(a,-e,+c,-b);JSM.AddVertexToBody(a,-e,-c,+b);JSM.AddVertexToBody(a,-e,-c,-b);JSM.AddVertexToBody(a,+b,+e,+c);JSM.AddVertexToBody(a,+b,+e,-c);JSM.AddVertexToBody(a,+b,-e,+c);JSM.AddVertexToBody(a,-b,+e,+c);JSM.AddVertexToBody(a,
+b,-e,-c);JSM.AddVertexToBody(a,-b,+e,-c);JSM.AddVertexToBody(a,-b,-e,+c);JSM.AddVertexToBody(a,-b,-e,-c);JSM.AddVertexToBody(a,+f,0,+c);JSM.AddVertexToBody(a,+f,0,-c);JSM.AddVertexToBody(a,-f,0,+c);JSM.AddVertexToBody(a,-f,0,-c);JSM.AddVertexToBody(a,+c,+f,0);JSM.AddVertexToBody(a,-c,+f,0);JSM.AddVertexToBody(a,+c,-f,0);JSM.AddVertexToBody(a,-c,-f,0);JSM.AddVertexToBody(a,0,+c,+f);JSM.AddVertexToBody(a,0,-c,+f);JSM.AddVertexToBody(a,0,+c,-f);JSM.AddVertexToBody(a,0,-c,-f);JSM.AddPolygonToBody(a,
[0,56,3]);JSM.AddPolygonToBody(a,[1,5,58]);JSM.AddPolygonToBody(a,[2,6,57]);JSM.AddPolygonToBody(a,[4,59,7]);JSM.AddPolygonToBody(a,[8,48,10]);JSM.AddPolygonToBody(a,[9,12,49]);JSM.AddPolygonToBody(a,[11,14,50]);JSM.AddPolygonToBody(a,[13,51,15]);JSM.AddPolygonToBody(a,[16,52,17]);JSM.AddPolygonToBody(a,[18,20,54]);JSM.AddPolygonToBody(a,[19,21,53]);JSM.AddPolygonToBody(a,[22,55,23]);JSM.AddPolygonToBody(a,[24,32,40]);JSM.AddPolygonToBody(a,[25,41,33]);JSM.AddPolygonToBody(a,[26,42,34]);JSM.AddPolygonToBody(a,
[27,43,35]);JSM.AddPolygonToBody(a,[28,36,44]);JSM.AddPolygonToBody(a,[29,37,45]);JSM.AddPolygonToBody(a,[30,38,46]);JSM.AddPolygonToBody(a,[31,47,39]);JSM.AddPolygonToBody(a,[0,3,6,2]);JSM.AddPolygonToBody(a,[0,24,40,56]);JSM.AddPolygonToBody(a,[1,4,7,5]);JSM.AddPolygonToBody(a,[1,58,41,25]);JSM.AddPolygonToBody(a,[2,57,42,26]);JSM.AddPolygonToBody(a,[3,56,43,27]);JSM.AddPolygonToBody(a,[4,28,44,59]);JSM.AddPolygonToBody(a,[5,29,45,58]);JSM.AddPolygonToBody(a,[6,30,46,57]);JSM.AddPolygonToBody(a,
[7,59,47,31]);JSM.AddPolygonToBody(a,[8,10,12,9]);JSM.AddPolygonToBody(a,[8,32,24,48]);JSM.AddPolygonToBody(a,[9,49,25,33]);JSM.AddPolygonToBody(a,[10,48,26,34]);JSM.AddPolygonToBody(a,[11,13,15,14]);JSM.AddPolygonToBody(a,[11,50,27,35]);JSM.AddPolygonToBody(a,[12,36,28,49]);JSM.AddPolygonToBody(a,[13,37,29,51]);JSM.AddPolygonToBody(a,[14,38,30,50]);JSM.AddPolygonToBody(a,[15,51,31,39]);JSM.AddPolygonToBody(a,[16,17,21,19]);JSM.AddPolygonToBody(a,[16,40,32,52]);JSM.AddPolygonToBody(a,[17,52,33,41]);
JSM.AddPolygonToBody(a,[18,22,23,20]);JSM.AddPolygonToBody(a,[18,54,34,42]);JSM.AddPolygonToBody(a,[19,53,35,43]);JSM.AddPolygonToBody(a,[20,44,36,54]);JSM.AddPolygonToBody(a,[21,45,37,53]);JSM.AddPolygonToBody(a,[22,46,38,55]);JSM.AddPolygonToBody(a,[23,55,39,47]);JSM.AddPolygonToBody(a,[0,2,26,48,24]);JSM.AddPolygonToBody(a,[1,25,49,28,4]);JSM.AddPolygonToBody(a,[3,27,50,30,6]);JSM.AddPolygonToBody(a,[5,7,31,51,29]);JSM.AddPolygonToBody(a,[8,9,33,52,32]);JSM.AddPolygonToBody(a,[10,34,54,36,12]);
JSM.AddPolygonToBody(a,[11,35,53,37,13]);JSM.AddPolygonToBody(a,[14,15,39,55,38]);JSM.AddPolygonToBody(a,[16,19,43,56,40]);JSM.AddPolygonToBody(a,[17,41,58,45,21]);JSM.AddPolygonToBody(a,[18,42,57,46,22]);JSM.AddPolygonToBody(a,[20,23,47,59,44]);return a};
JSM.GenerateTruncatedIcosidodecahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2,c=1/b,d=3+b,e=2/b,f=1+2*b,g=Math.pow(b,2),h=-1+3*b,l=-1+2*b,k=2+b,m=2*b;JSM.AddVertexToBody(a,+c,+c,+d);JSM.AddVertexToBody(a,+c,+c,-d);JSM.AddVertexToBody(a,+c,-c,+d);JSM.AddVertexToBody(a,-c,+c,+d);JSM.AddVertexToBody(a,+c,-c,-d);JSM.AddVertexToBody(a,-c,+c,-d);JSM.AddVertexToBody(a,-c,-c,+d);JSM.AddVertexToBody(a,-c,-c,-d);JSM.AddVertexToBody(a,+c,+d,+c);JSM.AddVertexToBody(a,+c,-d,+c);JSM.AddVertexToBody(a,
-c,+d,+c);JSM.AddVertexToBody(a,+c,+d,-c);JSM.AddVertexToBody(a,-c,-d,+c);JSM.AddVertexToBody(a,+c,-d,-c);JSM.AddVertexToBody(a,-c,+d,-c);JSM.AddVertexToBody(a,-c,-d,-c);JSM.AddVertexToBody(a,+d,+c,+c);JSM.AddVertexToBody(a,-d,+c,+c);JSM.AddVertexToBody(a,+d,+c,-c);JSM.AddVertexToBody(a,+d,-c,+c);JSM.AddVertexToBody(a,-d,+c,-c);JSM.AddVertexToBody(a,-d,-c,+c);JSM.AddVertexToBody(a,+d,-c,-c);JSM.AddVertexToBody(a,-d,-c,-c);JSM.AddVertexToBody(a,+e,+b,+f);JSM.AddVertexToBody(a,+e,+b,-f);JSM.AddVertexToBody(a,
+e,-b,+f);JSM.AddVertexToBody(a,-e,+b,+f);JSM.AddVertexToBody(a,+e,-b,-f);JSM.AddVertexToBody(a,-e,+b,-f);JSM.AddVertexToBody(a,-e,-b,+f);JSM.AddVertexToBody(a,-e,-b,-f);JSM.AddVertexToBody(a,+b,+f,+e);JSM.AddVertexToBody(a,+b,-f,+e);JSM.AddVertexToBody(a,-b,+f,+e);JSM.AddVertexToBody(a,+b,+f,-e);JSM.AddVertexToBody(a,-b,-f,+e);JSM.AddVertexToBody(a,+b,-f,-e);JSM.AddVertexToBody(a,-b,+f,-e);JSM.AddVertexToBody(a,-b,-f,-e);JSM.AddVertexToBody(a,+f,+e,+b);JSM.AddVertexToBody(a,-f,+e,+b);JSM.AddVertexToBody(a,
+f,+e,-b);JSM.AddVertexToBody(a,+f,-e,+b);JSM.AddVertexToBody(a,-f,+e,-b);JSM.AddVertexToBody(a,-f,-e,+b);JSM.AddVertexToBody(a,+f,-e,-b);JSM.AddVertexToBody(a,-f,-e,-b);JSM.AddVertexToBody(a,+c,+g,+h);JSM.AddVertexToBody(a,+c,+g,-h);JSM.AddVertexToBody(a,+c,-g,+h);JSM.AddVertexToBody(a,-c,+g,+h);JSM.AddVertexToBody(a,+c,-g,-h);JSM.AddVertexToBody(a,-c,+g,-h);JSM.AddVertexToBody(a,-c,-g,+h);JSM.AddVertexToBody(a,-c,-g,-h);JSM.AddVertexToBody(a,+g,+h,+c);JSM.AddVertexToBody(a,+g,-h,+c);JSM.AddVertexToBody(a,
-g,+h,+c);JSM.AddVertexToBody(a,+g,+h,-c);JSM.AddVertexToBody(a,-g,-h,+c);JSM.AddVertexToBody(a,+g,-h,-c);JSM.AddVertexToBody(a,-g,+h,-c);JSM.AddVertexToBody(a,-g,-h,-c);JSM.AddVertexToBody(a,+h,+c,+g);JSM.AddVertexToBody(a,-h,+c,+g);JSM.AddVertexToBody(a,+h,+c,-g);JSM.AddVertexToBody(a,+h,-c,+g);JSM.AddVertexToBody(a,-h,+c,-g);JSM.AddVertexToBody(a,-h,-c,+g);JSM.AddVertexToBody(a,+h,-c,-g);JSM.AddVertexToBody(a,-h,-c,-g);JSM.AddVertexToBody(a,+l,2,+k);JSM.AddVertexToBody(a,+l,2,-k);JSM.AddVertexToBody(a,
+l,-2,+k);JSM.AddVertexToBody(a,-l,2,+k);JSM.AddVertexToBody(a,+l,-2,-k);JSM.AddVertexToBody(a,-l,2,-k);JSM.AddVertexToBody(a,-l,-2,+k);JSM.AddVertexToBody(a,-l,-2,-k);JSM.AddVertexToBody(a,2,+k,+l);JSM.AddVertexToBody(a,2,-k,+l);JSM.AddVertexToBody(a,-2,+k,+l);JSM.AddVertexToBody(a,2,+k,-l);JSM.AddVertexToBody(a,-2,-k,+l);JSM.AddVertexToBody(a,2,-k,-l);JSM.AddVertexToBody(a,-2,+k,-l);JSM.AddVertexToBody(a,-2,-k,-l);JSM.AddVertexToBody(a,+k,+l,2);JSM.AddVertexToBody(a,-k,+l,2);JSM.AddVertexToBody(a,
+k,+l,-2);JSM.AddVertexToBody(a,+k,-l,2);JSM.AddVertexToBody(a,-k,+l,-2);JSM.AddVertexToBody(a,-k,-l,2);JSM.AddVertexToBody(a,+k,-l,-2);JSM.AddVertexToBody(a,-k,-l,-2);JSM.AddVertexToBody(a,+b,3,+m);JSM.AddVertexToBody(a,+b,3,-m);JSM.AddVertexToBody(a,+b,-3,+m);JSM.AddVertexToBody(a,-b,3,+m);JSM.AddVertexToBody(a,+b,-3,-m);JSM.AddVertexToBody(a,-b,3,-m);JSM.AddVertexToBody(a,-b,-3,+m);JSM.AddVertexToBody(a,-b,-3,-m);JSM.AddVertexToBody(a,3,+m,+b);JSM.AddVertexToBody(a,3,-m,+b);JSM.AddVertexToBody(a,
-3,+m,+b);JSM.AddVertexToBody(a,3,+m,-b);JSM.AddVertexToBody(a,-3,-m,+b);JSM.AddVertexToBody(a,3,-m,-b);JSM.AddVertexToBody(a,-3,+m,-b);JSM.AddVertexToBody(a,-3,-m,-b);JSM.AddVertexToBody(a,+m,+b,3);JSM.AddVertexToBody(a,-m,+b,3);JSM.AddVertexToBody(a,+m,+b,-3);JSM.AddVertexToBody(a,+m,-b,3);JSM.AddVertexToBody(a,-m,+b,-3);JSM.AddVertexToBody(a,-m,-b,3);JSM.AddVertexToBody(a,+m,-b,-3);JSM.AddVertexToBody(a,-m,-b,-3);JSM.AddPolygonToBody(a,[0,3,6,2]);JSM.AddPolygonToBody(a,[1,4,7,5]);JSM.AddPolygonToBody(a,
[8,11,14,10]);JSM.AddPolygonToBody(a,[9,12,15,13]);JSM.AddPolygonToBody(a,[16,19,22,18]);JSM.AddPolygonToBody(a,[17,20,23,21]);JSM.AddPolygonToBody(a,[24,72,96,48]);JSM.AddPolygonToBody(a,[25,49,97,73]);JSM.AddPolygonToBody(a,[26,50,98,74]);JSM.AddPolygonToBody(a,[27,51,99,75]);JSM.AddPolygonToBody(a,[28,76,100,52]);JSM.AddPolygonToBody(a,[29,77,101,53]);JSM.AddPolygonToBody(a,[30,78,102,54]);JSM.AddPolygonToBody(a,[31,55,103,79]);JSM.AddPolygonToBody(a,[32,80,104,56]);JSM.AddPolygonToBody(a,[33,
57,105,81]);JSM.AddPolygonToBody(a,[34,58,106,82]);JSM.AddPolygonToBody(a,[35,59,107,83]);JSM.AddPolygonToBody(a,[36,84,108,60]);JSM.AddPolygonToBody(a,[37,85,109,61]);JSM.AddPolygonToBody(a,[38,86,110,62]);JSM.AddPolygonToBody(a,[39,63,111,87]);JSM.AddPolygonToBody(a,[40,88,112,64]);JSM.AddPolygonToBody(a,[41,65,113,89]);JSM.AddPolygonToBody(a,[42,66,114,90]);JSM.AddPolygonToBody(a,[43,67,115,91]);JSM.AddPolygonToBody(a,[44,92,116,68]);JSM.AddPolygonToBody(a,[45,93,117,69]);JSM.AddPolygonToBody(a,
[46,94,118,70]);JSM.AddPolygonToBody(a,[47,71,119,95]);JSM.AddPolygonToBody(a,[0,24,48,51,27,3]);JSM.AddPolygonToBody(a,[1,5,29,53,49,25]);JSM.AddPolygonToBody(a,[2,6,30,54,50,26]);JSM.AddPolygonToBody(a,[4,28,52,55,31,7]);JSM.AddPolygonToBody(a,[8,32,56,59,35,11]);JSM.AddPolygonToBody(a,[9,13,37,61,57,33]);JSM.AddPolygonToBody(a,[10,14,38,62,58,34]);JSM.AddPolygonToBody(a,[12,36,60,63,39,15]);JSM.AddPolygonToBody(a,[16,40,64,67,43,19]);JSM.AddPolygonToBody(a,[17,21,45,69,65,41]);JSM.AddPolygonToBody(a,
[18,22,46,70,66,42]);JSM.AddPolygonToBody(a,[20,44,68,71,47,23]);JSM.AddPolygonToBody(a,[72,112,88,104,80,96]);JSM.AddPolygonToBody(a,[73,97,83,107,90,114]);JSM.AddPolygonToBody(a,[74,98,81,105,91,115]);JSM.AddPolygonToBody(a,[75,99,82,106,89,113]);JSM.AddPolygonToBody(a,[76,118,94,109,85,100]);JSM.AddPolygonToBody(a,[78,117,93,108,84,102]);JSM.AddPolygonToBody(a,[79,103,87,111,95,119]);JSM.AddPolygonToBody(a,[86,101,77,116,92,110]);JSM.AddPolygonToBody(a,[0,2,26,74,115,67,64,112,72,24]);JSM.AddPolygonToBody(a,
[1,25,73,114,66,70,118,76,28,4]);JSM.AddPolygonToBody(a,[3,27,75,113,65,69,117,78,30,6]);JSM.AddPolygonToBody(a,[5,7,31,79,119,71,68,116,77,29]);JSM.AddPolygonToBody(a,[8,10,34,82,99,51,48,96,80,32]);JSM.AddPolygonToBody(a,[9,33,81,98,50,54,102,84,36,12]);JSM.AddPolygonToBody(a,[11,35,83,97,49,53,101,86,38,14]);JSM.AddPolygonToBody(a,[13,15,39,87,103,55,52,100,85,37]);JSM.AddPolygonToBody(a,[16,18,42,90,107,59,56,104,88,40]);JSM.AddPolygonToBody(a,[17,41,89,106,58,62,110,92,44,20]);JSM.AddPolygonToBody(a,
[19,43,91,105,57,61,109,94,46,22]);JSM.AddPolygonToBody(a,[21,23,47,95,111,63,60,108,93,45]);return a};
JSM.GenerateSnubDodecahedron=function(){var a=new JSM.Body,b=(1+Math.sqrt(5))/2,c=Math.pow(b/2+0.5*Math.sqrt(b-5/27),1/3)+Math.pow(b/2-0.5*Math.sqrt(b-5/27),1/3),d=c-1/c,e=c*b+Math.pow(b,2)+b/c,c=2*d,f=2*e,g=d+e/b+b,h=-(d*b)+e+1/b,l=d/b+e*b-1,k=-(d/b)+e*b+1,m=-d+e/b-b,n=d*b+e-1/b,p=-(d/b)+e*b-1,q=d-e/b-b,r=d*b+e+1/b,s=d+e/b-b,x=d*b-e+1/b,b=d/b+e*b+1;JSM.AddVertexToBody(a,+c,2,-f);JSM.AddVertexToBody(a,+c,-2,+f);JSM.AddVertexToBody(a,-c,2,+f);JSM.AddVertexToBody(a,-c,-2,-f);JSM.AddVertexToBody(a,2,
-f,+c);JSM.AddVertexToBody(a,-2,+f,+c);JSM.AddVertexToBody(a,2,+f,-c);JSM.AddVertexToBody(a,-2,-f,-c);JSM.AddVertexToBody(a,-f,+c,2);JSM.AddVertexToBody(a,+f,+c,-2);JSM.AddVertexToBody(a,+f,-c,2);JSM.AddVertexToBody(a,-f,-c,-2);JSM.AddVertexToBody(a,+g,+h,-l);JSM.AddVertexToBody(a,+g,-h,+l);JSM.AddVertexToBody(a,-g,+h,+l);JSM.AddVertexToBody(a,-g,-h,-l);JSM.AddVertexToBody(a,+h,-l,+g);JSM.AddVertexToBody(a,-h,+l,+g);JSM.AddVertexToBody(a,+h,+l,-g);JSM.AddVertexToBody(a,-h,-l,-g);JSM.AddVertexToBody(a,
-l,+g,+h);JSM.AddVertexToBody(a,+l,+g,-h);JSM.AddVertexToBody(a,+l,-g,+h);JSM.AddVertexToBody(a,-l,-g,-h);JSM.AddVertexToBody(a,+k,+m,-n);JSM.AddVertexToBody(a,+k,-m,+n);JSM.AddVertexToBody(a,-k,+m,+n);JSM.AddVertexToBody(a,-k,-m,-n);JSM.AddVertexToBody(a,+m,-n,+k);JSM.AddVertexToBody(a,-m,+n,+k);JSM.AddVertexToBody(a,+m,+n,-k);JSM.AddVertexToBody(a,-m,-n,-k);JSM.AddVertexToBody(a,-n,+k,+m);JSM.AddVertexToBody(a,+n,+k,-m);JSM.AddVertexToBody(a,+n,-k,+m);JSM.AddVertexToBody(a,-n,-k,-m);JSM.AddVertexToBody(a,
+p,+q,-r);JSM.AddVertexToBody(a,+p,-q,+r);JSM.AddVertexToBody(a,-p,+q,+r);JSM.AddVertexToBody(a,-p,-q,-r);JSM.AddVertexToBody(a,+q,-r,+p);JSM.AddVertexToBody(a,-q,+r,+p);JSM.AddVertexToBody(a,+q,+r,-p);JSM.AddVertexToBody(a,-q,-r,-p);JSM.AddVertexToBody(a,-r,+p,+q);JSM.AddVertexToBody(a,+r,+p,-q);JSM.AddVertexToBody(a,+r,-p,+q);JSM.AddVertexToBody(a,-r,-p,-q);JSM.AddVertexToBody(a,+s,+x,-b);JSM.AddVertexToBody(a,+s,-x,+b);JSM.AddVertexToBody(a,-s,+x,+b);JSM.AddVertexToBody(a,-s,-x,-b);JSM.AddVertexToBody(a,
+x,-b,+s);JSM.AddVertexToBody(a,-x,+b,+s);JSM.AddVertexToBody(a,+x,+b,-s);JSM.AddVertexToBody(a,-x,-b,-s);JSM.AddVertexToBody(a,-b,+s,+x);JSM.AddVertexToBody(a,+b,+s,-x);JSM.AddVertexToBody(a,+b,-s,+x);JSM.AddVertexToBody(a,-b,-s,-x);JSM.AddPolygonToBody(a,[0,3,51]);JSM.AddPolygonToBody(a,[0,30,12]);JSM.AddPolygonToBody(a,[0,48,3]);JSM.AddPolygonToBody(a,[0,51,30]);JSM.AddPolygonToBody(a,[1,2,50]);JSM.AddPolygonToBody(a,[1,28,13]);JSM.AddPolygonToBody(a,[1,49,2]);JSM.AddPolygonToBody(a,[1,50,28]);
JSM.AddPolygonToBody(a,[2,29,14]);JSM.AddPolygonToBody(a,[2,49,29]);JSM.AddPolygonToBody(a,[3,31,15]);JSM.AddPolygonToBody(a,[3,48,31]);JSM.AddPolygonToBody(a,[4,7,55]);JSM.AddPolygonToBody(a,[4,34,16]);JSM.AddPolygonToBody(a,[4,52,7]);JSM.AddPolygonToBody(a,[4,55,34]);JSM.AddPolygonToBody(a,[5,6,54]);JSM.AddPolygonToBody(a,[5,32,17]);JSM.AddPolygonToBody(a,[5,53,6]);JSM.AddPolygonToBody(a,[5,54,32]);JSM.AddPolygonToBody(a,[6,33,18]);JSM.AddPolygonToBody(a,[6,53,33]);JSM.AddPolygonToBody(a,[7,35,
19]);JSM.AddPolygonToBody(a,[7,52,35]);JSM.AddPolygonToBody(a,[8,11,59]);JSM.AddPolygonToBody(a,[8,26,20]);JSM.AddPolygonToBody(a,[8,56,11]);JSM.AddPolygonToBody(a,[8,59,26]);JSM.AddPolygonToBody(a,[9,10,58]);JSM.AddPolygonToBody(a,[9,24,21]);JSM.AddPolygonToBody(a,[9,57,10]);JSM.AddPolygonToBody(a,[9,58,24]);JSM.AddPolygonToBody(a,[10,25,22]);JSM.AddPolygonToBody(a,[10,57,25]);JSM.AddPolygonToBody(a,[11,27,23]);JSM.AddPolygonToBody(a,[11,56,27]);JSM.AddPolygonToBody(a,[12,18,21]);JSM.AddPolygonToBody(a,
[12,21,24]);JSM.AddPolygonToBody(a,[12,30,18]);JSM.AddPolygonToBody(a,[13,16,22]);JSM.AddPolygonToBody(a,[13,22,25]);JSM.AddPolygonToBody(a,[13,28,16]);JSM.AddPolygonToBody(a,[14,17,20]);JSM.AddPolygonToBody(a,[14,20,26]);JSM.AddPolygonToBody(a,[14,29,17]);JSM.AddPolygonToBody(a,[15,19,23]);JSM.AddPolygonToBody(a,[15,23,27]);JSM.AddPolygonToBody(a,[15,31,19]);JSM.AddPolygonToBody(a,[16,34,22]);JSM.AddPolygonToBody(a,[17,32,20]);JSM.AddPolygonToBody(a,[18,33,21]);JSM.AddPolygonToBody(a,[19,35,23]);
JSM.AddPolygonToBody(a,[24,58,36]);JSM.AddPolygonToBody(a,[25,57,37]);JSM.AddPolygonToBody(a,[26,59,38]);JSM.AddPolygonToBody(a,[27,56,39]);JSM.AddPolygonToBody(a,[28,50,40]);JSM.AddPolygonToBody(a,[29,49,41]);JSM.AddPolygonToBody(a,[30,51,42]);JSM.AddPolygonToBody(a,[31,48,43]);JSM.AddPolygonToBody(a,[32,54,44]);JSM.AddPolygonToBody(a,[33,53,45]);JSM.AddPolygonToBody(a,[34,55,46]);JSM.AddPolygonToBody(a,[35,52,47]);JSM.AddPolygonToBody(a,[36,43,48]);JSM.AddPolygonToBody(a,[36,46,43]);JSM.AddPolygonToBody(a,
[36,58,46]);JSM.AddPolygonToBody(a,[37,41,49]);JSM.AddPolygonToBody(a,[37,45,41]);JSM.AddPolygonToBody(a,[37,57,45]);JSM.AddPolygonToBody(a,[38,40,50]);JSM.AddPolygonToBody(a,[38,47,40]);JSM.AddPolygonToBody(a,[38,59,47]);JSM.AddPolygonToBody(a,[39,42,51]);JSM.AddPolygonToBody(a,[39,44,42]);JSM.AddPolygonToBody(a,[39,56,44]);JSM.AddPolygonToBody(a,[40,47,52]);JSM.AddPolygonToBody(a,[41,45,53]);JSM.AddPolygonToBody(a,[42,44,54]);JSM.AddPolygonToBody(a,[43,46,55]);JSM.AddPolygonToBody(a,[0,12,24,36,
48]);JSM.AddPolygonToBody(a,[1,13,25,37,49]);JSM.AddPolygonToBody(a,[2,14,26,38,50]);JSM.AddPolygonToBody(a,[3,15,27,39,51]);JSM.AddPolygonToBody(a,[4,16,28,40,52]);JSM.AddPolygonToBody(a,[5,17,29,41,53]);JSM.AddPolygonToBody(a,[6,18,30,42,54]);JSM.AddPolygonToBody(a,[7,19,31,43,55]);JSM.AddPolygonToBody(a,[8,20,32,44,56]);JSM.AddPolygonToBody(a,[9,21,33,45,57]);JSM.AddPolygonToBody(a,[10,22,34,46,58]);JSM.AddPolygonToBody(a,[11,23,35,47,59]);return a};
JSM.AddCumulatedPolygonToBody=function(a,b,c){var d=new JSM.Coord(0,0,0),e=new JSM.Vector(0,0,0),f=d,g=[],h;for(h=0;h<b.length;h++)g.push(a.GetVertexPosition(b[h]));h=JSM.CalculateCentroid(g);g=JSM.CalculateNormal(g);f.Set(h.x,h.y,h.z);e.Set(g.x,g.y,g.z);d=JSM.CoordOffset(d,e,c);c=a.VertexCount();JSM.AddVertexToBody(a,d.x,d.y,d.z);d=b.length;for(e=0;e<d;e++)f=b[e],g=b[e<d-1?e+1:0],JSM.AddPolygonToBody(a,[f,g,c])};
JSM.GenerateCumulatedTetrahedron=function(a){var b=new JSM.Body;b.AddVertex(new JSM.BodyVertex(new JSM.Coord(1,1,1)));b.AddVertex(new JSM.BodyVertex(new JSM.Coord(-1,-1,1)));b.AddVertex(new JSM.BodyVertex(new JSM.Coord(-1,1,-1)));b.AddVertex(new JSM.BodyVertex(new JSM.Coord(1,-1,-1)));a*=2*Math.sqrt(2);JSM.AddCumulatedPolygonToBody(b,[0,1,3],a);JSM.AddCumulatedPolygonToBody(b,[0,2,1],a);JSM.AddCumulatedPolygonToBody(b,[0,3,2],a);JSM.AddCumulatedPolygonToBody(b,[1,2,3],a);return b};
JSM.GenerateCumulatedHexahedron=function(a){var b=new JSM.Body;JSM.AddVertexToBody(b,1,1,1);JSM.AddVertexToBody(b,1,1,-1);JSM.AddVertexToBody(b,1,-1,1);JSM.AddVertexToBody(b,-1,1,1);JSM.AddVertexToBody(b,1,-1,-1);JSM.AddVertexToBody(b,-1,1,-1);JSM.AddVertexToBody(b,-1,-1,1);JSM.AddVertexToBody(b,-1,-1,-1);a*=2;JSM.AddCumulatedPolygonToBody(b,[0,1,5,3],a);JSM.AddCumulatedPolygonToBody(b,[0,2,4,1],a);JSM.AddCumulatedPolygonToBody(b,[0,3,6,2],a);JSM.AddCumulatedPolygonToBody(b,[1,4,7,5],a);JSM.AddCumulatedPolygonToBody(b,
[2,6,7,4],a);JSM.AddCumulatedPolygonToBody(b,[3,5,7,6],a);return b};
JSM.GenerateCumulatedOctahedron=function(a){var b=new JSM.Body;JSM.AddVertexToBody(b,1,0,0);JSM.AddVertexToBody(b,-1,0,0);JSM.AddVertexToBody(b,0,1,0);JSM.AddVertexToBody(b,0,-1,0);JSM.AddVertexToBody(b,0,0,1);JSM.AddVertexToBody(b,0,0,-1);a*=Math.sqrt(2);JSM.AddCumulatedPolygonToBody(b,[0,2,4],a);JSM.AddCumulatedPolygonToBody(b,[0,3,5],a);JSM.AddCumulatedPolygonToBody(b,[0,4,3],a);JSM.AddCumulatedPolygonToBody(b,[0,5,2],a);JSM.AddCumulatedPolygonToBody(b,[1,2,5],a);JSM.AddCumulatedPolygonToBody(b,
[1,3,4],a);JSM.AddCumulatedPolygonToBody(b,[1,4,2],a);JSM.AddCumulatedPolygonToBody(b,[1,5,3],a);return b};
JSM.GenerateCumulatedDodecahedron=function(a){var b=new JSM.Body,c=(1+Math.sqrt(5))/2,d=1/c;JSM.AddVertexToBody(b,1,1,1);JSM.AddVertexToBody(b,1,1,-1);JSM.AddVertexToBody(b,1,-1,1);JSM.AddVertexToBody(b,-1,1,1);JSM.AddVertexToBody(b,1,-1,-1);JSM.AddVertexToBody(b,-1,1,-1);JSM.AddVertexToBody(b,-1,-1,1);JSM.AddVertexToBody(b,-1,-1,-1);JSM.AddVertexToBody(b,0,+d,+c);JSM.AddVertexToBody(b,0,+d,-c);JSM.AddVertexToBody(b,0,-d,+c);JSM.AddVertexToBody(b,0,-d,-c);JSM.AddVertexToBody(b,+d,+c,0);JSM.AddVertexToBody(b,
+d,-c,0);JSM.AddVertexToBody(b,-d,+c,0);JSM.AddVertexToBody(b,-d,-c,0);JSM.AddVertexToBody(b,+c,0,+d);JSM.AddVertexToBody(b,-c,0,+d);JSM.AddVertexToBody(b,+c,0,-d);JSM.AddVertexToBody(b,-c,0,-d);a*=Math.sqrt(5)-1;JSM.AddCumulatedPolygonToBody(b,[0,8,10,2,16],a);JSM.AddCumulatedPolygonToBody(b,[0,16,18,1,12],a);JSM.AddCumulatedPolygonToBody(b,[0,12,14,3,8],a);JSM.AddCumulatedPolygonToBody(b,[1,9,5,14,12],a);JSM.AddCumulatedPolygonToBody(b,[1,18,4,11,9],a);JSM.AddCumulatedPolygonToBody(b,[2,10,6,15,
13],a);JSM.AddCumulatedPolygonToBody(b,[2,13,4,18,16],a);JSM.AddCumulatedPolygonToBody(b,[3,14,5,19,17],a);JSM.AddCumulatedPolygonToBody(b,[3,17,6,10,8],a);JSM.AddCumulatedPolygonToBody(b,[4,13,15,7,11],a);JSM.AddCumulatedPolygonToBody(b,[5,9,11,7,19],a);JSM.AddCumulatedPolygonToBody(b,[6,17,19,7,15],a);return b};
JSM.GenerateCumulatedIcosahedron=function(a){var b=new JSM.Body,c=(1+Math.sqrt(5))/2;JSM.AddVertexToBody(b,0,1,+c);JSM.AddVertexToBody(b,0,1,-c);JSM.AddVertexToBody(b,0,-1,+c);JSM.AddVertexToBody(b,0,-1,-c);JSM.AddVertexToBody(b,1,+c,0);JSM.AddVertexToBody(b,1,-c,0);JSM.AddVertexToBody(b,-1,+c,0);JSM.AddVertexToBody(b,-1,-c,0);JSM.AddVertexToBody(b,+c,0,1);JSM.AddVertexToBody(b,-c,0,1);JSM.AddVertexToBody(b,+c,0,-1);JSM.AddVertexToBody(b,-c,0,-1);a*=2;JSM.AddCumulatedPolygonToBody(b,[0,2,8],a);JSM.AddCumulatedPolygonToBody(b,
[0,4,6],a);JSM.AddCumulatedPolygonToBody(b,[0,6,9],a);JSM.AddCumulatedPolygonToBody(b,[0,8,4],a);JSM.AddCumulatedPolygonToBody(b,[0,9,2],a);JSM.AddCumulatedPolygonToBody(b,[1,3,11],a);JSM.AddCumulatedPolygonToBody(b,[1,4,10],a);JSM.AddCumulatedPolygonToBody(b,[1,6,4],a);JSM.AddCumulatedPolygonToBody(b,[1,10,3],a);JSM.AddCumulatedPolygonToBody(b,[1,11,6],a);JSM.AddCumulatedPolygonToBody(b,[2,5,8],a);JSM.AddCumulatedPolygonToBody(b,[2,7,5],a);JSM.AddCumulatedPolygonToBody(b,[2,9,7],a);JSM.AddCumulatedPolygonToBody(b,
[3,5,7],a);JSM.AddCumulatedPolygonToBody(b,[3,7,11],a);JSM.AddCumulatedPolygonToBody(b,[3,10,5],a);JSM.AddCumulatedPolygonToBody(b,[4,8,10],a);JSM.AddCumulatedPolygonToBody(b,[6,11,9],a);JSM.AddCumulatedPolygonToBody(b,[5,10,8],a);JSM.AddCumulatedPolygonToBody(b,[7,9,11],a);return b};JSM.GenerateTetrakisHexahedron=function(){return JSM.GenerateCumulatedHexahedron(0.25)};JSM.GenerateRhombicDodecahedron=function(){return JSM.GenerateCumulatedHexahedron(0.5)};
JSM.GeneratePentakisDodecahedron=function(){var a=Math.sqrt((65+22*Math.sqrt(5))/5)/19;return JSM.GenerateCumulatedDodecahedron(a)};JSM.GenerateSmallStellatedDodecahedron=function(){var a=Math.sqrt((5+2*Math.sqrt(5))/5);return JSM.GenerateCumulatedDodecahedron(a)};JSM.GenerateGreatDodecahedron=function(){var a=Math.sqrt(3)*(Math.sqrt(5)-3)/6;return JSM.GenerateCumulatedIcosahedron(a)};JSM.GenerateSmallTriambicIcosahedron=function(){var a=Math.sqrt(15)/15;return JSM.GenerateCumulatedIcosahedron(a)};
JSM.GenerateGreatStellatedDodecahedron=function(){var a=Math.sqrt(3)*(3+Math.sqrt(5))/6;return JSM.GenerateCumulatedIcosahedron(a)};JSM.GenerateSmallTriakisOctahedron=function(){var a=Math.sqrt(3)-2*Math.sqrt(6)/3;return JSM.GenerateCumulatedOctahedron(a)};JSM.GenerateStellaOctangula=function(){var a=Math.sqrt(6)/3;return JSM.GenerateCumulatedOctahedron(a)};JSM.GenerateTriakisTetrahedron=function(){var a=Math.sqrt(6)/15;return JSM.GenerateCumulatedTetrahedron(a)};
JSM.LegoDimensions=function(){this.legoWidth=0.78;this.legoSmallHeight=0.32;this.legoLargeHeight=0.96;this.legoWallWidth=0.16;this.legoCylinderWidth=0.5;this.legoCylinderHeight=0.17;this.legoBottomSmallCylinderWidth=0.3;this.legoBottomLargeCylinderWidth=0.6;this.legoBottomLargeCylinderWallWidth=0.1};
JSM.GenerateLegoBrick=function(a,b,c,d,e,f,g){function h(a,b){var c,d;for(c=0;c<a.VertexCount();c++)d=a.GetVertex(c),d.position=JSM.CoordAdd(d.position,b)}var l=new JSM.LegoDimensions,k=new JSM.Vector(0,0,1),m=l.legoWidth,n=l.legoLargeHeight;c||(n=l.legoSmallHeight);c=l.legoWallWidth;var p=l.legoCylinderWidth,q=l.legoCylinderHeight,r=l.legoBottomSmallCylinderWidth,s=l.legoBottomLargeCylinderWidth,x=l.legoBottomLargeCylinderWallWidth,v=[];v.push(new JSM.Coord(0,0,0));v.push(new JSM.Coord(m*a,0,0));
v.push(new JSM.Coord(m*a,m*b,0));v.push(new JSM.Coord(0,m*b,0));var l=new JSM.Body,t=JSM.GeneratePrismShell(v,k,n-c,c,!0);l.Merge(t);for(t=0;4>t;t++)v[t].z=n-c;t=JSM.GeneratePrism(v,k,c,!0);l.Merge(t);if(d)for(t=0;t<a;t++)for(v=0;v<b;v++)d=new JSM.Coord(m*t+m/2,m*v+m/2,n+q/2),k=JSM.GenerateCylinder(p/2,q,f,!0,g),h(k,d),l.Merge(k);if(e)if(1===a&&1<b||1===b&&1<a){e=b;p=!0;a>b&&(e=a,p=!1);for(t=0;t<e-1;t++)d=p?new JSM.Coord(m/2,m*(t+1),(n-c)/2):new JSM.Coord(m*(t+1),m/2,(n-c)/2),k=JSM.GenerateCylinder(r/
2,n-c,f,!0,g),h(k,d),l.Merge(k)}else if(1<a&&1<b)for(t=0;t<a-1;t++)for(v=0;v<b-1;v++)d=new JSM.Coord(m*(t+1),m*(v+1),(n-c)/2),k=JSM.GenerateCylinderShell(s/2,n-c,x,f,!0,g),h(k,d),l.Merge(k);l.SetCubicTextureProjection(new JSM.Coord(0,0,0),new JSM.Coord(1,0,0),new JSM.Coord(0,1,0),new JSM.Coord(0,0,1));return l};
JSM.GenerateConvexHullBody=function(a){var b=new JSM.Body,c=JSM.ConvexHull3D(a),d={},e,f,g,h;for(e=0;e<c.length;e++){g=c[e];for(f=0;f<g.length;f++)h=g[f],h in d||(d[h]=b.VertexCount(),b.AddVertex(new JSM.BodyVertex(a[h])))}for(e=0;e<c.length;e++){g=c[e];a=[];for(f=0;f<g.length;f++)h=g[f],a.push(d[h]);b.AddPolygon(new JSM.BodyPolygon(a))}return b};
JSM.GenerateSuperShape=function(a,b,c,d,e,f,g,h,l,k,m,n,p,q){function r(a){var b=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z),c=Math.asin(a.z/b);a=Math.atan2(a.y,a.x);return[b,c,a]}function s(a,b,c,d,e,f,g){b=Math.abs(Math.cos(d*a/4)/b);a=Math.abs(Math.sin(d*a/4)/c);return Math.pow(Math.pow(b,f)+Math.pow(a,g),-1/e)}function x(p,q){var x=new JSM.Coord(0,0,0),t=s(p,g,h,l,k,m,n),r=s(q,a,b,c,d,e,f);x.x=r*Math.cos(q)*t*Math.cos(p);x.y=r*Math.sin(q)*t*Math.cos(p);x.z=t*Math.sin(p);return x}p=JSM.GenerateSphere(1,
p,q);var v,t;for(q=0;q<p.VertexCount();q++)v=p.GetVertex(q),t=v.position,t=r(t),t=x(t[1],t[2]),v.SetPosition(t);return p};
JSM.OrderPolygons=function(a,b,c){var d=[],e=[],f=[],g=[],h=[],l=[],k=[],m=a.PolygonCount(),n,p;for(n=0;n<m;n++){l.push(n);k.push([]);for(p=0;p<m;p++)k[n].push(null)}(function(){var k=JSM.VectorNormalize(JSM.CoordSub(c,b)),k=JSM.GetPlaneFromCoordAndDirection(b,k),l,m,n,p,t,y;for(l=0;l<a.PolygonCount();l++){t=JSM.Inf;y=-JSM.Inf;n=a.GetPolygon(l);for(m=0;m<n.VertexIndexCount();m++)p=a.GetVertexPosition(n.GetVertexIndex(m)),p=JSM.CoordPlaneDistance(p,k),JSM.IsLower(p,t)&&(t=p),JSM.IsGreater(p,y)&&(y=
p);d.push(t);e.push(y);m=a.GetPolygon(l);n=new JSM.Coord(0,0,0);y=t=void 0;for(t=0;t<m.VertexIndexCount();t++)y=a.GetVertexPosition(m.GetVertexIndex(t)),n=JSM.CoordAdd(n,y);m=n=JSM.VectorMultiply(n,1/m.VertexIndexCount());n=JSM.CoordPlaneDistance(m,k);f.push(m);g.push(n);n=JSM.CalculateBodyPolygonNormal(a,l);t=JSM.VectorNormalize(JSM.CoordSub(m,b));t=JSM.VectorDot(n,t);JSM.IsGreaterOrEqual(t,0)&&(n=JSM.VectorMultiply(n,-1));m=JSM.GetPlaneFromCoordAndDirection(m,n);h.push(m)}})();(function(){var a=
l.length,b,c;for(b=0;b<a-1;b++)for(c=0;c<a-b-1;c++){var d;d=l[c];var f=l[c+1];d=JSM.IsLower(e[d],e[f])?!0:JSM.IsEqual(e[d],e[f])&&JSM.IsLower(g[d],g[f])?!0:!1;if(d){d=l;var f=c+1,h=d[c];d[c]=d[f];d[f]=h}}})();(function(){var b=l.length,c,f;for(c=0;c<b-1;c++)for(f=0;f<b-c-1;f++){var g;g=l[f];var m=l[f+1];if(null!==k[g][m])g=k[g][m];else{var n;if(n=JSM.IsLowerOrEqual(d[g],e[m])){var p=m;n=h[g];for(var F=h[p],C=void 0,u=void 0,H=!0,z=a.GetPolygon(g),C=0;C<z.VertexIndexCount();C++)if(u=a.GetVertexPosition(z.GetVertexIndex(C)),
"CoordInFrontOfPlane"===JSM.CoordPlanePosition(u,F)){H=!1;break}if(H)n=!1;else{F=!0;p=a.GetPolygon(p);for(C=0;C<p.VertexIndexCount();C++)if(u=a.GetVertexPosition(p.GetVertexIndex(C)),"CoordAtBackOfPlane"===JSM.CoordPlanePosition(u,n)){F=!1;break}n=F?!1:!0}}g=n?k[g][m]=!0:k[g][m]=!1}g&&(g=l,m=f+1,n=g[f],g[f]=g[m],g[m]=n)}})();return l};JSM.CanvasDrawer=function(a){this.canvas=a;this.context=this.canvas.getContext("2d")};JSM.CanvasDrawer.prototype.GetWidth=function(){return this.canvas.width};
JSM.CanvasDrawer.prototype.GetHeight=function(){return this.canvas.height};JSM.CanvasDrawer.prototype.BeginPath=function(){this.context.beginPath()};JSM.CanvasDrawer.prototype.EndPath=function(){this.context.stroke()};JSM.CanvasDrawer.prototype.Clear=function(){this.context.clearRect(0,0,this.canvas.width,this.canvas.height);this.context.fillStyle="#ffffff";this.context.fillRect(0,0,this.canvas.width,this.canvas.height)};
JSM.CanvasDrawer.prototype.DrawLine=function(a,b){this.context.moveTo(a.x,this.canvas.height-a.y);this.context.lineTo(b.x,this.canvas.height-b.y)};
JSM.CanvasDrawer.prototype.DrawPolygon=function(a,b){var c=this.context,d=JSM.HexColorToRGBComponents(b);c.fillStyle="rgb("+d[0]+","+d[1]+","+d[2]+")";this.context.beginPath();for(var e,c=0;c<a.VertexCount();c++)d=a.GetVertex(c),0===c?this.context.moveTo(d.x,this.canvas.height-d.y):this.context.lineTo(d.x,this.canvas.height-d.y);this.context.closePath();this.context.fill();this.BeginPath();for(c=0;c<a.VertexCount();c++)d=a.GetVertex(c),e=a.GetVertex(c<a.VertexCount()-1?c+1:0),this.DrawLine(d,e);this.EndPath()};
JSM.SVGDrawer=function(a){this.svgObject=a;this.svgNameSpace="http://www.w3.org/2000/svg"};JSM.SVGDrawer.prototype.GetWidth=function(){return this.svgObject.getAttribute("width")};JSM.SVGDrawer.prototype.GetHeight=function(){return this.svgObject.getAttribute("height")};JSM.SVGDrawer.prototype.BeginPath=function(){};JSM.SVGDrawer.prototype.EndPath=function(){};JSM.SVGDrawer.prototype.Clear=function(){for(;this.svgObject.lastChild;)this.svgObject.removeChild(this.svgObject.lastChild)};
JSM.SVGDrawer.prototype.DrawLine=function(a,b){var c=document.createElementNS(this.svgNameSpace,"line"),d=this.GetHeight();c.setAttributeNS(null,"stroke","black");c.setAttributeNS(null,"x1",a.x);c.setAttributeNS(null,"y1",d-a.y);c.setAttributeNS(null,"x2",b.x);c.setAttributeNS(null,"y2",d-b.y);this.svgObject.appendChild(c)};
JSM.SVGDrawer.prototype.DrawPolygon=function(a,b){var c="",d=this.GetHeight(),e,f;for(e=0;e<a.VertexCount();e++)f=a.GetVertex(e),c=c+f.x+", "+(d-f.y),e<a.VertexCount()-1&&(c+=", ");d=document.createElementNS(this.svgNameSpace,"polygon");d.setAttributeNS(null,"points",c);d.setAttributeNS(null,"fill",function(a){a=JSM.HexColorToRGBComponents(a);return"rgb("+a[0]+","+a[1]+","+a[2]+")"}(b));d.setAttributeNS(null,"fill-opacity","1.0");d.setAttributeNS(null,"stroke","black");this.svgObject.appendChild(d)};
JSM.DrawProjectedBody=function(a,b,c,d,e,f){function g(b){var c=new JSM.Polygon2D,d,e,f;for(d=0;d<b.VertexIndexCount();d++)e=a.GetVertexPosition(b.GetVertexIndex(d)),f=JSM.Project(e,l,k,m,n*JSM.DegRad,p,q,r,s),e=f.x,f=f.y,c.AddVertex(e,f);return c}e&&f.Clear();e=f.GetWidth();var h=f.GetHeight(),l=c.eye,k=c.center,m=c.up,n=c.fieldOfView,p=e/h,q=c.nearClippingPlane,r=c.farClippingPlane,s=[0,0,e,h];if("HiddenLinePainter"==d){h=JSM.OrderPolygons(a,l,k);if(void 0===b||null===b)b=new JSM.Materials;for(c=
0;c<h.length;c++)e=a.GetPolygon(h[c]),d=g(e),e=e.GetMaterialIndex(),e=b.GetMaterial(e).diffuse,f.DrawPolygon(d,e)}else if("HiddenLineFrontFacing"==d){if(void 0===b||null===b)b=new JSM.Materials;for(c=0;c<a.PolygonCount();c++)e=a.GetPolygon(c),d=g(e),"CounterClockwise"==JSM.PolygonOrientation2D(d)&&(e=e.GetMaterialIndex(),e=b.GetMaterial(e).diffuse,f.DrawPolygon(d,e))}else if("Wireframe"==d){var x,v,t;f.BeginPath();var y=[];for(c=0;c<a.PolygonCount();c++){v=x=null;e=a.GetPolygon(c);h=e.VertexIndexCount();
for(b=0;b<=h;b++)t=e.GetVertexIndex(b%h),d=a.GetVertexPosition(t),d=JSM.Project(d,l,k,m,n*JSM.DegRad,p,q,r,s),null!==x&&(null!==v&&void 0===y[[v,t]])&&(f.DrawLine(x,d),y[[v,t]]=!0,y[[t,v]]=!0),v=t,x=d}f.EndPath()}return!0};
JSM.CatmullClarkSubdivisionOneIteration=function(a){var b=new JSM.Body,c=JSM.CalculateAdjacencyInfo(a);(function(){var d,e;for(d=0;d<c.verts.length;d++)e=a.GetVertex(d).position,b.AddVertex(new JSM.BodyVertex(new JSM.Coord(e.x,e.y,e.z)))})();var d=[];(function(){var e,g,h,l,k;for(e=0;e<c.pgons.length;e++){h=c.pgons[e];k=new JSM.Coord(0,0,0);for(g=0;g<h.verts.length;g++)l=a.GetVertex(h.verts[g]).position,k=JSM.CoordAdd(k,l);k=JSM.VectorMultiply(k,1/h.verts.length);d.push(b.AddVertex(new JSM.BodyVertex(k)))}})();
var e=[];(function(){var f,g,h,l,k;for(f=0;f<c.edges.length;f++){h=c.edges[f];l=new JSM.Coord(0,0,0);l=JSM.CoordAdd(l,JSM.VectorMultiply(a.GetVertex(h.vert1).position,0.25));l=JSM.CoordAdd(l,JSM.VectorMultiply(a.GetVertex(h.vert2).position,0.25));for(g=0;2>g;g++)k=0===g?h.pgon1:h.pgon2,-1===k&&(k=0===g?h.pgon2:h.pgon1),k=b.GetVertex(d[k]).position,l=JSM.CoordAdd(l,JSM.VectorMultiply(k,0.25));e.push(b.AddVertex(new JSM.BodyVertex(l)))}})();(function(){var e=[],g,h,l,k;for(l=0;l<c.edges.length;l++)g=
c.edges[l],h=JSM.MidCoord(a.GetVertex(g.vert1).position,a.GetVertex(g.vert2).position),e.push(h);var m,n,p;for(l=0;l<c.verts.length;l++){m=c.verts[l];p=new JSM.Coord(0,0,0);g=new JSM.Coord(0,0,0);n=1/m.pgons.length;for(k=0;k<m.pgons.length;k++)h=b.GetVertex(d[m.pgons[k]]).position,p=JSM.CoordAdd(p,JSM.VectorMultiply(h,n));n=1/m.edges.length;for(k=0;k<m.edges.length;k++)h=e[m.edges[k]],g=JSM.CoordAdd(g,JSM.VectorMultiply(h,n));m=m.edges.length;k=b.GetVertex(l).position;k.x=(p.x+2*g.x+(m-3)*k.x)/m;
k.y=(p.y+2*g.y+(m-3)*k.y)/m;k.z=(p.z+2*g.z+(m-3)*k.z)/m}})();(function(){var f,g,h,l,k,m,n,p;for(m=0;m<c.pgons.length;m++){p=c.pgons[m];f=p.verts.length;for(n=0;n<f;n++)g=p.pedges[n],h=p.pedges[(n+1)%f],l=d[m],g=e[g.index],k=JSM.GetPolyEdgeStartVertex(h,c),h=e[h.index],l=new JSM.BodyPolygon([l,g,k,h]),h=a.GetPolygon(m),l.material=h.material,l.curved=h.curved,b.AddPolygon(l)}})();return b};
JSM.CatmullClarkSubdivision=function(a,b){var c=a,d;for(d=0;d<b;d++)c=JSM.CatmullClarkSubdivisionOneIteration(c);return c};
JSM.SvgToModel=function(a,b,c){function d(a,b){function c(a,b,d,e,f,g){a=a.createSVGPoint();a.x=f;a.y=g;e=a.matrixTransform(e.getCTM());a=new JSM.Coord2D(e.x,e.y);f=new JSM.Coord2D(f,g);g=b.VertexCount(d);if(0<g&&JSM.CoordIsEqual2DWithEps(b.GetVertex(d,g-1),a,0.1))return f;b.AddVertex(d,e.x,e.y);return f}function d(a,b,e,f,g,h,k){var l=document.createElementNS("http://www.w3.org/2000/svg","path"),m="M "+f.x+" "+f.y+" ",n,q,t,r,s;for(n=0;n<g.length;n++)if(q=g[n],q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS||
q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL)t=q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS?"C":"c",m+=t+" "+q.x1+" "+q.y1+" "+q.x2+" "+q.y2+" "+q.x+" "+q.y+" ";else if(q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS||q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL)t=q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS?"Q":"q",m+=t+" "+q.x1+" "+q.y1+" "+q.x+" "+q.y+" ";else if(q.pathSegType==SVGPathSeg.PATHSEG_ARC_ABS||q.pathSegType==SVGPathSeg.PATHSEG_ARC_REL)t=q.pathSegType==
SVGPathSeg.PATHSEG_ARC_ABS?"A":"a",r=q.largeArcFlag?1:0,s=q.sweepFlag?1:0,m+=t+" "+q.r1+" "+q.r2+" "+q.angle+" "+r+" "+s+" "+q.x+" "+q.y+" ";else if(q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS||q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL)t=q.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS?"S":"s",m+=t+" "+q.x2+" "+q.y2+" "+q.x+" "+q.y+" ";l.setAttributeNS(null,"d",m);m=l.getTotalLength();g=0;0<e&&(g=parseInt(m/e,10));3>g&&(g=3);e=m/g;for(m=1;m<=g;m++)f=l.getPointAtLength(m*
e),f=c(a,h,k,b,f.x,f.y);return f}function e(a,b){var c=a.VertexCount(b);if(0!==c){var d=a.GetVertex(b,0),c=a.GetVertex(b,c-1);JSM.CoordIsEqual2DWithEps(d,c,0.1)&&a.GetContour(b).vertices.pop()}}function f(a,b){return 0<a.VertexCount(b)?(e(a,b),a.AddContour(),b+1):b}var g=new JSM.ContourPolygon2D,h=document.createElementNS("http://www.w3.org/2000/svg","svg"),l;if(a instanceof SVGPathElement){var k=new JSM.Coord2D(0,0),F=new JSM.Coord2D(0,0),C=b;a.hasAttribute("segmentlength")&&(C=parseFloat(a.getAttribute("segmentlength")));
var u,H,z=0;for(l=0;l<a.pathSegList.numberOfItems;l++)if(u=a.pathSegList.getItem(l),u.pathSegType!=SVGPathSeg.PATHSEG_CLOSEPATH)if(u.pathSegType==SVGPathSeg.PATHSEG_MOVETO_ABS)z=f(g,z),k=c(h,g,z,a,u.x,u.y),F=k.Clone();else if(u.pathSegType==SVGPathSeg.PATHSEG_MOVETO_REL)z=f(g,z),k=c(h,g,z,a,F.x+u.x,F.y+u.y),F=k.Clone();else if(u.pathSegType==SVGPathSeg.PATHSEG_LINETO_ABS)k=c(h,g,z,a,u.x,u.y);else if(u.pathSegType==SVGPathSeg.PATHSEG_LINETO_REL)k=c(h,g,z,a,k.x+u.x,k.y+u.y);else if(u.pathSegType==SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS)k=
c(h,g,z,a,u.x,k.y);else if(u.pathSegType==SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS)k=c(h,g,z,a,k.x,u.y);else if(u.pathSegType==SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL)k=c(h,g,z,a,k.x+u.x,k.y);else if(u.pathSegType==SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL)k=c(h,g,z,a,k.x,k.y+u.y);else if(u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS||u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL||u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS||u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL||
u.pathSegType==SVGPathSeg.PATHSEG_ARC_ABS||u.pathSegType==SVGPathSeg.PATHSEG_ARC_REL||u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS||u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL){H=[];if(u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS||u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL){for(;l<a.pathSegList.numberOfItems;l++){u=a.pathSegList.getItem(l);if(!(u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS||u.pathSegType==SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL))break;
H.push(u)}l-=1}else H.push(u);k=d(h,a,C,k,H,g,z)}e(g,z)}else if(a instanceof SVGRectElement)c(h,g,0,a,a.x.baseVal.value,a.y.baseVal.value),c(h,g,0,a,a.x.baseVal.value+a.width.baseVal.value,a.y.baseVal.value),c(h,g,0,a,a.x.baseVal.value+a.width.baseVal.value,a.y.baseVal.value+a.height.baseVal.value),c(h,g,0,a,a.x.baseVal.value,a.y.baseVal.value+a.height.baseVal.value);else if(a instanceof SVGPolygonElement)for(l=0;l<a.points.numberOfItems;l++)k=a.points.getItem(l),c(h,g,0,a,k.x,k.y);g.color=function(a){for(var b=
"";null!==a&&void 0!==a&&0===b.length;)b=a.getAttribute("fill"),null===b&&(b=a.style.fill),a=a.parentElement;a=0;if(0===b.length)return a;if("#"==b[0])a=JSM.HexColorToRGBColor(b.substring(1));else{var c=b.indexOf("("),d=b.indexOf(")");if(-1==c||-1==d)return a;b=b.substring(c+1,d).split(", ");if(3!=b.length)return a;a=JSM.RGBComponentsToHexColor(b[0],b[1],b[2])}return a}(a);return g}function e(a,b){function c(a,b){var d=[],e,f;if("Clockwise"==b)for(e=0;e<a.VertexCount();e++)f=a.GetVertex(e),d.push(new JSM.Coord(f.x,
0,-f.y));else for(e=a.VertexCount()-1;0<=e;e--)f=a.GetVertex(e),d.push(new JSM.Coord(f.x,0,-f.y));return d}function d(a,b,c){a.push(null);var e;if("CounterClockwise"==c)for(c=0;c<b.VertexCount();c++)e=b.GetVertex(c),a.push(new JSM.Coord(e.x,0,-e.y));else for(c=b.VertexCount()-1;0<=c;c--)e=b.GetVertex(c),a.push(new JSM.Coord(e.x,0,-e.y))}var e=[],f=new JSM.Vector(0,-1,0),g,h;h=a.ContourCount();if(1==h)h=JSM.PolygonOrientation2D(a.GetContour(0)),g=c(a.GetContour(0),h),g=JSM.GeneratePrism(g,f,b,!0),
e.push(g);else if(1<h){h=JSM.PolygonOrientation2D(a.GetContour(0));var k=c(a.GetContour(0),h),l=!1,F;for(F=1;F<a.ContourCount();F++)g=JSM.PolygonOrientation2D(a.GetContour(F)),g==h?(g=c(a.GetContour(F),h),g=JSM.GeneratePrism(g,f,b,!0),e.push(g)):(d(k,a.GetContour(F),g),l=!0);g=l?JSM.GeneratePrismWithHole(k,f,b,!0):JSM.GeneratePrism(k,f,b,!0);e.push(g)}f=new JSM.Material({ambient:a.color,diffuse:a.color});return[e,f]}var f=new JSM.Model,g=new JSM.Materials;c=function(a,b){function c(a,b,d){a=a.getElementsByTagName(b);
for(b=0;b<a.length;b++)d.push(a[b])}var e=[],f=[];c(a,"path",f);c(a,"rect",f);c(a,"polygon",f);var g=b;a.hasAttribute("segmentlength")&&(g=parseFloat(a.getAttribute("segmentlength")));var h,k;for(h=0;h<f.length;h++)k=d(f[h],g),e.push(k);return e}(a,c);a.hasAttribute("modelheight")&&(b=parseFloat(a.getAttribute("modelheight")));var h,l,k;for(a=0;a<c.length;a++){h=e(c[a],b);l=h[0];h=h[1];g.AddMaterial(h);for(h=0;h<l.length;h++)k=l[h],k.SetPolygonsMaterialIndex(g.Count()-1),f.AddBody(k)}return[f,g]};
JSM.BSPPolygonUserData=function(){this.material=this.id=null};JSM.AddBodyToBSPTree=function(a,b,c){var d,e,f;for(d=0;d<a.PolygonCount();d++){f=new JSM.BSPPolygonUserData;f.id=c;e=a;var g=f,h=e.GetPolygon(d);g.material=h.GetMaterialIndex();for(var g=new JSM.Polygon,l=void 0,k=void 0,l=0;l<h.VertexIndexCount();l++)k=e.GetVertexPosition(h.GetVertexIndex(l)),g.AddVertex(k.x,k.y,k.z);e=g;b.AddPolygon(e,f)}};
JSM.BooleanOperation=function(a,b,c){function d(a,b,c){function d(a){b.AddVertex(new JSM.BodyVertex(a));return b.VertexCount()-1}var e=new JSM.BodyPolygon([]),f;if(c)for(c=a.VertexCount()-1;0<=c;c--)f=d(a.GetVertex(c)),e.AddVertexIndex(f);else for(c=0;c<a.VertexCount();c++)f=d(a.GetVertex(c)),e.AddVertexIndex(f);void 0!==a.userData&&e.SetMaterialIndex(a.userData.material);b.AddPolygon(e)}function e(a,b,c){var e;for(e=0;e<a.length;e++)d(a[e],b,c)}function f(a,b,c,d,e,f){function g(a,b){var c;for(c=
0;c<a.length;c++)a[c].userData=b}var h,k;for(h=0;h<a.length;h++)k=a[h],JSM.ClipPolygonWithBSPTree(k.polygon,b,c,d,e,f),g(c,k.userData),g(d,k.userData),g(e,k.userData),g(f,k.userData)}var g=new JSM.BSPTree,h=new JSM.BSPTree;JSM.AddBodyToBSPTree(b,g,"a");JSM.AddBodyToBSPTree(c,h,"b");b=new JSM.Body;c=[];var l=[],k=[],m=[];f(g.GetNodes(),h,c,l,k,m);var n=[],p=[],q=[];f(h.GetNodes(),g,n,p,q,[]);"Union"==a?(e(c,b,!1),e(k,b,!1),e(m,b,!1),e(n,b,!1),e(q,b,!1)):"Difference"==a?(e(c,b,!1),e(k,b,!1),e(p,b,!0)):
"Intersection"==a&&(e(l,b,!1),e(m,b,!1),e(p,b,!1));return b};
JSM.GenerateSurface=function(a,b,c,d,e,f,g,h){var l=new JSM.Body,k=a[0],m=b[0],n=(a[1]-a[0])/c,p=(b[1]-b[0])/d;(function(){var a,b,e,f;for(a=0;a<=d;a++)for(b=0;b<=c;b++)e=k+b*n,f=m+a*p,e=g(a,b,e,f,h),l.AddVertex(new JSM.BodyVertex(e))})();(function(){var a,b,g,h,k,m;for(b=0;b<d;b++)for(a=0;a<c;a++)g=b*(c+1)+a,h=g+1,k=g+c+1,m=k+1,e?(h=new JSM.BodyPolygon([g,h,m]),f&&h.SetCurveGroup(0),l.AddPolygon(h),h=new JSM.BodyPolygon([g,m,k])):h=new JSM.BodyPolygon([g,h,m,k]),f&&h.SetCurveGroup(0),l.AddPolygon(h)})();
return l};JSM.SurfaceControlPoints=function(a,b){this.n=a;this.m=b;this.points=[];var c,d;for(c=0;c<=this.n;c++){this.points.push([]);for(d=0;d<=this.m;d++)this.points[c].push(new JSM.Coord(0,0,0))}};JSM.SurfaceControlPoints.prototype.GetNValue=function(){return this.n};JSM.SurfaceControlPoints.prototype.GetMValue=function(){return this.m};JSM.SurfaceControlPoints.prototype.GetControlPoint=function(a,b){return this.points[a][b]};
JSM.SurfaceControlPoints.prototype.InitPlanar=function(a,b){var c=a/this.n,d=b/this.m,e,f,g;for(e=0;e<=this.n;e++)for(f=0;f<=this.m;f++)g=this.points[e][f],g.x=e*c,g.y=f*d};
JSM.GenerateBezierSurface=function(a,b,c,d){return JSM.GenerateSurface([0,1],[0,1],b,c,!1,d,function(a,b,c,d,l){function k(a,b,c){var d=1,e=JSM.Minimum(a,b-a),f;for(f=0;f<e;f++)d*=b-f,d/=f+1;return d*Math.pow(c,a)*Math.pow(1-c,b-a)}var m,n,p,q=l.GetNValue(),r=l.GetMValue();m=new JSM.Coord(0,0,0);for(a=0;a<=q;a++){n=new JSM.Coord(0,0,0);for(b=0;b<=r;b++)p=k(a,q,c)*k(b,r,d),p=JSM.VectorMultiply(l.GetControlPoint(a,b),p),n=JSM.CoordAdd(n,p);m=JSM.CoordAdd(m,n)}return m},a)};
JSM.RenderMaterial=function(a,b,c,d,e,f,g){this.ambient=a;this.diffuse=b;this.specular=c;this.shininess=d;this.texture=e;this.textureWidth=f;this.textureHeight=g;this.textureImage=this.textureBuffer=null;this.textureLoaded=!1};JSM.RenderMaterial.prototype.HasTexture=function(){return null!==this.texture&&this.textureLoaded};
JSM.RenderMaterial.prototype.Compile=function(a,b){if(null!==this.texture){var c=this;this.textureBuffer=a.createTexture();this.textureImage=new Image;this.textureImage.src=this.texture;this.textureImage.onload=function(){a.bindTexture(a.TEXTURE_2D,c.textureBuffer);a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,c.textureImage);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR_MIPMAP_LINEAR);a.generateMipmap(a.TEXTURE_2D);
a.bindTexture(a.TEXTURE_2D,null);c.textureLoaded=!0;void 0!==b&&null!==b&&b()}}};JSM.RenderGeometry=function(){this.transformation=new JSM.Transformation;this.uvBuffer=this.normalBuffer=this.vertexBuffer=this.uvArray=this.normalArray=this.vertexArray=this.material=null};JSM.RenderGeometry.prototype.SetMaterial=function(a){this.material=a};JSM.RenderGeometry.prototype.GetMaterial=function(){return this.material};JSM.RenderGeometry.prototype.SetVertexArray=function(a){this.vertexArray=new Float32Array(a)};
JSM.RenderGeometry.prototype.SetNormalArray=function(a){this.normalArray=new Float32Array(a)};JSM.RenderGeometry.prototype.SetUVArray=function(a){this.uvArray=new Float32Array(a)};JSM.RenderGeometry.prototype.GetTransformation=function(){return this.transformation};JSM.RenderGeometry.prototype.GetTransformationMatrix=function(){return this.transformation.matrix};JSM.RenderGeometry.prototype.SetTransformation=function(a){this.transformation=a};JSM.RenderGeometry.prototype.GetVertexBuffer=function(){return this.vertexBuffer};
JSM.RenderGeometry.prototype.GetNormalBuffer=function(){return this.normalBuffer};JSM.RenderGeometry.prototype.GetUVBuffer=function(){return this.uvBuffer};JSM.RenderGeometry.prototype.VertexCount=function(){return parseInt(this.vertexArray.length/3,10)};JSM.RenderGeometry.prototype.GetVertex=function(a){return new JSM.Coord(this.vertexArray[3*a],this.vertexArray[3*a+1],this.vertexArray[3*a+2])};JSM.RenderGeometry.prototype.GetTransformedVertex=function(a){a=this.GetVertex(a);return this.transformation.Apply(a)};
JSM.RenderGeometry.prototype.Compile=function(a,b){this.material.Compile(a,b);this.vertexBuffer=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer);a.bufferData(a.ARRAY_BUFFER,this.vertexArray,a.STATIC_DRAW);this.vertexBuffer.itemSize=3;this.vertexBuffer.numItems=parseInt(this.vertexArray.length/3,10);this.normalBuffer=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,this.normalBuffer);a.bufferData(a.ARRAY_BUFFER,this.normalArray,a.STATIC_DRAW);this.normalBuffer.itemSize=3;this.normalBuffer.numItems=
parseInt(this.normalArray.length/3,10);null!==this.uvArray&&(this.uvBuffer=a.createBuffer(),a.bindBuffer(a.ARRAY_BUFFER,this.uvBuffer),a.bufferData(a.ARRAY_BUFFER,this.uvArray,a.STATIC_DRAW),this.uvBuffer.itemSize=2,this.uvBuffer.numItems=parseInt(this.uvArray.length/2,10))};JSM.Renderer=function(){this.geometries=this.light=this.camera=this.texShader=this.shader=this.context=this.canvas=null};
JSM.Renderer.prototype.Init=function(a,b,c){return!this.InitContext(a)||!this.InitView(b,c)||!this.InitShaders()||!this.InitBuffers()?!1:!0};
JSM.Renderer.prototype.InitContext=function(a){if(!window.WebGLRenderingContext)return!1;this.canvas=document.getElementById(a);if(null===this.canvas||void 0===this.canvas.getContext)return!1;this.context=this.canvas.getContext("webgl")||this.canvas.getContext("experimental-webgl");if(null===this.context)return!1;this.context.viewportWidth=this.canvas.width;this.context.viewportHeight=this.canvas.height;this.context.viewport(0,0,this.context.viewportWidth,this.context.viewportHeight);this.context.clearColor(1,
1,1,1);this.context.enable(this.context.DEPTH_TEST);this.context.depthFunc(this.context.LEQUAL);this.context.enable(this.context.BLEND);this.context.blendEquation(this.context.FUNC_ADD);this.context.blendFunc(this.context.SRC_ALPHA,this.context.ONE_MINUS_SRC_ALPHA);return!0};
JSM.Renderer.prototype.InitShaders=function(){function a(a,b,c){c=a.createShader(c);a.shaderSource(c,b);a.compileShader(c);return!a.getShaderParameter(c,a.COMPILE_STATUS)?null:c}function b(b,c,d){c=a(b,c,b.FRAGMENT_SHADER);d=a(b,d,b.VERTEX_SHADER);if(null===c||null===d)return null;var e=b.createProgram();b.attachShader(e,d);b.attachShader(e,c);b.linkProgram(e);return!b.getProgramParameter(e,b.LINK_STATUS)?null:e}function c(a){var b="";a&&(b="#define USETEXTURE");return[b,"uniform highp vec3 uPolygonAmbientColor;\nuniform highp vec3 uPolygonDiffuseColor;\nuniform highp vec3 uPolygonSpecularColor;\nuniform highp float uPolygonShininess;\nuniform highp vec3 uLightAmbientColor;\nuniform highp vec3 uLightDiffuseColor;\nuniform highp vec3 uLightSpecularColor;\nvarying highp vec3 vVertex;\nvarying highp vec3 vNormal;\nvarying highp vec3 vLight;\n#ifdef USETEXTURE\nvarying highp vec2 vUV;\nuniform sampler2D uSampler;\n#endif\nvoid main (void) {\n\thighp vec3 N = normalize (vNormal);\n\tif (!gl_FrontFacing) {\n\t\tN = -N;\n\t}\n\thighp vec3 L = normalize (-vLight);\n\thighp vec3 E = normalize (-vVertex);\n\thighp vec3 R = normalize (-reflect (L, N));\n\thighp vec3 ambientComponent = uPolygonAmbientColor * uLightAmbientColor;\n\thighp vec3 diffuseComponent = uPolygonDiffuseColor * uLightDiffuseColor * max (dot (N, L), 0.0);\n\thighp vec3 specularComponent = uPolygonSpecularColor * uLightSpecularColor * pow (max (dot (R, E), 0.0), uPolygonShininess);\n#ifdef USETEXTURE\n\thighp vec3 textureColor = texture2D (uSampler, vec2 (vUV.s, vUV.t)).xyz;\n\tambientComponent = textureColor * ambientComponent;\n\tdiffuseComponent = textureColor * diffuseComponent;\n\tspecularComponent = textureColor * specularComponent;\n#endif\n\tambientComponent = clamp (ambientComponent, 0.0, 1.0);\n\tdiffuseComponent = clamp (diffuseComponent, 0.0, 1.0);\n\tspecularComponent = clamp (specularComponent, 0.0, 1.0);\n\tgl_FragColor = vec4 (ambientComponent + diffuseComponent + specularComponent, 1.0);\n}"].join("\n")}
function d(a){var b="";a&&(b="#define USETEXTURE");return[b,"attribute highp vec3 aVertexPosition;\nattribute highp vec3 aVertexNormal;\nuniform highp mat4 uViewMatrix;\nuniform highp mat4 uModelViewMatrix;\nuniform highp mat4 uProjectionMatrix;\nuniform highp vec3 uLightDirection;\nvarying highp vec3 vVertex;\nvarying highp vec3 vNormal;\nvarying highp vec3 vLight;\n#ifdef USETEXTURE\nattribute highp vec2 aVertexUV;\nvarying highp vec2 vUV;\n#endif\nvoid main (void) {\n\tvVertex = vec3 (uModelViewMatrix * vec4 (aVertexPosition, 1.0));\n\tvNormal = normalize (vec3 (uModelViewMatrix * vec4 (aVertexNormal, 0.0)));\n\tvLight = normalize (vec3 (uViewMatrix * vec4 (uLightDirection, 0.0)));\n#ifdef USETEXTURE\n\tvUV = aVertexUV;\n#endif\n\tgl_Position = uProjectionMatrix * vec4 (vVertex, 1.0);\n}"].join("\n")}
function e(a,b){b.vertexPositionAttribute=a.getAttribLocation(b,"aVertexPosition");b.vertexNormalAttribute=a.getAttribLocation(b,"aVertexNormal");b.lightAmbientColorUniform=a.getUniformLocation(b,"uLightAmbientColor");b.lightDiffuseColorUniform=a.getUniformLocation(b,"uLightDiffuseColor");b.lightSpecularColorUniform=a.getUniformLocation(b,"uLightSpecularColor");b.lightDirectionUniform=a.getUniformLocation(b,"uLightDirection");b.vMatrixUniform=a.getUniformLocation(b,"uViewMatrix");b.mvMatrixUniform=
a.getUniformLocation(b,"uModelViewMatrix");b.pMatrixUniform=a.getUniformLocation(b,"uProjectionMatrix");b.polygonAmbientColorUniform=a.getUniformLocation(b,"uPolygonAmbientColor");b.polygonDiffuseColorUniform=a.getUniformLocation(b,"uPolygonDiffuseColor");b.polygonSpecularColorUniform=a.getUniformLocation(b,"uPolygonSpecularColor");b.polygonShininessUniform=a.getUniformLocation(b,"uPolygonShininess")}this.shader=function(a){var g=c(!1),h=d(!1),g=b(a,g,h);if(null===g)return null;a.useProgram(g);e(a,
g);return g}(this.context);if(null===this.shader)return!1;this.texShader=function(a){var g=c(!0),h=d(!0),g=b(a,g,h);if(null===g)return null;a.useProgram(g);e(a,g);g.vertexUVAttribute=a.getAttribLocation(g,"aVertexUV");g.samplerUniform=a.getUniformLocation(g,"uSampler");return g}(this.context);return null===this.texShader?!1:!0};JSM.Renderer.prototype.InitBuffers=function(){this.geometries=[];return!0};
JSM.Renderer.prototype.InitView=function(a,b){this.camera=JSM.ValueOrDefault(a,new JSM.Camera);if(!this.camera)return!1;this.light=JSM.ValueOrDefault(b,new JSM.Light);return!this.light?!1:!0};JSM.Renderer.prototype.SetClearColor=function(a,b,c){this.context.clearColor(a,b,c,1)};JSM.Renderer.prototype.AddGeometries=function(a){var b,c;for(b=0;b<a.length;b++)c=a[b],c.Compile(this.context,this.Render.bind(this)),this.geometries.push(c)};
JSM.Renderer.prototype.RemoveGeometries=function(){this.geometries=[]};JSM.Renderer.prototype.Resize=function(){this.context.viewportWidth=this.canvas.width;this.context.viewportHeight=this.canvas.height;this.context.viewport(0,0,this.context.viewportWidth,this.context.viewportHeight)};
JSM.Renderer.prototype.Render=function(){this.context.clear(this.context.COLOR_BUFFER_BIT|this.context.DEPTH_BUFFER_BIT);var a=JSM.MatrixPerspective(this.camera.fieldOfView*JSM.DegRad,this.context.viewportWidth/this.context.viewportHeight,this.camera.nearClippingPlane,this.camera.farClippingPlane),b=JSM.MatrixView(this.camera.eye,this.camera.center,this.camera.up),c=JSM.MatrixIdentity(),d=JSM.HexColorToNormalizedRGBComponents(this.light.ambient),e=JSM.HexColorToNormalizedRGBComponents(this.light.diffuse),
f=JSM.HexColorToNormalizedRGBComponents(this.light.specular);this.light.direction=JSM.VectorNormalize(JSM.CoordSub(this.camera.center,this.camera.eye));var g,h,l,k,m,n;for(g=0;g<this.geometries.length;g++)m=this.geometries[g],c=m.GetMaterial().HasTexture()?this.texShader:this.shader,n!=c&&(n=c,this.context.useProgram(n),this.context.uniformMatrix4fv(n.pMatrixUniform,!1,a),this.context.uniformMatrix4fv(n.vMatrixUniform,!1,b),this.context.uniform3f(n.lightDirectionUniform,this.light.direction.x,this.light.direction.y,
this.light.direction.z),this.context.uniform3f(n.lightAmbientColorUniform,d[0],d[1],d[2]),this.context.uniform3f(n.lightDiffuseColorUniform,e[0],e[1],e[2]),this.context.uniform3f(n.lightSpecularColorUniform,f[0],f[1],f[2])),c=m.material.ambient,h=m.material.diffuse,l=m.material.specular,k=m.material.shininess,this.context.uniform3f(n.polygonAmbientColorUniform,c[0],c[1],c[2]),this.context.uniform3f(n.polygonDiffuseColorUniform,h[0],h[1],h[2]),this.context.uniform3f(n.polygonSpecularColorUniform,l[0],
l[1],l[2]),this.context.uniform1f(n.polygonShininessUniform,k),n==this.texShader&&(c=m.GetUVBuffer(),this.context.activeTexture(this.context.TEXTURE0),this.context.bindTexture(this.context.TEXTURE_2D,m.material.textureBuffer),this.context.bindBuffer(this.context.ARRAY_BUFFER,c),this.context.vertexAttribPointer(n.vertexUVAttribute,c.itemSize,this.context.FLOAT,!1,0,0),this.context.enableVertexAttribArray(n.vertexUVAttribute),this.context.uniform1i(n.samplerUniform,0)),c=JSM.MatrixMultiply(m.GetTransformationMatrix(),
b),this.context.uniformMatrix4fv(n.mvMatrixUniform,!1,c),c=m.GetVertexBuffer(),this.context.bindBuffer(this.context.ARRAY_BUFFER,c),this.context.enableVertexAttribArray(n.vertexPositionAttribute),this.context.vertexAttribPointer(n.vertexPositionAttribute,c.itemSize,this.context.FLOAT,!1,0,0),m=m.GetNormalBuffer(),this.context.bindBuffer(this.context.ARRAY_BUFFER,m),this.context.enableVertexAttribArray(n.vertexNormalAttribute),this.context.vertexAttribPointer(n.vertexNormalAttribute,m.itemSize,this.context.FLOAT,
!1,0,0),this.context.drawArrays(this.context.TRIANGLES,0,c.numItems)};JSM.PointCloudRenderer=function(){this.pointSize=this.points=this.camera=this.shader=this.context=this.canvas=null};JSM.PointCloudRenderer.prototype.Init=function(a,b){return!this.InitContext(a)||!this.InitShaders()||!this.InitBuffers()||!this.InitView(b)?!1:!0};
JSM.PointCloudRenderer.prototype.InitContext=function(a){if(!window.WebGLRenderingContext)return!1;this.canvas=document.getElementById(a);if(null===this.canvas||void 0===this.canvas.getContext)return!1;this.context=this.canvas.getContext("experimental-webgl");if(null===this.context)return!1;this.context.viewportWidth=this.canvas.width;this.context.viewportHeight=this.canvas.height;this.context.clearColor(1,1,1,1);this.context.enable(this.context.DEPTH_TEST);return!0};
JSM.PointCloudRenderer.prototype.InitShaders=function(){function a(a,b,c){c=a.createShader(c);a.shaderSource(c,b);a.compileShader(c);return!a.getShaderParameter(c,a.COMPILE_STATUS)?null:c}var b=a(this.context,"varying highp vec3 vColor;\nvoid main (void) {\n\tgl_FragColor = vec4 (vColor, 1.0);\n}",this.context.FRAGMENT_SHADER),c=a(this.context,"attribute highp vec3 aVertexPosition;\nattribute highp vec3 aVertexColor;\nuniform highp mat4 uViewMatrix;\nuniform highp mat4 uProjectionMatrix;\nuniform highp float uPointSize;\nvarying highp vec3 vColor;\nvoid main (void) {\n\tvColor = aVertexColor;\n\tgl_PointSize = uPointSize;\n\tgl_Position = uProjectionMatrix * uViewMatrix * vec4 (aVertexPosition, 1.0);\n}",
this.context.VERTEX_SHADER);if(null===b||null===c)return!1;this.shader=this.context.createProgram();this.context.attachShader(this.shader,c);this.context.attachShader(this.shader,b);this.context.linkProgram(this.shader);if(!this.context.getProgramParameter(this.shader,this.context.LINK_STATUS))return!1;this.context.useProgram(this.shader);this.shader.vertexPositionAttribute=this.context.getAttribLocation(this.shader,"aVertexPosition");this.context.enableVertexAttribArray(this.shader.vertexPositionAttribute);
this.shader.vertexColorAttribute=this.context.getAttribLocation(this.shader,"aVertexColor");this.context.enableVertexAttribArray(this.shader.vertexColorAttribute);this.shader.pMatrixUniform=this.context.getUniformLocation(this.shader,"uProjectionMatrix");this.shader.vMatrixUniform=this.context.getUniformLocation(this.shader,"uViewMatrix");this.shader.pointSizeUniform=this.context.getUniformLocation(this.shader,"uPointSize");return!0};
JSM.PointCloudRenderer.prototype.InitBuffers=function(){this.points=[];this.pointSize=1;return!0};JSM.PointCloudRenderer.prototype.InitView=function(a){this.camera=JSM.ValueOrDefault(a,new JSM.Camera);return!this.camera?!1:!0};JSM.PointCloudRenderer.prototype.SetClearColor=function(a,b,c){this.context.clearColor(a,b,c,1)};JSM.PointCloudRenderer.prototype.SetPointSize=function(a){this.pointSize=a};
JSM.PointCloudRenderer.prototype.AddPoints=function(a,b){var c=this.context.createBuffer(),d=new Float32Array(a);this.context.bindBuffer(this.context.ARRAY_BUFFER,c);this.context.bufferData(this.context.ARRAY_BUFFER,d,this.context.STATIC_DRAW);c.itemSize=3;c.numItems=parseInt(d.length/3,10);var e=this.context.createBuffer(),f=new Float32Array(b);this.context.bindBuffer(this.context.ARRAY_BUFFER,e);this.context.bufferData(this.context.ARRAY_BUFFER,f,this.context.STATIC_DRAW);e.itemSize=3;e.numItems=
parseInt(f.length/3,10);this.points.push({pointArray:d,pointBuffer:c,colorBuffer:e})};JSM.PointCloudRenderer.prototype.RemovePoints=function(){this.points=[]};JSM.PointCloudRenderer.prototype.Resize=function(){this.context.viewportWidth=this.canvas.width;this.context.viewportHeight=this.canvas.height};
JSM.PointCloudRenderer.prototype.Render=function(){this.context.viewport(0,0,this.context.viewportWidth,this.context.viewportHeight);this.context.clear(this.context.COLOR_BUFFER_BIT|this.context.DEPTH_BUFFER_BIT);var a=JSM.MatrixPerspective(this.camera.fieldOfView*JSM.DegRad,this.context.viewportWidth/this.context.viewportHeight,this.camera.nearClippingPlane,this.camera.farClippingPlane);this.context.uniformMatrix4fv(this.shader.pMatrixUniform,!1,a);a=JSM.MatrixView(this.camera.eye,this.camera.center,
this.camera.up);this.context.uniformMatrix4fv(this.shader.vMatrixUniform,!1,a);this.context.uniform1f(this.shader.pointSizeUniform,this.pointSize);for(var b,c,a=0;a<this.points.length;a++)b=this.points[a].pointBuffer,c=this.points[a].colorBuffer,this.context.bindBuffer(this.context.ARRAY_BUFFER,b),this.context.vertexAttribPointer(this.shader.vertexPositionAttribute,b.itemSize,this.context.FLOAT,!1,0,0),this.context.bindBuffer(this.context.ARRAY_BUFFER,c),this.context.vertexAttribPointer(this.shader.vertexColorAttribute,
c.itemSize,this.context.FLOAT,!1,0,0),this.context.drawArrays(this.context.POINTS,0,b.numItems)};
JSM.ConvertBodyToRenderGeometries=function(a,b){var c=[],d=null,e=null,f=null,g=null;JSM.ExplodeBodyToTriangles(a,b,{hasConvexPolygons:!1,onGeometryStart:function(a){e=[];f=[];g=[];var b=JSM.HexColorToNormalizedRGBComponents(a.ambient),k=JSM.HexColorToNormalizedRGBComponents(a.diffuse),m=JSM.HexColorToNormalizedRGBComponents(a.specular);a=new JSM.RenderMaterial(b,k,m,a.shininess,a.texture,a.textureWidth,a.textureHeight);d=new JSM.RenderGeometry;d.SetMaterial(a);c.push(d)},onGeometryEnd:function(a){d.SetVertexArray(e);
d.SetNormalArray(f);null!==a.texture&&d.SetUVArray(g)},onTriangle:function(a,b,c,d,n,p,q,r,s){e.push(a.x,a.y,a.z);e.push(b.x,b.y,b.z);e.push(c.x,c.y,c.z);f.push(d.x,d.y,d.z);f.push(n.x,n.y,n.z);f.push(p.x,p.y,p.z);null!==q&&(null!==r&&null!==s)&&(g.push(q.x,q.y),g.push(r.x,r.y),g.push(s.x,s.y))}});return c};JSM.ConvertModelToRenderGeometries=function(a,b){var c=[],d,e;for(d=0;d<a.BodyCount();d++){e=a.GetBody(d);var f=JSM.ConvertBodyToRenderGeometries(e,b,c);for(e=0;e<f.length;e++)c.push(f[e])}return c};
JSM.JSONFileLoader=function(a){this.onReady=a};JSM.JSONFileLoader.prototype.Load=function(a){var b=this,c=new XMLHttpRequest;c.overrideMimeType("application/json");c.open("GET",a,!0);c.onreadystatechange=function(){4==c.readyState&&b.OnReady(c.responseText)};c.send(null)};JSM.JSONFileLoader.prototype.OnReady=function(a){null!==this.onReady&&(a=JSON.parse(a),this.onReady(a))};
JSM.Mouse=function(){this.down=!1;this.button=0;this.alt=this.ctrl=this.shift=!1;this.diffY=this.diffX=this.currY=this.currX=this.prevY=this.prevX=0};JSM.Mouse.prototype.Down=function(a,b){var c=a;void 0===c&&(c=window.event);this.down=!0;this.button=a.which;this.shift=a.shiftKey;this.ctrl=a.ctrlKey;this.alt=a.altKey;this.SetCurrent(c,b);this.prevX=this.currX;this.prevY=this.currY};
JSM.Mouse.prototype.Move=function(a,b){var c=a;void 0===c&&(c=window.event);this.shift=a.shiftKey;this.ctrl=a.ctrlKey;this.alt=a.altKey;this.SetCurrent(c,b);this.diffX=this.currX-this.prevX;this.diffY=this.currY-this.prevY;this.prevX=this.currX;this.prevY=this.currY};JSM.Mouse.prototype.Up=function(a,b){var c=a;void 0===c&&(c=window.event);this.down=!1;this.SetCurrent(c,b)};JSM.Mouse.prototype.Out=function(a,b){var c=a;void 0===c&&(c=window.event);this.down=!1;this.SetCurrent(c,b)};
JSM.Mouse.prototype.SetCurrent=function(a,b){this.currX=a.clientX;this.currY=a.clientY;void 0!==b&&(void 0!==b.offsetLeft&&void 0!==b.offsetTop)&&(this.currX-=b.offsetLeft,this.currY-=b.offsetTop)};JSM.Touch=function(){this.down=!1;this.diffY=this.diffX=this.currY=this.currX=this.prevY=this.prevX=0};JSM.Touch.prototype.Start=function(a,b){if(0!==a.touches.length){var c=a.touches[0];this.down=!0;this.SetCurrent(c,b);this.prevX=this.currX;this.prevY=this.currY}};
JSM.Touch.prototype.Move=function(a,b){0!==a.touches.length&&(this.SetCurrent(a.touches[0],b),this.diffX=this.currX-this.prevX,this.diffY=this.currY-this.prevY,this.prevX=this.currX,this.prevY=this.currY)};JSM.Touch.prototype.End=function(a,b){if(0!==a.touches.length){var c=a.touches[0];this.down=!1;this.SetCurrent(c,b)}};
JSM.Touch.prototype.SetCurrent=function(a,b){this.currX=a.pageX;this.currY=a.pageY;void 0!==b&&(void 0!==b.offsetLeft&&void 0!==b.offsetTop)&&(this.currX=a.pageX-b.offsetLeft,this.currY=a.pageY-b.offsetTop)};JSM.Navigation=function(){this.orbitCenter=this.cameraEnableZoom=this.cameraEnablePan=this.cameraEnableOrbit=this.cameraFixUp=this.touch=this.mouse=this.resizeCallback=this.drawCallback=this.camera=this.canvas=null};
JSM.Navigation.prototype.Init=function(a,b,c,d){this.canvas=a;this.camera=b;this.drawCallback=c;this.resizeCallback=d;this.mouse=new JSM.Mouse;this.touch=new JSM.Touch;this.cameraEnableZoom=this.cameraEnablePan=this.cameraEnableOrbit=this.cameraFixUp=!0;this.orbitCenter=this.camera.center.Clone();var e=this;document.addEventListener&&(document.addEventListener("mousemove",function(a){e.OnMouseMove(a)}),document.addEventListener("mouseup",function(a){e.OnMouseUp(a)}));this.canvas.addEventListener&&
(this.canvas.addEventListener("mousedown",function(a){e.OnMouseDown(a)},!1),this.canvas.addEventListener("DOMMouseScroll",function(a){e.OnMouseWheel(a)},!1),this.canvas.addEventListener("mousewheel",function(a){e.OnMouseWheel(a)},!1),this.canvas.addEventListener("touchstart",function(a){e.OnTouchStart(a)},!1),this.canvas.addEventListener("touchmove",function(a){e.OnTouchMove(a)},!1),this.canvas.addEventListener("touchend",function(a){e.OnTouchEnd(a)},!1),this.canvas.addEventListener("contextmenu",
function(a){e.OnContextMenu(a)},!1));window.addEventListener&&window.addEventListener("resize",function(a){e.OnResize(a)},!1);return!0};JSM.Navigation.prototype.SetCamera=function(a,b,c){this.camera.Set(a,b,c);this.orbitCenter=this.camera.center.Clone()};JSM.Navigation.prototype.EnableFixUp=function(a){this.cameraFixUp=a};JSM.Navigation.prototype.EnableOrbit=function(a){this.cameraEnableOrbit=a};JSM.Navigation.prototype.EnablePan=function(a){this.cameraEnablePan=a};
JSM.Navigation.prototype.EnableZoom=function(a){this.cameraEnableZoom=a};JSM.Navigation.prototype.SetOrbitCenter=function(a){this.orbitCenter=a};
JSM.Navigation.prototype.FitInWindow=function(a,b){var c=JSM.CoordSub(this.camera.center,a);this.camera.center=a;this.camera.eye=JSM.CoordSub(this.camera.eye,c);var c=JSM.VectorNormalize(JSM.CoordSub(this.camera.eye,this.camera.center)),d=this.camera.fieldOfView/2;this.canvas.width<this.canvas.height&&(d=d*this.canvas.width/this.canvas.height);d=b/Math.sin(d*JSM.DegRad);this.camera.eye=JSM.CoordOffset(this.camera.center,c,d);this.orbitCenter=this.camera.center.Clone()};
JSM.Navigation.prototype.Orbit=function(a,b){var c=a*JSM.DegRad,d=b*JSM.DegRad,e=JSM.VectorNormalize(JSM.CoordSub(this.camera.center,this.camera.eye)),f=JSM.VectorNormalize(JSM.VectorCross(e,this.camera.up)),g=!JSM.CoordIsEqual(this.orbitCenter,this.camera.center);this.cameraFixUp?(e=JSM.GetVectorsAngle(e,this.camera.up)+d,JSM.IsGreater(e,0)&&JSM.IsLower(e,Math.PI)&&(this.camera.eye=JSM.CoordRotate(this.camera.eye,f,-d,this.orbitCenter),g&&(this.camera.center=JSM.CoordRotate(this.camera.center,f,
-d,this.orbitCenter))),this.camera.eye=JSM.CoordRotate(this.camera.eye,this.camera.up,-c,this.orbitCenter),g&&(this.camera.center=JSM.CoordRotate(this.camera.center,this.camera.up,-c,this.orbitCenter))):(e=JSM.VectorNormalize(JSM.VectorCross(f,e)),this.camera.eye=JSM.CoordRotate(this.camera.eye,f,-d,this.orbitCenter),this.camera.eye=JSM.CoordRotate(this.camera.eye,e,-c,this.orbitCenter),g&&(this.camera.center=JSM.CoordRotate(this.camera.center,f,-d,this.orbitCenter),this.camera.center=JSM.CoordRotate(this.camera.center,
e,-c,this.orbitCenter)),this.camera.up=e)};JSM.Navigation.prototype.Pan=function(a,b){var c=JSM.VectorNormalize(JSM.CoordSub(this.camera.center,this.camera.eye)),d=JSM.VectorNormalize(JSM.VectorCross(c,this.camera.up)),c=JSM.VectorNormalize(JSM.VectorCross(d,c));this.camera.eye=JSM.CoordOffset(this.camera.eye,d,-a);this.camera.center=JSM.CoordOffset(this.camera.center,d,-a);this.camera.eye=JSM.CoordOffset(this.camera.eye,c,b);this.camera.center=JSM.CoordOffset(this.camera.center,c,b)};
JSM.Navigation.prototype.Zoom=function(a){var b=JSM.CoordSub(this.camera.center,this.camera.eye),c=JSM.VectorLength(b);if(a&&0.1>c)return 0;c*=0.1;a||(c*=-1);this.camera.eye=JSM.CoordOffset(this.camera.eye,b,c)};JSM.Navigation.prototype.DrawCallback=function(){void 0!==this.drawCallback&&null!==this.drawCallback&&this.drawCallback()};JSM.Navigation.prototype.ResizeCallback=function(){void 0!==this.resizeCallback&&null!==this.resizeCallback&&this.resizeCallback()};
JSM.Navigation.prototype.OnMouseDown=function(a){a.preventDefault();this.mouse.Down(a,this.canvas)};JSM.Navigation.prototype.OnMouseMove=function(a){a.preventDefault();this.mouse.Move(a,this.canvas);this.mouse.down&&(a=0,1==this.mouse.button?this.cameraEnableOrbit&&(a=0.5,this.Orbit(this.mouse.diffX*a,this.mouse.diffY*a),this.DrawCallback()):3==this.mouse.button&&this.cameraEnablePan&&(a=0.001*JSM.CoordDistance(this.camera.eye,this.camera.center),this.Pan(this.mouse.diffX*a,this.mouse.diffY*a),this.DrawCallback()))};
JSM.Navigation.prototype.OnMouseUp=function(a){a.preventDefault();this.mouse.Up(a,this.canvas)};JSM.Navigation.prototype.OnMouseOut=function(a){a.preventDefault();this.mouse.Out(a,this.canvas)};JSM.Navigation.prototype.OnMouseWheel=function(a){a.preventDefault();if(this.cameraEnableZoom){null===a&&(a=window.event);var b=0;a.detail?b=-a.detail:a.wheelDelta&&(b=a.wheelDelta/40);this.Zoom(0<b);this.DrawCallback()}};
JSM.Navigation.prototype.OnTouchStart=function(a){a.preventDefault();this.touch.Start(a,this.canvas)};JSM.Navigation.prototype.OnTouchMove=function(a){a.preventDefault();this.touch.Move(a,this.canvas);this.touch.down&&this.cameraEnableOrbit&&(this.Orbit(0.5*this.touch.diffX,0.5*this.touch.diffY),this.DrawCallback())};JSM.Navigation.prototype.OnTouchEnd=function(a){a.preventDefault();this.touch.End(a,this.canvas)};JSM.Navigation.prototype.OnContextMenu=function(a){a.preventDefault()};
JSM.Navigation.prototype.OnResize=function(a){a.preventDefault();this.ResizeCallback()};JSM.SoftwareViewer=function(){this.navigation=this.drawMode=this.drawer=this.bodies=this.camera=this.canvas=null};JSM.SoftwareViewer.prototype.Start=function(a,b){return!this.InitCanvas(a)||!this.InitCamera(b)?!1:!0};
JSM.SoftwareViewer.prototype.InitCanvas=function(a){this.bodies=[];this.canvas=document.getElementById(a);if(!this.canvas)return!1;this.canvas instanceof HTMLCanvasElement?this.drawer=new JSM.CanvasDrawer(this.canvas):this.canvas instanceof SVGSVGElement&&(this.drawer=new JSM.SVGDrawer(this.canvas));if(!this.drawer)return!1;this.drawMode="Wireframe";return!0};
JSM.SoftwareViewer.prototype.InitCamera=function(a){this.camera=JSM.ValueOrDefault(a,new JSM.Camera);if(!this.camera)return!1;this.navigation=new JSM.Navigation;return!this.navigation.Init(this.canvas,this.camera,this.Draw.bind(this),this.Resize.bind(this))?!1:!0};JSM.SoftwareViewer.prototype.AddBody=function(a,b){this.bodies.push([a,b])};JSM.SoftwareViewer.prototype.RemoveBodies=function(){this.bodies=[]};
JSM.SoftwareViewer.prototype.FitInWindow=function(){var a=this.GetCenter(),b=this.GetBoundingSphereRadius(a);this.navigation.FitInWindow(a,b);this.Draw()};JSM.SoftwareViewer.prototype.GetCenter=function(){var a=this.GetBoundingBox();return JSM.MidCoord(a[0],a[1])};
JSM.SoftwareViewer.prototype.GetBoundingBox=function(){var a=new JSM.Coord(JSM.Inf,JSM.Inf,JSM.Inf),b=new JSM.Coord(-JSM.Inf,-JSM.Inf,-JSM.Inf),c,d,e,f;for(c=0;c<this.bodies.length;c++){e=this.bodies[c][0];for(d=0;d<e.VertexCount();d++)f=e.GetVertex(d),a.x=JSM.Minimum(a.x,f.position.x),a.y=JSM.Minimum(a.y,f.position.y),a.z=JSM.Minimum(a.z,f.position.z),b.x=JSM.Maximum(b.x,f.position.x),b.y=JSM.Maximum(b.y,f.position.y),b.z=JSM.Maximum(b.z,f.position.z)}return[a,b]};
JSM.SoftwareViewer.prototype.GetBoundingSphereRadius=function(a){if(void 0===a||null===a)a=this.GetCenter();var b=0,c,d,e,f;for(c=0;c<this.bodies.length;c++){e=this.bodies[c][0];for(d=0;d<e.VertexCount();d++)f=e.GetVertex(d),f=JSM.CoordDistance(a,f.position),JSM.IsGreater(f,b)&&(b=f)}return b};JSM.SoftwareViewer.prototype.Resize=function(){this.Draw()};
JSM.SoftwareViewer.prototype.Draw=function(){var a,b;this.drawer.Clear();for(a=0;a<this.bodies.length;a++)b=this.bodies[a],JSM.DrawProjectedBody(b[0],b[1],this.camera,this.drawMode,!1,this.drawer);return!0};JSM.SpriteViewer=function(){this.navigation=this.projected=this.points=this.callbacks=this.camera=this.canvas=null};JSM.SpriteViewer.prototype.Start=function(a,b,c){return!this.InitCanvas(a)||!this.InitCamera(b)||!this.InitCallbacks(c)?!1:!0};
JSM.SpriteViewer.prototype.InitCanvas=function(a){this.points=[];this.canvas=document.getElementById(a);return!this.canvas?!1:!0};JSM.SpriteViewer.prototype.InitCamera=function(a){this.camera=JSM.ValueOrDefault(a,new JSM.Camera);if(!this.camera)return!1;this.navigation=new JSM.Navigation;return!this.navigation.Init(this.canvas,this.camera,this.Draw.bind(this))?!1:!0};
JSM.SpriteViewer.prototype.InitCallbacks=function(a){this.callbacks={onPointDraw:null};void 0!==a&&(void 0!==a.onDrawStart&&(this.callbacks.onDrawStart=a.onDrawStart),void 0!==a.onPointDraw&&(this.callbacks.onPointDraw=a.onPointDraw),void 0!==a.onDrawEnd&&(this.callbacks.onDrawEnd=a.onDrawEnd));return!0};JSM.SpriteViewer.prototype.AddPoint=function(a){this.points.push(a)};JSM.SpriteViewer.prototype.RemovePoints=function(){this.points=[]};JSM.SpriteViewer.prototype.Resize=function(){this.Draw()};
JSM.SpriteViewer.prototype.NearestPointUnderPosition=function(a,b,c){b=new JSM.Coord2D(b,c);c=-1;var d=JSM.Inf,e,f,g;for(e=0;e<this.projected.length;e++)f=this.projected[e],g=JSM.CoordDistance2D(new JSM.Coord2D(f.position.x,f.position.y),b),JSM.IsLower(g,a)&&JSM.IsLower(g,d)&&(c=f.originalIndex,d=g);return c};JSM.SpriteViewer.prototype.NearestPointUnderMouse=function(a){return this.NearestPointUnderPosition(a,this.navigation.mouse.currX,this.navigation.mouse.currY)};
JSM.SpriteViewer.prototype.NearestPointUnderTouch=function(a){return this.NearestPointUnderPosition(a,this.navigation.touch.currX,this.navigation.touch.currY)};JSM.SpriteViewer.prototype.FitInWindow=function(){var a=this.GetCenter(),b=this.GetBoundingSphereRadius(a);this.navigation.FitInWindow(a,b);this.Draw()};JSM.SpriteViewer.prototype.GetCenter=function(){var a=this.GetBoundingBox();return JSM.MidCoord(a[0],a[1])};
JSM.SpriteViewer.prototype.GetBoundingBox=function(){var a=new JSM.Coord(JSM.Inf,JSM.Inf,JSM.Inf),b=new JSM.Coord(-JSM.Inf,-JSM.Inf,-JSM.Inf),c,d;for(c=0;c<this.points.length;c++)d=this.points[c],a.x=JSM.Minimum(a.x,d.x),a.y=JSM.Minimum(a.y,d.y),a.z=JSM.Minimum(a.z,d.z),b.x=JSM.Maximum(b.x,d.x),b.y=JSM.Maximum(b.y,d.y),b.z=JSM.Maximum(b.z,d.z);return[a,b]};
JSM.SpriteViewer.prototype.GetBoundingSphereRadius=function(a){if(void 0===a||null===a)a=this.GetCenter();var b=0,c,d;for(c=0;c<this.points.length;c++)d=this.points[c],d=JSM.CoordDistance(a,d),JSM.IsGreater(d,b)&&(b=d);return b};
JSM.SpriteViewer.prototype.Draw=function(){if(null!==this.callbacks.onDrawStart)this.callbacks.onDrawStart(this.canvas);var a=this.canvas.width/this.canvas.height,b=[0,0,this.canvas.width,this.canvas.height];this.projected=[];var c,d;for(c=0;c<this.points.length;c++)d=this.points[c],d=JSM.Project(d,this.camera.eye,this.camera.center,this.camera.up,this.camera.fieldOfView*JSM.DegRad,a,this.camera.nearClippingPlane,this.camera.farClippingPlane,b),d.y=this.canvas.height-d.y,null!==d&&this.projected.push({position:d,
originalIndex:c});this.projected.sort(function(a,b){return a.position.z>b.position.z?-1:a.position.z<b.position.z?1:0});for(c=0;c<this.projected.length;c++)if(null!==this.callbacks.onPointDraw)this.callbacks.onPointDraw(this.canvas,this.projected[c].originalIndex,this.projected[c].position);if(null!==this.callbacks.onDrawEnd)this.callbacks.onDrawEnd(this.canvas);return!0};JSM.Viewer=function(){this.navigation=this.renderer=this.canvas=null};
JSM.Viewer.prototype.Init=function(a,b,c){return!this.InitRenderer(a,b,c)||!this.InitNavigation()?!1:!0};JSM.Viewer.prototype.InitRenderer=function(a,b,c){this.renderer=new JSM.Renderer;return!this.renderer.Init(a,b,c)?!1:!0};JSM.Viewer.prototype.InitNavigation=function(){this.navigation=new JSM.Navigation;return!this.navigation.Init(this.renderer.canvas,this.renderer.camera,this.Draw.bind(this),this.Resize.bind(this))?!1:!0};
JSM.Viewer.prototype.SetClearColor=function(a,b,c){this.renderer.SetClearColor(a,b,c);this.Draw()};JSM.Viewer.prototype.AddGeometries=function(a){this.renderer.AddGeometries(a);this.Draw()};JSM.Viewer.prototype.RemoveGeometries=function(){this.renderer.RemoveGeometries();this.Draw()};JSM.Viewer.prototype.FitInWindow=function(){var a=this.GetCenter(),b=this.GetBoundingSphereRadius(a);this.navigation.FitInWindow(a,b);this.Draw()};
JSM.Viewer.prototype.GetCenter=function(){var a=this.GetBoundingBox();return JSM.MidCoord(a[0],a[1])};
JSM.Viewer.prototype.GetBoundingBox=function(){var a=new JSM.Coord(JSM.Inf,JSM.Inf,JSM.Inf),b=new JSM.Coord(-JSM.Inf,-JSM.Inf,-JSM.Inf),c,d,e,f;for(c=0;c<this.renderer.geometries.length;c++){e=this.renderer.geometries[c];for(d=0;d<e.VertexCount();d+=1)f=e.GetTransformedVertex(d),a.x=JSM.Minimum(a.x,f.x),a.y=JSM.Minimum(a.y,f.y),a.z=JSM.Minimum(a.z,f.z),b.x=JSM.Maximum(b.x,f.x),b.y=JSM.Maximum(b.y,f.y),b.z=JSM.Maximum(b.z,f.z)}return[a,b]};
JSM.Viewer.prototype.GetBoundingSphereRadius=function(a){if(void 0===a||null===a)a=this.GetCenter();var b=0,c,d,e,f;for(c=0;c<this.renderer.geometries.length;c++){e=this.renderer.geometries[c];for(d=0;d<e.VertexCount();d+=1)f=e.GetTransformedVertex(d),f=JSM.CoordDistance(a,f),JSM.IsGreater(f,b)&&(b=f)}return b};JSM.Viewer.prototype.Resize=function(){this.renderer.Resize();this.Draw()};JSM.Viewer.prototype.Draw=function(){this.renderer.Render()};
JSM.PointCloudViewer=function(){this.navigation=this.renderer=this.canvas=null};JSM.PointCloudViewer.prototype.Init=function(a,b){return!this.InitRenderer(a,b)||!this.InitNavigation()?!1:!0};JSM.PointCloudViewer.prototype.InitRenderer=function(a,b){this.renderer=new JSM.PointCloudRenderer;return!this.renderer.Init(a,b)?!1:!0};
JSM.PointCloudViewer.prototype.InitNavigation=function(){this.navigation=new JSM.Navigation;return!this.navigation.Init(this.renderer.canvas,this.renderer.camera,this.Draw.bind(this),this.Resize.bind(this))?!1:!0};JSM.PointCloudViewer.prototype.SetClearColor=function(a,b,c){this.renderer.SetClearColor(a,b,c)};JSM.PointCloudViewer.prototype.SetPointSize=function(a){this.renderer.SetPointSize(a)};JSM.PointCloudViewer.prototype.AddPoints=function(a,b){this.renderer.AddPoints(a,b)};
JSM.PointCloudViewer.prototype.RemovePoints=function(){this.renderer.RemovePoints()};JSM.PointCloudViewer.prototype.FitInWindow=function(){var a=this.GetCenter(),b=this.GetBoundingSphereRadius(a);this.navigation.FitInWindow(a,b);this.Draw()};JSM.PointCloudViewer.prototype.GetCenter=function(){var a=this.GetBoundingBox();return JSM.MidCoord(a[0],a[1])};
JSM.PointCloudViewer.prototype.GetBoundingBox=function(){var a=new JSM.Coord(JSM.Inf,JSM.Inf,JSM.Inf),b=new JSM.Coord(-JSM.Inf,-JSM.Inf,-JSM.Inf),c,d,e,f;for(c=0;c<this.renderer.points.length;c++){e=this.renderer.points[c].pointArray;for(d=0;d<e.length;d+=3)f=new JSM.Coord(e[d],e[d+1],e[d+2]),a.x=JSM.Minimum(a.x,f.x),a.y=JSM.Minimum(a.y,f.y),a.z=JSM.Minimum(a.z,f.z),b.x=JSM.Maximum(b.x,f.x),b.y=JSM.Maximum(b.y,f.y),b.z=JSM.Maximum(b.z,f.z)}return[a,b]};
JSM.PointCloudViewer.prototype.GetBoundingSphereRadius=function(a){if(void 0===a||null===a)a=this.GetCenter();var b=0,c,d,e,f;for(c=0;c<this.renderer.points.length;c++){e=this.renderer.points[c].pointArray;for(d=0;d<e.length;d+=3)f=new JSM.Coord(e[d],e[d+1],e[d+2]),f=JSM.CoordDistance(a,f),JSM.IsGreater(f,b)&&(b=f)}return b};JSM.PointCloudViewer.prototype.Resize=function(){this.renderer.Resize();this.Draw()};JSM.PointCloudViewer.prototype.Draw=function(){this.renderer.Render()};
JSM.ConvertBodyToThreeMeshes=function(a,b,c){var d={textureLoadedCallback:null,hasConvexPolygons:!1,doubleSided:!0};void 0!==c&&null!==c&&(d.textureLoadedCallback=JSM.ValueOrDefault(c.textureLoadedCallback,d.textureLoadedCallback),d.hasConvexPolygons=JSM.ValueOrDefault(c.hasConvexPolygons,d.hasConvexPolygons),d.doubleSided=JSM.ValueOrDefault(c.doubleSided,d.doubleSided));var e=[],f=null;JSM.ExplodeBodyToTriangles(a,b,{hasConvexPolygons:d.hasConvexPolygons,onGeometryStart:function(){f=new THREE.Geometry},
onGeometryEnd:function(a){var b=null!==a.texture,c=1!==a.opacity,k=new THREE.MeshPhongMaterial({ambient:a.ambient,color:a.diffuse,specular:a.specular});d.doubleSided&&(k.side=THREE.DoubleSide);c&&(k.opacity=a.opacity,k.transparent=!0);b&&(a=THREE.ImageUtils.loadTexture(a.texture,new THREE.UVMapping,function(){null!==d.textureLoadedCallback&&d.textureLoadedCallback()}),a.wrapS=THREE.RepeatWrapping,a.wrapT=THREE.RepeatWrapping,k.map=a);f.computeFaceNormals();k=new THREE.Mesh(f,k);e.push(k)},onTriangle:function(a,
b,c,d,e,n,p,q,r){var s=f.vertices.length;f.vertices.push(new THREE.Vector3(a.x,a.y,a.z));f.vertices.push(new THREE.Vector3(b.x,b.y,b.z));f.vertices.push(new THREE.Vector3(c.x,c.y,c.z));a=new THREE.Face3(s+0,s+1,s+2);f.faces.push(a);null!==d&&(null!==e&&null!==n)&&(a=[],a.push(new THREE.Vector3(d.x,d.y,d.z)),a.push(new THREE.Vector3(e.x,e.y,e.z)),a.push(new THREE.Vector3(n.x,n.y,n.z)),f.faces[f.faces.length-1].vertexNormals=a);null!==p&&(null!==q&&null!==r)&&(d=[],d.push(new THREE.Vector2(p.x,-p.y)),
d.push(new THREE.Vector2(q.x,-q.y)),d.push(new THREE.Vector2(r.x,-r.y)),f.faceVertexUvs[0].push(d))}});return e};JSM.ConvertModelToThreeMeshes=function(a,b,c){var d=[],e=[],f,g;for(f=0;f<a.BodyCount();f++){e=a.GetBody(f);e=JSM.ConvertBodyToThreeMeshes(e,b,c);for(g=0;g<e.length;g++)d.push(e[g])}return d};
JSM.ConvertJSONDataToThreeMeshes=function(a,b,c){function d(a,c){function d(a){var l=a.parameters,m=f[a.material];a=m.texture;var r=m.offset,s=m.scale,C=new THREE.Color,u=new THREE.Color,H=new THREE.Color;C.setRGB(m.ambient[0],m.ambient[1],m.ambient[2]);u.setRGB(m.diffuse[0],m.diffuse[1],m.diffuse[2]);H.setRGB(m.specular[0],m.specular[1],m.specular[2]);void 0!==a&&(C.setRGB(1,1,1),u.setRGB(1,1,1),H.setRGB(1,1,1),void 0===r&&(r=[0,0]),void 0===s&&(s=[1,1]));C=new THREE.MeshPhongMaterial({ambient:u.getHex(),
color:u.getHex(),specular:H.getHex(),side:THREE.DoubleSide});1!==m.opacity&&(C.opacity=m.opacity,C.transparent=!0);void 0!==a&&(m=THREE.ImageUtils.loadTexture(a,new THREE.UVMapping,function(){void 0!==b&&null!==b&&b()}),m.wrapS=THREE.RepeatWrapping,m.wrapT=THREE.RepeatWrapping,C.map=m);var m=new THREE.Geometry,z,I,J,D,A,B,K,L,M,w;for(w=0;w<l.length;w+=9)z=3*l[w+0],I=3*l[w+1],J=3*l[w+2],D=3*l[w+3],A=3*l[w+4],B=3*l[w+5],u=2*l[w+6],H=2*l[w+7],K=2*l[w+8],L=m.vertices.length,M=m.faces.length,m.vertices.push(new THREE.Vector3(g[z+
0],g[z+1],g[z+2])),m.vertices.push(new THREE.Vector3(g[I+0],g[I+1],g[I+2])),m.vertices.push(new THREE.Vector3(g[J+0],g[J+1],g[J+2])),m.faces.push(new THREE.Face3(L+0,L+1,L+2)),z=[],z.push(new THREE.Vector3(h[D+0],h[D+1],h[D+2])),z.push(new THREE.Vector3(h[A+0],h[A+1],h[A+2])),z.push(new THREE.Vector3(h[B+0],h[B+1],h[B+2])),m.faces[M].vertexNormals=z,void 0!==a&&(D=[],D.push(new THREE.Vector2(r[0]+q[u+0]*s[0],r[1]+q[u+1]*s[1])),D.push(new THREE.Vector2(r[0]+q[H+0]*s[0],r[1]+q[H+1]*s[1])),D.push(new THREE.Vector2(r[0]+
q[K+0]*s[0],r[1]+q[K+1]*s[1])),m.faceVertexUvs[0].push(D));l=new THREE.Mesh(m,C);l.originalJsonIndex=c;e.push(l)}var g=a.vertices;if(void 0!==g){var h=a.normals;if(void 0!==h){var q=a.uvs;if(void 0!==q){var r=a.triangles,s;for(s=0;s<r.length;s++)d(r[s])}}}}var e=[],f=a.materials;if(void 0===f)return e;var g=a.meshes;if(void 0===g)return e;var h=0;JSM.AsyncRunTask(function(){d(g[h],h);h+=1;return!0},c,g.length,0,e);return e};JSM.JSONFileConverter=function(a,b){this.onReady=a;this.onTextureLoaded=b};
JSM.JSONFileConverter.prototype.Convert=function(a){(new JSM.JSONFileLoader(this.OnReady.bind(this))).Load(a)};JSM.JSONFileConverter.prototype.OnReady=function(a){null!==this.onReady&&(a=JSM.ConvertJSONDataToThreeMeshes(a,this.onTextureLoaded),this.onReady(a))};JSM.ThreeViewer=function(){this.enableDraw=this.drawLoop=this.settings=this.navigation=this.cameraMove=this.runAfterRender=this.runBeforeRender=this.directionalLight=this.ambientLight=this.renderer=this.camera=this.scene=this.canvas=null};
JSM.ThreeViewer.prototype.Start=function(a,b){if(!this.IsWebGLEnabled()||!this.InitSettings(b)||!this.InitThree(a)||!this.InitCamera(b)||!this.InitLights())return!1;this.drawLoop=!1;this.enableDraw=!0;this.DrawIfNeeded();return!0};JSM.ThreeViewer.prototype.IsWebGLEnabled=function(){return!window.WebGLRenderingContext||!document.createElement("canvas").getContext("experimental-webgl")?!1:!0};
JSM.ThreeViewer.prototype.InitSettings=function(a){this.settings={cameraEyePosition:new JSM.Coord(1,1,1),cameraCenterPosition:new JSM.Coord(0,0,0),cameraUpVector:new JSM.Coord(0,0,1),lightAmbientColor:[0.5,0.5,0.5],lightDiffuseColor:[0.5,0.5,0.5]};void 0!==a&&(void 0!==a.cameraEyePosition&&(this.settings.cameraEyePosition=JSM.CoordFromArray(a.cameraEyePosition)),void 0!==a.cameraCenterPosition&&(this.settings.cameraCenterPosition=JSM.CoordFromArray(a.cameraCenterPosition)),void 0!==a.cameraUpVector&&
(this.settings.cameraUpVector=JSM.CoordFromArray(a.cameraUpVector)),void 0!==a.lightAmbientColor&&(this.settings.lightAmbientColor=a.lightAmbientColor),void 0!==a.lightDiffuseColor&&(this.settings.lightDiffuseColor=a.lightDiffuseColor));return!0};
JSM.ThreeViewer.prototype.InitThree=function(a){this.canvas=document.getElementById(a);if(!this.canvas||!this.canvas.getContext)return!1;this.scene=new THREE.Scene;if(!this.scene)return!1;this.renderer=new THREE.WebGLRenderer({canvas:this.canvas,antialias:!0});if(!this.renderer)return!1;this.renderer.setClearColor(new THREE.Color(16777215));this.renderer.setSize(this.canvas.width,this.canvas.height);return!0};
JSM.ThreeViewer.prototype.InitCamera=function(a){this.cameraMove=new JSM.Camera(JSM.CoordFromArray(a.cameraEyePosition),JSM.CoordFromArray(a.cameraCenterPosition),JSM.CoordFromArray(a.cameraUpVector),a.fieldOfView,a.nearClippingPlane,a.farClippingPlane);if(!this.cameraMove)return!1;this.navigation=new JSM.Navigation;if(!this.navigation.Init(this.canvas,this.cameraMove,this.DrawIfNeeded.bind(this),this.Resize.bind(this)))return!1;this.camera=new THREE.PerspectiveCamera(this.cameraMove.fieldOfView,
this.canvas.width/this.canvas.height,this.cameraMove.nearClippingPlane,this.cameraMove.farClippingPlane);if(!this.camera)return!1;this.scene.add(this.camera);return!0};
JSM.ThreeViewer.prototype.InitLights=function(){var a=new THREE.Color,b=new THREE.Color;a.setRGB(this.settings.lightAmbientColor[0],this.settings.lightAmbientColor[1],this.settings.lightAmbientColor[2]);b.setRGB(this.settings.lightDiffuseColor[0],this.settings.lightDiffuseColor[1],this.settings.lightDiffuseColor[2]);this.ambientLight=new THREE.AmbientLight(a.getHex());if(!this.ambientLight)return!1;this.scene.add(this.ambientLight);this.directionalLight=new THREE.DirectionalLight(b.getHex());if(!this.directionalLight)return!1;
a=(new THREE.Vector3).subVectors(this.cameraMove.eye,this.cameraMove.center);this.directionalLight.position.set(a.x,a.y,a.z);this.scene.add(this.directionalLight);return!0};JSM.ThreeViewer.prototype.SetRunBeforeRender=function(a){this.runBeforeRender=a};JSM.ThreeViewer.prototype.SetRunAfterRender=function(a){this.runAfterRender=a};JSM.ThreeViewer.prototype.SetClearColor=function(a){this.renderer.setClearColor(new THREE.Color(a));this.DrawIfNeeded()};
JSM.ThreeViewer.prototype.AddMesh=function(a){this.scene.add(a);this.DrawIfNeeded()};JSM.ThreeViewer.prototype.AddMeshes=function(a){var b;for(b=0;b<a.length;b++)this.scene.add(a[b]);this.DrawIfNeeded()};JSM.ThreeViewer.prototype.MeshCount=function(){var a=0;this.scene.traverse(function(b){b instanceof THREE.Mesh&&(a+=1)});return a};JSM.ThreeViewer.prototype.VertexCount=function(){var a=0;this.scene.traverse(function(b){b instanceof THREE.Mesh&&(a+=b.geometry.vertices.length)});return a};
JSM.ThreeViewer.prototype.FaceCount=function(){var a=0;this.scene.traverse(function(b){b instanceof THREE.Mesh&&(a+=b.geometry.faces.length)});return a};JSM.ThreeViewer.prototype.GetMesh=function(a){var b=null,c=0,d;for(d=0;d<this.scene.children.length;d++)if(b=this.scene.children[d],b instanceof THREE.Mesh){if(c==a)return b;c+=1}return null};JSM.ThreeViewer.prototype.RemoveMesh=function(a){this.scene.remove(a);this.DrawIfNeeded()};
JSM.ThreeViewer.prototype.RemoveMeshes=function(){var a,b;for(b=0;b<this.scene.children.length;b++)a=this.scene.children[b],a instanceof THREE.Mesh&&(this.scene.remove(a),b--);this.DrawIfNeeded()};JSM.ThreeViewer.prototype.RemoveLastMesh=function(){var a=null;this.scene.traverse(function(b){b instanceof THREE.Mesh&&(a=b)});null!==a&&this.scene.remove(a);this.DrawIfNeeded()};
JSM.ThreeViewer.prototype.SetCamera=function(a,b,c){this.navigation.SetCamera(a,b,c);this.navigation.SetOrbitCenter(b.Clone());this.DrawIfNeeded()};JSM.ThreeViewer.prototype.Resize=function(){this.camera.aspect=this.canvas.width/this.canvas.height;this.camera.updateProjectionMatrix();this.renderer.setSize(this.canvas.width,this.canvas.height);this.DrawIfNeeded()};
JSM.ThreeViewer.prototype.FitInWindow=function(){if(0!==this.MeshCount()){var a=this.GetCenter(),b=this.GetBoundingSphereRadius(a);this.navigation.FitInWindow(a,b);this.DrawIfNeeded()}};JSM.ThreeViewer.prototype.AdjustClippingPlanes=function(a){var b=this.GetCenter();this.GetBoundingSphereRadius(b)<a?(this.camera.near=0.1,this.camera.far=1E3):(this.camera.near=10,this.camera.far=1E6);this.camera.updateProjectionMatrix();this.Draw()};
JSM.ThreeViewer.prototype.GetCenter=function(){var a=this.GetBoundingBox();return JSM.MidCoord(a[0],a[1])};
JSM.ThreeViewer.prototype.GetBoundingBox=function(){var a=new JSM.Coord(JSM.Inf,JSM.Inf,JSM.Inf),b=new JSM.Coord(-JSM.Inf,-JSM.Inf,-JSM.Inf),c,d;this.scene.traverse(function(e){if(e instanceof THREE.Mesh){c=e.geometry;var f;for(f=0;f<c.vertices.length;f++)d=c.vertices[f].clone(),d.add(e.position),a.x=JSM.Minimum(a.x,d.x),a.y=JSM.Minimum(a.y,d.y),a.z=JSM.Minimum(a.z,d.z),b.x=JSM.Maximum(b.x,d.x),b.y=JSM.Maximum(b.y,d.y),b.z=JSM.Maximum(b.z,d.z)}});return[a,b]};
JSM.ThreeViewer.prototype.GetBoundingSphereRadius=function(a){if(void 0===a||null===a)a=this.GetCenter();var b=0,c,d,e;this.scene.traverse(function(f){if(f instanceof THREE.Mesh){c=f.geometry;var g;for(g=0;g<c.vertices.length;g++)d=c.vertices[g].clone(),d.add(f.position),e=JSM.CoordDistance(a,new JSM.Coord(d.x,d.y,d.z)),JSM.IsGreater(e,b)&&(b=e)}});return b};
JSM.ThreeViewer.prototype.GetObjectsUnderPosition=function(a,b){var c=2*(a/this.canvas.width)-1,d=2*-(b/this.canvas.height)+1,e=new THREE.Projector,f=this.camera.position,c=new THREE.Vector3(c,d,0.5);e.unprojectVector(c,this.camera);c.sub(f);c.normalize();return(new THREE.Raycaster(f,c)).intersectObjects(this.scene.children)};JSM.ThreeViewer.prototype.GetObjectsUnderMouse=function(){return this.GetObjectsUnderPosition(this.navigation.mouse.currX,this.navigation.mouse.currY)};
JSM.ThreeViewer.prototype.GetObjectsUnderTouch=function(){return this.GetObjectsUnderPosition(this.navigation.touch.currX,this.navigation.touch.currY)};JSM.ThreeViewer.prototype.ProjectVector=function(a,b,c){var d=this.canvas.width/2,e=this.canvas.height/2,f=new THREE.Projector;a=new THREE.Vector3(a,b,c);f.projectVector(a,this.camera);a.x=a.x*d+d;a.y=-(a.y*e)+e;return a};JSM.ThreeViewer.prototype.EnableDraw=function(a){this.enableDraw=a};
JSM.ThreeViewer.prototype.Draw=function(){if(this.enableDraw){null!==this.runBeforeRender&&this.runBeforeRender();this.camera.position.set(this.cameraMove.eye.x,this.cameraMove.eye.y,this.cameraMove.eye.z);this.camera.up.set(this.cameraMove.up.x,this.cameraMove.up.y,this.cameraMove.up.z);this.camera.lookAt(new THREE.Vector3(this.cameraMove.center.x,this.cameraMove.center.y,this.cameraMove.center.z));var a=(new THREE.Vector3).subVectors(this.cameraMove.eye,this.cameraMove.center);this.directionalLight.position.set(a.x,
a.y,a.z);this.renderer.render(this.scene,this.camera);null!==this.runAfterRender&&this.runAfterRender();this.drawLoop&&requestAnimationFrame(this.Draw.bind(this))}};JSM.ThreeViewer.prototype.DrawIfNeeded=function(){this.drawLoop||this.Draw()};JSM.ThreeViewer.prototype.StartDrawLoop=function(){this.drawLoop=!0;this.Draw()};

